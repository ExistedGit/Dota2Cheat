// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_common_league.proto

#include "dota_gcmessages_common_league.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CMsgDOTALeagueNode_MatchDetails::CMsgDOTALeagueNode_MatchDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.winning_team_id_)*/0u} {}
struct CMsgDOTALeagueNode_MatchDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueNode_MatchDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueNode_MatchDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueNode_MatchDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueNode_MatchDetailsDefaultTypeInternal _CMsgDOTALeagueNode_MatchDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueNode_VOD::CMsgDOTALeagueNode_VOD(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.series_game_)*/0u
  , /*decltype(_impl_.stream_id_)*/0u} {}
struct CMsgDOTALeagueNode_VODDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueNode_VODDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueNode_VODDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueNode_VOD _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueNode_VODDefaultTypeInternal _CMsgDOTALeagueNode_VOD_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueNode::CMsgDOTALeagueNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.matches_)*/{}
  , /*decltype(_impl_.stream_ids_)*/{}
  , /*decltype(_impl_.vods_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.node_id_)*/0u
  , /*decltype(_impl_.node_group_id_)*/0u
  , /*decltype(_impl_.winning_node_id_)*/0u
  , /*decltype(_impl_.losing_node_id_)*/0u
  , /*decltype(_impl_.incoming_node_id_1_)*/0u
  , /*decltype(_impl_.incoming_node_id_2_)*/0u
  , /*decltype(_impl_.node_type_)*/0
  , /*decltype(_impl_.scheduled_time_)*/0u
  , /*decltype(_impl_.series_id_)*/0u
  , /*decltype(_impl_.team_id_1_)*/0u
  , /*decltype(_impl_.team_id_2_)*/0u
  , /*decltype(_impl_.team_1_wins_)*/0u
  , /*decltype(_impl_.team_2_wins_)*/0u
  , /*decltype(_impl_.has_started_)*/false
  , /*decltype(_impl_.is_completed_)*/false
  , /*decltype(_impl_.actual_time_)*/0u} {}
struct CMsgDOTALeagueNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueNodeDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueNodeDefaultTypeInternal _CMsgDOTALeagueNode_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeGroup_TeamStanding::CMsgDOTALeagueNodeGroup_TeamStanding(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_logo_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_abbreviation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.standing_)*/0u
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.team_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.wins_)*/0u
  , /*decltype(_impl_.losses_)*/0u
  , /*decltype(_impl_.score_)*/int64_t{0}
  , /*decltype(_impl_.score_tiebreak_group_)*/int64_t{0}
  , /*decltype(_impl_.score_tiebreak_below_)*/int64_t{0}
  , /*decltype(_impl_.score_tiebreak_random_)*/int64_t{0}
  , /*decltype(_impl_.is_pro_)*/false} {}
struct CMsgDOTALeagueNodeGroup_TeamStandingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeGroup_TeamStandingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueNodeGroup_TeamStandingDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueNodeGroup_TeamStanding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueNodeGroup_TeamStandingDefaultTypeInternal _CMsgDOTALeagueNodeGroup_TeamStanding_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeGroup::CMsgDOTALeagueNodeGroup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.incoming_node_group_ids_)*/{}
  , /*decltype(_impl_.team_standings_)*/{}
  , /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_.node_groups_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.node_group_id_)*/0u
  , /*decltype(_impl_.parent_node_group_id_)*/0u
  , /*decltype(_impl_.advancing_node_group_id_)*/0u
  , /*decltype(_impl_.advancing_team_count_)*/0u
  , /*decltype(_impl_.team_count_)*/0u
  , /*decltype(_impl_.node_group_type_)*/0
  , /*decltype(_impl_.default_node_type_)*/0
  , /*decltype(_impl_.round_)*/0u
  , /*decltype(_impl_.max_rounds_)*/0u
  , /*decltype(_impl_.is_tiebreaker_)*/false
  , /*decltype(_impl_.is_final_group_)*/false
  , /*decltype(_impl_.is_completed_)*/false
  , /*decltype(_impl_.phase_)*/0
  , /*decltype(_impl_.region_)*/0
  , /*decltype(_impl_.start_time_)*/0u
  , /*decltype(_impl_.end_time_)*/0u
  , /*decltype(_impl_.secondary_advancing_node_group_id_)*/0u
  , /*decltype(_impl_.secondary_advancing_team_count_)*/0u
  , /*decltype(_impl_.tertiary_advancing_node_group_id_)*/0u
  , /*decltype(_impl_.tertiary_advancing_team_count_)*/0u
  , /*decltype(_impl_.elimination_dpc_points_)*/0u} {}
struct CMsgDOTALeagueNodeGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueNodeGroupDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueNodeGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueNodeGroupDefaultTypeInternal _CMsgDOTALeagueNodeGroup_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeague_Info::CMsgDOTALeague_Info(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.notes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.tier_)*/0
  , /*decltype(_impl_.region_)*/0
  , /*decltype(_impl_.start_timestamp_)*/0u
  , /*decltype(_impl_.end_timestamp_)*/0u
  , /*decltype(_impl_.pro_circuit_points_)*/0u
  , /*decltype(_impl_.image_bits_)*/0u
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.most_recent_activity_)*/0u
  , /*decltype(_impl_.registration_period_)*/0u} {}
struct CMsgDOTALeague_InfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeague_InfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeague_InfoDefaultTypeInternal() {}
  union {
    CMsgDOTALeague_Info _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeague_InfoDefaultTypeInternal _CMsgDOTALeague_Info_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeague_Admin::CMsgDOTALeague_Admin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.email_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.is_primary_)*/false} {}
struct CMsgDOTALeague_AdminDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeague_AdminDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeague_AdminDefaultTypeInternal() {}
  union {
    CMsgDOTALeague_Admin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeague_AdminDefaultTypeInternal _CMsgDOTALeague_Admin_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeague_PrizePoolItem::CMsgDOTALeague_PrizePoolItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_def_)*/0u
  , /*decltype(_impl_.sales_stop_timestamp_)*/0u
  , /*decltype(_impl_.revenue_pct_)*/0u
  , /*decltype(_impl_.revenue_cents_per_sale_)*/0u} {}
struct CMsgDOTALeague_PrizePoolItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeague_PrizePoolItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeague_PrizePoolItemDefaultTypeInternal() {}
  union {
    CMsgDOTALeague_PrizePoolItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeague_PrizePoolItemDefaultTypeInternal _CMsgDOTALeague_PrizePoolItem_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeague_PrizePool::CMsgDOTALeague_PrizePool(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.prize_split_pct_x100_)*/{}
  , /*decltype(_impl_.prize_pool_items_)*/{}
  , /*decltype(_impl_.base_prize_pool_)*/0u
  , /*decltype(_impl_.total_prize_pool_)*/0u} {}
struct CMsgDOTALeague_PrizePoolDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeague_PrizePoolDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeague_PrizePoolDefaultTypeInternal() {}
  union {
    CMsgDOTALeague_PrizePool _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeague_PrizePoolDefaultTypeInternal _CMsgDOTALeague_PrizePool_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeague_Stream::CMsgDOTALeague_Stream(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stream_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vod_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stream_id_)*/0u
  , /*decltype(_impl_.language_)*/0u
  , /*decltype(_impl_.broadcast_provider_)*/0} {}
struct CMsgDOTALeague_StreamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeague_StreamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeague_StreamDefaultTypeInternal() {}
  union {
    CMsgDOTALeague_Stream _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeague_StreamDefaultTypeInternal _CMsgDOTALeague_Stream_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeague_SeriesInfo::CMsgDOTALeague_SeriesInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_ids_)*/{}
  , /*decltype(_impl_.series_id_)*/0u
  , /*decltype(_impl_.series_type_)*/0u
  , /*decltype(_impl_.start_time_)*/0u
  , /*decltype(_impl_.team_id_1_)*/0u
  , /*decltype(_impl_.team_id_2_)*/0u} {}
struct CMsgDOTALeague_SeriesInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeague_SeriesInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeague_SeriesInfoDefaultTypeInternal() {}
  union {
    CMsgDOTALeague_SeriesInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeague_SeriesInfoDefaultTypeInternal _CMsgDOTALeague_SeriesInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeague_Player::CMsgDOTALeague_Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.team_id_)*/0u} {}
struct CMsgDOTALeague_PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeague_PlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeague_PlayerDefaultTypeInternal() {}
  union {
    CMsgDOTALeague_Player _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeague_PlayerDefaultTypeInternal _CMsgDOTALeague_Player_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeague::CMsgDOTALeague(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.admins_)*/{}
  , /*decltype(_impl_.streams_)*/{}
  , /*decltype(_impl_.node_groups_)*/{}
  , /*decltype(_impl_.series_infos_)*/{}
  , /*decltype(_impl_.registered_players_)*/{}
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.prize_pool_)*/nullptr} {}
struct CMsgDOTALeagueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueDefaultTypeInternal() {}
  union {
    CMsgDOTALeague _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueDefaultTypeInternal _CMsgDOTALeague_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueList::CMsgDOTALeagueList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.leagues_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTALeagueListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueListDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueListDefaultTypeInternal _CMsgDOTALeagueList_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueInfo::CMsgDOTALeagueInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.tier_)*/0
  , /*decltype(_impl_.region_)*/0
  , /*decltype(_impl_.most_recent_activity_)*/0u
  , /*decltype(_impl_.total_prize_pool_)*/0u
  , /*decltype(_impl_.start_timestamp_)*/0u
  , /*decltype(_impl_.end_timestamp_)*/0u
  , /*decltype(_impl_.status_)*/0u} {}
struct CMsgDOTALeagueInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueInfoDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueInfoDefaultTypeInternal _CMsgDOTALeagueInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueInfoList::CMsgDOTALeagueInfoList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.infos_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTALeagueInfoListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueInfoListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueInfoListDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueInfoList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueInfoListDefaultTypeInternal _CMsgDOTALeagueInfoList_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueLiveGames_LiveGame::CMsgDOTALeagueLiveGames_LiveGame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.radiant_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dire_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.server_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.radiant_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.time_)*/0u
  , /*decltype(_impl_.dire_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.spectators_)*/0u
  , /*decltype(_impl_.radiant_team_id_)*/0u
  , /*decltype(_impl_.dire_team_id_)*/0u
  , /*decltype(_impl_.league_node_id_)*/0u
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.series_id_)*/0u} {}
struct CMsgDOTALeagueLiveGames_LiveGameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueLiveGames_LiveGameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueLiveGames_LiveGameDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueLiveGames_LiveGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueLiveGames_LiveGameDefaultTypeInternal _CMsgDOTALeagueLiveGames_LiveGame_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueLiveGames::CMsgDOTALeagueLiveGames(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.games_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTALeagueLiveGamesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueLiveGamesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueLiveGamesDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueLiveGames _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueLiveGamesDefaultTypeInternal _CMsgDOTALeagueLiveGames_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueMessages_Message::CMsgDOTALeagueMessages_Message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.author_account_id_)*/0u
  , /*decltype(_impl_.timestamp_)*/0u} {}
struct CMsgDOTALeagueMessages_MessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueMessages_MessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueMessages_MessageDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueMessages_Message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueMessages_MessageDefaultTypeInternal _CMsgDOTALeagueMessages_Message_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueMessages::CMsgDOTALeagueMessages(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messages_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTALeagueMessagesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueMessagesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueMessagesDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueMessages _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueMessagesDefaultTypeInternal _CMsgDOTALeagueMessages_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeaguePrizePool::CMsgDOTALeaguePrizePool(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.prize_pool_)*/0u
  , /*decltype(_impl_.increment_per_second_)*/0} {}
struct CMsgDOTALeaguePrizePoolDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeaguePrizePoolDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeaguePrizePoolDefaultTypeInternal() {}
  union {
    CMsgDOTALeaguePrizePool _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeaguePrizePoolDefaultTypeInternal _CMsgDOTALeaguePrizePool_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueInfoListAdminsRequest::CMsgDOTALeagueInfoListAdminsRequest(
    ::_pbi::ConstantInitialized) {}
struct CMsgDOTALeagueInfoListAdminsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueInfoListAdminsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueInfoListAdminsRequestDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueInfoListAdminsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueInfoListAdminsRequestDefaultTypeInternal _CMsgDOTALeagueInfoListAdminsRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueAvailableLobbyNodesRequest::CMsgDOTALeagueAvailableLobbyNodesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.league_id_)*/0u} {}
struct CMsgDOTALeagueAvailableLobbyNodesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueAvailableLobbyNodesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueAvailableLobbyNodesRequestDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueAvailableLobbyNodesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueAvailableLobbyNodesRequestDefaultTypeInternal _CMsgDOTALeagueAvailableLobbyNodesRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.node_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.node_group_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.node_id_)*/0u
  , /*decltype(_impl_.team_id_1_)*/0u
  , /*decltype(_impl_.team_id_2_)*/0u} {}
struct CMsgDOTALeagueAvailableLobbyNodes_NodeInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueAvailableLobbyNodes_NodeInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueAvailableLobbyNodes_NodeInfoDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueAvailableLobbyNodes_NodeInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueAvailableLobbyNodes_NodeInfoDefaultTypeInternal _CMsgDOTALeagueAvailableLobbyNodes_NodeInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueAvailableLobbyNodes::CMsgDOTALeagueAvailableLobbyNodes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.node_infos_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTALeagueAvailableLobbyNodesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueAvailableLobbyNodesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueAvailableLobbyNodesDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueAvailableLobbyNodes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueAvailableLobbyNodesDefaultTypeInternal _CMsgDOTALeagueAvailableLobbyNodes_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeResults_Result::CMsgDOTALeagueNodeResults_Result(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_ids_)*/{}
  , /*decltype(_impl_.team_1_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_2_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.node_id_)*/0u
  , /*decltype(_impl_.winning_node_id_)*/0u
  , /*decltype(_impl_.losing_node_id_)*/0u
  , /*decltype(_impl_.incoming_node_id_1_)*/0u
  , /*decltype(_impl_.incoming_node_id_2_)*/0u
  , /*decltype(_impl_.team_id_1_)*/0u
  , /*decltype(_impl_.team_id_2_)*/0u
  , /*decltype(_impl_.team_1_wins_)*/0u
  , /*decltype(_impl_.team_2_wins_)*/0u
  , /*decltype(_impl_.winning_team_id_)*/0u
  , /*decltype(_impl_.losing_team_id_)*/0u
  , /*decltype(_impl_.has_started_)*/false
  , /*decltype(_impl_.is_completed_)*/false
  , /*decltype(_impl_.scheduled_time_)*/0u} {}
struct CMsgDOTALeagueNodeResults_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeResults_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueNodeResults_ResultDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueNodeResults_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueNodeResults_ResultDefaultTypeInternal _CMsgDOTALeagueNodeResults_Result_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeResults::CMsgDOTALeagueNodeResults(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.node_results_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTALeagueNodeResultsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeResultsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTALeagueNodeResultsDefaultTypeInternal() {}
  union {
    CMsgDOTALeagueNodeResults _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTALeagueNodeResultsDefaultTypeInternal _CMsgDOTALeagueNodeResults_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCLeagueResults_Result::CMsgDOTADPCLeagueResults_Result(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_logo_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_abbreviation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.standing_)*/0u
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.team_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.points_)*/0u
  , /*decltype(_impl_.earnings_)*/0u
  , /*decltype(_impl_.timestamp_)*/0u
  , /*decltype(_impl_.phase_)*/0} {}
struct CMsgDOTADPCLeagueResults_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCLeagueResults_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCLeagueResults_ResultDefaultTypeInternal() {}
  union {
    CMsgDOTADPCLeagueResults_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCLeagueResults_ResultDefaultTypeInternal _CMsgDOTADPCLeagueResults_Result_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCLeagueResults::CMsgDOTADPCLeagueResults(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.results_)*/{}
  , /*decltype(_impl_.points_)*/{}
  , /*decltype(_impl_.dollars_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTADPCLeagueResultsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCLeagueResultsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCLeagueResultsDefaultTypeInternal() {}
  union {
    CMsgDOTADPCLeagueResults _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCLeagueResultsDefaultTypeInternal _CMsgDOTADPCLeagueResults_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCTeamResults_Result::CMsgDOTADPCTeamResults_Result(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.standing_)*/0u
  , /*decltype(_impl_.points_)*/0u
  , /*decltype(_impl_.earnings_)*/0u
  , /*decltype(_impl_.timestamp_)*/0u} {}
struct CMsgDOTADPCTeamResults_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCTeamResults_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCTeamResults_ResultDefaultTypeInternal() {}
  union {
    CMsgDOTADPCTeamResults_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCTeamResults_ResultDefaultTypeInternal _CMsgDOTADPCTeamResults_Result_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCTeamResults::CMsgDOTADPCTeamResults(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.results_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTADPCTeamResultsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCTeamResultsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCTeamResultsDefaultTypeInternal() {}
  union {
    CMsgDOTADPCTeamResults _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCTeamResultsDefaultTypeInternal _CMsgDOTADPCTeamResults_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults_TeamLeagueResult::CMsgDOTADPCSeasonResults_TeamLeagueResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/0u
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.standing_)*/0u
  , /*decltype(_impl_.points_)*/0u
  , /*decltype(_impl_.earnings_)*/0u
  , /*decltype(_impl_.audit_action_)*/0u
  , /*decltype(_impl_.audit_data_)*/0u} {}
struct CMsgDOTADPCSeasonResults_TeamLeagueResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults_TeamLeagueResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCSeasonResults_TeamLeagueResultDefaultTypeInternal() {}
  union {
    CMsgDOTADPCSeasonResults_TeamLeagueResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCSeasonResults_TeamLeagueResultDefaultTypeInternal _CMsgDOTADPCSeasonResults_TeamLeagueResult_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults_TeamResult::CMsgDOTADPCSeasonResults_TeamResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.league_results_)*/{}
  , /*decltype(_impl_.team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_logo_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_abbreviation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.total_points_)*/0u
  , /*decltype(_impl_.total_earnings_)*/0u} {}
struct CMsgDOTADPCSeasonResults_TeamResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults_TeamResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCSeasonResults_TeamResultDefaultTypeInternal() {}
  union {
    CMsgDOTADPCSeasonResults_TeamResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCSeasonResults_TeamResultDefaultTypeInternal _CMsgDOTADPCSeasonResults_TeamResult_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults_StandingEntry::CMsgDOTADPCSeasonResults_StandingEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.team_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_abbreviation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.wins_)*/0u
  , /*decltype(_impl_.losses_)*/0u} {}
struct CMsgDOTADPCSeasonResults_StandingEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults_StandingEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCSeasonResults_StandingEntryDefaultTypeInternal() {}
  union {
    CMsgDOTADPCSeasonResults_StandingEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCSeasonResults_StandingEntryDefaultTypeInternal _CMsgDOTADPCSeasonResults_StandingEntry_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults_Standing::CMsgDOTADPCSeasonResults_Standing(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_.region_)*/0
  , /*decltype(_impl_.division_)*/0} {}
struct CMsgDOTADPCSeasonResults_StandingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults_StandingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCSeasonResults_StandingDefaultTypeInternal() {}
  union {
    CMsgDOTADPCSeasonResults_Standing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCSeasonResults_StandingDefaultTypeInternal _CMsgDOTADPCSeasonResults_Standing_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults::CMsgDOTADPCSeasonResults(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.results_)*/{}
  , /*decltype(_impl_.standings_)*/{}
  , /*decltype(_impl_.major_wildcard_standings_)*/{}
  , /*decltype(_impl_.major_group_standings_)*/{}
  , /*decltype(_impl_.major_playoff_standings_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTADPCSeasonResultsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResultsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCSeasonResultsDefaultTypeInternal() {}
  union {
    CMsgDOTADPCSeasonResults _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCSeasonResultsDefaultTypeInternal _CMsgDOTADPCSeasonResults_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonSpoilerResults::CMsgDOTADPCSeasonSpoilerResults(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.saved_results_)*/nullptr
  , /*decltype(_impl_.time_last_updated_)*/0u} {}
struct CMsgDOTADPCSeasonSpoilerResultsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonSpoilerResultsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCSeasonSpoilerResultsDefaultTypeInternal() {}
  union {
    CMsgDOTADPCSeasonSpoilerResults _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCSeasonSpoilerResultsDefaultTypeInternal _CMsgDOTADPCSeasonSpoilerResults_default_instance_;
static ::_pb::Metadata file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[37];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5fleague_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_dota_5fgcmessages_5fcommon_5fleague_2eproto = nullptr;

const uint32_t TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode_MatchDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode_MatchDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode_MatchDetails, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode_MatchDetails, _impl_.winning_team_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode_VOD, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode_VOD, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode_VOD, _impl_.series_game_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode_VOD, _impl_.stream_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode_VOD, _impl_.url_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.node_group_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.winning_node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.losing_node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.incoming_node_id_1_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.incoming_node_id_2_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.node_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.scheduled_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.actual_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.series_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.team_id_1_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.team_id_2_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.matches_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.team_1_wins_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.team_2_wins_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.has_started_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.is_completed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.stream_ids_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNode, _impl_.vods_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  16,
  9,
  10,
  11,
  ~0u,
  12,
  13,
  14,
  15,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.standing_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.team_tag_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.team_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.team_logo_url_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.wins_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.losses_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.score_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.team_abbreviation_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.score_tiebreak_group_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.score_tiebreak_below_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.score_tiebreak_random_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.is_pro_),
  4,
  5,
  0,
  1,
  6,
  2,
  7,
  8,
  9,
  3,
  10,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.node_group_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.parent_node_group_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.incoming_node_group_ids_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.advancing_node_group_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.advancing_team_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.team_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.node_group_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.default_node_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.round_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.max_rounds_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.is_tiebreaker_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.is_final_group_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.is_completed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.phase_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.region_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.start_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.end_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.secondary_advancing_node_group_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.secondary_advancing_team_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.tertiary_advancing_node_group_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.tertiary_advancing_team_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.elimination_dpc_points_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.team_standings_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.nodes_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeGroup, _impl_.node_groups_),
  0,
  1,
  2,
  ~0u,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.tier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.region_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.url_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.notes_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.start_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.end_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.pro_circuit_points_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.image_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.most_recent_activity_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Info, _impl_.registration_period_),
  4,
  0,
  5,
  6,
  1,
  2,
  3,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Admin, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Admin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Admin, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Admin, _impl_.is_primary_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Admin, _impl_.email_address_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_PrizePoolItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_PrizePoolItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_PrizePoolItem, _impl_.item_def_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_PrizePoolItem, _impl_.sales_stop_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_PrizePoolItem, _impl_.revenue_pct_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_PrizePoolItem, _impl_.revenue_cents_per_sale_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_PrizePool, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_PrizePool, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_PrizePool, _impl_.base_prize_pool_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_PrizePool, _impl_.total_prize_pool_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_PrizePool, _impl_.prize_split_pct_x100_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_PrizePool, _impl_.prize_pool_items_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Stream, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Stream, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Stream, _impl_.stream_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Stream, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Stream, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Stream, _impl_.broadcast_provider_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Stream, _impl_.stream_url_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Stream, _impl_.vod_url_),
  3,
  4,
  0,
  5,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_SeriesInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_SeriesInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_SeriesInfo, _impl_.series_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_SeriesInfo, _impl_.series_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_SeriesInfo, _impl_.start_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_SeriesInfo, _impl_.match_ids_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_SeriesInfo, _impl_.team_id_1_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_SeriesInfo, _impl_.team_id_2_),
  0,
  1,
  2,
  ~0u,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Player, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Player, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Player, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague_Player, _impl_.team_id_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague, _impl_.prize_pool_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague, _impl_.admins_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague, _impl_.streams_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague, _impl_.node_groups_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague, _impl_.series_infos_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeague, _impl_.registered_players_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueList, _impl_.leagues_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfo, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfo, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfo, _impl_.tier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfo, _impl_.region_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfo, _impl_.most_recent_activity_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfo, _impl_.total_prize_pool_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfo, _impl_.start_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfo, _impl_.end_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfo, _impl_.status_),
  1,
  0,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfoList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfoList, _impl_.infos_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.server_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.radiant_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.radiant_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.radiant_team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.dire_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.dire_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.dire_team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.spectators_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.league_node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.series_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames_LiveGame, _impl_.match_id_),
  4,
  2,
  0,
  3,
  8,
  1,
  6,
  9,
  5,
  7,
  10,
  12,
  11,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueLiveGames, _impl_.games_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueMessages_Message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueMessages_Message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueMessages_Message, _impl_.author_account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueMessages_Message, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueMessages_Message, _impl_.message_),
  1,
  2,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueMessages, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueMessages, _impl_.messages_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeaguePrizePool, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeaguePrizePool, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeaguePrizePool, _impl_.prize_pool_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeaguePrizePool, _impl_.increment_per_second_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueInfoListAdminsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueAvailableLobbyNodesRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueAvailableLobbyNodesRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueAvailableLobbyNodesRequest, _impl_.league_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo, _impl_.node_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo, _impl_.node_group_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo, _impl_.team_id_1_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo, _impl_.team_id_2_),
  2,
  0,
  1,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueAvailableLobbyNodes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueAvailableLobbyNodes, _impl_.node_infos_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.winning_node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.losing_node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.incoming_node_id_1_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.incoming_node_id_2_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.team_id_1_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.team_id_2_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.team_1_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.team_2_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.team_1_wins_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.team_2_wins_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.winning_team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.losing_team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.has_started_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.is_completed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.scheduled_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults_Result, _impl_.match_ids_),
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  0,
  1,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTALeagueNodeResults, _impl_.node_results_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults_Result, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults_Result, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults_Result, _impl_.standing_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults_Result, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults_Result, _impl_.team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults_Result, _impl_.team_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults_Result, _impl_.team_logo_url_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults_Result, _impl_.points_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults_Result, _impl_.earnings_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults_Result, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults_Result, _impl_.phase_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults_Result, _impl_.team_abbreviation_),
  3,
  4,
  0,
  5,
  1,
  6,
  7,
  8,
  9,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults, _impl_.results_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults, _impl_.points_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCLeagueResults, _impl_.dollars_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCTeamResults_Result, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCTeamResults_Result, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCTeamResults_Result, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCTeamResults_Result, _impl_.standing_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCTeamResults_Result, _impl_.points_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCTeamResults_Result, _impl_.earnings_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCTeamResults_Result, _impl_.timestamp_),
  0,
  1,
  2,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCTeamResults, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCTeamResults, _impl_.results_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamLeagueResult, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamLeagueResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamLeagueResult, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamLeagueResult, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamLeagueResult, _impl_.standing_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamLeagueResult, _impl_.points_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamLeagueResult, _impl_.earnings_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamLeagueResult, _impl_.audit_action_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamLeagueResult, _impl_.audit_data_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamResult, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamResult, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamResult, _impl_.team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamResult, _impl_.team_abbreviation_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamResult, _impl_.team_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamResult, _impl_.team_logo_url_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamResult, _impl_.total_points_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamResult, _impl_.total_earnings_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_TeamResult, _impl_.league_results_),
  4,
  0,
  2,
  3,
  1,
  5,
  6,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_StandingEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_StandingEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_StandingEntry, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_StandingEntry, _impl_.wins_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_StandingEntry, _impl_.losses_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_StandingEntry, _impl_.team_url_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_StandingEntry, _impl_.team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_StandingEntry, _impl_.team_abbreviation_),
  3,
  4,
  5,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_Standing, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_Standing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_Standing, _impl_.region_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_Standing, _impl_.division_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults_Standing, _impl_.entries_),
  0,
  1,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults, _impl_.results_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults, _impl_.standings_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults, _impl_.major_wildcard_standings_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults, _impl_.major_group_standings_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonResults, _impl_.major_playoff_standings_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonSpoilerResults, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonSpoilerResults, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonSpoilerResults, _impl_.time_last_updated_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCSeasonSpoilerResults, _impl_.saved_results_),
  1,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::CMsgDOTALeagueNode_MatchDetails)},
  { 10, 19, -1, sizeof(::CMsgDOTALeagueNode_VOD)},
  { 22, 48, -1, sizeof(::CMsgDOTALeagueNode)},
  { 68, 88, -1, sizeof(::CMsgDOTALeagueNodeGroup_TeamStanding)},
  { 102, 134, -1, sizeof(::CMsgDOTALeagueNodeGroup)},
  { 160, 180, -1, sizeof(::CMsgDOTALeague_Info)},
  { 194, 203, -1, sizeof(::CMsgDOTALeague_Admin)},
  { 206, 216, -1, sizeof(::CMsgDOTALeague_PrizePoolItem)},
  { 220, 230, -1, sizeof(::CMsgDOTALeague_PrizePool)},
  { 234, 246, -1, sizeof(::CMsgDOTALeague_Stream)},
  { 252, 264, -1, sizeof(::CMsgDOTALeague_SeriesInfo)},
  { 270, 279, -1, sizeof(::CMsgDOTALeague_Player)},
  { 282, 295, -1, sizeof(::CMsgDOTALeague)},
  { 302, -1, -1, sizeof(::CMsgDOTALeagueList)},
  { 309, 324, -1, sizeof(::CMsgDOTALeagueInfo)},
  { 333, -1, -1, sizeof(::CMsgDOTALeagueInfoList)},
  { 340, 359, -1, sizeof(::CMsgDOTALeagueLiveGames_LiveGame)},
  { 372, -1, -1, sizeof(::CMsgDOTALeagueLiveGames)},
  { 379, 388, -1, sizeof(::CMsgDOTALeagueMessages_Message)},
  { 391, -1, -1, sizeof(::CMsgDOTALeagueMessages)},
  { 398, 406, -1, sizeof(::CMsgDOTALeaguePrizePool)},
  { 408, -1, -1, sizeof(::CMsgDOTALeagueInfoListAdminsRequest)},
  { 414, 421, -1, sizeof(::CMsgDOTALeagueAvailableLobbyNodesRequest)},
  { 422, 433, -1, sizeof(::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo)},
  { 438, -1, -1, sizeof(::CMsgDOTALeagueAvailableLobbyNodes)},
  { 445, 468, -1, sizeof(::CMsgDOTALeagueNodeResults_Result)},
  { 485, -1, -1, sizeof(::CMsgDOTALeagueNodeResults)},
  { 492, 508, -1, sizeof(::CMsgDOTADPCLeagueResults_Result)},
  { 518, -1, -1, sizeof(::CMsgDOTADPCLeagueResults)},
  { 527, 538, -1, sizeof(::CMsgDOTADPCTeamResults_Result)},
  { 543, -1, -1, sizeof(::CMsgDOTADPCTeamResults)},
  { 550, 563, -1, sizeof(::CMsgDOTADPCSeasonResults_TeamLeagueResult)},
  { 570, 584, -1, sizeof(::CMsgDOTADPCSeasonResults_TeamResult)},
  { 592, 604, -1, sizeof(::CMsgDOTADPCSeasonResults_StandingEntry)},
  { 610, 619, -1, sizeof(::CMsgDOTADPCSeasonResults_Standing)},
  { 622, -1, -1, sizeof(::CMsgDOTADPCSeasonResults)},
  { 633, 641, -1, sizeof(::CMsgDOTADPCSeasonSpoilerResults)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CMsgDOTALeagueNode_MatchDetails_default_instance_._instance,
  &::_CMsgDOTALeagueNode_VOD_default_instance_._instance,
  &::_CMsgDOTALeagueNode_default_instance_._instance,
  &::_CMsgDOTALeagueNodeGroup_TeamStanding_default_instance_._instance,
  &::_CMsgDOTALeagueNodeGroup_default_instance_._instance,
  &::_CMsgDOTALeague_Info_default_instance_._instance,
  &::_CMsgDOTALeague_Admin_default_instance_._instance,
  &::_CMsgDOTALeague_PrizePoolItem_default_instance_._instance,
  &::_CMsgDOTALeague_PrizePool_default_instance_._instance,
  &::_CMsgDOTALeague_Stream_default_instance_._instance,
  &::_CMsgDOTALeague_SeriesInfo_default_instance_._instance,
  &::_CMsgDOTALeague_Player_default_instance_._instance,
  &::_CMsgDOTALeague_default_instance_._instance,
  &::_CMsgDOTALeagueList_default_instance_._instance,
  &::_CMsgDOTALeagueInfo_default_instance_._instance,
  &::_CMsgDOTALeagueInfoList_default_instance_._instance,
  &::_CMsgDOTALeagueLiveGames_LiveGame_default_instance_._instance,
  &::_CMsgDOTALeagueLiveGames_default_instance_._instance,
  &::_CMsgDOTALeagueMessages_Message_default_instance_._instance,
  &::_CMsgDOTALeagueMessages_default_instance_._instance,
  &::_CMsgDOTALeaguePrizePool_default_instance_._instance,
  &::_CMsgDOTALeagueInfoListAdminsRequest_default_instance_._instance,
  &::_CMsgDOTALeagueAvailableLobbyNodesRequest_default_instance_._instance,
  &::_CMsgDOTALeagueAvailableLobbyNodes_NodeInfo_default_instance_._instance,
  &::_CMsgDOTALeagueAvailableLobbyNodes_default_instance_._instance,
  &::_CMsgDOTALeagueNodeResults_Result_default_instance_._instance,
  &::_CMsgDOTALeagueNodeResults_default_instance_._instance,
  &::_CMsgDOTADPCLeagueResults_Result_default_instance_._instance,
  &::_CMsgDOTADPCLeagueResults_default_instance_._instance,
  &::_CMsgDOTADPCTeamResults_Result_default_instance_._instance,
  &::_CMsgDOTADPCTeamResults_default_instance_._instance,
  &::_CMsgDOTADPCSeasonResults_TeamLeagueResult_default_instance_._instance,
  &::_CMsgDOTADPCSeasonResults_TeamResult_default_instance_._instance,
  &::_CMsgDOTADPCSeasonResults_StandingEntry_default_instance_._instance,
  &::_CMsgDOTADPCSeasonResults_Standing_default_instance_._instance,
  &::_CMsgDOTADPCSeasonResults_default_instance_._instance,
  &::_CMsgDOTADPCSeasonSpoilerResults_default_instance_._instance,
};

const char descriptor_table_protodef_dota_5fgcmessages_5fcommon_5fleague_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n#dota_gcmessages_common_league.proto\032\027d"
  "ota_shared_enums.proto\"\213\005\n\022CMsgDOTALeagu"
  "eNode\022\014\n\004name\030\001 \001(\t\022\017\n\007node_id\030\002 \001(\r\022\025\n\r"
  "node_group_id\030\003 \001(\r\022\027\n\017winning_node_id\030\004"
  " \001(\r\022\026\n\016losing_node_id\030\005 \001(\r\022\032\n\022incoming"
  "_node_id_1\030\006 \001(\r\022\032\n\022incoming_node_id_2\030\007"
  " \001(\r\0226\n\tnode_type\030\010 \001(\0162\020.ELeagueNodeTyp"
  "e:\021INVALID_NODE_TYPE\022\026\n\016scheduled_time\030\t"
  " \001(\r\022\023\n\013actual_time\030\023 \001(\r\022\021\n\tseries_id\030\n"
  " \001(\r\022\021\n\tteam_id_1\030\013 \001(\r\022\021\n\tteam_id_2\030\014 \001"
  "(\r\0221\n\007matches\030\r \003(\0132 .CMsgDOTALeagueNode"
  ".MatchDetails\022\023\n\013team_1_wins\030\016 \001(\r\022\023\n\013te"
  "am_2_wins\030\017 \001(\r\022\023\n\013has_started\030\020 \001(\010\022\024\n\014"
  "is_completed\030\021 \001(\010\022\022\n\nstream_ids\030\022 \003(\r\022%"
  "\n\004vods\030\024 \003(\0132\027.CMsgDOTALeagueNode.VOD\0329\n"
  "\014MatchDetails\022\020\n\010match_id\030\001 \001(\004\022\027\n\017winni"
  "ng_team_id\030\002 \001(\r\032:\n\003VOD\022\023\n\013series_game\030\001"
  " \001(\r\022\021\n\tstream_id\030\002 \001(\r\022\013\n\003url\030\003 \001(\t\"\325\t\n"
  "\027CMsgDOTALeagueNodeGroup\022\014\n\004name\030\001 \001(\t\022\025"
  "\n\rnode_group_id\030\002 \001(\r\022\034\n\024parent_node_gro"
  "up_id\030\003 \001(\r\022\037\n\027incoming_node_group_ids\030\004"
  " \003(\r\022\037\n\027advancing_node_group_id\030\005 \001(\r\022\034\n"
  "\024advancing_team_count\030\006 \001(\r\022\022\n\nteam_coun"
  "t\030\007 \001(\r\022B\n\017node_group_type\030\010 \001(\0162\025.ELeag"
  "ueNodeGroupType:\022INVALID_GROUP_TYPE\022>\n\021d"
  "efault_node_type\030\t \001(\0162\020.ELeagueNodeType"
  ":\021INVALID_NODE_TYPE\022\r\n\005round\030\n \001(\r\022\022\n\nma"
  "x_rounds\030\013 \001(\r\022\025\n\ris_tiebreaker\030\014 \001(\010\022\026\n"
  "\016is_final_group\030\r \001(\010\022\024\n\014is_completed\030\016 "
  "\001(\010\0220\n\005phase\030\022 \001(\0162\r.ELeaguePhase:\022LEAGU"
  "E_PHASE_UNSET\0223\n\006region\030\023 \001(\0162\016.ELeagueR"
  "egion:\023LEAGUE_REGION_UNSET\022\022\n\nstart_time"
  "\030\024 \001(\r\022\020\n\010end_time\030\025 \001(\r\022)\n!secondary_ad"
  "vancing_node_group_id\030\026 \001(\r\022&\n\036secondary"
  "_advancing_team_count\030\027 \001(\r\022(\n tertiary_"
  "advancing_node_group_id\030\030 \001(\r\022%\n\035tertiar"
  "y_advancing_team_count\030\031 \001(\r\022\036\n\026eliminat"
  "ion_dpc_points\030\032 \001(\r\022=\n\016team_standings\030\017"
  " \003(\0132%.CMsgDOTALeagueNodeGroup.TeamStand"
  "ing\022\"\n\005nodes\030\020 \003(\0132\023.CMsgDOTALeagueNode\022"
  "-\n\013node_groups\030\021 \003(\0132\030.CMsgDOTALeagueNod"
  "eGroup\032\263\002\n\014TeamStanding\022\020\n\010standing\030\001 \001("
  "\r\022\017\n\007team_id\030\002 \001(\r\022\021\n\tteam_name\030\003 \001(\t\022\020\n"
  "\010team_tag\030\004 \001(\t\022\021\n\tteam_logo\030\005 \001(\004\022\025\n\rte"
  "am_logo_url\030\006 \001(\t\022\014\n\004wins\030\007 \001(\r\022\016\n\006losse"
  "s\030\010 \001(\r\022\r\n\005score\030\t \001(\003\022\031\n\021team_abbreviat"
  "ion\030\n \001(\t\022\034\n\024score_tiebreak_group\030\013 \001(\003\022"
  "\034\n\024score_tiebreak_below\030\014 \001(\003\022\035\n\025score_t"
  "iebreak_random\030\r \001(\003\022\016\n\006is_pro\030\016 \001(\010\"\242\013\n"
  "\016CMsgDOTALeague\022\"\n\004info\030\001 \001(\0132\024.CMsgDOTA"
  "League.Info\022-\n\nprize_pool\030\002 \001(\0132\031.CMsgDO"
  "TALeague.PrizePool\022%\n\006admins\030\003 \003(\0132\025.CMs"
  "gDOTALeague.Admin\022\'\n\007streams\030\004 \003(\0132\026.CMs"
  "gDOTALeague.Stream\022-\n\013node_groups\030\005 \003(\0132"
  "\030.CMsgDOTALeagueNodeGroup\0220\n\014series_info"
  "s\030\006 \003(\0132\032.CMsgDOTALeague.SeriesInfo\0222\n\022r"
  "egistered_players\030\007 \003(\0132\026.CMsgDOTALeague"
  ".Player\032\214\003\n\004Info\022\021\n\tleague_id\030\001 \001(\r\022\014\n\004n"
  "ame\030\002 \001(\t\022-\n\004tier\030\003 \001(\0162\014.ELeagueTier:\021L"
  "EAGUE_TIER_UNSET\0223\n\006region\030\004 \001(\0162\016.ELeag"
  "ueRegion:\023LEAGUE_REGION_UNSET\022\013\n\003url\030\005 \001"
  "(\t\022\023\n\013description\030\006 \001(\t\022\r\n\005notes\030\007 \001(\t\022\027"
  "\n\017start_timestamp\030\010 \001(\r\022\025\n\rend_timestamp"
  "\030\t \001(\r\022\032\n\022pro_circuit_points\030\n \001(\r\022\022\n\nim"
  "age_bits\030\013 \001(\r\0223\n\006status\030\014 \001(\0162\016.ELeague"
  "Status:\023LEAGUE_STATUS_UNSET\022\034\n\024most_rece"
  "nt_activity\030\r \001(\r\022\033\n\023registration_period"
  "\030\016 \001(\r\032F\n\005Admin\022\022\n\naccount_id\030\001 \001(\r\022\022\n\ni"
  "s_primary\030\002 \001(\010\022\025\n\remail_address\030\003 \001(\t\032t"
  "\n\rPrizePoolItem\022\020\n\010item_def\030\001 \001(\r\022\034\n\024sal"
  "es_stop_timestamp\030\002 \001(\r\022\023\n\013revenue_pct\030\003"
  " \001(\r\022\036\n\026revenue_cents_per_sale\030\004 \001(\r\032\225\001\n"
  "\tPrizePool\022\027\n\017base_prize_pool\030\001 \001(\r\022\030\n\020t"
  "otal_prize_pool\030\002 \001(\r\022\034\n\024prize_split_pct"
  "_x100\030\003 \003(\r\0227\n\020prize_pool_items\030\004 \003(\0132\035."
  "CMsgDOTALeague.PrizePoolItem\032\261\001\n\006Stream\022"
  "\021\n\tstream_id\030\001 \001(\r\022\020\n\010language\030\002 \001(\r\022\014\n\004"
  "name\030\003 \001(\t\022O\n\022broadcast_provider\030\004 \001(\0162\031"
  ".ELeagueBroadcastProvider:\030LEAGUE_BROADC"
  "AST_UNKNOWN\022\022\n\nstream_url\030\005 \001(\t\022\017\n\007vod_u"
  "rl\030\006 \001(\t\032\201\001\n\nSeriesInfo\022\021\n\tseries_id\030\001 \001"
  "(\r\022\023\n\013series_type\030\002 \001(\r\022\022\n\nstart_time\030\003 "
  "\001(\r\022\021\n\tmatch_ids\030\004 \003(\004\022\021\n\tteam_id_1\030\005 \001("
  "\r\022\021\n\tteam_id_2\030\006 \001(\r\032;\n\006Player\022\022\n\naccoun"
  "t_id\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\022\017\n\007team_id\030\003 \001("
  "\r\"6\n\022CMsgDOTALeagueList\022 \n\007leagues\030\001 \003(\013"
  "2\017.CMsgDOTALeague\"\221\002\n\022CMsgDOTALeagueInfo"
  "\022\021\n\tleague_id\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\022-\n\004tie"
  "r\030\003 \001(\0162\014.ELeagueTier:\021LEAGUE_TIER_UNSET"
  "\0223\n\006region\030\004 \001(\0162\016.ELeagueRegion:\023LEAGUE"
  "_REGION_UNSET\022\034\n\024most_recent_activity\030\005 "
  "\001(\r\022\030\n\020total_prize_pool\030\006 \001(\r\022\027\n\017start_t"
  "imestamp\030\007 \001(\r\022\025\n\rend_timestamp\030\010 \001(\r\022\016\n"
  "\006status\030\t \001(\r\"<\n\026CMsgDOTALeagueInfoList\022"
  "\"\n\005infos\030\001 \003(\0132\023.CMsgDOTALeagueInfo\"\344\002\n\027"
  "CMsgDOTALeagueLiveGames\0220\n\005games\030\001 \003(\0132!"
  ".CMsgDOTALeagueLiveGames.LiveGame\032\226\002\n\010Li"
  "veGame\022\021\n\tleague_id\030\001 \001(\r\022\027\n\017server_stea"
  "m_id\030\002 \001(\004\022\024\n\014radiant_name\030\003 \001(\t\022\024\n\014radi"
  "ant_logo\030\004 \001(\004\022\027\n\017radiant_team_id\030\t \001(\r\022"
  "\021\n\tdire_name\030\005 \001(\t\022\021\n\tdire_logo\030\006 \001(\004\022\024\n"
  "\014dire_team_id\030\n \001(\r\022\014\n\004time\030\007 \001(\r\022\022\n\nspe"
  "ctators\030\010 \001(\r\022\026\n\016league_node_id\030\013 \001(\r\022\021\n"
  "\tseries_id\030\014 \001(\r\022\020\n\010match_id\030\r \001(\004\"\225\001\n\026C"
  "MsgDOTALeagueMessages\0221\n\010messages\030\001 \003(\0132"
  "\037.CMsgDOTALeagueMessages.Message\032H\n\007Mess"
  "age\022\031\n\021author_account_id\030\001 \001(\r\022\021\n\ttimest"
  "amp\030\002 \001(\r\022\017\n\007message\030\003 \001(\t\"K\n\027CMsgDOTALe"
  "aguePrizePool\022\022\n\nprize_pool\030\001 \001(\r\022\034\n\024inc"
  "rement_per_second\030\002 \001(\002\"%\n#CMsgDOTALeagu"
  "eInfoListAdminsRequest\"=\n(CMsgDOTALeague"
  "AvailableLobbyNodesRequest\022\021\n\tleague_id\030"
  "\001 \001(\r\"\323\001\n!CMsgDOTALeagueAvailableLobbyNo"
  "des\022\?\n\nnode_infos\030\001 \003(\0132+.CMsgDOTALeague"
  "AvailableLobbyNodes.NodeInfo\032m\n\010NodeInfo"
  "\022\017\n\007node_id\030\001 \001(\r\022\021\n\tnode_name\030\002 \001(\t\022\027\n\017"
  "node_group_name\030\003 \001(\t\022\021\n\tteam_id_1\030\004 \001(\r"
  "\022\021\n\tteam_id_2\030\005 \001(\r\"\332\003\n\031CMsgDOTALeagueNo"
  "deResults\0227\n\014node_results\030\001 \003(\0132!.CMsgDO"
  "TALeagueNodeResults.Result\032\203\003\n\006Result\022\017\n"
  "\007node_id\030\001 \001(\r\022\027\n\017winning_node_id\030\002 \001(\r\022"
  "\026\n\016losing_node_id\030\003 \001(\r\022\032\n\022incoming_node"
  "_id_1\030\004 \001(\r\022\032\n\022incoming_node_id_2\030\005 \001(\r\022"
  "\021\n\tteam_id_1\030\006 \001(\r\022\021\n\tteam_id_2\030\007 \001(\r\022\023\n"
  "\013team_1_name\030\010 \001(\t\022\023\n\013team_2_name\030\t \001(\t\022"
  "\023\n\013team_1_wins\030\n \001(\r\022\023\n\013team_2_wins\030\013 \001("
  "\r\022\027\n\017winning_team_id\030\014 \001(\r\022\026\n\016losing_tea"
  "m_id\030\r \001(\r\022\023\n\013has_started\030\016 \001(\010\022\024\n\014is_co"
  "mpleted\030\017 \001(\010\022\026\n\016scheduled_time\030\020 \001(\r\022\021\n"
  "\tmatch_ids\030\021 \003(\004\"\333\002\n\030CMsgDOTADPCLeagueRe"
  "sults\0221\n\007results\030\001 \003(\0132 .CMsgDOTADPCLeag"
  "ueResults.Result\022\016\n\006points\030\002 \003(\r\022\017\n\007doll"
  "ars\030\003 \003(\r\032\352\001\n\006Result\022\020\n\010standing\030\001 \001(\r\022\017"
  "\n\007team_id\030\002 \001(\r\022\021\n\tteam_name\030\003 \001(\t\022\021\n\tte"
  "am_logo\030\004 \001(\004\022\025\n\rteam_logo_url\030\005 \001(\t\022\016\n\006"
  "points\030\006 \001(\r\022\020\n\010earnings\030\007 \001(\r\022\021\n\ttimest"
  "amp\030\010 \001(\r\0220\n\005phase\030\t \001(\0162\r.ELeaguePhase:"
  "\022LEAGUE_PHASE_UNSET\022\031\n\021team_abbreviation"
  "\030\n \001(\t\"\255\001\n\026CMsgDOTADPCTeamResults\022/\n\007res"
  "ults\030\001 \003(\0132\036.CMsgDOTADPCTeamResults.Resu"
  "lt\032b\n\006Result\022\021\n\tleague_id\030\001 \001(\r\022\020\n\010stand"
  "ing\030\002 \001(\r\022\016\n\006points\030\003 \001(\r\022\020\n\010earnings\030\004 "
  "\001(\r\022\021\n\ttimestamp\030\005 \001(\r\"\237\010\n\030CMsgDOTADPCSe"
  "asonResults\0225\n\007results\030\001 \003(\0132$.CMsgDOTAD"
  "PCSeasonResults.TeamResult\0225\n\tstandings\030"
  "\002 \003(\0132\".CMsgDOTADPCSeasonResults.Standin"
  "g\022I\n\030major_wildcard_standings\030\003 \003(\0132\'.CM"
  "sgDOTADPCSeasonResults.StandingEntry\022F\n\025"
  "major_group_standings\030\004 \003(\0132\'.CMsgDOTADP"
  "CSeasonResults.StandingEntry\022H\n\027major_pl"
  "ayoff_standings\030\005 \003(\0132\'.CMsgDOTADPCSeaso"
  "nResults.StandingEntry\032\226\001\n\020TeamLeagueRes"
  "ult\022\021\n\ttimestamp\030\001 \001(\r\022\021\n\tleague_id\030\002 \001("
  "\r\022\020\n\010standing\030\003 \001(\r\022\016\n\006points\030\004 \001(\r\022\020\n\010e"
  "arnings\030\005 \001(\r\022\024\n\014audit_action\030\006 \001(\r\022\022\n\na"
  "udit_data\030\007 \001(\r\032\347\001\n\nTeamResult\022\017\n\007team_i"
  "d\030\001 \001(\r\022\021\n\tteam_name\030\002 \001(\t\022\031\n\021team_abbre"
  "viation\030\010 \001(\t\022\021\n\tteam_logo\030\003 \001(\004\022\025\n\rteam"
  "_logo_url\030\004 \001(\t\022\024\n\014total_points\030\005 \001(\r\022\026\n"
  "\016total_earnings\030\006 \001(\r\022B\n\016league_results\030"
  "\007 \003(\0132*.CMsgDOTADPCSeasonResults.TeamLea"
  "gueResult\032~\n\rStandingEntry\022\017\n\007team_id\030\001 "
  "\001(\r\022\014\n\004wins\030\002 \001(\r\022\016\n\006losses\030\003 \001(\r\022\020\n\010tea"
  "m_url\030\004 \001(\t\022\021\n\tteam_name\030\005 \001(\t\022\031\n\021team_a"
  "bbreviation\030\006 \001(\t\032\264\001\n\010Standing\0223\n\006region"
  "\030\001 \001(\0162\016.ELeagueRegion:\023LEAGUE_REGION_UN"
  "SET\0229\n\010division\030\002 \001(\0162\020.ELeagueDivision:"
  "\025LEAGUE_DIVISION_UNSET\0228\n\007entries\030\003 \003(\0132"
  "\'.CMsgDOTADPCSeasonResults.StandingEntry"
  "\"n\n\037CMsgDOTADPCSeasonSpoilerResults\022\031\n\021t"
  "ime_last_updated\030\001 \001(\r\0220\n\rsaved_results\030"
  "\002 \001(\0132\031.CMsgDOTADPCSeasonResults*\310\001\n\024ELe"
  "agueNodeGroupType\022\026\n\022INVALID_GROUP_TYPE\020"
  "\000\022\022\n\016ORGANIZATIONAL\020\001\022\017\n\013ROUND_ROBIN\020\002\022\t"
  "\n\005SWISS\020\003\022\022\n\016BRACKET_SINGLE\020\004\022\035\n\031BRACKET"
  "_DOUBLE_SEED_LOSER\020\005\022\035\n\031BRACKET_DOUBLE_A"
  "LL_WINNER\020\006\022\r\n\tSHOWMATCH\020\007\022\007\n\003GSL\020\010*o\n\017E"
  "LeagueNodeType\022\025\n\021INVALID_NODE_TYPE\020\000\022\017\n"
  "\013BEST_OF_ONE\020\001\022\021\n\rBEST_OF_THREE\020\002\022\020\n\014BES"
  "T_OF_FIVE\020\003\022\017\n\013BEST_OF_TWO\020\004"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_deps[1] = {
  &::descriptor_table_dota_5fshared_5fenums_2eproto,
};
static ::_pbi::once_flag descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto = {
    false, false, 7188, descriptor_table_protodef_dota_5fgcmessages_5fcommon_5fleague_2eproto,
    "dota_gcmessages_common_league.proto",
    &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once, descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_deps, 1, 37,
    schemas, file_default_instances, TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto::offsets,
    file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto, file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5fleague_2eproto,
    file_level_service_descriptors_dota_5fgcmessages_5fcommon_5fleague_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter() {
  return &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_dota_5fgcmessages_5fcommon_5fleague_2eproto(&descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueNodeGroupType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5fleague_2eproto[0];
}
bool ELeagueNodeGroupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueNodeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5fleague_2eproto[1];
}
bool ELeagueNodeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CMsgDOTALeagueNode_MatchDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeagueNode_MatchDetails>()._impl_._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_winning_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTALeagueNode_MatchDetails::CMsgDOTALeagueNode_MatchDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueNode.MatchDetails)
}
CMsgDOTALeagueNode_MatchDetails::CMsgDOTALeagueNode_MatchDetails(const CMsgDOTALeagueNode_MatchDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueNode_MatchDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.winning_team_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.match_id_, &from._impl_.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.winning_team_id_) -
    reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.winning_team_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueNode.MatchDetails)
}

inline void CMsgDOTALeagueNode_MatchDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.winning_team_id_){0u}
  };
}

CMsgDOTALeagueNode_MatchDetails::~CMsgDOTALeagueNode_MatchDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueNode.MatchDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueNode_MatchDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTALeagueNode_MatchDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueNode_MatchDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueNode.MatchDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.winning_team_id_) -
        reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.winning_team_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueNode_MatchDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 match_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 winning_team_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_winning_team_id(&has_bits);
          _impl_.winning_team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueNode_MatchDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueNode.MatchDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 match_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_match_id(), target);
  }

  // optional uint32 winning_team_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_winning_team_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueNode.MatchDetails)
  return target;
}

size_t CMsgDOTALeagueNode_MatchDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueNode.MatchDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 match_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 winning_team_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_winning_team_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueNode_MatchDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueNode_MatchDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueNode_MatchDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueNode_MatchDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueNode_MatchDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueNode_MatchDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueNode.MatchDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.winning_team_id_ = from._impl_.winning_team_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueNode_MatchDetails::CopyFrom(const CMsgDOTALeagueNode_MatchDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueNode.MatchDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueNode_MatchDetails::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueNode_MatchDetails::InternalSwap(CMsgDOTALeagueNode_MatchDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueNode_MatchDetails, _impl_.winning_team_id_)
      + sizeof(CMsgDOTALeagueNode_MatchDetails::_impl_.winning_team_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueNode_MatchDetails, _impl_.match_id_)>(
          reinterpret_cast<char*>(&_impl_.match_id_),
          reinterpret_cast<char*>(&other->_impl_.match_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueNode_MatchDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[0]);
}

// ===================================================================

class CMsgDOTALeagueNode_VOD::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeagueNode_VOD>()._impl_._has_bits_);
  static void set_has_series_game(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTALeagueNode_VOD::CMsgDOTALeagueNode_VOD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueNode.VOD)
}
CMsgDOTALeagueNode_VOD::CMsgDOTALeagueNode_VOD(const CMsgDOTALeagueNode_VOD& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueNode_VOD* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.series_game_){}
    , decltype(_impl_.stream_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.series_game_, &from._impl_.series_game_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stream_id_) -
    reinterpret_cast<char*>(&_impl_.series_game_)) + sizeof(_impl_.stream_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueNode.VOD)
}

inline void CMsgDOTALeagueNode_VOD::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.series_game_){0u}
    , decltype(_impl_.stream_id_){0u}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeagueNode_VOD::~CMsgDOTALeagueNode_VOD() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueNode.VOD)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueNode_VOD::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.url_.Destroy();
}

void CMsgDOTALeagueNode_VOD::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueNode_VOD::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueNode.VOD)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.url_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.series_game_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.stream_id_) -
        reinterpret_cast<char*>(&_impl_.series_game_)) + sizeof(_impl_.stream_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueNode_VOD::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 series_game = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_series_game(&has_bits);
          _impl_.series_game_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stream_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_stream_id(&has_bits);
          _impl_.stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueNode.VOD.url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueNode_VOD::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueNode.VOD)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 series_game = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_series_game(), target);
  }

  // optional uint32 stream_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_stream_id(), target);
  }

  // optional string url = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueNode.VOD.url");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueNode.VOD)
  return target;
}

size_t CMsgDOTALeagueNode_VOD::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueNode.VOD)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string url = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional uint32 series_game = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_series_game());
    }

    // optional uint32 stream_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stream_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueNode_VOD::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueNode_VOD::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueNode_VOD::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueNode_VOD::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueNode_VOD*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueNode_VOD&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueNode.VOD)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.series_game_ = from._impl_.series_game_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.stream_id_ = from._impl_.stream_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueNode_VOD::CopyFrom(const CMsgDOTALeagueNode_VOD& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueNode.VOD)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueNode_VOD::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueNode_VOD::InternalSwap(CMsgDOTALeagueNode_VOD* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueNode_VOD, _impl_.stream_id_)
      + sizeof(CMsgDOTALeagueNode_VOD::_impl_.stream_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueNode_VOD, _impl_.series_game_)>(
          reinterpret_cast<char*>(&_impl_.series_game_),
          reinterpret_cast<char*>(&other->_impl_.series_game_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueNode_VOD::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[1]);
}

// ===================================================================

class CMsgDOTALeagueNode::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeagueNode>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_node_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_winning_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_losing_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_incoming_node_id_1(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_incoming_node_id_2(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_node_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_scheduled_time(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_actual_time(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_series_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_team_id_1(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_team_id_2(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_team_1_wins(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_team_2_wins(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_has_started(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_completed(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

CMsgDOTALeagueNode::CMsgDOTALeagueNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueNode)
}
CMsgDOTALeagueNode::CMsgDOTALeagueNode(const CMsgDOTALeagueNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.matches_){from._impl_.matches_}
    , decltype(_impl_.stream_ids_){from._impl_.stream_ids_}
    , decltype(_impl_.vods_){from._impl_.vods_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.node_group_id_){}
    , decltype(_impl_.winning_node_id_){}
    , decltype(_impl_.losing_node_id_){}
    , decltype(_impl_.incoming_node_id_1_){}
    , decltype(_impl_.incoming_node_id_2_){}
    , decltype(_impl_.node_type_){}
    , decltype(_impl_.scheduled_time_){}
    , decltype(_impl_.series_id_){}
    , decltype(_impl_.team_id_1_){}
    , decltype(_impl_.team_id_2_){}
    , decltype(_impl_.team_1_wins_){}
    , decltype(_impl_.team_2_wins_){}
    , decltype(_impl_.has_started_){}
    , decltype(_impl_.is_completed_){}
    , decltype(_impl_.actual_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.node_id_, &from._impl_.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.actual_time_) -
    reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.actual_time_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueNode)
}

inline void CMsgDOTALeagueNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.matches_){arena}
    , decltype(_impl_.stream_ids_){arena}
    , decltype(_impl_.vods_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.node_id_){0u}
    , decltype(_impl_.node_group_id_){0u}
    , decltype(_impl_.winning_node_id_){0u}
    , decltype(_impl_.losing_node_id_){0u}
    , decltype(_impl_.incoming_node_id_1_){0u}
    , decltype(_impl_.incoming_node_id_2_){0u}
    , decltype(_impl_.node_type_){0}
    , decltype(_impl_.scheduled_time_){0u}
    , decltype(_impl_.series_id_){0u}
    , decltype(_impl_.team_id_1_){0u}
    , decltype(_impl_.team_id_2_){0u}
    , decltype(_impl_.team_1_wins_){0u}
    , decltype(_impl_.team_2_wins_){0u}
    , decltype(_impl_.has_started_){false}
    , decltype(_impl_.is_completed_){false}
    , decltype(_impl_.actual_time_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeagueNode::~CMsgDOTALeagueNode() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.matches_.~RepeatedPtrField();
  _impl_.stream_ids_.~RepeatedField();
  _impl_.vods_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void CMsgDOTALeagueNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueNode::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matches_.Clear();
  _impl_.stream_ids_.Clear();
  _impl_.vods_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.node_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.node_type_) -
        reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.node_type_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.scheduled_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_completed_) -
        reinterpret_cast<char*>(&_impl_.scheduled_time_)) + sizeof(_impl_.is_completed_));
  }
  _impl_.actual_time_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueNode.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 node_group_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_node_group_id(&has_bits);
          _impl_.node_group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 winning_node_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_winning_node_id(&has_bits);
          _impl_.winning_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 losing_node_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_losing_node_id(&has_bits);
          _impl_.losing_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 incoming_node_id_1 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_incoming_node_id_1(&has_bits);
          _impl_.incoming_node_id_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 incoming_node_id_2 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_incoming_node_id_2(&has_bits);
          _impl_.incoming_node_id_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueNodeType node_type = 8 [default = INVALID_NODE_TYPE];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueNodeType_IsValid(val))) {
            _internal_set_node_type(static_cast<::ELeagueNodeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 scheduled_time = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_scheduled_time(&has_bits);
          _impl_.scheduled_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 series_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_series_id(&has_bits);
          _impl_.series_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id_1 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_team_id_1(&has_bits);
          _impl_.team_id_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id_2 = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_team_id_2(&has_bits);
          _impl_.team_id_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTALeagueNode.MatchDetails matches = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_1_wins = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_team_1_wins(&has_bits);
          _impl_.team_1_wins_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_2_wins = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_team_2_wins(&has_bits);
          _impl_.team_2_wins_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_started = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_has_started(&has_bits);
          _impl_.has_started_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_completed = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_is_completed(&has_bits);
          _impl_.is_completed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 stream_ids = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_stream_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<144>(ptr));
        } else if (static_cast<uint8_t>(tag) == 146) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_stream_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 actual_time = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_actual_time(&has_bits);
          _impl_.actual_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTALeagueNode.VOD vods = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_vods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueNode.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 node_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_node_id(), target);
  }

  // optional uint32 node_group_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_node_group_id(), target);
  }

  // optional uint32 winning_node_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_winning_node_id(), target);
  }

  // optional uint32 losing_node_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_losing_node_id(), target);
  }

  // optional uint32 incoming_node_id_1 = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_incoming_node_id_1(), target);
  }

  // optional uint32 incoming_node_id_2 = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_incoming_node_id_2(), target);
  }

  // optional .ELeagueNodeType node_type = 8 [default = INVALID_NODE_TYPE];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_node_type(), target);
  }

  // optional uint32 scheduled_time = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_scheduled_time(), target);
  }

  // optional uint32 series_id = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_series_id(), target);
  }

  // optional uint32 team_id_1 = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_team_id_1(), target);
  }

  // optional uint32 team_id_2 = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_team_id_2(), target);
  }

  // repeated .CMsgDOTALeagueNode.MatchDetails matches = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_matches_size()); i < n; i++) {
    const auto& repfield = this->_internal_matches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 team_1_wins = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_team_1_wins(), target);
  }

  // optional uint32 team_2_wins = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_team_2_wins(), target);
  }

  // optional bool has_started = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_has_started(), target);
  }

  // optional bool is_completed = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_is_completed(), target);
  }

  // repeated uint32 stream_ids = 18;
  for (int i = 0, n = this->_internal_stream_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_stream_ids(i), target);
  }

  // optional uint32 actual_time = 19;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_actual_time(), target);
  }

  // repeated .CMsgDOTALeagueNode.VOD vods = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vods_size()); i < n; i++) {
    const auto& repfield = this->_internal_vods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueNode)
  return target;
}

size_t CMsgDOTALeagueNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTALeagueNode.MatchDetails matches = 13;
  total_size += 1UL * this->_internal_matches_size();
  for (const auto& msg : this->_impl_.matches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 stream_ids = 18;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.stream_ids_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_stream_ids_size());
    total_size += data_size;
  }

  // repeated .CMsgDOTALeagueNode.VOD vods = 20;
  total_size += 2UL * this->_internal_vods_size();
  for (const auto& msg : this->_impl_.vods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 node_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
    }

    // optional uint32 node_group_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_group_id());
    }

    // optional uint32 winning_node_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_winning_node_id());
    }

    // optional uint32 losing_node_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_losing_node_id());
    }

    // optional uint32 incoming_node_id_1 = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_incoming_node_id_1());
    }

    // optional uint32 incoming_node_id_2 = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_incoming_node_id_2());
    }

    // optional .ELeagueNodeType node_type = 8 [default = INVALID_NODE_TYPE];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_node_type());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 scheduled_time = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_scheduled_time());
    }

    // optional uint32 series_id = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_series_id());
    }

    // optional uint32 team_id_1 = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id_1());
    }

    // optional uint32 team_id_2 = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id_2());
    }

    // optional uint32 team_1_wins = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_1_wins());
    }

    // optional uint32 team_2_wins = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_2_wins());
    }

    // optional bool has_started = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool is_completed = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  // optional uint32 actual_time = 19;
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_actual_time());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueNode::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueNode*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.matches_.MergeFrom(from._impl_.matches_);
  _this->_impl_.stream_ids_.MergeFrom(from._impl_.stream_ids_);
  _this->_impl_.vods_.MergeFrom(from._impl_.vods_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.node_id_ = from._impl_.node_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.node_group_id_ = from._impl_.node_group_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.winning_node_id_ = from._impl_.winning_node_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.losing_node_id_ = from._impl_.losing_node_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.incoming_node_id_1_ = from._impl_.incoming_node_id_1_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.incoming_node_id_2_ = from._impl_.incoming_node_id_2_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.node_type_ = from._impl_.node_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.scheduled_time_ = from._impl_.scheduled_time_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.series_id_ = from._impl_.series_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.team_id_1_ = from._impl_.team_id_1_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.team_id_2_ = from._impl_.team_id_2_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.team_1_wins_ = from._impl_.team_1_wins_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.team_2_wins_ = from._impl_.team_2_wins_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.has_started_ = from._impl_.has_started_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.is_completed_ = from._impl_.is_completed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _this->_internal_set_actual_time(from._internal_actual_time());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueNode::CopyFrom(const CMsgDOTALeagueNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueNode::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueNode::InternalSwap(CMsgDOTALeagueNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.matches_.InternalSwap(&other->_impl_.matches_);
  _impl_.stream_ids_.InternalSwap(&other->_impl_.stream_ids_);
  _impl_.vods_.InternalSwap(&other->_impl_.vods_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueNode, _impl_.actual_time_)
      + sizeof(CMsgDOTALeagueNode::_impl_.actual_time_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueNode, _impl_.node_id_)>(
          reinterpret_cast<char*>(&_impl_.node_id_),
          reinterpret_cast<char*>(&other->_impl_.node_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[2]);
}

// ===================================================================

class CMsgDOTALeagueNodeGroup_TeamStanding::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeagueNodeGroup_TeamStanding>()._impl_._has_bits_);
  static void set_has_standing(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_team_logo_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_wins(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_losses(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_team_abbreviation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_score_tiebreak_group(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_score_tiebreak_below(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_score_tiebreak_random(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_is_pro(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

CMsgDOTALeagueNodeGroup_TeamStanding::CMsgDOTALeagueNodeGroup_TeamStanding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueNodeGroup.TeamStanding)
}
CMsgDOTALeagueNodeGroup_TeamStanding::CMsgDOTALeagueNodeGroup_TeamStanding(const CMsgDOTALeagueNodeGroup_TeamStanding& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueNodeGroup_TeamStanding* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_tag_){}
    , decltype(_impl_.team_logo_url_){}
    , decltype(_impl_.team_abbreviation_){}
    , decltype(_impl_.standing_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.team_logo_){}
    , decltype(_impl_.wins_){}
    , decltype(_impl_.losses_){}
    , decltype(_impl_.score_){}
    , decltype(_impl_.score_tiebreak_group_){}
    , decltype(_impl_.score_tiebreak_below_){}
    , decltype(_impl_.score_tiebreak_random_){}
    , decltype(_impl_.is_pro_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_name()) {
    _this->_impl_.team_name_.Set(from._internal_team_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_tag()) {
    _this->_impl_.team_tag_.Set(from._internal_team_tag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_logo_url()) {
    _this->_impl_.team_logo_url_.Set(from._internal_team_logo_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_abbreviation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_abbreviation()) {
    _this->_impl_.team_abbreviation_.Set(from._internal_team_abbreviation(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.standing_, &from._impl_.standing_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_pro_) -
    reinterpret_cast<char*>(&_impl_.standing_)) + sizeof(_impl_.is_pro_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueNodeGroup.TeamStanding)
}

inline void CMsgDOTALeagueNodeGroup_TeamStanding::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_tag_){}
    , decltype(_impl_.team_logo_url_){}
    , decltype(_impl_.team_abbreviation_){}
    , decltype(_impl_.standing_){0u}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.team_logo_){uint64_t{0u}}
    , decltype(_impl_.wins_){0u}
    , decltype(_impl_.losses_){0u}
    , decltype(_impl_.score_){int64_t{0}}
    , decltype(_impl_.score_tiebreak_group_){int64_t{0}}
    , decltype(_impl_.score_tiebreak_below_){int64_t{0}}
    , decltype(_impl_.score_tiebreak_random_){int64_t{0}}
    , decltype(_impl_.is_pro_){false}
  };
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_abbreviation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeagueNodeGroup_TeamStanding::~CMsgDOTALeagueNodeGroup_TeamStanding() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueNodeGroup.TeamStanding)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueNodeGroup_TeamStanding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.team_name_.Destroy();
  _impl_.team_tag_.Destroy();
  _impl_.team_logo_url_.Destroy();
  _impl_.team_abbreviation_.Destroy();
}

void CMsgDOTALeagueNodeGroup_TeamStanding::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueNodeGroup_TeamStanding::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueNodeGroup.TeamStanding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.team_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.team_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.team_logo_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.team_abbreviation_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.standing_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.wins_) -
        reinterpret_cast<char*>(&_impl_.standing_)) + sizeof(_impl_.wins_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.losses_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_pro_) -
        reinterpret_cast<char*>(&_impl_.losses_)) + sizeof(_impl_.is_pro_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueNodeGroup_TeamStanding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 standing = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_standing(&has_bits);
          _impl_.standing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueNodeGroup.TeamStanding.team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string team_tag = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_team_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueNodeGroup.TeamStanding.team_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 team_logo = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_team_logo(&has_bits);
          _impl_.team_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_logo_url = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_team_logo_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 wins = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_wins(&has_bits);
          _impl_.wins_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 losses = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_losses(&has_bits);
          _impl_.losses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 score = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_score(&has_bits);
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_abbreviation = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_team_abbreviation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueNodeGroup.TeamStanding.team_abbreviation");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int64 score_tiebreak_group = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_score_tiebreak_group(&has_bits);
          _impl_.score_tiebreak_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 score_tiebreak_below = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_score_tiebreak_below(&has_bits);
          _impl_.score_tiebreak_below_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 score_tiebreak_random = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_score_tiebreak_random(&has_bits);
          _impl_.score_tiebreak_random_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_pro = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_is_pro(&has_bits);
          _impl_.is_pro_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueNodeGroup_TeamStanding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueNodeGroup.TeamStanding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 standing = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_standing(), target);
  }

  // optional uint32 team_id = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_team_id(), target);
  }

  // optional string team_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_name().data(), static_cast<int>(this->_internal_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueNodeGroup.TeamStanding.team_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_team_name(), target);
  }

  // optional string team_tag = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_tag().data(), static_cast<int>(this->_internal_team_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueNodeGroup.TeamStanding.team_tag");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_team_tag(), target);
  }

  // optional uint64 team_logo = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_team_logo(), target);
  }

  // optional string team_logo_url = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_logo_url().data(), static_cast<int>(this->_internal_team_logo_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_team_logo_url(), target);
  }

  // optional uint32 wins = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_wins(), target);
  }

  // optional uint32 losses = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_losses(), target);
  }

  // optional int64 score = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_score(), target);
  }

  // optional string team_abbreviation = 10;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_abbreviation().data(), static_cast<int>(this->_internal_team_abbreviation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueNodeGroup.TeamStanding.team_abbreviation");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_team_abbreviation(), target);
  }

  // optional int64 score_tiebreak_group = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(11, this->_internal_score_tiebreak_group(), target);
  }

  // optional int64 score_tiebreak_below = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(12, this->_internal_score_tiebreak_below(), target);
  }

  // optional int64 score_tiebreak_random = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_score_tiebreak_random(), target);
  }

  // optional bool is_pro = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_is_pro(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueNodeGroup.TeamStanding)
  return target;
}

size_t CMsgDOTALeagueNodeGroup_TeamStanding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueNodeGroup.TeamStanding)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string team_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_name());
    }

    // optional string team_tag = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_tag());
    }

    // optional string team_logo_url = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_logo_url());
    }

    // optional string team_abbreviation = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_abbreviation());
    }

    // optional uint32 standing = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_standing());
    }

    // optional uint32 team_id = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint64 team_logo = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_team_logo());
    }

    // optional uint32 wins = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_wins());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional uint32 losses = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_losses());
    }

    // optional int64 score = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_score());
    }

    // optional int64 score_tiebreak_group = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_score_tiebreak_group());
    }

    // optional int64 score_tiebreak_below = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_score_tiebreak_below());
    }

    // optional int64 score_tiebreak_random = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_score_tiebreak_random());
    }

    // optional bool is_pro = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueNodeGroup_TeamStanding::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueNodeGroup_TeamStanding::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueNodeGroup_TeamStanding::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueNodeGroup_TeamStanding::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueNodeGroup_TeamStanding*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueNodeGroup_TeamStanding&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueNodeGroup.TeamStanding)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_team_name(from._internal_team_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_team_tag(from._internal_team_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_team_logo_url(from._internal_team_logo_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_team_abbreviation(from._internal_team_abbreviation());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.standing_ = from._impl_.standing_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.team_logo_ = from._impl_.team_logo_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.wins_ = from._impl_.wins_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.losses_ = from._impl_.losses_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.score_ = from._impl_.score_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.score_tiebreak_group_ = from._impl_.score_tiebreak_group_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.score_tiebreak_below_ = from._impl_.score_tiebreak_below_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.score_tiebreak_random_ = from._impl_.score_tiebreak_random_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.is_pro_ = from._impl_.is_pro_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueNodeGroup_TeamStanding::CopyFrom(const CMsgDOTALeagueNodeGroup_TeamStanding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueNodeGroup.TeamStanding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueNodeGroup_TeamStanding::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueNodeGroup_TeamStanding::InternalSwap(CMsgDOTALeagueNodeGroup_TeamStanding* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_name_, lhs_arena,
      &other->_impl_.team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_tag_, lhs_arena,
      &other->_impl_.team_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_logo_url_, lhs_arena,
      &other->_impl_.team_logo_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_abbreviation_, lhs_arena,
      &other->_impl_.team_abbreviation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.is_pro_)
      + sizeof(CMsgDOTALeagueNodeGroup_TeamStanding::_impl_.is_pro_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueNodeGroup_TeamStanding, _impl_.standing_)>(
          reinterpret_cast<char*>(&_impl_.standing_),
          reinterpret_cast<char*>(&other->_impl_.standing_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueNodeGroup_TeamStanding::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[3]);
}

// ===================================================================

class CMsgDOTALeagueNodeGroup::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeagueNodeGroup>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_node_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_parent_node_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_advancing_node_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_advancing_team_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_team_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_node_group_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_default_node_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_round(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_max_rounds(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_is_tiebreaker(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_is_final_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_is_completed(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_secondary_advancing_node_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_secondary_advancing_team_count(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_tertiary_advancing_node_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_tertiary_advancing_team_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_elimination_dpc_points(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
};

CMsgDOTALeagueNodeGroup::CMsgDOTALeagueNodeGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueNodeGroup)
}
CMsgDOTALeagueNodeGroup::CMsgDOTALeagueNodeGroup(const CMsgDOTALeagueNodeGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueNodeGroup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.incoming_node_group_ids_){from._impl_.incoming_node_group_ids_}
    , decltype(_impl_.team_standings_){from._impl_.team_standings_}
    , decltype(_impl_.nodes_){from._impl_.nodes_}
    , decltype(_impl_.node_groups_){from._impl_.node_groups_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.node_group_id_){}
    , decltype(_impl_.parent_node_group_id_){}
    , decltype(_impl_.advancing_node_group_id_){}
    , decltype(_impl_.advancing_team_count_){}
    , decltype(_impl_.team_count_){}
    , decltype(_impl_.node_group_type_){}
    , decltype(_impl_.default_node_type_){}
    , decltype(_impl_.round_){}
    , decltype(_impl_.max_rounds_){}
    , decltype(_impl_.is_tiebreaker_){}
    , decltype(_impl_.is_final_group_){}
    , decltype(_impl_.is_completed_){}
    , decltype(_impl_.phase_){}
    , decltype(_impl_.region_){}
    , decltype(_impl_.start_time_){}
    , decltype(_impl_.end_time_){}
    , decltype(_impl_.secondary_advancing_node_group_id_){}
    , decltype(_impl_.secondary_advancing_team_count_){}
    , decltype(_impl_.tertiary_advancing_node_group_id_){}
    , decltype(_impl_.tertiary_advancing_team_count_){}
    , decltype(_impl_.elimination_dpc_points_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.node_group_id_, &from._impl_.node_group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.elimination_dpc_points_) -
    reinterpret_cast<char*>(&_impl_.node_group_id_)) + sizeof(_impl_.elimination_dpc_points_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueNodeGroup)
}

inline void CMsgDOTALeagueNodeGroup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.incoming_node_group_ids_){arena}
    , decltype(_impl_.team_standings_){arena}
    , decltype(_impl_.nodes_){arena}
    , decltype(_impl_.node_groups_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.node_group_id_){0u}
    , decltype(_impl_.parent_node_group_id_){0u}
    , decltype(_impl_.advancing_node_group_id_){0u}
    , decltype(_impl_.advancing_team_count_){0u}
    , decltype(_impl_.team_count_){0u}
    , decltype(_impl_.node_group_type_){0}
    , decltype(_impl_.default_node_type_){0}
    , decltype(_impl_.round_){0u}
    , decltype(_impl_.max_rounds_){0u}
    , decltype(_impl_.is_tiebreaker_){false}
    , decltype(_impl_.is_final_group_){false}
    , decltype(_impl_.is_completed_){false}
    , decltype(_impl_.phase_){0}
    , decltype(_impl_.region_){0}
    , decltype(_impl_.start_time_){0u}
    , decltype(_impl_.end_time_){0u}
    , decltype(_impl_.secondary_advancing_node_group_id_){0u}
    , decltype(_impl_.secondary_advancing_team_count_){0u}
    , decltype(_impl_.tertiary_advancing_node_group_id_){0u}
    , decltype(_impl_.tertiary_advancing_team_count_){0u}
    , decltype(_impl_.elimination_dpc_points_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeagueNodeGroup::~CMsgDOTALeagueNodeGroup() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueNodeGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueNodeGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.incoming_node_group_ids_.~RepeatedField();
  _impl_.team_standings_.~RepeatedPtrField();
  _impl_.nodes_.~RepeatedPtrField();
  _impl_.node_groups_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void CMsgDOTALeagueNodeGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueNodeGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueNodeGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.incoming_node_group_ids_.Clear();
  _impl_.team_standings_.Clear();
  _impl_.nodes_.Clear();
  _impl_.node_groups_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.node_group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.default_node_type_) -
        reinterpret_cast<char*>(&_impl_.node_group_id_)) + sizeof(_impl_.default_node_type_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.round_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.start_time_) -
        reinterpret_cast<char*>(&_impl_.round_)) + sizeof(_impl_.start_time_));
  }
  if (cached_has_bits & 0x003f0000u) {
    ::memset(&_impl_.end_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.elimination_dpc_points_) -
        reinterpret_cast<char*>(&_impl_.end_time_)) + sizeof(_impl_.elimination_dpc_points_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueNodeGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueNodeGroup.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 node_group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_node_group_id(&has_bits);
          _impl_.node_group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 parent_node_group_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_parent_node_group_id(&has_bits);
          _impl_.parent_node_group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 incoming_node_group_ids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_incoming_node_group_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_incoming_node_group_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 advancing_node_group_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_advancing_node_group_id(&has_bits);
          _impl_.advancing_node_group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 advancing_team_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_advancing_team_count(&has_bits);
          _impl_.advancing_team_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_team_count(&has_bits);
          _impl_.team_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueNodeGroupType node_group_type = 8 [default = INVALID_GROUP_TYPE];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueNodeGroupType_IsValid(val))) {
            _internal_set_node_group_type(static_cast<::ELeagueNodeGroupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueNodeType default_node_type = 9 [default = INVALID_NODE_TYPE];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueNodeType_IsValid(val))) {
            _internal_set_default_node_type(static_cast<::ELeagueNodeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 round = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_round(&has_bits);
          _impl_.round_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_rounds = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_max_rounds(&has_bits);
          _impl_.max_rounds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_tiebreaker = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_is_tiebreaker(&has_bits);
          _impl_.is_tiebreaker_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_final_group = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_is_final_group(&has_bits);
          _impl_.is_final_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_completed = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_is_completed(&has_bits);
          _impl_.is_completed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTALeagueNodeGroup.TeamStanding team_standings = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_team_standings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTALeagueNode nodes = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTALeagueNodeGroup node_groups = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_node_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ELeaguePhase phase = 18 [default = LEAGUE_PHASE_UNSET];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeaguePhase_IsValid(val))) {
            _internal_set_phase(static_cast<::ELeaguePhase>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueRegion region = 19 [default = LEAGUE_REGION_UNSET];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueRegion_IsValid(val))) {
            _internal_set_region(static_cast<::ELeagueRegion>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start_time = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_start_time(&has_bits);
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 end_time = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_end_time(&has_bits);
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 secondary_advancing_node_group_id = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_secondary_advancing_node_group_id(&has_bits);
          _impl_.secondary_advancing_node_group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 secondary_advancing_team_count = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_secondary_advancing_team_count(&has_bits);
          _impl_.secondary_advancing_team_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tertiary_advancing_node_group_id = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_tertiary_advancing_node_group_id(&has_bits);
          _impl_.tertiary_advancing_node_group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tertiary_advancing_team_count = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_tertiary_advancing_team_count(&has_bits);
          _impl_.tertiary_advancing_team_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 elimination_dpc_points = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_elimination_dpc_points(&has_bits);
          _impl_.elimination_dpc_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueNodeGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueNodeGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueNodeGroup.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 node_group_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_node_group_id(), target);
  }

  // optional uint32 parent_node_group_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_parent_node_group_id(), target);
  }

  // repeated uint32 incoming_node_group_ids = 4;
  for (int i = 0, n = this->_internal_incoming_node_group_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_incoming_node_group_ids(i), target);
  }

  // optional uint32 advancing_node_group_id = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_advancing_node_group_id(), target);
  }

  // optional uint32 advancing_team_count = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_advancing_team_count(), target);
  }

  // optional uint32 team_count = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_team_count(), target);
  }

  // optional .ELeagueNodeGroupType node_group_type = 8 [default = INVALID_GROUP_TYPE];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_node_group_type(), target);
  }

  // optional .ELeagueNodeType default_node_type = 9 [default = INVALID_NODE_TYPE];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_default_node_type(), target);
  }

  // optional uint32 round = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_round(), target);
  }

  // optional uint32 max_rounds = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_max_rounds(), target);
  }

  // optional bool is_tiebreaker = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_is_tiebreaker(), target);
  }

  // optional bool is_final_group = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_is_final_group(), target);
  }

  // optional bool is_completed = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_is_completed(), target);
  }

  // repeated .CMsgDOTALeagueNodeGroup.TeamStanding team_standings = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_team_standings_size()); i < n; i++) {
    const auto& repfield = this->_internal_team_standings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTALeagueNode nodes = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTALeagueNodeGroup node_groups = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_node_groups_size()); i < n; i++) {
    const auto& repfield = this->_internal_node_groups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .ELeaguePhase phase = 18 [default = LEAGUE_PHASE_UNSET];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_phase(), target);
  }

  // optional .ELeagueRegion region = 19 [default = LEAGUE_REGION_UNSET];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      19, this->_internal_region(), target);
  }

  // optional uint32 start_time = 20;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_start_time(), target);
  }

  // optional uint32 end_time = 21;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_end_time(), target);
  }

  // optional uint32 secondary_advancing_node_group_id = 22;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_secondary_advancing_node_group_id(), target);
  }

  // optional uint32 secondary_advancing_team_count = 23;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_secondary_advancing_team_count(), target);
  }

  // optional uint32 tertiary_advancing_node_group_id = 24;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_tertiary_advancing_node_group_id(), target);
  }

  // optional uint32 tertiary_advancing_team_count = 25;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_tertiary_advancing_team_count(), target);
  }

  // optional uint32 elimination_dpc_points = 26;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(26, this->_internal_elimination_dpc_points(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueNodeGroup)
  return target;
}

size_t CMsgDOTALeagueNodeGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueNodeGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 incoming_node_group_ids = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.incoming_node_group_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_incoming_node_group_ids_size());
    total_size += data_size;
  }

  // repeated .CMsgDOTALeagueNodeGroup.TeamStanding team_standings = 15;
  total_size += 1UL * this->_internal_team_standings_size();
  for (const auto& msg : this->_impl_.team_standings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTALeagueNode nodes = 16;
  total_size += 2UL * this->_internal_nodes_size();
  for (const auto& msg : this->_impl_.nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTALeagueNodeGroup node_groups = 17;
  total_size += 2UL * this->_internal_node_groups_size();
  for (const auto& msg : this->_impl_.node_groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 node_group_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_group_id());
    }

    // optional uint32 parent_node_group_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_parent_node_group_id());
    }

    // optional uint32 advancing_node_group_id = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_advancing_node_group_id());
    }

    // optional uint32 advancing_team_count = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_advancing_team_count());
    }

    // optional uint32 team_count = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_count());
    }

    // optional .ELeagueNodeGroupType node_group_type = 8 [default = INVALID_GROUP_TYPE];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_node_group_type());
    }

    // optional .ELeagueNodeType default_node_type = 9 [default = INVALID_NODE_TYPE];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_default_node_type());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 round = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_round());
    }

    // optional uint32 max_rounds = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_rounds());
    }

    // optional bool is_tiebreaker = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool is_final_group = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool is_completed = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional .ELeaguePhase phase = 18 [default = LEAGUE_PHASE_UNSET];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_phase());
    }

    // optional .ELeagueRegion region = 19 [default = LEAGUE_REGION_UNSET];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_region());
    }

    // optional uint32 start_time = 20;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_start_time());
    }

  }
  if (cached_has_bits & 0x003f0000u) {
    // optional uint32 end_time = 21;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_end_time());
    }

    // optional uint32 secondary_advancing_node_group_id = 22;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_secondary_advancing_node_group_id());
    }

    // optional uint32 secondary_advancing_team_count = 23;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_secondary_advancing_team_count());
    }

    // optional uint32 tertiary_advancing_node_group_id = 24;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tertiary_advancing_node_group_id());
    }

    // optional uint32 tertiary_advancing_team_count = 25;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tertiary_advancing_team_count());
    }

    // optional uint32 elimination_dpc_points = 26;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_elimination_dpc_points());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueNodeGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueNodeGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueNodeGroup::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueNodeGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueNodeGroup*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueNodeGroup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueNodeGroup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.incoming_node_group_ids_.MergeFrom(from._impl_.incoming_node_group_ids_);
  _this->_impl_.team_standings_.MergeFrom(from._impl_.team_standings_);
  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  _this->_impl_.node_groups_.MergeFrom(from._impl_.node_groups_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.node_group_id_ = from._impl_.node_group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.parent_node_group_id_ = from._impl_.parent_node_group_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.advancing_node_group_id_ = from._impl_.advancing_node_group_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.advancing_team_count_ = from._impl_.advancing_team_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.team_count_ = from._impl_.team_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.node_group_type_ = from._impl_.node_group_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.default_node_type_ = from._impl_.default_node_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.round_ = from._impl_.round_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.max_rounds_ = from._impl_.max_rounds_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.is_tiebreaker_ = from._impl_.is_tiebreaker_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.is_final_group_ = from._impl_.is_final_group_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.is_completed_ = from._impl_.is_completed_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.phase_ = from._impl_.phase_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.region_ = from._impl_.region_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.start_time_ = from._impl_.start_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x003f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.end_time_ = from._impl_.end_time_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.secondary_advancing_node_group_id_ = from._impl_.secondary_advancing_node_group_id_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.secondary_advancing_team_count_ = from._impl_.secondary_advancing_team_count_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.tertiary_advancing_node_group_id_ = from._impl_.tertiary_advancing_node_group_id_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.tertiary_advancing_team_count_ = from._impl_.tertiary_advancing_team_count_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.elimination_dpc_points_ = from._impl_.elimination_dpc_points_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueNodeGroup::CopyFrom(const CMsgDOTALeagueNodeGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueNodeGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueNodeGroup::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueNodeGroup::InternalSwap(CMsgDOTALeagueNodeGroup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.incoming_node_group_ids_.InternalSwap(&other->_impl_.incoming_node_group_ids_);
  _impl_.team_standings_.InternalSwap(&other->_impl_.team_standings_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
  _impl_.node_groups_.InternalSwap(&other->_impl_.node_groups_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueNodeGroup, _impl_.elimination_dpc_points_)
      + sizeof(CMsgDOTALeagueNodeGroup::_impl_.elimination_dpc_points_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueNodeGroup, _impl_.node_group_id_)>(
          reinterpret_cast<char*>(&_impl_.node_group_id_),
          reinterpret_cast<char*>(&other->_impl_.node_group_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueNodeGroup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[4]);
}

// ===================================================================

class CMsgDOTALeague_Info::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeague_Info>()._impl_._has_bits_);
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_notes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_start_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_end_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pro_circuit_points(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_image_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_most_recent_activity(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_registration_period(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

CMsgDOTALeague_Info::CMsgDOTALeague_Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeague.Info)
}
CMsgDOTALeague_Info::CMsgDOTALeague_Info(const CMsgDOTALeague_Info& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeague_Info* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.notes_){}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.tier_){}
    , decltype(_impl_.region_){}
    , decltype(_impl_.start_timestamp_){}
    , decltype(_impl_.end_timestamp_){}
    , decltype(_impl_.pro_circuit_points_){}
    , decltype(_impl_.image_bits_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.most_recent_activity_){}
    , decltype(_impl_.registration_period_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.notes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.notes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_notes()) {
    _this->_impl_.notes_.Set(from._internal_notes(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.league_id_, &from._impl_.league_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.registration_period_) -
    reinterpret_cast<char*>(&_impl_.league_id_)) + sizeof(_impl_.registration_period_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeague.Info)
}

inline void CMsgDOTALeague_Info::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.notes_){}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.tier_){0}
    , decltype(_impl_.region_){0}
    , decltype(_impl_.start_timestamp_){0u}
    , decltype(_impl_.end_timestamp_){0u}
    , decltype(_impl_.pro_circuit_points_){0u}
    , decltype(_impl_.image_bits_){0u}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.most_recent_activity_){0u}
    , decltype(_impl_.registration_period_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.notes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.notes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeague_Info::~CMsgDOTALeague_Info() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeague.Info)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeague_Info::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.url_.Destroy();
  _impl_.description_.Destroy();
  _impl_.notes_.Destroy();
}

void CMsgDOTALeague_Info::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeague_Info::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeague.Info)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.notes_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.league_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.start_timestamp_) -
        reinterpret_cast<char*>(&_impl_.league_id_)) + sizeof(_impl_.start_timestamp_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.end_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.registration_period_) -
        reinterpret_cast<char*>(&_impl_.end_timestamp_)) + sizeof(_impl_.registration_period_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeague_Info::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 league_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeague.Info.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueTier_IsValid(val))) {
            _internal_set_tier(static_cast<::ELeagueTier>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueRegion_IsValid(val))) {
            _internal_set_region(static_cast<::ELeagueRegion>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string url = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeague.Info.url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string description = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeague.Info.description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string notes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_notes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeague.Info.notes");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start_timestamp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_start_timestamp(&has_bits);
          _impl_.start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 end_timestamp = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_end_timestamp(&has_bits);
          _impl_.end_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pro_circuit_points = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_pro_circuit_points(&has_bits);
          _impl_.pro_circuit_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 image_bits = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_image_bits(&has_bits);
          _impl_.image_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueStatus status = 12 [default = LEAGUE_STATUS_UNSET];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueStatus_IsValid(val))) {
            _internal_set_status(static_cast<::ELeagueStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 most_recent_activity = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_most_recent_activity(&has_bits);
          _impl_.most_recent_activity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 registration_period = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_registration_period(&has_bits);
          _impl_.registration_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeague_Info::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeague.Info)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 league_id = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_league_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeague.Info.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional .ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_tier(), target);
  }

  // optional .ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_region(), target);
  }

  // optional string url = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeague.Info.url");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_url(), target);
  }

  // optional string description = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeague.Info.description");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_description(), target);
  }

  // optional string notes = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_notes().data(), static_cast<int>(this->_internal_notes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeague.Info.notes");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_notes(), target);
  }

  // optional uint32 start_timestamp = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_start_timestamp(), target);
  }

  // optional uint32 end_timestamp = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_end_timestamp(), target);
  }

  // optional uint32 pro_circuit_points = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_pro_circuit_points(), target);
  }

  // optional uint32 image_bits = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_image_bits(), target);
  }

  // optional .ELeagueStatus status = 12 [default = LEAGUE_STATUS_UNSET];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_status(), target);
  }

  // optional uint32 most_recent_activity = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_most_recent_activity(), target);
  }

  // optional uint32 registration_period = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_registration_period(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeague.Info)
  return target;
}

size_t CMsgDOTALeague_Info::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeague.Info)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string url = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string description = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string notes = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_notes());
    }

    // optional uint32 league_id = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional .ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_tier());
    }

    // optional .ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_region());
    }

    // optional uint32 start_timestamp = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_timestamp());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional uint32 end_timestamp = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_timestamp());
    }

    // optional uint32 pro_circuit_points = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pro_circuit_points());
    }

    // optional uint32 image_bits = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_image_bits());
    }

    // optional .ELeagueStatus status = 12 [default = LEAGUE_STATUS_UNSET];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional uint32 most_recent_activity = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_most_recent_activity());
    }

    // optional uint32 registration_period = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_registration_period());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeague_Info::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeague_Info::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeague_Info::GetClassData() const { return &_class_data_; }


void CMsgDOTALeague_Info::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeague_Info*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeague_Info&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeague.Info)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_notes(from._internal_notes());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.tier_ = from._impl_.tier_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.region_ = from._impl_.region_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.start_timestamp_ = from._impl_.start_timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.end_timestamp_ = from._impl_.end_timestamp_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.pro_circuit_points_ = from._impl_.pro_circuit_points_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.image_bits_ = from._impl_.image_bits_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.most_recent_activity_ = from._impl_.most_recent_activity_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.registration_period_ = from._impl_.registration_period_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeague_Info::CopyFrom(const CMsgDOTALeague_Info& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeague.Info)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeague_Info::IsInitialized() const {
  return true;
}

void CMsgDOTALeague_Info::InternalSwap(CMsgDOTALeague_Info* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.notes_, lhs_arena,
      &other->_impl_.notes_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_Info, _impl_.registration_period_)
      + sizeof(CMsgDOTALeague_Info::_impl_.registration_period_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_Info, _impl_.league_id_)>(
          reinterpret_cast<char*>(&_impl_.league_id_),
          reinterpret_cast<char*>(&other->_impl_.league_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeague_Info::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[5]);
}

// ===================================================================

class CMsgDOTALeague_Admin::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeague_Admin>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_primary(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_email_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTALeague_Admin::CMsgDOTALeague_Admin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeague.Admin)
}
CMsgDOTALeague_Admin::CMsgDOTALeague_Admin(const CMsgDOTALeague_Admin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeague_Admin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.email_address_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.is_primary_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.email_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_email_address()) {
    _this->_impl_.email_address_.Set(from._internal_email_address(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_primary_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.is_primary_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeague.Admin)
}

inline void CMsgDOTALeague_Admin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.email_address_){}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.is_primary_){false}
  };
  _impl_.email_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeague_Admin::~CMsgDOTALeague_Admin() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeague.Admin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeague_Admin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.email_address_.Destroy();
}

void CMsgDOTALeague_Admin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeague_Admin::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeague.Admin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.email_address_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_primary_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.is_primary_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeague_Admin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_primary = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_primary(&has_bits);
          _impl_.is_primary_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string email_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_email_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeague.Admin.email_address");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeague_Admin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeague.Admin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional bool is_primary = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_primary(), target);
  }

  // optional string email_address = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_email_address().data(), static_cast<int>(this->_internal_email_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeague.Admin.email_address");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_email_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeague.Admin)
  return target;
}

size_t CMsgDOTALeague_Admin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeague.Admin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string email_address = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_email_address());
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional bool is_primary = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeague_Admin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeague_Admin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeague_Admin::GetClassData() const { return &_class_data_; }


void CMsgDOTALeague_Admin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeague_Admin*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeague_Admin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeague.Admin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_email_address(from._internal_email_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_primary_ = from._impl_.is_primary_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeague_Admin::CopyFrom(const CMsgDOTALeague_Admin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeague.Admin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeague_Admin::IsInitialized() const {
  return true;
}

void CMsgDOTALeague_Admin::InternalSwap(CMsgDOTALeague_Admin* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.email_address_, lhs_arena,
      &other->_impl_.email_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_Admin, _impl_.is_primary_)
      + sizeof(CMsgDOTALeague_Admin::_impl_.is_primary_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_Admin, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeague_Admin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[6]);
}

// ===================================================================

class CMsgDOTALeague_PrizePoolItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeague_PrizePoolItem>()._impl_._has_bits_);
  static void set_has_item_def(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sales_stop_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_revenue_pct(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_revenue_cents_per_sale(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgDOTALeague_PrizePoolItem::CMsgDOTALeague_PrizePoolItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeague.PrizePoolItem)
}
CMsgDOTALeague_PrizePoolItem::CMsgDOTALeague_PrizePoolItem(const CMsgDOTALeague_PrizePoolItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeague_PrizePoolItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_def_){}
    , decltype(_impl_.sales_stop_timestamp_){}
    , decltype(_impl_.revenue_pct_){}
    , decltype(_impl_.revenue_cents_per_sale_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.item_def_, &from._impl_.item_def_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.revenue_cents_per_sale_) -
    reinterpret_cast<char*>(&_impl_.item_def_)) + sizeof(_impl_.revenue_cents_per_sale_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeague.PrizePoolItem)
}

inline void CMsgDOTALeague_PrizePoolItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_def_){0u}
    , decltype(_impl_.sales_stop_timestamp_){0u}
    , decltype(_impl_.revenue_pct_){0u}
    , decltype(_impl_.revenue_cents_per_sale_){0u}
  };
}

CMsgDOTALeague_PrizePoolItem::~CMsgDOTALeague_PrizePoolItem() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeague.PrizePoolItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeague_PrizePoolItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTALeague_PrizePoolItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeague_PrizePoolItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeague.PrizePoolItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.item_def_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.revenue_cents_per_sale_) -
        reinterpret_cast<char*>(&_impl_.item_def_)) + sizeof(_impl_.revenue_cents_per_sale_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeague_PrizePoolItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 item_def = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_def(&has_bits);
          _impl_.item_def_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sales_stop_timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sales_stop_timestamp(&has_bits);
          _impl_.sales_stop_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 revenue_pct = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_revenue_pct(&has_bits);
          _impl_.revenue_pct_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 revenue_cents_per_sale = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_revenue_cents_per_sale(&has_bits);
          _impl_.revenue_cents_per_sale_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeague_PrizePoolItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeague.PrizePoolItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 item_def = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_item_def(), target);
  }

  // optional uint32 sales_stop_timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sales_stop_timestamp(), target);
  }

  // optional uint32 revenue_pct = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_revenue_pct(), target);
  }

  // optional uint32 revenue_cents_per_sale = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_revenue_cents_per_sale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeague.PrizePoolItem)
  return target;
}

size_t CMsgDOTALeague_PrizePoolItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeague.PrizePoolItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 item_def = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_item_def());
    }

    // optional uint32 sales_stop_timestamp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sales_stop_timestamp());
    }

    // optional uint32 revenue_pct = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_revenue_pct());
    }

    // optional uint32 revenue_cents_per_sale = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_revenue_cents_per_sale());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeague_PrizePoolItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeague_PrizePoolItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeague_PrizePoolItem::GetClassData() const { return &_class_data_; }


void CMsgDOTALeague_PrizePoolItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeague_PrizePoolItem*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeague_PrizePoolItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeague.PrizePoolItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.item_def_ = from._impl_.item_def_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sales_stop_timestamp_ = from._impl_.sales_stop_timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.revenue_pct_ = from._impl_.revenue_pct_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.revenue_cents_per_sale_ = from._impl_.revenue_cents_per_sale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeague_PrizePoolItem::CopyFrom(const CMsgDOTALeague_PrizePoolItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeague.PrizePoolItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeague_PrizePoolItem::IsInitialized() const {
  return true;
}

void CMsgDOTALeague_PrizePoolItem::InternalSwap(CMsgDOTALeague_PrizePoolItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_PrizePoolItem, _impl_.revenue_cents_per_sale_)
      + sizeof(CMsgDOTALeague_PrizePoolItem::_impl_.revenue_cents_per_sale_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_PrizePoolItem, _impl_.item_def_)>(
          reinterpret_cast<char*>(&_impl_.item_def_),
          reinterpret_cast<char*>(&other->_impl_.item_def_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeague_PrizePoolItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[7]);
}

// ===================================================================

class CMsgDOTALeague_PrizePool::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeague_PrizePool>()._impl_._has_bits_);
  static void set_has_base_prize_pool(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_total_prize_pool(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTALeague_PrizePool::CMsgDOTALeague_PrizePool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeague.PrizePool)
}
CMsgDOTALeague_PrizePool::CMsgDOTALeague_PrizePool(const CMsgDOTALeague_PrizePool& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeague_PrizePool* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prize_split_pct_x100_){from._impl_.prize_split_pct_x100_}
    , decltype(_impl_.prize_pool_items_){from._impl_.prize_pool_items_}
    , decltype(_impl_.base_prize_pool_){}
    , decltype(_impl_.total_prize_pool_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.base_prize_pool_, &from._impl_.base_prize_pool_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_prize_pool_) -
    reinterpret_cast<char*>(&_impl_.base_prize_pool_)) + sizeof(_impl_.total_prize_pool_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeague.PrizePool)
}

inline void CMsgDOTALeague_PrizePool::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prize_split_pct_x100_){arena}
    , decltype(_impl_.prize_pool_items_){arena}
    , decltype(_impl_.base_prize_pool_){0u}
    , decltype(_impl_.total_prize_pool_){0u}
  };
}

CMsgDOTALeague_PrizePool::~CMsgDOTALeague_PrizePool() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeague.PrizePool)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeague_PrizePool::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prize_split_pct_x100_.~RepeatedField();
  _impl_.prize_pool_items_.~RepeatedPtrField();
}

void CMsgDOTALeague_PrizePool::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeague_PrizePool::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeague.PrizePool)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.prize_split_pct_x100_.Clear();
  _impl_.prize_pool_items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.base_prize_pool_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.total_prize_pool_) -
        reinterpret_cast<char*>(&_impl_.base_prize_pool_)) + sizeof(_impl_.total_prize_pool_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeague_PrizePool::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 base_prize_pool = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_base_prize_pool(&has_bits);
          _impl_.base_prize_pool_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 total_prize_pool = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_total_prize_pool(&has_bits);
          _impl_.total_prize_pool_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 prize_split_pct_x100 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_prize_split_pct_x100(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_prize_split_pct_x100(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTALeague.PrizePoolItem prize_pool_items = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_prize_pool_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeague_PrizePool::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeague.PrizePool)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 base_prize_pool = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_base_prize_pool(), target);
  }

  // optional uint32 total_prize_pool = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_total_prize_pool(), target);
  }

  // repeated uint32 prize_split_pct_x100 = 3;
  for (int i = 0, n = this->_internal_prize_split_pct_x100_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_prize_split_pct_x100(i), target);
  }

  // repeated .CMsgDOTALeague.PrizePoolItem prize_pool_items = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_prize_pool_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_prize_pool_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeague.PrizePool)
  return target;
}

size_t CMsgDOTALeague_PrizePool::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeague.PrizePool)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 prize_split_pct_x100 = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.prize_split_pct_x100_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_prize_split_pct_x100_size());
    total_size += data_size;
  }

  // repeated .CMsgDOTALeague.PrizePoolItem prize_pool_items = 4;
  total_size += 1UL * this->_internal_prize_pool_items_size();
  for (const auto& msg : this->_impl_.prize_pool_items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 base_prize_pool = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_base_prize_pool());
    }

    // optional uint32 total_prize_pool = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_prize_pool());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeague_PrizePool::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeague_PrizePool::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeague_PrizePool::GetClassData() const { return &_class_data_; }


void CMsgDOTALeague_PrizePool::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeague_PrizePool*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeague_PrizePool&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeague.PrizePool)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.prize_split_pct_x100_.MergeFrom(from._impl_.prize_split_pct_x100_);
  _this->_impl_.prize_pool_items_.MergeFrom(from._impl_.prize_pool_items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.base_prize_pool_ = from._impl_.base_prize_pool_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.total_prize_pool_ = from._impl_.total_prize_pool_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeague_PrizePool::CopyFrom(const CMsgDOTALeague_PrizePool& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeague.PrizePool)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeague_PrizePool::IsInitialized() const {
  return true;
}

void CMsgDOTALeague_PrizePool::InternalSwap(CMsgDOTALeague_PrizePool* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.prize_split_pct_x100_.InternalSwap(&other->_impl_.prize_split_pct_x100_);
  _impl_.prize_pool_items_.InternalSwap(&other->_impl_.prize_pool_items_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_PrizePool, _impl_.total_prize_pool_)
      + sizeof(CMsgDOTALeague_PrizePool::_impl_.total_prize_pool_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_PrizePool, _impl_.base_prize_pool_)>(
          reinterpret_cast<char*>(&_impl_.base_prize_pool_),
          reinterpret_cast<char*>(&other->_impl_.base_prize_pool_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeague_PrizePool::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[8]);
}

// ===================================================================

class CMsgDOTALeague_Stream::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeague_Stream>()._impl_._has_bits_);
  static void set_has_stream_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_broadcast_provider(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_stream_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vod_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDOTALeague_Stream::CMsgDOTALeague_Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeague.Stream)
}
CMsgDOTALeague_Stream::CMsgDOTALeague_Stream(const CMsgDOTALeague_Stream& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeague_Stream* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.stream_url_){}
    , decltype(_impl_.vod_url_){}
    , decltype(_impl_.stream_id_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.broadcast_provider_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.stream_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stream_url()) {
    _this->_impl_.stream_url_.Set(from._internal_stream_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.vod_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vod_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vod_url()) {
    _this->_impl_.vod_url_.Set(from._internal_vod_url(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.stream_id_, &from._impl_.stream_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.broadcast_provider_) -
    reinterpret_cast<char*>(&_impl_.stream_id_)) + sizeof(_impl_.broadcast_provider_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeague.Stream)
}

inline void CMsgDOTALeague_Stream::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.stream_url_){}
    , decltype(_impl_.vod_url_){}
    , decltype(_impl_.stream_id_){0u}
    , decltype(_impl_.language_){0u}
    , decltype(_impl_.broadcast_provider_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.stream_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vod_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vod_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeague_Stream::~CMsgDOTALeague_Stream() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeague.Stream)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeague_Stream::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.stream_url_.Destroy();
  _impl_.vod_url_.Destroy();
}

void CMsgDOTALeague_Stream::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeague_Stream::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeague.Stream)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.stream_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.vod_url_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.stream_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.broadcast_provider_) -
        reinterpret_cast<char*>(&_impl_.stream_id_)) + sizeof(_impl_.broadcast_provider_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeague_Stream::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 stream_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_stream_id(&has_bits);
          _impl_.stream_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 language = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_language(&has_bits);
          _impl_.language_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeague.Stream.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueBroadcastProvider broadcast_provider = 4 [default = LEAGUE_BROADCAST_UNKNOWN];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueBroadcastProvider_IsValid(val))) {
            _internal_set_broadcast_provider(static_cast<::ELeagueBroadcastProvider>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string stream_url = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_stream_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeague.Stream.stream_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string vod_url = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_vod_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeague.Stream.vod_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeague_Stream::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeague.Stream)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 stream_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_stream_id(), target);
  }

  // optional uint32 language = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_language(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeague.Stream.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional .ELeagueBroadcastProvider broadcast_provider = 4 [default = LEAGUE_BROADCAST_UNKNOWN];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_broadcast_provider(), target);
  }

  // optional string stream_url = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_stream_url().data(), static_cast<int>(this->_internal_stream_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeague.Stream.stream_url");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_stream_url(), target);
  }

  // optional string vod_url = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_vod_url().data(), static_cast<int>(this->_internal_vod_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeague.Stream.vod_url");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_vod_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeague.Stream)
  return target;
}

size_t CMsgDOTALeague_Stream::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeague.Stream)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string stream_url = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stream_url());
    }

    // optional string vod_url = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vod_url());
    }

    // optional uint32 stream_id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stream_id());
    }

    // optional uint32 language = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_language());
    }

    // optional .ELeagueBroadcastProvider broadcast_provider = 4 [default = LEAGUE_BROADCAST_UNKNOWN];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_broadcast_provider());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeague_Stream::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeague_Stream::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeague_Stream::GetClassData() const { return &_class_data_; }


void CMsgDOTALeague_Stream::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeague_Stream*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeague_Stream&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeague.Stream)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_stream_url(from._internal_stream_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_vod_url(from._internal_vod_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.stream_id_ = from._impl_.stream_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.language_ = from._impl_.language_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.broadcast_provider_ = from._impl_.broadcast_provider_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeague_Stream::CopyFrom(const CMsgDOTALeague_Stream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeague.Stream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeague_Stream::IsInitialized() const {
  return true;
}

void CMsgDOTALeague_Stream::InternalSwap(CMsgDOTALeague_Stream* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stream_url_, lhs_arena,
      &other->_impl_.stream_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vod_url_, lhs_arena,
      &other->_impl_.vod_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_Stream, _impl_.broadcast_provider_)
      + sizeof(CMsgDOTALeague_Stream::_impl_.broadcast_provider_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_Stream, _impl_.stream_id_)>(
          reinterpret_cast<char*>(&_impl_.stream_id_),
          reinterpret_cast<char*>(&other->_impl_.stream_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeague_Stream::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[9]);
}

// ===================================================================

class CMsgDOTALeague_SeriesInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeague_SeriesInfo>()._impl_._has_bits_);
  static void set_has_series_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_series_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_team_id_1(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_team_id_2(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgDOTALeague_SeriesInfo::CMsgDOTALeague_SeriesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeague.SeriesInfo)
}
CMsgDOTALeague_SeriesInfo::CMsgDOTALeague_SeriesInfo(const CMsgDOTALeague_SeriesInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeague_SeriesInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_ids_){from._impl_.match_ids_}
    , decltype(_impl_.series_id_){}
    , decltype(_impl_.series_type_){}
    , decltype(_impl_.start_time_){}
    , decltype(_impl_.team_id_1_){}
    , decltype(_impl_.team_id_2_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.series_id_, &from._impl_.series_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.team_id_2_) -
    reinterpret_cast<char*>(&_impl_.series_id_)) + sizeof(_impl_.team_id_2_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeague.SeriesInfo)
}

inline void CMsgDOTALeague_SeriesInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_ids_){arena}
    , decltype(_impl_.series_id_){0u}
    , decltype(_impl_.series_type_){0u}
    , decltype(_impl_.start_time_){0u}
    , decltype(_impl_.team_id_1_){0u}
    , decltype(_impl_.team_id_2_){0u}
  };
}

CMsgDOTALeague_SeriesInfo::~CMsgDOTALeague_SeriesInfo() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeague.SeriesInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeague_SeriesInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.match_ids_.~RepeatedField();
}

void CMsgDOTALeague_SeriesInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeague_SeriesInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeague.SeriesInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.match_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.series_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.team_id_2_) -
        reinterpret_cast<char*>(&_impl_.series_id_)) + sizeof(_impl_.team_id_2_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeague_SeriesInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 series_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_series_id(&has_bits);
          _impl_.series_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 series_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_series_type(&has_bits);
          _impl_.series_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_start_time(&has_bits);
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 match_ids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_match_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_match_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id_1 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_team_id_1(&has_bits);
          _impl_.team_id_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id_2 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_team_id_2(&has_bits);
          _impl_.team_id_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeague_SeriesInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeague.SeriesInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 series_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_series_id(), target);
  }

  // optional uint32 series_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_series_type(), target);
  }

  // optional uint32 start_time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_start_time(), target);
  }

  // repeated uint64 match_ids = 4;
  for (int i = 0, n = this->_internal_match_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_match_ids(i), target);
  }

  // optional uint32 team_id_1 = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_team_id_1(), target);
  }

  // optional uint32 team_id_2 = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_team_id_2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeague.SeriesInfo)
  return target;
}

size_t CMsgDOTALeague_SeriesInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeague.SeriesInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 match_ids = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.match_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_match_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 series_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_series_id());
    }

    // optional uint32 series_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_series_type());
    }

    // optional uint32 start_time = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_time());
    }

    // optional uint32 team_id_1 = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id_1());
    }

    // optional uint32 team_id_2 = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id_2());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeague_SeriesInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeague_SeriesInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeague_SeriesInfo::GetClassData() const { return &_class_data_; }


void CMsgDOTALeague_SeriesInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeague_SeriesInfo*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeague_SeriesInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeague.SeriesInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.match_ids_.MergeFrom(from._impl_.match_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.series_id_ = from._impl_.series_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.series_type_ = from._impl_.series_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.start_time_ = from._impl_.start_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_id_1_ = from._impl_.team_id_1_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.team_id_2_ = from._impl_.team_id_2_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeague_SeriesInfo::CopyFrom(const CMsgDOTALeague_SeriesInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeague.SeriesInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeague_SeriesInfo::IsInitialized() const {
  return true;
}

void CMsgDOTALeague_SeriesInfo::InternalSwap(CMsgDOTALeague_SeriesInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.match_ids_.InternalSwap(&other->_impl_.match_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_SeriesInfo, _impl_.team_id_2_)
      + sizeof(CMsgDOTALeague_SeriesInfo::_impl_.team_id_2_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_SeriesInfo, _impl_.series_id_)>(
          reinterpret_cast<char*>(&_impl_.series_id_),
          reinterpret_cast<char*>(&other->_impl_.series_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeague_SeriesInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[10]);
}

// ===================================================================

class CMsgDOTALeague_Player::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeague_Player>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDOTALeague_Player::CMsgDOTALeague_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeague.Player)
}
CMsgDOTALeague_Player::CMsgDOTALeague_Player(const CMsgDOTALeague_Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeague_Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.team_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.team_id_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.team_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeague.Player)
}

inline void CMsgDOTALeague_Player::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.team_id_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeague_Player::~CMsgDOTALeague_Player() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeague.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeague_Player::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgDOTALeague_Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeague_Player::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeague.Player)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.team_id_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.team_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeague_Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeague.Player.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeague_Player::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeague.Player)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeague.Player.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional uint32 team_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_team_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeague.Player)
  return target;
}

size_t CMsgDOTALeague_Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeague.Player)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 team_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeague_Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeague_Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeague_Player::GetClassData() const { return &_class_data_; }


void CMsgDOTALeague_Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeague_Player*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeague_Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeague.Player)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeague_Player::CopyFrom(const CMsgDOTALeague_Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeague.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeague_Player::IsInitialized() const {
  return true;
}

void CMsgDOTALeague_Player::InternalSwap(CMsgDOTALeague_Player* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_Player, _impl_.team_id_)
      + sizeof(CMsgDOTALeague_Player::_impl_.team_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeague_Player, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeague_Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[11]);
}

// ===================================================================

class CMsgDOTALeague::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeague>()._impl_._has_bits_);
  static const ::CMsgDOTALeague_Info& info(const CMsgDOTALeague* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgDOTALeague_PrizePool& prize_pool(const CMsgDOTALeague* msg);
  static void set_has_prize_pool(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgDOTALeague_Info&
CMsgDOTALeague::_Internal::info(const CMsgDOTALeague* msg) {
  return *msg->_impl_.info_;
}
const ::CMsgDOTALeague_PrizePool&
CMsgDOTALeague::_Internal::prize_pool(const CMsgDOTALeague* msg) {
  return *msg->_impl_.prize_pool_;
}
CMsgDOTALeague::CMsgDOTALeague(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeague)
}
CMsgDOTALeague::CMsgDOTALeague(const CMsgDOTALeague& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeague* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.admins_){from._impl_.admins_}
    , decltype(_impl_.streams_){from._impl_.streams_}
    , decltype(_impl_.node_groups_){from._impl_.node_groups_}
    , decltype(_impl_.series_infos_){from._impl_.series_infos_}
    , decltype(_impl_.registered_players_){from._impl_.registered_players_}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.prize_pool_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::CMsgDOTALeague_Info(*from._impl_.info_);
  }
  if (from._internal_has_prize_pool()) {
    _this->_impl_.prize_pool_ = new ::CMsgDOTALeague_PrizePool(*from._impl_.prize_pool_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeague)
}

inline void CMsgDOTALeague::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.admins_){arena}
    , decltype(_impl_.streams_){arena}
    , decltype(_impl_.node_groups_){arena}
    , decltype(_impl_.series_infos_){arena}
    , decltype(_impl_.registered_players_){arena}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.prize_pool_){nullptr}
  };
}

CMsgDOTALeague::~CMsgDOTALeague() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeague)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeague::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.admins_.~RepeatedPtrField();
  _impl_.streams_.~RepeatedPtrField();
  _impl_.node_groups_.~RepeatedPtrField();
  _impl_.series_infos_.~RepeatedPtrField();
  _impl_.registered_players_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.info_;
  if (this != internal_default_instance()) delete _impl_.prize_pool_;
}

void CMsgDOTALeague::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeague::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeague)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.admins_.Clear();
  _impl_.streams_.Clear();
  _impl_.node_groups_.Clear();
  _impl_.series_infos_.Clear();
  _impl_.registered_players_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.prize_pool_ != nullptr);
      _impl_.prize_pool_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeague::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgDOTALeague.Info info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTALeague.PrizePool prize_pool = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_prize_pool(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTALeague.Admin admins = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_admins(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTALeague.Stream streams = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_streams(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTALeagueNodeGroup node_groups = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_node_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTALeague.SeriesInfo series_infos = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_series_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTALeague.Player registered_players = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_registered_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeague::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeague)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgDOTALeague.Info info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgDOTALeague.PrizePool prize_pool = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::prize_pool(this),
        _Internal::prize_pool(this).GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTALeague.Admin admins = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_admins_size()); i < n; i++) {
    const auto& repfield = this->_internal_admins(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTALeague.Stream streams = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_streams_size()); i < n; i++) {
    const auto& repfield = this->_internal_streams(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTALeagueNodeGroup node_groups = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_node_groups_size()); i < n; i++) {
    const auto& repfield = this->_internal_node_groups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTALeague.SeriesInfo series_infos = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_series_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_series_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTALeague.Player registered_players = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_registered_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_registered_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeague)
  return target;
}

size_t CMsgDOTALeague::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeague)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTALeague.Admin admins = 3;
  total_size += 1UL * this->_internal_admins_size();
  for (const auto& msg : this->_impl_.admins_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTALeague.Stream streams = 4;
  total_size += 1UL * this->_internal_streams_size();
  for (const auto& msg : this->_impl_.streams_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTALeagueNodeGroup node_groups = 5;
  total_size += 1UL * this->_internal_node_groups_size();
  for (const auto& msg : this->_impl_.node_groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTALeague.SeriesInfo series_infos = 6;
  total_size += 1UL * this->_internal_series_infos_size();
  for (const auto& msg : this->_impl_.series_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTALeague.Player registered_players = 7;
  total_size += 1UL * this->_internal_registered_players_size();
  for (const auto& msg : this->_impl_.registered_players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgDOTALeague.Info info = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional .CMsgDOTALeague.PrizePool prize_pool = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.prize_pool_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeague::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeague::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeague::GetClassData() const { return &_class_data_; }


void CMsgDOTALeague::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeague*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeague&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeague)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.admins_.MergeFrom(from._impl_.admins_);
  _this->_impl_.streams_.MergeFrom(from._impl_.streams_);
  _this->_impl_.node_groups_.MergeFrom(from._impl_.node_groups_);
  _this->_impl_.series_infos_.MergeFrom(from._impl_.series_infos_);
  _this->_impl_.registered_players_.MergeFrom(from._impl_.registered_players_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_info()->::CMsgDOTALeague_Info::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_prize_pool()->::CMsgDOTALeague_PrizePool::MergeFrom(
          from._internal_prize_pool());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeague::CopyFrom(const CMsgDOTALeague& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeague)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeague::IsInitialized() const {
  return true;
}

void CMsgDOTALeague::InternalSwap(CMsgDOTALeague* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.admins_.InternalSwap(&other->_impl_.admins_);
  _impl_.streams_.InternalSwap(&other->_impl_.streams_);
  _impl_.node_groups_.InternalSwap(&other->_impl_.node_groups_);
  _impl_.series_infos_.InternalSwap(&other->_impl_.series_infos_);
  _impl_.registered_players_.InternalSwap(&other->_impl_.registered_players_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeague, _impl_.prize_pool_)
      + sizeof(CMsgDOTALeague::_impl_.prize_pool_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeague, _impl_.info_)>(
          reinterpret_cast<char*>(&_impl_.info_),
          reinterpret_cast<char*>(&other->_impl_.info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeague::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[12]);
}

// ===================================================================

class CMsgDOTALeagueList::_Internal {
 public:
};

CMsgDOTALeagueList::CMsgDOTALeagueList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueList)
}
CMsgDOTALeagueList::CMsgDOTALeagueList(const CMsgDOTALeagueList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.leagues_){from._impl_.leagues_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueList)
}

inline void CMsgDOTALeagueList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.leagues_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTALeagueList::~CMsgDOTALeagueList() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.leagues_.~RepeatedPtrField();
}

void CMsgDOTALeagueList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.leagues_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTALeague leagues = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_leagues(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTALeague leagues = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_leagues_size()); i < n; i++) {
    const auto& repfield = this->_internal_leagues(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueList)
  return target;
}

size_t CMsgDOTALeagueList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTALeague leagues = 1;
  total_size += 1UL * this->_internal_leagues_size();
  for (const auto& msg : this->_impl_.leagues_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueList::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueList*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.leagues_.MergeFrom(from._impl_.leagues_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueList::CopyFrom(const CMsgDOTALeagueList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueList::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueList::InternalSwap(CMsgDOTALeagueList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.leagues_.InternalSwap(&other->_impl_.leagues_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[13]);
}

// ===================================================================

class CMsgDOTALeagueInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeagueInfo>()._impl_._has_bits_);
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_most_recent_activity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_total_prize_pool(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_start_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_end_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CMsgDOTALeagueInfo::CMsgDOTALeagueInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueInfo)
}
CMsgDOTALeagueInfo::CMsgDOTALeagueInfo(const CMsgDOTALeagueInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.tier_){}
    , decltype(_impl_.region_){}
    , decltype(_impl_.most_recent_activity_){}
    , decltype(_impl_.total_prize_pool_){}
    , decltype(_impl_.start_timestamp_){}
    , decltype(_impl_.end_timestamp_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.league_id_, &from._impl_.league_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.league_id_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueInfo)
}

inline void CMsgDOTALeagueInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.tier_){0}
    , decltype(_impl_.region_){0}
    , decltype(_impl_.most_recent_activity_){0u}
    , decltype(_impl_.total_prize_pool_){0u}
    , decltype(_impl_.start_timestamp_){0u}
    , decltype(_impl_.end_timestamp_){0u}
    , decltype(_impl_.status_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeagueInfo::~CMsgDOTALeagueInfo() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgDOTALeagueInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.league_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.end_timestamp_) -
        reinterpret_cast<char*>(&_impl_.league_id_)) + sizeof(_impl_.end_timestamp_));
  }
  _impl_.status_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 league_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueInfo.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueTier_IsValid(val))) {
            _internal_set_tier(static_cast<::ELeagueTier>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueRegion_IsValid(val))) {
            _internal_set_region(static_cast<::ELeagueRegion>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 most_recent_activity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_most_recent_activity(&has_bits);
          _impl_.most_recent_activity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 total_prize_pool = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_total_prize_pool(&has_bits);
          _impl_.total_prize_pool_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start_timestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_start_timestamp(&has_bits);
          _impl_.start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 end_timestamp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_end_timestamp(&has_bits);
          _impl_.end_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 status = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 league_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_league_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueInfo.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional .ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_tier(), target);
  }

  // optional .ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_region(), target);
  }

  // optional uint32 most_recent_activity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_most_recent_activity(), target);
  }

  // optional uint32 total_prize_pool = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_total_prize_pool(), target);
  }

  // optional uint32 start_timestamp = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_start_timestamp(), target);
  }

  // optional uint32 end_timestamp = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_end_timestamp(), target);
  }

  // optional uint32 status = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueInfo)
  return target;
}

size_t CMsgDOTALeagueInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 league_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional .ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_tier());
    }

    // optional .ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_region());
    }

    // optional uint32 most_recent_activity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_most_recent_activity());
    }

    // optional uint32 total_prize_pool = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_prize_pool());
    }

    // optional uint32 start_timestamp = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_timestamp());
    }

    // optional uint32 end_timestamp = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_timestamp());
    }

  }
  // optional uint32 status = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueInfo::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueInfo*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tier_ = from._impl_.tier_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.region_ = from._impl_.region_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.most_recent_activity_ = from._impl_.most_recent_activity_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.total_prize_pool_ = from._impl_.total_prize_pool_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.start_timestamp_ = from._impl_.start_timestamp_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.end_timestamp_ = from._impl_.end_timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueInfo::CopyFrom(const CMsgDOTALeagueInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueInfo::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueInfo::InternalSwap(CMsgDOTALeagueInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueInfo, _impl_.status_)
      + sizeof(CMsgDOTALeagueInfo::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueInfo, _impl_.league_id_)>(
          reinterpret_cast<char*>(&_impl_.league_id_),
          reinterpret_cast<char*>(&other->_impl_.league_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[14]);
}

// ===================================================================

class CMsgDOTALeagueInfoList::_Internal {
 public:
};

CMsgDOTALeagueInfoList::CMsgDOTALeagueInfoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueInfoList)
}
CMsgDOTALeagueInfoList::CMsgDOTALeagueInfoList(const CMsgDOTALeagueInfoList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueInfoList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.infos_){from._impl_.infos_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueInfoList)
}

inline void CMsgDOTALeagueInfoList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.infos_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTALeagueInfoList::~CMsgDOTALeagueInfoList() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueInfoList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueInfoList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.infos_.~RepeatedPtrField();
}

void CMsgDOTALeagueInfoList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueInfoList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueInfoList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.infos_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueInfoList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTALeagueInfo infos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueInfoList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueInfoList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTALeagueInfo infos = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueInfoList)
  return target;
}

size_t CMsgDOTALeagueInfoList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueInfoList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTALeagueInfo infos = 1;
  total_size += 1UL * this->_internal_infos_size();
  for (const auto& msg : this->_impl_.infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueInfoList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueInfoList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueInfoList::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueInfoList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueInfoList*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueInfoList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueInfoList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.infos_.MergeFrom(from._impl_.infos_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueInfoList::CopyFrom(const CMsgDOTALeagueInfoList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueInfoList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueInfoList::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueInfoList::InternalSwap(CMsgDOTALeagueInfoList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.infos_.InternalSwap(&other->_impl_.infos_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueInfoList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[15]);
}

// ===================================================================

class CMsgDOTALeagueLiveGames_LiveGame::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeagueLiveGames_LiveGame>()._impl_._has_bits_);
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_server_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_radiant_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_radiant_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_radiant_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_dire_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dire_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_dire_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_spectators(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_league_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_series_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

CMsgDOTALeagueLiveGames_LiveGame::CMsgDOTALeagueLiveGames_LiveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueLiveGames.LiveGame)
}
CMsgDOTALeagueLiveGames_LiveGame::CMsgDOTALeagueLiveGames_LiveGame(const CMsgDOTALeagueLiveGames_LiveGame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueLiveGames_LiveGame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.radiant_name_){}
    , decltype(_impl_.dire_name_){}
    , decltype(_impl_.server_steam_id_){}
    , decltype(_impl_.radiant_logo_){}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.dire_logo_){}
    , decltype(_impl_.spectators_){}
    , decltype(_impl_.radiant_team_id_){}
    , decltype(_impl_.dire_team_id_){}
    , decltype(_impl_.league_node_id_){}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.series_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.radiant_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.radiant_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_radiant_name()) {
    _this->_impl_.radiant_name_.Set(from._internal_radiant_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dire_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dire_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dire_name()) {
    _this->_impl_.dire_name_.Set(from._internal_dire_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.server_steam_id_, &from._impl_.server_steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.series_id_) -
    reinterpret_cast<char*>(&_impl_.server_steam_id_)) + sizeof(_impl_.series_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueLiveGames.LiveGame)
}

inline void CMsgDOTALeagueLiveGames_LiveGame::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.radiant_name_){}
    , decltype(_impl_.dire_name_){}
    , decltype(_impl_.server_steam_id_){uint64_t{0u}}
    , decltype(_impl_.radiant_logo_){uint64_t{0u}}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.time_){0u}
    , decltype(_impl_.dire_logo_){uint64_t{0u}}
    , decltype(_impl_.spectators_){0u}
    , decltype(_impl_.radiant_team_id_){0u}
    , decltype(_impl_.dire_team_id_){0u}
    , decltype(_impl_.league_node_id_){0u}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.series_id_){0u}
  };
  _impl_.radiant_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.radiant_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dire_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dire_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeagueLiveGames_LiveGame::~CMsgDOTALeagueLiveGames_LiveGame() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueLiveGames.LiveGame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueLiveGames_LiveGame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.radiant_name_.Destroy();
  _impl_.dire_name_.Destroy();
}

void CMsgDOTALeagueLiveGames_LiveGame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueLiveGames_LiveGame::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueLiveGames.LiveGame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.radiant_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.dire_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.server_steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.spectators_) -
        reinterpret_cast<char*>(&_impl_.server_steam_id_)) + sizeof(_impl_.spectators_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.radiant_team_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.series_id_) -
        reinterpret_cast<char*>(&_impl_.radiant_team_id_)) + sizeof(_impl_.series_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueLiveGames_LiveGame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 league_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 server_steam_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_server_steam_id(&has_bits);
          _impl_.server_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string radiant_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_radiant_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueLiveGames.LiveGame.radiant_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 radiant_logo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_radiant_logo(&has_bits);
          _impl_.radiant_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string dire_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_dire_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueLiveGames.LiveGame.dire_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 dire_logo = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_dire_logo(&has_bits);
          _impl_.dire_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 spectators = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_spectators(&has_bits);
          _impl_.spectators_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 radiant_team_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_radiant_team_id(&has_bits);
          _impl_.radiant_team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dire_team_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_dire_team_id(&has_bits);
          _impl_.dire_team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league_node_id = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_league_node_id(&has_bits);
          _impl_.league_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 series_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_series_id(&has_bits);
          _impl_.series_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 match_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueLiveGames_LiveGame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueLiveGames.LiveGame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 league_id = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_league_id(), target);
  }

  // optional uint64 server_steam_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_server_steam_id(), target);
  }

  // optional string radiant_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_radiant_name().data(), static_cast<int>(this->_internal_radiant_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueLiveGames.LiveGame.radiant_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_radiant_name(), target);
  }

  // optional uint64 radiant_logo = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_radiant_logo(), target);
  }

  // optional string dire_name = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dire_name().data(), static_cast<int>(this->_internal_dire_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueLiveGames.LiveGame.dire_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_dire_name(), target);
  }

  // optional uint64 dire_logo = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_dire_logo(), target);
  }

  // optional uint32 time = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_time(), target);
  }

  // optional uint32 spectators = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_spectators(), target);
  }

  // optional uint32 radiant_team_id = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_radiant_team_id(), target);
  }

  // optional uint32 dire_team_id = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_dire_team_id(), target);
  }

  // optional uint32 league_node_id = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_league_node_id(), target);
  }

  // optional uint32 series_id = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_series_id(), target);
  }

  // optional uint64 match_id = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_match_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueLiveGames.LiveGame)
  return target;
}

size_t CMsgDOTALeagueLiveGames_LiveGame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueLiveGames.LiveGame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string radiant_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_radiant_name());
    }

    // optional string dire_name = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dire_name());
    }

    // optional uint64 server_steam_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_server_steam_id());
    }

    // optional uint64 radiant_logo = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_radiant_logo());
    }

    // optional uint32 league_id = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional uint32 time = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time());
    }

    // optional uint64 dire_logo = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dire_logo());
    }

    // optional uint32 spectators = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_spectators());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint32 radiant_team_id = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_radiant_team_id());
    }

    // optional uint32 dire_team_id = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dire_team_id());
    }

    // optional uint32 league_node_id = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_node_id());
    }

    // optional uint64 match_id = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 series_id = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_series_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueLiveGames_LiveGame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueLiveGames_LiveGame::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueLiveGames_LiveGame::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueLiveGames_LiveGame::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueLiveGames_LiveGame*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueLiveGames_LiveGame&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueLiveGames.LiveGame)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_radiant_name(from._internal_radiant_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_dire_name(from._internal_dire_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.server_steam_id_ = from._impl_.server_steam_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.radiant_logo_ = from._impl_.radiant_logo_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.dire_logo_ = from._impl_.dire_logo_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.spectators_ = from._impl_.spectators_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.radiant_team_id_ = from._impl_.radiant_team_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.dire_team_id_ = from._impl_.dire_team_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.league_node_id_ = from._impl_.league_node_id_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.series_id_ = from._impl_.series_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueLiveGames_LiveGame::CopyFrom(const CMsgDOTALeagueLiveGames_LiveGame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueLiveGames.LiveGame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueLiveGames_LiveGame::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueLiveGames_LiveGame::InternalSwap(CMsgDOTALeagueLiveGames_LiveGame* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.radiant_name_, lhs_arena,
      &other->_impl_.radiant_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dire_name_, lhs_arena,
      &other->_impl_.dire_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueLiveGames_LiveGame, _impl_.series_id_)
      + sizeof(CMsgDOTALeagueLiveGames_LiveGame::_impl_.series_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueLiveGames_LiveGame, _impl_.server_steam_id_)>(
          reinterpret_cast<char*>(&_impl_.server_steam_id_),
          reinterpret_cast<char*>(&other->_impl_.server_steam_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueLiveGames_LiveGame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[16]);
}

// ===================================================================

class CMsgDOTALeagueLiveGames::_Internal {
 public:
};

CMsgDOTALeagueLiveGames::CMsgDOTALeagueLiveGames(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueLiveGames)
}
CMsgDOTALeagueLiveGames::CMsgDOTALeagueLiveGames(const CMsgDOTALeagueLiveGames& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueLiveGames* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.games_){from._impl_.games_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueLiveGames)
}

inline void CMsgDOTALeagueLiveGames::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.games_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTALeagueLiveGames::~CMsgDOTALeagueLiveGames() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueLiveGames)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueLiveGames::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.games_.~RepeatedPtrField();
}

void CMsgDOTALeagueLiveGames::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueLiveGames::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueLiveGames)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.games_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueLiveGames::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTALeagueLiveGames.LiveGame games = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_games(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueLiveGames::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueLiveGames)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTALeagueLiveGames.LiveGame games = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_games_size()); i < n; i++) {
    const auto& repfield = this->_internal_games(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueLiveGames)
  return target;
}

size_t CMsgDOTALeagueLiveGames::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueLiveGames)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTALeagueLiveGames.LiveGame games = 1;
  total_size += 1UL * this->_internal_games_size();
  for (const auto& msg : this->_impl_.games_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueLiveGames::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueLiveGames::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueLiveGames::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueLiveGames::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueLiveGames*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueLiveGames&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueLiveGames)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.games_.MergeFrom(from._impl_.games_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueLiveGames::CopyFrom(const CMsgDOTALeagueLiveGames& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueLiveGames)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueLiveGames::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueLiveGames::InternalSwap(CMsgDOTALeagueLiveGames* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.games_.InternalSwap(&other->_impl_.games_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueLiveGames::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[17]);
}

// ===================================================================

class CMsgDOTALeagueMessages_Message::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeagueMessages_Message>()._impl_._has_bits_);
  static void set_has_author_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTALeagueMessages_Message::CMsgDOTALeagueMessages_Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueMessages.Message)
}
CMsgDOTALeagueMessages_Message::CMsgDOTALeagueMessages_Message(const CMsgDOTALeagueMessages_Message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueMessages_Message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.author_account_id_){}
    , decltype(_impl_.timestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.author_account_id_, &from._impl_.author_account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timestamp_) -
    reinterpret_cast<char*>(&_impl_.author_account_id_)) + sizeof(_impl_.timestamp_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueMessages.Message)
}

inline void CMsgDOTALeagueMessages_Message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.author_account_id_){0u}
    , decltype(_impl_.timestamp_){0u}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeagueMessages_Message::~CMsgDOTALeagueMessages_Message() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueMessages.Message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueMessages_Message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void CMsgDOTALeagueMessages_Message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueMessages_Message::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueMessages.Message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.author_account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timestamp_) -
        reinterpret_cast<char*>(&_impl_.author_account_id_)) + sizeof(_impl_.timestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueMessages_Message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 author_account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_author_account_id(&has_bits);
          _impl_.author_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueMessages.Message.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueMessages_Message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueMessages.Message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 author_account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_author_account_id(), target);
  }

  // optional uint32 timestamp = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_timestamp(), target);
  }

  // optional string message = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueMessages.Message.message");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueMessages.Message)
  return target;
}

size_t CMsgDOTALeagueMessages_Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueMessages.Message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional uint32 author_account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_author_account_id());
    }

    // optional uint32 timestamp = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueMessages_Message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueMessages_Message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueMessages_Message::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueMessages_Message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueMessages_Message*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueMessages_Message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueMessages.Message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.author_account_id_ = from._impl_.author_account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueMessages_Message::CopyFrom(const CMsgDOTALeagueMessages_Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueMessages.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueMessages_Message::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueMessages_Message::InternalSwap(CMsgDOTALeagueMessages_Message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueMessages_Message, _impl_.timestamp_)
      + sizeof(CMsgDOTALeagueMessages_Message::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueMessages_Message, _impl_.author_account_id_)>(
          reinterpret_cast<char*>(&_impl_.author_account_id_),
          reinterpret_cast<char*>(&other->_impl_.author_account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueMessages_Message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[18]);
}

// ===================================================================

class CMsgDOTALeagueMessages::_Internal {
 public:
};

CMsgDOTALeagueMessages::CMsgDOTALeagueMessages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueMessages)
}
CMsgDOTALeagueMessages::CMsgDOTALeagueMessages(const CMsgDOTALeagueMessages& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueMessages* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messages_){from._impl_.messages_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueMessages)
}

inline void CMsgDOTALeagueMessages::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.messages_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTALeagueMessages::~CMsgDOTALeagueMessages() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueMessages)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueMessages::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.messages_.~RepeatedPtrField();
}

void CMsgDOTALeagueMessages::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueMessages::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueMessages)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.messages_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueMessages::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTALeagueMessages.Message messages = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_messages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueMessages::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueMessages)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTALeagueMessages.Message messages = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_messages_size()); i < n; i++) {
    const auto& repfield = this->_internal_messages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueMessages)
  return target;
}

size_t CMsgDOTALeagueMessages::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueMessages)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTALeagueMessages.Message messages = 1;
  total_size += 1UL * this->_internal_messages_size();
  for (const auto& msg : this->_impl_.messages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueMessages::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueMessages::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueMessages::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueMessages::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueMessages*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueMessages&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueMessages)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.messages_.MergeFrom(from._impl_.messages_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueMessages::CopyFrom(const CMsgDOTALeagueMessages& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueMessages)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueMessages::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueMessages::InternalSwap(CMsgDOTALeagueMessages* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.messages_.InternalSwap(&other->_impl_.messages_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueMessages::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[19]);
}

// ===================================================================

class CMsgDOTALeaguePrizePool::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeaguePrizePool>()._impl_._has_bits_);
  static void set_has_prize_pool(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_increment_per_second(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTALeaguePrizePool::CMsgDOTALeaguePrizePool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeaguePrizePool)
}
CMsgDOTALeaguePrizePool::CMsgDOTALeaguePrizePool(const CMsgDOTALeaguePrizePool& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeaguePrizePool* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prize_pool_){}
    , decltype(_impl_.increment_per_second_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.prize_pool_, &from._impl_.prize_pool_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.increment_per_second_) -
    reinterpret_cast<char*>(&_impl_.prize_pool_)) + sizeof(_impl_.increment_per_second_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeaguePrizePool)
}

inline void CMsgDOTALeaguePrizePool::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prize_pool_){0u}
    , decltype(_impl_.increment_per_second_){0}
  };
}

CMsgDOTALeaguePrizePool::~CMsgDOTALeaguePrizePool() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeaguePrizePool)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeaguePrizePool::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTALeaguePrizePool::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeaguePrizePool::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeaguePrizePool)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.prize_pool_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.increment_per_second_) -
        reinterpret_cast<char*>(&_impl_.prize_pool_)) + sizeof(_impl_.increment_per_second_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeaguePrizePool::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 prize_pool = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_prize_pool(&has_bits);
          _impl_.prize_pool_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float increment_per_second = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_increment_per_second(&has_bits);
          _impl_.increment_per_second_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeaguePrizePool::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeaguePrizePool)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 prize_pool = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_prize_pool(), target);
  }

  // optional float increment_per_second = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_increment_per_second(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeaguePrizePool)
  return target;
}

size_t CMsgDOTALeaguePrizePool::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeaguePrizePool)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 prize_pool = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prize_pool());
    }

    // optional float increment_per_second = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeaguePrizePool::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeaguePrizePool::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeaguePrizePool::GetClassData() const { return &_class_data_; }


void CMsgDOTALeaguePrizePool::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeaguePrizePool*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeaguePrizePool&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeaguePrizePool)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.prize_pool_ = from._impl_.prize_pool_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.increment_per_second_ = from._impl_.increment_per_second_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeaguePrizePool::CopyFrom(const CMsgDOTALeaguePrizePool& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeaguePrizePool)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeaguePrizePool::IsInitialized() const {
  return true;
}

void CMsgDOTALeaguePrizePool::InternalSwap(CMsgDOTALeaguePrizePool* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeaguePrizePool, _impl_.increment_per_second_)
      + sizeof(CMsgDOTALeaguePrizePool::_impl_.increment_per_second_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeaguePrizePool, _impl_.prize_pool_)>(
          reinterpret_cast<char*>(&_impl_.prize_pool_),
          reinterpret_cast<char*>(&other->_impl_.prize_pool_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeaguePrizePool::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[20]);
}

// ===================================================================

class CMsgDOTALeagueInfoListAdminsRequest::_Internal {
 public:
};

CMsgDOTALeagueInfoListAdminsRequest::CMsgDOTALeagueInfoListAdminsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueInfoListAdminsRequest)
}
CMsgDOTALeagueInfoListAdminsRequest::CMsgDOTALeagueInfoListAdminsRequest(const CMsgDOTALeagueInfoListAdminsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgDOTALeagueInfoListAdminsRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueInfoListAdminsRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueInfoListAdminsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueInfoListAdminsRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueInfoListAdminsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[21]);
}

// ===================================================================

class CMsgDOTALeagueAvailableLobbyNodesRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeagueAvailableLobbyNodesRequest>()._impl_._has_bits_);
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTALeagueAvailableLobbyNodesRequest::CMsgDOTALeagueAvailableLobbyNodesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueAvailableLobbyNodesRequest)
}
CMsgDOTALeagueAvailableLobbyNodesRequest::CMsgDOTALeagueAvailableLobbyNodesRequest(const CMsgDOTALeagueAvailableLobbyNodesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueAvailableLobbyNodesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.league_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.league_id_ = from._impl_.league_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueAvailableLobbyNodesRequest)
}

inline void CMsgDOTALeagueAvailableLobbyNodesRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.league_id_){0u}
  };
}

CMsgDOTALeagueAvailableLobbyNodesRequest::~CMsgDOTALeagueAvailableLobbyNodesRequest() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueAvailableLobbyNodesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueAvailableLobbyNodesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTALeagueAvailableLobbyNodesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueAvailableLobbyNodesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueAvailableLobbyNodesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.league_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueAvailableLobbyNodesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 league_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueAvailableLobbyNodesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueAvailableLobbyNodesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 league_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_league_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueAvailableLobbyNodesRequest)
  return target;
}

size_t CMsgDOTALeagueAvailableLobbyNodesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueAvailableLobbyNodesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 league_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueAvailableLobbyNodesRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueAvailableLobbyNodesRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueAvailableLobbyNodesRequest::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueAvailableLobbyNodesRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueAvailableLobbyNodesRequest*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueAvailableLobbyNodesRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueAvailableLobbyNodesRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_league_id()) {
    _this->_internal_set_league_id(from._internal_league_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueAvailableLobbyNodesRequest::CopyFrom(const CMsgDOTALeagueAvailableLobbyNodesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueAvailableLobbyNodesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueAvailableLobbyNodesRequest::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueAvailableLobbyNodesRequest::InternalSwap(CMsgDOTALeagueAvailableLobbyNodesRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.league_id_, other->_impl_.league_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueAvailableLobbyNodesRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[22]);
}

// ===================================================================

class CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeagueAvailableLobbyNodes_NodeInfo>()._impl_._has_bits_);
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_node_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_node_group_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team_id_1(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_team_id_2(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
}
CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo(const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.node_name_){}
    , decltype(_impl_.node_group_name_){}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.team_id_1_){}
    , decltype(_impl_.team_id_2_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.node_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.node_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_node_name()) {
    _this->_impl_.node_name_.Set(from._internal_node_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.node_group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.node_group_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_node_group_name()) {
    _this->_impl_.node_group_name_.Set(from._internal_node_group_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.node_id_, &from._impl_.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.team_id_2_) -
    reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.team_id_2_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
}

inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.node_name_){}
    , decltype(_impl_.node_group_name_){}
    , decltype(_impl_.node_id_){0u}
    , decltype(_impl_.team_id_1_){0u}
    , decltype(_impl_.team_id_2_){0u}
  };
  _impl_.node_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.node_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.node_group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.node_group_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::~CMsgDOTALeagueAvailableLobbyNodes_NodeInfo() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.node_name_.Destroy();
  _impl_.node_group_name_.Destroy();
}

void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.node_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.node_group_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.node_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.team_id_2_) -
        reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.team_id_2_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 node_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string node_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_node_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string node_group_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_node_group_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id_1 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_team_id_1(&has_bits);
          _impl_.team_id_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id_2 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_team_id_2(&has_bits);
          _impl_.team_id_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 node_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_node_id(), target);
  }

  // optional string node_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_node_name().data(), static_cast<int>(this->_internal_node_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_node_name(), target);
  }

  // optional string node_group_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_node_group_name().data(), static_cast<int>(this->_internal_node_group_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_node_group_name(), target);
  }

  // optional uint32 team_id_1 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_team_id_1(), target);
  }

  // optional uint32 team_id_2 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_team_id_2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
  return target;
}

size_t CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string node_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_node_name());
    }

    // optional string node_group_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_node_group_name());
    }

    // optional uint32 node_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
    }

    // optional uint32 team_id_1 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id_1());
    }

    // optional uint32 team_id_2 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id_2());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueAvailableLobbyNodes_NodeInfo*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_node_name(from._internal_node_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_node_group_name(from._internal_node_group_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.node_id_ = from._impl_.node_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_id_1_ = from._impl_.team_id_1_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.team_id_2_ = from._impl_.team_id_2_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::CopyFrom(const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::InternalSwap(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.node_name_, lhs_arena,
      &other->_impl_.node_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.node_group_name_, lhs_arena,
      &other->_impl_.node_group_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo, _impl_.team_id_2_)
      + sizeof(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_impl_.team_id_2_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo, _impl_.node_id_)>(
          reinterpret_cast<char*>(&_impl_.node_id_),
          reinterpret_cast<char*>(&other->_impl_.node_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[23]);
}

// ===================================================================

class CMsgDOTALeagueAvailableLobbyNodes::_Internal {
 public:
};

CMsgDOTALeagueAvailableLobbyNodes::CMsgDOTALeagueAvailableLobbyNodes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueAvailableLobbyNodes)
}
CMsgDOTALeagueAvailableLobbyNodes::CMsgDOTALeagueAvailableLobbyNodes(const CMsgDOTALeagueAvailableLobbyNodes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueAvailableLobbyNodes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.node_infos_){from._impl_.node_infos_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueAvailableLobbyNodes)
}

inline void CMsgDOTALeagueAvailableLobbyNodes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.node_infos_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTALeagueAvailableLobbyNodes::~CMsgDOTALeagueAvailableLobbyNodes() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueAvailableLobbyNodes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueAvailableLobbyNodes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.node_infos_.~RepeatedPtrField();
}

void CMsgDOTALeagueAvailableLobbyNodes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueAvailableLobbyNodes::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueAvailableLobbyNodes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.node_infos_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueAvailableLobbyNodes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTALeagueAvailableLobbyNodes.NodeInfo node_infos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_node_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueAvailableLobbyNodes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueAvailableLobbyNodes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTALeagueAvailableLobbyNodes.NodeInfo node_infos = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_node_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_node_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueAvailableLobbyNodes)
  return target;
}

size_t CMsgDOTALeagueAvailableLobbyNodes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueAvailableLobbyNodes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTALeagueAvailableLobbyNodes.NodeInfo node_infos = 1;
  total_size += 1UL * this->_internal_node_infos_size();
  for (const auto& msg : this->_impl_.node_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueAvailableLobbyNodes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueAvailableLobbyNodes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueAvailableLobbyNodes::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueAvailableLobbyNodes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueAvailableLobbyNodes*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueAvailableLobbyNodes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueAvailableLobbyNodes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.node_infos_.MergeFrom(from._impl_.node_infos_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueAvailableLobbyNodes::CopyFrom(const CMsgDOTALeagueAvailableLobbyNodes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueAvailableLobbyNodes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueAvailableLobbyNodes::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueAvailableLobbyNodes::InternalSwap(CMsgDOTALeagueAvailableLobbyNodes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.node_infos_.InternalSwap(&other->_impl_.node_infos_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueAvailableLobbyNodes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[24]);
}

// ===================================================================

class CMsgDOTALeagueNodeResults_Result::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTALeagueNodeResults_Result>()._impl_._has_bits_);
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_winning_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_losing_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_incoming_node_id_1(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_incoming_node_id_2(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_team_id_1(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_team_id_2(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_team_1_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_2_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team_1_wins(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_team_2_wins(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_winning_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_losing_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_has_started(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_is_completed(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_scheduled_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

CMsgDOTALeagueNodeResults_Result::CMsgDOTALeagueNodeResults_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueNodeResults.Result)
}
CMsgDOTALeagueNodeResults_Result::CMsgDOTALeagueNodeResults_Result(const CMsgDOTALeagueNodeResults_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueNodeResults_Result* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_ids_){from._impl_.match_ids_}
    , decltype(_impl_.team_1_name_){}
    , decltype(_impl_.team_2_name_){}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.winning_node_id_){}
    , decltype(_impl_.losing_node_id_){}
    , decltype(_impl_.incoming_node_id_1_){}
    , decltype(_impl_.incoming_node_id_2_){}
    , decltype(_impl_.team_id_1_){}
    , decltype(_impl_.team_id_2_){}
    , decltype(_impl_.team_1_wins_){}
    , decltype(_impl_.team_2_wins_){}
    , decltype(_impl_.winning_team_id_){}
    , decltype(_impl_.losing_team_id_){}
    , decltype(_impl_.has_started_){}
    , decltype(_impl_.is_completed_){}
    , decltype(_impl_.scheduled_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.team_1_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_1_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_1_name()) {
    _this->_impl_.team_1_name_.Set(from._internal_team_1_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_2_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_2_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_2_name()) {
    _this->_impl_.team_2_name_.Set(from._internal_team_2_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.node_id_, &from._impl_.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.scheduled_time_) -
    reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.scheduled_time_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueNodeResults.Result)
}

inline void CMsgDOTALeagueNodeResults_Result::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_ids_){arena}
    , decltype(_impl_.team_1_name_){}
    , decltype(_impl_.team_2_name_){}
    , decltype(_impl_.node_id_){0u}
    , decltype(_impl_.winning_node_id_){0u}
    , decltype(_impl_.losing_node_id_){0u}
    , decltype(_impl_.incoming_node_id_1_){0u}
    , decltype(_impl_.incoming_node_id_2_){0u}
    , decltype(_impl_.team_id_1_){0u}
    , decltype(_impl_.team_id_2_){0u}
    , decltype(_impl_.team_1_wins_){0u}
    , decltype(_impl_.team_2_wins_){0u}
    , decltype(_impl_.winning_team_id_){0u}
    , decltype(_impl_.losing_team_id_){0u}
    , decltype(_impl_.has_started_){false}
    , decltype(_impl_.is_completed_){false}
    , decltype(_impl_.scheduled_time_){0u}
  };
  _impl_.team_1_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_1_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_2_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_2_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTALeagueNodeResults_Result::~CMsgDOTALeagueNodeResults_Result() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueNodeResults.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueNodeResults_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.match_ids_.~RepeatedField();
  _impl_.team_1_name_.Destroy();
  _impl_.team_2_name_.Destroy();
}

void CMsgDOTALeagueNodeResults_Result::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueNodeResults_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueNodeResults.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.match_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.team_1_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.team_2_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.node_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.team_id_1_) -
        reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.team_id_1_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.team_id_2_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.scheduled_time_) -
        reinterpret_cast<char*>(&_impl_.team_id_2_)) + sizeof(_impl_.scheduled_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueNodeResults_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 node_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 winning_node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_winning_node_id(&has_bits);
          _impl_.winning_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 losing_node_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_losing_node_id(&has_bits);
          _impl_.losing_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 incoming_node_id_1 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_incoming_node_id_1(&has_bits);
          _impl_.incoming_node_id_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 incoming_node_id_2 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_incoming_node_id_2(&has_bits);
          _impl_.incoming_node_id_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id_1 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_team_id_1(&has_bits);
          _impl_.team_id_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id_2 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_team_id_2(&has_bits);
          _impl_.team_id_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_1_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_team_1_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueNodeResults.Result.team_1_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string team_2_name = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_team_2_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTALeagueNodeResults.Result.team_2_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_1_wins = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_team_1_wins(&has_bits);
          _impl_.team_1_wins_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_2_wins = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_team_2_wins(&has_bits);
          _impl_.team_2_wins_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 winning_team_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_winning_team_id(&has_bits);
          _impl_.winning_team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 losing_team_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_losing_team_id(&has_bits);
          _impl_.losing_team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_started = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_has_started(&has_bits);
          _impl_.has_started_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_completed = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_is_completed(&has_bits);
          _impl_.is_completed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 scheduled_time = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_scheduled_time(&has_bits);
          _impl_.scheduled_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 match_ids = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_match_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<136>(ptr));
        } else if (static_cast<uint8_t>(tag) == 138) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_match_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueNodeResults_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueNodeResults.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 node_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_node_id(), target);
  }

  // optional uint32 winning_node_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_winning_node_id(), target);
  }

  // optional uint32 losing_node_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_losing_node_id(), target);
  }

  // optional uint32 incoming_node_id_1 = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_incoming_node_id_1(), target);
  }

  // optional uint32 incoming_node_id_2 = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_incoming_node_id_2(), target);
  }

  // optional uint32 team_id_1 = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_team_id_1(), target);
  }

  // optional uint32 team_id_2 = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_team_id_2(), target);
  }

  // optional string team_1_name = 8;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_1_name().data(), static_cast<int>(this->_internal_team_1_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueNodeResults.Result.team_1_name");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_team_1_name(), target);
  }

  // optional string team_2_name = 9;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_2_name().data(), static_cast<int>(this->_internal_team_2_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTALeagueNodeResults.Result.team_2_name");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_team_2_name(), target);
  }

  // optional uint32 team_1_wins = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_team_1_wins(), target);
  }

  // optional uint32 team_2_wins = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_team_2_wins(), target);
  }

  // optional uint32 winning_team_id = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_winning_team_id(), target);
  }

  // optional uint32 losing_team_id = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_losing_team_id(), target);
  }

  // optional bool has_started = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_has_started(), target);
  }

  // optional bool is_completed = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_is_completed(), target);
  }

  // optional uint32 scheduled_time = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_scheduled_time(), target);
  }

  // repeated uint64 match_ids = 17;
  for (int i = 0, n = this->_internal_match_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(17, this->_internal_match_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueNodeResults.Result)
  return target;
}

size_t CMsgDOTALeagueNodeResults_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueNodeResults.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 match_ids = 17;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.match_ids_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_match_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string team_1_name = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_1_name());
    }

    // optional string team_2_name = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_2_name());
    }

    // optional uint32 node_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
    }

    // optional uint32 winning_node_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_winning_node_id());
    }

    // optional uint32 losing_node_id = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_losing_node_id());
    }

    // optional uint32 incoming_node_id_1 = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_incoming_node_id_1());
    }

    // optional uint32 incoming_node_id_2 = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_incoming_node_id_2());
    }

    // optional uint32 team_id_1 = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id_1());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 team_id_2 = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id_2());
    }

    // optional uint32 team_1_wins = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_1_wins());
    }

    // optional uint32 team_2_wins = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_2_wins());
    }

    // optional uint32 winning_team_id = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_winning_team_id());
    }

    // optional uint32 losing_team_id = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_losing_team_id());
    }

    // optional bool has_started = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool is_completed = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional uint32 scheduled_time = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_scheduled_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueNodeResults_Result::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueNodeResults_Result::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueNodeResults_Result::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueNodeResults_Result::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueNodeResults_Result*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueNodeResults_Result&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueNodeResults.Result)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.match_ids_.MergeFrom(from._impl_.match_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_team_1_name(from._internal_team_1_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_team_2_name(from._internal_team_2_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.node_id_ = from._impl_.node_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.winning_node_id_ = from._impl_.winning_node_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.losing_node_id_ = from._impl_.losing_node_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.incoming_node_id_1_ = from._impl_.incoming_node_id_1_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.incoming_node_id_2_ = from._impl_.incoming_node_id_2_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.team_id_1_ = from._impl_.team_id_1_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.team_id_2_ = from._impl_.team_id_2_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.team_1_wins_ = from._impl_.team_1_wins_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.team_2_wins_ = from._impl_.team_2_wins_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.winning_team_id_ = from._impl_.winning_team_id_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.losing_team_id_ = from._impl_.losing_team_id_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.has_started_ = from._impl_.has_started_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.is_completed_ = from._impl_.is_completed_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.scheduled_time_ = from._impl_.scheduled_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueNodeResults_Result::CopyFrom(const CMsgDOTALeagueNodeResults_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueNodeResults.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueNodeResults_Result::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueNodeResults_Result::InternalSwap(CMsgDOTALeagueNodeResults_Result* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.match_ids_.InternalSwap(&other->_impl_.match_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_1_name_, lhs_arena,
      &other->_impl_.team_1_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_2_name_, lhs_arena,
      &other->_impl_.team_2_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueNodeResults_Result, _impl_.scheduled_time_)
      + sizeof(CMsgDOTALeagueNodeResults_Result::_impl_.scheduled_time_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTALeagueNodeResults_Result, _impl_.node_id_)>(
          reinterpret_cast<char*>(&_impl_.node_id_),
          reinterpret_cast<char*>(&other->_impl_.node_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueNodeResults_Result::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[25]);
}

// ===================================================================

class CMsgDOTALeagueNodeResults::_Internal {
 public:
};

CMsgDOTALeagueNodeResults::CMsgDOTALeagueNodeResults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTALeagueNodeResults)
}
CMsgDOTALeagueNodeResults::CMsgDOTALeagueNodeResults(const CMsgDOTALeagueNodeResults& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTALeagueNodeResults* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.node_results_){from._impl_.node_results_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTALeagueNodeResults)
}

inline void CMsgDOTALeagueNodeResults::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.node_results_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTALeagueNodeResults::~CMsgDOTALeagueNodeResults() {
  // @@protoc_insertion_point(destructor:CMsgDOTALeagueNodeResults)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTALeagueNodeResults::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.node_results_.~RepeatedPtrField();
}

void CMsgDOTALeagueNodeResults::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTALeagueNodeResults::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTALeagueNodeResults)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.node_results_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTALeagueNodeResults::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTALeagueNodeResults.Result node_results = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_node_results(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTALeagueNodeResults::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTALeagueNodeResults)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTALeagueNodeResults.Result node_results = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_node_results_size()); i < n; i++) {
    const auto& repfield = this->_internal_node_results(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTALeagueNodeResults)
  return target;
}

size_t CMsgDOTALeagueNodeResults::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTALeagueNodeResults)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTALeagueNodeResults.Result node_results = 1;
  total_size += 1UL * this->_internal_node_results_size();
  for (const auto& msg : this->_impl_.node_results_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTALeagueNodeResults::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTALeagueNodeResults::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTALeagueNodeResults::GetClassData() const { return &_class_data_; }


void CMsgDOTALeagueNodeResults::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTALeagueNodeResults*>(&to_msg);
  auto& from = static_cast<const CMsgDOTALeagueNodeResults&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTALeagueNodeResults)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.node_results_.MergeFrom(from._impl_.node_results_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTALeagueNodeResults::CopyFrom(const CMsgDOTALeagueNodeResults& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTALeagueNodeResults)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTALeagueNodeResults::IsInitialized() const {
  return true;
}

void CMsgDOTALeagueNodeResults::InternalSwap(CMsgDOTALeagueNodeResults* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.node_results_.InternalSwap(&other->_impl_.node_results_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTALeagueNodeResults::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[26]);
}

// ===================================================================

class CMsgDOTADPCLeagueResults_Result::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTADPCLeagueResults_Result>()._impl_._has_bits_);
  static void set_has_standing(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_team_logo_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_points(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_earnings(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_team_abbreviation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDOTADPCLeagueResults_Result::CMsgDOTADPCLeagueResults_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCLeagueResults.Result)
}
CMsgDOTADPCLeagueResults_Result::CMsgDOTADPCLeagueResults_Result(const CMsgDOTADPCLeagueResults_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCLeagueResults_Result* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_logo_url_){}
    , decltype(_impl_.team_abbreviation_){}
    , decltype(_impl_.standing_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.team_logo_){}
    , decltype(_impl_.points_){}
    , decltype(_impl_.earnings_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.phase_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_name()) {
    _this->_impl_.team_name_.Set(from._internal_team_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_logo_url()) {
    _this->_impl_.team_logo_url_.Set(from._internal_team_logo_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_abbreviation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_abbreviation()) {
    _this->_impl_.team_abbreviation_.Set(from._internal_team_abbreviation(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.standing_, &from._impl_.standing_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.phase_) -
    reinterpret_cast<char*>(&_impl_.standing_)) + sizeof(_impl_.phase_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCLeagueResults.Result)
}

inline void CMsgDOTADPCLeagueResults_Result::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_logo_url_){}
    , decltype(_impl_.team_abbreviation_){}
    , decltype(_impl_.standing_){0u}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.team_logo_){uint64_t{0u}}
    , decltype(_impl_.points_){0u}
    , decltype(_impl_.earnings_){0u}
    , decltype(_impl_.timestamp_){0u}
    , decltype(_impl_.phase_){0}
  };
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_abbreviation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTADPCLeagueResults_Result::~CMsgDOTADPCLeagueResults_Result() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCLeagueResults.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCLeagueResults_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.team_name_.Destroy();
  _impl_.team_logo_url_.Destroy();
  _impl_.team_abbreviation_.Destroy();
}

void CMsgDOTADPCLeagueResults_Result::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCLeagueResults_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCLeagueResults.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.team_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.team_logo_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.team_abbreviation_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.standing_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.earnings_) -
        reinterpret_cast<char*>(&_impl_.standing_)) + sizeof(_impl_.earnings_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.phase_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.phase_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCLeagueResults_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 standing = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_standing(&has_bits);
          _impl_.standing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTADPCLeagueResults.Result.team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 team_logo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_team_logo(&has_bits);
          _impl_.team_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_logo_url = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_team_logo_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTADPCLeagueResults.Result.team_logo_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 points = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_points(&has_bits);
          _impl_.points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 earnings = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_earnings(&has_bits);
          _impl_.earnings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ELeaguePhase phase = 9 [default = LEAGUE_PHASE_UNSET];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeaguePhase_IsValid(val))) {
            _internal_set_phase(static_cast<::ELeaguePhase>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string team_abbreviation = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_team_abbreviation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTADPCLeagueResults.Result.team_abbreviation");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCLeagueResults_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCLeagueResults.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 standing = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_standing(), target);
  }

  // optional uint32 team_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_team_id(), target);
  }

  // optional string team_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_name().data(), static_cast<int>(this->_internal_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTADPCLeagueResults.Result.team_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_team_name(), target);
  }

  // optional uint64 team_logo = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_team_logo(), target);
  }

  // optional string team_logo_url = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_logo_url().data(), static_cast<int>(this->_internal_team_logo_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTADPCLeagueResults.Result.team_logo_url");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_team_logo_url(), target);
  }

  // optional uint32 points = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_points(), target);
  }

  // optional uint32 earnings = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_earnings(), target);
  }

  // optional uint32 timestamp = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_timestamp(), target);
  }

  // optional .ELeaguePhase phase = 9 [default = LEAGUE_PHASE_UNSET];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_phase(), target);
  }

  // optional string team_abbreviation = 10;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_abbreviation().data(), static_cast<int>(this->_internal_team_abbreviation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTADPCLeagueResults.Result.team_abbreviation");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_team_abbreviation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCLeagueResults.Result)
  return target;
}

size_t CMsgDOTADPCLeagueResults_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCLeagueResults.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string team_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_name());
    }

    // optional string team_logo_url = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_logo_url());
    }

    // optional string team_abbreviation = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_abbreviation());
    }

    // optional uint32 standing = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_standing());
    }

    // optional uint32 team_id = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint64 team_logo = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_team_logo());
    }

    // optional uint32 points = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_points());
    }

    // optional uint32 earnings = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_earnings());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 timestamp = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

    // optional .ELeaguePhase phase = 9 [default = LEAGUE_PHASE_UNSET];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_phase());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCLeagueResults_Result::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCLeagueResults_Result::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCLeagueResults_Result::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCLeagueResults_Result::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCLeagueResults_Result*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCLeagueResults_Result&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCLeagueResults.Result)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_team_name(from._internal_team_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_team_logo_url(from._internal_team_logo_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_team_abbreviation(from._internal_team_abbreviation());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.standing_ = from._impl_.standing_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.team_logo_ = from._impl_.team_logo_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.points_ = from._impl_.points_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.earnings_ = from._impl_.earnings_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.phase_ = from._impl_.phase_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCLeagueResults_Result::CopyFrom(const CMsgDOTADPCLeagueResults_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCLeagueResults.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCLeagueResults_Result::IsInitialized() const {
  return true;
}

void CMsgDOTADPCLeagueResults_Result::InternalSwap(CMsgDOTADPCLeagueResults_Result* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_name_, lhs_arena,
      &other->_impl_.team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_logo_url_, lhs_arena,
      &other->_impl_.team_logo_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_abbreviation_, lhs_arena,
      &other->_impl_.team_abbreviation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTADPCLeagueResults_Result, _impl_.phase_)
      + sizeof(CMsgDOTADPCLeagueResults_Result::_impl_.phase_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTADPCLeagueResults_Result, _impl_.standing_)>(
          reinterpret_cast<char*>(&_impl_.standing_),
          reinterpret_cast<char*>(&other->_impl_.standing_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCLeagueResults_Result::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[27]);
}

// ===================================================================

class CMsgDOTADPCLeagueResults::_Internal {
 public:
};

CMsgDOTADPCLeagueResults::CMsgDOTADPCLeagueResults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCLeagueResults)
}
CMsgDOTADPCLeagueResults::CMsgDOTADPCLeagueResults(const CMsgDOTADPCLeagueResults& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCLeagueResults* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.results_){from._impl_.results_}
    , decltype(_impl_.points_){from._impl_.points_}
    , decltype(_impl_.dollars_){from._impl_.dollars_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCLeagueResults)
}

inline void CMsgDOTADPCLeagueResults::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.results_){arena}
    , decltype(_impl_.points_){arena}
    , decltype(_impl_.dollars_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTADPCLeagueResults::~CMsgDOTADPCLeagueResults() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCLeagueResults)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCLeagueResults::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.results_.~RepeatedPtrField();
  _impl_.points_.~RepeatedField();
  _impl_.dollars_.~RepeatedField();
}

void CMsgDOTADPCLeagueResults::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCLeagueResults::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCLeagueResults)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.results_.Clear();
  _impl_.points_.Clear();
  _impl_.dollars_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCLeagueResults::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTADPCLeagueResults.Result results = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_results(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 points = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_points(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_points(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 dollars = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dollars(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_dollars(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCLeagueResults::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCLeagueResults)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTADPCLeagueResults.Result results = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_results_size()); i < n; i++) {
    const auto& repfield = this->_internal_results(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated uint32 points = 2;
  for (int i = 0, n = this->_internal_points_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_points(i), target);
  }

  // repeated uint32 dollars = 3;
  for (int i = 0, n = this->_internal_dollars_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_dollars(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCLeagueResults)
  return target;
}

size_t CMsgDOTADPCLeagueResults::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCLeagueResults)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTADPCLeagueResults.Result results = 1;
  total_size += 1UL * this->_internal_results_size();
  for (const auto& msg : this->_impl_.results_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 points = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.points_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_points_size());
    total_size += data_size;
  }

  // repeated uint32 dollars = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.dollars_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_dollars_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCLeagueResults::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCLeagueResults::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCLeagueResults::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCLeagueResults::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCLeagueResults*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCLeagueResults&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCLeagueResults)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.results_.MergeFrom(from._impl_.results_);
  _this->_impl_.points_.MergeFrom(from._impl_.points_);
  _this->_impl_.dollars_.MergeFrom(from._impl_.dollars_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCLeagueResults::CopyFrom(const CMsgDOTADPCLeagueResults& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCLeagueResults)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCLeagueResults::IsInitialized() const {
  return true;
}

void CMsgDOTADPCLeagueResults::InternalSwap(CMsgDOTADPCLeagueResults* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.results_.InternalSwap(&other->_impl_.results_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
  _impl_.dollars_.InternalSwap(&other->_impl_.dollars_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCLeagueResults::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[28]);
}

// ===================================================================

class CMsgDOTADPCTeamResults_Result::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTADPCTeamResults_Result>()._impl_._has_bits_);
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_standing(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_points(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_earnings(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgDOTADPCTeamResults_Result::CMsgDOTADPCTeamResults_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCTeamResults.Result)
}
CMsgDOTADPCTeamResults_Result::CMsgDOTADPCTeamResults_Result(const CMsgDOTADPCTeamResults_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCTeamResults_Result* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.standing_){}
    , decltype(_impl_.points_){}
    , decltype(_impl_.earnings_){}
    , decltype(_impl_.timestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.league_id_, &from._impl_.league_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timestamp_) -
    reinterpret_cast<char*>(&_impl_.league_id_)) + sizeof(_impl_.timestamp_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCTeamResults.Result)
}

inline void CMsgDOTADPCTeamResults_Result::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.standing_){0u}
    , decltype(_impl_.points_){0u}
    , decltype(_impl_.earnings_){0u}
    , decltype(_impl_.timestamp_){0u}
  };
}

CMsgDOTADPCTeamResults_Result::~CMsgDOTADPCTeamResults_Result() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCTeamResults.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCTeamResults_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTADPCTeamResults_Result::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCTeamResults_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCTeamResults.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.league_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timestamp_) -
        reinterpret_cast<char*>(&_impl_.league_id_)) + sizeof(_impl_.timestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCTeamResults_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 league_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 standing = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_standing(&has_bits);
          _impl_.standing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 points = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_points(&has_bits);
          _impl_.points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 earnings = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_earnings(&has_bits);
          _impl_.earnings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCTeamResults_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCTeamResults.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 league_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_league_id(), target);
  }

  // optional uint32 standing = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_standing(), target);
  }

  // optional uint32 points = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_points(), target);
  }

  // optional uint32 earnings = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_earnings(), target);
  }

  // optional uint32 timestamp = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCTeamResults.Result)
  return target;
}

size_t CMsgDOTADPCTeamResults_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCTeamResults.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 league_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional uint32 standing = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_standing());
    }

    // optional uint32 points = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_points());
    }

    // optional uint32 earnings = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_earnings());
    }

    // optional uint32 timestamp = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCTeamResults_Result::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCTeamResults_Result::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCTeamResults_Result::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCTeamResults_Result::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCTeamResults_Result*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCTeamResults_Result&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCTeamResults.Result)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.standing_ = from._impl_.standing_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.points_ = from._impl_.points_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.earnings_ = from._impl_.earnings_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCTeamResults_Result::CopyFrom(const CMsgDOTADPCTeamResults_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCTeamResults.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCTeamResults_Result::IsInitialized() const {
  return true;
}

void CMsgDOTADPCTeamResults_Result::InternalSwap(CMsgDOTADPCTeamResults_Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTADPCTeamResults_Result, _impl_.timestamp_)
      + sizeof(CMsgDOTADPCTeamResults_Result::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTADPCTeamResults_Result, _impl_.league_id_)>(
          reinterpret_cast<char*>(&_impl_.league_id_),
          reinterpret_cast<char*>(&other->_impl_.league_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCTeamResults_Result::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[29]);
}

// ===================================================================

class CMsgDOTADPCTeamResults::_Internal {
 public:
};

CMsgDOTADPCTeamResults::CMsgDOTADPCTeamResults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCTeamResults)
}
CMsgDOTADPCTeamResults::CMsgDOTADPCTeamResults(const CMsgDOTADPCTeamResults& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCTeamResults* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.results_){from._impl_.results_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCTeamResults)
}

inline void CMsgDOTADPCTeamResults::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.results_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTADPCTeamResults::~CMsgDOTADPCTeamResults() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCTeamResults)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCTeamResults::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.results_.~RepeatedPtrField();
}

void CMsgDOTADPCTeamResults::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCTeamResults::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCTeamResults)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.results_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCTeamResults::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTADPCTeamResults.Result results = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_results(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCTeamResults::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCTeamResults)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTADPCTeamResults.Result results = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_results_size()); i < n; i++) {
    const auto& repfield = this->_internal_results(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCTeamResults)
  return target;
}

size_t CMsgDOTADPCTeamResults::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCTeamResults)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTADPCTeamResults.Result results = 1;
  total_size += 1UL * this->_internal_results_size();
  for (const auto& msg : this->_impl_.results_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCTeamResults::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCTeamResults::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCTeamResults::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCTeamResults::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCTeamResults*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCTeamResults&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCTeamResults)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.results_.MergeFrom(from._impl_.results_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCTeamResults::CopyFrom(const CMsgDOTADPCTeamResults& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCTeamResults)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCTeamResults::IsInitialized() const {
  return true;
}

void CMsgDOTADPCTeamResults::InternalSwap(CMsgDOTADPCTeamResults* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.results_.InternalSwap(&other->_impl_.results_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCTeamResults::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[30]);
}

// ===================================================================

class CMsgDOTADPCSeasonResults_TeamLeagueResult::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTADPCSeasonResults_TeamLeagueResult>()._impl_._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_standing(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_points(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_earnings(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_audit_action(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_audit_data(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CMsgDOTADPCSeasonResults_TeamLeagueResult::CMsgDOTADPCSeasonResults_TeamLeagueResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCSeasonResults.TeamLeagueResult)
}
CMsgDOTADPCSeasonResults_TeamLeagueResult::CMsgDOTADPCSeasonResults_TeamLeagueResult(const CMsgDOTADPCSeasonResults_TeamLeagueResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCSeasonResults_TeamLeagueResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.standing_){}
    , decltype(_impl_.points_){}
    , decltype(_impl_.earnings_){}
    , decltype(_impl_.audit_action_){}
    , decltype(_impl_.audit_data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.audit_data_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.audit_data_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCSeasonResults.TeamLeagueResult)
}

inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){0u}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.standing_){0u}
    , decltype(_impl_.points_){0u}
    , decltype(_impl_.earnings_){0u}
    , decltype(_impl_.audit_action_){0u}
    , decltype(_impl_.audit_data_){0u}
  };
}

CMsgDOTADPCSeasonResults_TeamLeagueResult::~CMsgDOTADPCSeasonResults_TeamLeagueResult() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCSeasonResults.TeamLeagueResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTADPCSeasonResults_TeamLeagueResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCSeasonResults_TeamLeagueResult::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCSeasonResults.TeamLeagueResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.audit_data_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.audit_data_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCSeasonResults_TeamLeagueResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 standing = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_standing(&has_bits);
          _impl_.standing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 points = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_points(&has_bits);
          _impl_.points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 earnings = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_earnings(&has_bits);
          _impl_.earnings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 audit_action = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_audit_action(&has_bits);
          _impl_.audit_action_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 audit_data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_audit_data(&has_bits);
          _impl_.audit_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCSeasonResults_TeamLeagueResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCSeasonResults.TeamLeagueResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_timestamp(), target);
  }

  // optional uint32 league_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_league_id(), target);
  }

  // optional uint32 standing = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_standing(), target);
  }

  // optional uint32 points = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_points(), target);
  }

  // optional uint32 earnings = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_earnings(), target);
  }

  // optional uint32 audit_action = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_audit_action(), target);
  }

  // optional uint32 audit_data = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_audit_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCSeasonResults.TeamLeagueResult)
  return target;
}

size_t CMsgDOTADPCSeasonResults_TeamLeagueResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCSeasonResults.TeamLeagueResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint32 timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

    // optional uint32 league_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional uint32 standing = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_standing());
    }

    // optional uint32 points = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_points());
    }

    // optional uint32 earnings = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_earnings());
    }

    // optional uint32 audit_action = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_audit_action());
    }

    // optional uint32 audit_data = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_audit_data());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCSeasonResults_TeamLeagueResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCSeasonResults_TeamLeagueResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCSeasonResults_TeamLeagueResult::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCSeasonResults_TeamLeagueResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCSeasonResults_TeamLeagueResult*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCSeasonResults_TeamLeagueResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCSeasonResults.TeamLeagueResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.standing_ = from._impl_.standing_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.points_ = from._impl_.points_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.earnings_ = from._impl_.earnings_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.audit_action_ = from._impl_.audit_action_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.audit_data_ = from._impl_.audit_data_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCSeasonResults_TeamLeagueResult::CopyFrom(const CMsgDOTADPCSeasonResults_TeamLeagueResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCSeasonResults.TeamLeagueResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCSeasonResults_TeamLeagueResult::IsInitialized() const {
  return true;
}

void CMsgDOTADPCSeasonResults_TeamLeagueResult::InternalSwap(CMsgDOTADPCSeasonResults_TeamLeagueResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTADPCSeasonResults_TeamLeagueResult, _impl_.audit_data_)
      + sizeof(CMsgDOTADPCSeasonResults_TeamLeagueResult::_impl_.audit_data_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTADPCSeasonResults_TeamLeagueResult, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCSeasonResults_TeamLeagueResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[31]);
}

// ===================================================================

class CMsgDOTADPCSeasonResults_TeamResult::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTADPCSeasonResults_TeamResult>()._impl_._has_bits_);
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_abbreviation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_team_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_team_logo_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_total_points(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_total_earnings(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CMsgDOTADPCSeasonResults_TeamResult::CMsgDOTADPCSeasonResults_TeamResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCSeasonResults.TeamResult)
}
CMsgDOTADPCSeasonResults_TeamResult::CMsgDOTADPCSeasonResults_TeamResult(const CMsgDOTADPCSeasonResults_TeamResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCSeasonResults_TeamResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.league_results_){from._impl_.league_results_}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_logo_url_){}
    , decltype(_impl_.team_abbreviation_){}
    , decltype(_impl_.team_logo_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.total_points_){}
    , decltype(_impl_.total_earnings_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_name()) {
    _this->_impl_.team_name_.Set(from._internal_team_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_logo_url()) {
    _this->_impl_.team_logo_url_.Set(from._internal_team_logo_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_abbreviation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_abbreviation()) {
    _this->_impl_.team_abbreviation_.Set(from._internal_team_abbreviation(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.team_logo_, &from._impl_.team_logo_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_earnings_) -
    reinterpret_cast<char*>(&_impl_.team_logo_)) + sizeof(_impl_.total_earnings_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCSeasonResults.TeamResult)
}

inline void CMsgDOTADPCSeasonResults_TeamResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.league_results_){arena}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_logo_url_){}
    , decltype(_impl_.team_abbreviation_){}
    , decltype(_impl_.team_logo_){uint64_t{0u}}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.total_points_){0u}
    , decltype(_impl_.total_earnings_){0u}
  };
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_abbreviation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTADPCSeasonResults_TeamResult::~CMsgDOTADPCSeasonResults_TeamResult() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCSeasonResults.TeamResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCSeasonResults_TeamResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.league_results_.~RepeatedPtrField();
  _impl_.team_name_.Destroy();
  _impl_.team_logo_url_.Destroy();
  _impl_.team_abbreviation_.Destroy();
}

void CMsgDOTADPCSeasonResults_TeamResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCSeasonResults_TeamResult::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCSeasonResults.TeamResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.league_results_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.team_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.team_logo_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.team_abbreviation_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&_impl_.team_logo_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.total_earnings_) -
        reinterpret_cast<char*>(&_impl_.team_logo_)) + sizeof(_impl_.total_earnings_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCSeasonResults_TeamResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 team_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTADPCSeasonResults.TeamResult.team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 team_logo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_team_logo(&has_bits);
          _impl_.team_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_logo_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_team_logo_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTADPCSeasonResults.TeamResult.team_logo_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 total_points = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_total_points(&has_bits);
          _impl_.total_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 total_earnings = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_total_earnings(&has_bits);
          _impl_.total_earnings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTADPCSeasonResults.TeamLeagueResult league_results = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_league_results(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string team_abbreviation = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_team_abbreviation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTADPCSeasonResults.TeamResult.team_abbreviation");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCSeasonResults_TeamResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCSeasonResults.TeamResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 team_id = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_team_id(), target);
  }

  // optional string team_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_name().data(), static_cast<int>(this->_internal_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTADPCSeasonResults.TeamResult.team_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_team_name(), target);
  }

  // optional uint64 team_logo = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_team_logo(), target);
  }

  // optional string team_logo_url = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_logo_url().data(), static_cast<int>(this->_internal_team_logo_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTADPCSeasonResults.TeamResult.team_logo_url");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_team_logo_url(), target);
  }

  // optional uint32 total_points = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_total_points(), target);
  }

  // optional uint32 total_earnings = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_total_earnings(), target);
  }

  // repeated .CMsgDOTADPCSeasonResults.TeamLeagueResult league_results = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_league_results_size()); i < n; i++) {
    const auto& repfield = this->_internal_league_results(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string team_abbreviation = 8;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_abbreviation().data(), static_cast<int>(this->_internal_team_abbreviation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTADPCSeasonResults.TeamResult.team_abbreviation");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_team_abbreviation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCSeasonResults.TeamResult)
  return target;
}

size_t CMsgDOTADPCSeasonResults_TeamResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCSeasonResults.TeamResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTADPCSeasonResults.TeamLeagueResult league_results = 7;
  total_size += 1UL * this->_internal_league_results_size();
  for (const auto& msg : this->_impl_.league_results_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string team_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_name());
    }

    // optional string team_logo_url = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_logo_url());
    }

    // optional string team_abbreviation = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_abbreviation());
    }

    // optional uint64 team_logo = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_team_logo());
    }

    // optional uint32 team_id = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint32 total_points = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_points());
    }

    // optional uint32 total_earnings = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_earnings());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCSeasonResults_TeamResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCSeasonResults_TeamResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCSeasonResults_TeamResult::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCSeasonResults_TeamResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCSeasonResults_TeamResult*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCSeasonResults_TeamResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCSeasonResults.TeamResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.league_results_.MergeFrom(from._impl_.league_results_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_team_name(from._internal_team_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_team_logo_url(from._internal_team_logo_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_team_abbreviation(from._internal_team_abbreviation());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_logo_ = from._impl_.team_logo_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.total_points_ = from._impl_.total_points_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.total_earnings_ = from._impl_.total_earnings_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCSeasonResults_TeamResult::CopyFrom(const CMsgDOTADPCSeasonResults_TeamResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCSeasonResults.TeamResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCSeasonResults_TeamResult::IsInitialized() const {
  return true;
}

void CMsgDOTADPCSeasonResults_TeamResult::InternalSwap(CMsgDOTADPCSeasonResults_TeamResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.league_results_.InternalSwap(&other->_impl_.league_results_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_name_, lhs_arena,
      &other->_impl_.team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_logo_url_, lhs_arena,
      &other->_impl_.team_logo_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_abbreviation_, lhs_arena,
      &other->_impl_.team_abbreviation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTADPCSeasonResults_TeamResult, _impl_.total_earnings_)
      + sizeof(CMsgDOTADPCSeasonResults_TeamResult::_impl_.total_earnings_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTADPCSeasonResults_TeamResult, _impl_.team_logo_)>(
          reinterpret_cast<char*>(&_impl_.team_logo_),
          reinterpret_cast<char*>(&other->_impl_.team_logo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCSeasonResults_TeamResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[32]);
}

// ===================================================================

class CMsgDOTADPCSeasonResults_StandingEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTADPCSeasonResults_StandingEntry>()._impl_._has_bits_);
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_wins(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_losses(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_team_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team_abbreviation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDOTADPCSeasonResults_StandingEntry::CMsgDOTADPCSeasonResults_StandingEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCSeasonResults.StandingEntry)
}
CMsgDOTADPCSeasonResults_StandingEntry::CMsgDOTADPCSeasonResults_StandingEntry(const CMsgDOTADPCSeasonResults_StandingEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCSeasonResults_StandingEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_url_){}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_abbreviation_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.wins_){}
    , decltype(_impl_.losses_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.team_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_url()) {
    _this->_impl_.team_url_.Set(from._internal_team_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_name()) {
    _this->_impl_.team_name_.Set(from._internal_team_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_abbreviation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_abbreviation()) {
    _this->_impl_.team_abbreviation_.Set(from._internal_team_abbreviation(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.team_id_, &from._impl_.team_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.losses_) -
    reinterpret_cast<char*>(&_impl_.team_id_)) + sizeof(_impl_.losses_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCSeasonResults.StandingEntry)
}

inline void CMsgDOTADPCSeasonResults_StandingEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_url_){}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_abbreviation_){}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.wins_){0u}
    , decltype(_impl_.losses_){0u}
  };
  _impl_.team_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_abbreviation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTADPCSeasonResults_StandingEntry::~CMsgDOTADPCSeasonResults_StandingEntry() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCSeasonResults.StandingEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCSeasonResults_StandingEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.team_url_.Destroy();
  _impl_.team_name_.Destroy();
  _impl_.team_abbreviation_.Destroy();
}

void CMsgDOTADPCSeasonResults_StandingEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCSeasonResults_StandingEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCSeasonResults.StandingEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.team_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.team_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.team_abbreviation_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.team_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.losses_) -
        reinterpret_cast<char*>(&_impl_.team_id_)) + sizeof(_impl_.losses_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCSeasonResults_StandingEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 team_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 wins = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_wins(&has_bits);
          _impl_.wins_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 losses = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_losses(&has_bits);
          _impl_.losses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_team_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTADPCSeasonResults.StandingEntry.team_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string team_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTADPCSeasonResults.StandingEntry.team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string team_abbreviation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_team_abbreviation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTADPCSeasonResults.StandingEntry.team_abbreviation");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCSeasonResults_StandingEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCSeasonResults.StandingEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 team_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_team_id(), target);
  }

  // optional uint32 wins = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_wins(), target);
  }

  // optional uint32 losses = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_losses(), target);
  }

  // optional string team_url = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_url().data(), static_cast<int>(this->_internal_team_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTADPCSeasonResults.StandingEntry.team_url");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_team_url(), target);
  }

  // optional string team_name = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_name().data(), static_cast<int>(this->_internal_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTADPCSeasonResults.StandingEntry.team_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_team_name(), target);
  }

  // optional string team_abbreviation = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_abbreviation().data(), static_cast<int>(this->_internal_team_abbreviation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTADPCSeasonResults.StandingEntry.team_abbreviation");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_team_abbreviation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCSeasonResults.StandingEntry)
  return target;
}

size_t CMsgDOTADPCSeasonResults_StandingEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCSeasonResults.StandingEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string team_url = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_url());
    }

    // optional string team_name = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_name());
    }

    // optional string team_abbreviation = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_abbreviation());
    }

    // optional uint32 team_id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint32 wins = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_wins());
    }

    // optional uint32 losses = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_losses());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCSeasonResults_StandingEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCSeasonResults_StandingEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCSeasonResults_StandingEntry::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCSeasonResults_StandingEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCSeasonResults_StandingEntry*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCSeasonResults_StandingEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCSeasonResults.StandingEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_team_url(from._internal_team_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_team_name(from._internal_team_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_team_abbreviation(from._internal_team_abbreviation());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.wins_ = from._impl_.wins_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.losses_ = from._impl_.losses_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCSeasonResults_StandingEntry::CopyFrom(const CMsgDOTADPCSeasonResults_StandingEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCSeasonResults.StandingEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCSeasonResults_StandingEntry::IsInitialized() const {
  return true;
}

void CMsgDOTADPCSeasonResults_StandingEntry::InternalSwap(CMsgDOTADPCSeasonResults_StandingEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_url_, lhs_arena,
      &other->_impl_.team_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_name_, lhs_arena,
      &other->_impl_.team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_abbreviation_, lhs_arena,
      &other->_impl_.team_abbreviation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTADPCSeasonResults_StandingEntry, _impl_.losses_)
      + sizeof(CMsgDOTADPCSeasonResults_StandingEntry::_impl_.losses_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTADPCSeasonResults_StandingEntry, _impl_.team_id_)>(
          reinterpret_cast<char*>(&_impl_.team_id_),
          reinterpret_cast<char*>(&other->_impl_.team_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCSeasonResults_StandingEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[33]);
}

// ===================================================================

class CMsgDOTADPCSeasonResults_Standing::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTADPCSeasonResults_Standing>()._impl_._has_bits_);
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_division(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTADPCSeasonResults_Standing::CMsgDOTADPCSeasonResults_Standing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCSeasonResults.Standing)
}
CMsgDOTADPCSeasonResults_Standing::CMsgDOTADPCSeasonResults_Standing(const CMsgDOTADPCSeasonResults_Standing& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCSeasonResults_Standing* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entries_){from._impl_.entries_}
    , decltype(_impl_.region_){}
    , decltype(_impl_.division_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.region_, &from._impl_.region_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.division_) -
    reinterpret_cast<char*>(&_impl_.region_)) + sizeof(_impl_.division_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCSeasonResults.Standing)
}

inline void CMsgDOTADPCSeasonResults_Standing::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entries_){arena}
    , decltype(_impl_.region_){0}
    , decltype(_impl_.division_){0}
  };
}

CMsgDOTADPCSeasonResults_Standing::~CMsgDOTADPCSeasonResults_Standing() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCSeasonResults.Standing)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCSeasonResults_Standing::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
}

void CMsgDOTADPCSeasonResults_Standing::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCSeasonResults_Standing::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCSeasonResults.Standing)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.region_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.division_) -
        reinterpret_cast<char*>(&_impl_.region_)) + sizeof(_impl_.division_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCSeasonResults_Standing::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ELeagueRegion region = 1 [default = LEAGUE_REGION_UNSET];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueRegion_IsValid(val))) {
            _internal_set_region(static_cast<::ELeagueRegion>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueDivision division = 2 [default = LEAGUE_DIVISION_UNSET];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueDivision_IsValid(val))) {
            _internal_set_division(static_cast<::ELeagueDivision>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTADPCSeasonResults.StandingEntry entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCSeasonResults_Standing::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCSeasonResults.Standing)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .ELeagueRegion region = 1 [default = LEAGUE_REGION_UNSET];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_region(), target);
  }

  // optional .ELeagueDivision division = 2 [default = LEAGUE_DIVISION_UNSET];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_division(), target);
  }

  // repeated .CMsgDOTADPCSeasonResults.StandingEntry entries = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCSeasonResults.Standing)
  return target;
}

size_t CMsgDOTADPCSeasonResults_Standing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCSeasonResults.Standing)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTADPCSeasonResults.StandingEntry entries = 3;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ELeagueRegion region = 1 [default = LEAGUE_REGION_UNSET];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_region());
    }

    // optional .ELeagueDivision division = 2 [default = LEAGUE_DIVISION_UNSET];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_division());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCSeasonResults_Standing::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCSeasonResults_Standing::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCSeasonResults_Standing::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCSeasonResults_Standing::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCSeasonResults_Standing*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCSeasonResults_Standing&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCSeasonResults.Standing)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.region_ = from._impl_.region_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.division_ = from._impl_.division_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCSeasonResults_Standing::CopyFrom(const CMsgDOTADPCSeasonResults_Standing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCSeasonResults.Standing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCSeasonResults_Standing::IsInitialized() const {
  return true;
}

void CMsgDOTADPCSeasonResults_Standing::InternalSwap(CMsgDOTADPCSeasonResults_Standing* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTADPCSeasonResults_Standing, _impl_.division_)
      + sizeof(CMsgDOTADPCSeasonResults_Standing::_impl_.division_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTADPCSeasonResults_Standing, _impl_.region_)>(
          reinterpret_cast<char*>(&_impl_.region_),
          reinterpret_cast<char*>(&other->_impl_.region_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCSeasonResults_Standing::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[34]);
}

// ===================================================================

class CMsgDOTADPCSeasonResults::_Internal {
 public:
};

CMsgDOTADPCSeasonResults::CMsgDOTADPCSeasonResults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCSeasonResults)
}
CMsgDOTADPCSeasonResults::CMsgDOTADPCSeasonResults(const CMsgDOTADPCSeasonResults& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCSeasonResults* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.results_){from._impl_.results_}
    , decltype(_impl_.standings_){from._impl_.standings_}
    , decltype(_impl_.major_wildcard_standings_){from._impl_.major_wildcard_standings_}
    , decltype(_impl_.major_group_standings_){from._impl_.major_group_standings_}
    , decltype(_impl_.major_playoff_standings_){from._impl_.major_playoff_standings_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCSeasonResults)
}

inline void CMsgDOTADPCSeasonResults::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.results_){arena}
    , decltype(_impl_.standings_){arena}
    , decltype(_impl_.major_wildcard_standings_){arena}
    , decltype(_impl_.major_group_standings_){arena}
    , decltype(_impl_.major_playoff_standings_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTADPCSeasonResults::~CMsgDOTADPCSeasonResults() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCSeasonResults)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCSeasonResults::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.results_.~RepeatedPtrField();
  _impl_.standings_.~RepeatedPtrField();
  _impl_.major_wildcard_standings_.~RepeatedPtrField();
  _impl_.major_group_standings_.~RepeatedPtrField();
  _impl_.major_playoff_standings_.~RepeatedPtrField();
}

void CMsgDOTADPCSeasonResults::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCSeasonResults::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCSeasonResults)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.results_.Clear();
  _impl_.standings_.Clear();
  _impl_.major_wildcard_standings_.Clear();
  _impl_.major_group_standings_.Clear();
  _impl_.major_playoff_standings_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCSeasonResults::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTADPCSeasonResults.TeamResult results = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_results(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTADPCSeasonResults.Standing standings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_standings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTADPCSeasonResults.StandingEntry major_wildcard_standings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_major_wildcard_standings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTADPCSeasonResults.StandingEntry major_group_standings = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_major_group_standings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTADPCSeasonResults.StandingEntry major_playoff_standings = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_major_playoff_standings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCSeasonResults::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCSeasonResults)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTADPCSeasonResults.TeamResult results = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_results_size()); i < n; i++) {
    const auto& repfield = this->_internal_results(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTADPCSeasonResults.Standing standings = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_standings_size()); i < n; i++) {
    const auto& repfield = this->_internal_standings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTADPCSeasonResults.StandingEntry major_wildcard_standings = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_major_wildcard_standings_size()); i < n; i++) {
    const auto& repfield = this->_internal_major_wildcard_standings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTADPCSeasonResults.StandingEntry major_group_standings = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_major_group_standings_size()); i < n; i++) {
    const auto& repfield = this->_internal_major_group_standings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTADPCSeasonResults.StandingEntry major_playoff_standings = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_major_playoff_standings_size()); i < n; i++) {
    const auto& repfield = this->_internal_major_playoff_standings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCSeasonResults)
  return target;
}

size_t CMsgDOTADPCSeasonResults::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCSeasonResults)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTADPCSeasonResults.TeamResult results = 1;
  total_size += 1UL * this->_internal_results_size();
  for (const auto& msg : this->_impl_.results_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTADPCSeasonResults.Standing standings = 2;
  total_size += 1UL * this->_internal_standings_size();
  for (const auto& msg : this->_impl_.standings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTADPCSeasonResults.StandingEntry major_wildcard_standings = 3;
  total_size += 1UL * this->_internal_major_wildcard_standings_size();
  for (const auto& msg : this->_impl_.major_wildcard_standings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTADPCSeasonResults.StandingEntry major_group_standings = 4;
  total_size += 1UL * this->_internal_major_group_standings_size();
  for (const auto& msg : this->_impl_.major_group_standings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTADPCSeasonResults.StandingEntry major_playoff_standings = 5;
  total_size += 1UL * this->_internal_major_playoff_standings_size();
  for (const auto& msg : this->_impl_.major_playoff_standings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCSeasonResults::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCSeasonResults::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCSeasonResults::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCSeasonResults::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCSeasonResults*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCSeasonResults&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCSeasonResults)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.results_.MergeFrom(from._impl_.results_);
  _this->_impl_.standings_.MergeFrom(from._impl_.standings_);
  _this->_impl_.major_wildcard_standings_.MergeFrom(from._impl_.major_wildcard_standings_);
  _this->_impl_.major_group_standings_.MergeFrom(from._impl_.major_group_standings_);
  _this->_impl_.major_playoff_standings_.MergeFrom(from._impl_.major_playoff_standings_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCSeasonResults::CopyFrom(const CMsgDOTADPCSeasonResults& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCSeasonResults)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCSeasonResults::IsInitialized() const {
  return true;
}

void CMsgDOTADPCSeasonResults::InternalSwap(CMsgDOTADPCSeasonResults* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.results_.InternalSwap(&other->_impl_.results_);
  _impl_.standings_.InternalSwap(&other->_impl_.standings_);
  _impl_.major_wildcard_standings_.InternalSwap(&other->_impl_.major_wildcard_standings_);
  _impl_.major_group_standings_.InternalSwap(&other->_impl_.major_group_standings_);
  _impl_.major_playoff_standings_.InternalSwap(&other->_impl_.major_playoff_standings_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCSeasonResults::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[35]);
}

// ===================================================================

class CMsgDOTADPCSeasonSpoilerResults::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTADPCSeasonSpoilerResults>()._impl_._has_bits_);
  static void set_has_time_last_updated(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgDOTADPCSeasonResults& saved_results(const CMsgDOTADPCSeasonSpoilerResults* msg);
  static void set_has_saved_results(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgDOTADPCSeasonResults&
CMsgDOTADPCSeasonSpoilerResults::_Internal::saved_results(const CMsgDOTADPCSeasonSpoilerResults* msg) {
  return *msg->_impl_.saved_results_;
}
CMsgDOTADPCSeasonSpoilerResults::CMsgDOTADPCSeasonSpoilerResults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCSeasonSpoilerResults)
}
CMsgDOTADPCSeasonSpoilerResults::CMsgDOTADPCSeasonSpoilerResults(const CMsgDOTADPCSeasonSpoilerResults& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCSeasonSpoilerResults* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.saved_results_){nullptr}
    , decltype(_impl_.time_last_updated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_saved_results()) {
    _this->_impl_.saved_results_ = new ::CMsgDOTADPCSeasonResults(*from._impl_.saved_results_);
  }
  _this->_impl_.time_last_updated_ = from._impl_.time_last_updated_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCSeasonSpoilerResults)
}

inline void CMsgDOTADPCSeasonSpoilerResults::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.saved_results_){nullptr}
    , decltype(_impl_.time_last_updated_){0u}
  };
}

CMsgDOTADPCSeasonSpoilerResults::~CMsgDOTADPCSeasonSpoilerResults() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCSeasonSpoilerResults)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCSeasonSpoilerResults::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.saved_results_;
}

void CMsgDOTADPCSeasonSpoilerResults::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCSeasonSpoilerResults::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCSeasonSpoilerResults)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.saved_results_ != nullptr);
    _impl_.saved_results_->Clear();
  }
  _impl_.time_last_updated_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCSeasonSpoilerResults::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 time_last_updated = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_time_last_updated(&has_bits);
          _impl_.time_last_updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTADPCSeasonResults saved_results = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_saved_results(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCSeasonSpoilerResults::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCSeasonSpoilerResults)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 time_last_updated = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_time_last_updated(), target);
  }

  // optional .CMsgDOTADPCSeasonResults saved_results = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::saved_results(this),
        _Internal::saved_results(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCSeasonSpoilerResults)
  return target;
}

size_t CMsgDOTADPCSeasonSpoilerResults::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCSeasonSpoilerResults)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgDOTADPCSeasonResults saved_results = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.saved_results_);
    }

    // optional uint32 time_last_updated = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time_last_updated());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCSeasonSpoilerResults::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCSeasonSpoilerResults::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCSeasonSpoilerResults::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCSeasonSpoilerResults::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCSeasonSpoilerResults*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCSeasonSpoilerResults&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCSeasonSpoilerResults)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_saved_results()->::CMsgDOTADPCSeasonResults::MergeFrom(
          from._internal_saved_results());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.time_last_updated_ = from._impl_.time_last_updated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCSeasonSpoilerResults::CopyFrom(const CMsgDOTADPCSeasonSpoilerResults& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCSeasonSpoilerResults)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCSeasonSpoilerResults::IsInitialized() const {
  return true;
}

void CMsgDOTADPCSeasonSpoilerResults::InternalSwap(CMsgDOTADPCSeasonSpoilerResults* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTADPCSeasonSpoilerResults, _impl_.time_last_updated_)
      + sizeof(CMsgDOTADPCSeasonSpoilerResults::_impl_.time_last_updated_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTADPCSeasonSpoilerResults, _impl_.saved_results_)>(
          reinterpret_cast<char*>(&_impl_.saved_results_),
          reinterpret_cast<char*>(&other->_impl_.saved_results_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCSeasonSpoilerResults::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5fleague_2eproto[36]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueNode_MatchDetails*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueNode_MatchDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueNode_MatchDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueNode_VOD*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueNode_VOD >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueNode_VOD >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueNode*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueNode >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueNodeGroup_TeamStanding*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueNodeGroup_TeamStanding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueNodeGroup_TeamStanding >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueNodeGroup*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueNodeGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueNodeGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeague_Info*
Arena::CreateMaybeMessage< ::CMsgDOTALeague_Info >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeague_Info >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeague_Admin*
Arena::CreateMaybeMessage< ::CMsgDOTALeague_Admin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeague_Admin >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeague_PrizePoolItem*
Arena::CreateMaybeMessage< ::CMsgDOTALeague_PrizePoolItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeague_PrizePoolItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeague_PrizePool*
Arena::CreateMaybeMessage< ::CMsgDOTALeague_PrizePool >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeague_PrizePool >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeague_Stream*
Arena::CreateMaybeMessage< ::CMsgDOTALeague_Stream >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeague_Stream >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeague_SeriesInfo*
Arena::CreateMaybeMessage< ::CMsgDOTALeague_SeriesInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeague_SeriesInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeague_Player*
Arena::CreateMaybeMessage< ::CMsgDOTALeague_Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeague_Player >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeague*
Arena::CreateMaybeMessage< ::CMsgDOTALeague >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeague >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueList*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueInfo*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueInfoList*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueInfoList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueInfoList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueLiveGames_LiveGame*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueLiveGames_LiveGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueLiveGames_LiveGame >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueLiveGames*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueLiveGames >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueLiveGames >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueMessages_Message*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueMessages_Message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueMessages_Message >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueMessages*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueMessages >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueMessages >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeaguePrizePool*
Arena::CreateMaybeMessage< ::CMsgDOTALeaguePrizePool >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeaguePrizePool >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueInfoListAdminsRequest*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueInfoListAdminsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueInfoListAdminsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueAvailableLobbyNodesRequest*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueAvailableLobbyNodesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueAvailableLobbyNodesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueAvailableLobbyNodes*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueAvailableLobbyNodes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueAvailableLobbyNodes >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueNodeResults_Result*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueNodeResults_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueNodeResults_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTALeagueNodeResults*
Arena::CreateMaybeMessage< ::CMsgDOTALeagueNodeResults >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTALeagueNodeResults >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCLeagueResults_Result*
Arena::CreateMaybeMessage< ::CMsgDOTADPCLeagueResults_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCLeagueResults_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCLeagueResults*
Arena::CreateMaybeMessage< ::CMsgDOTADPCLeagueResults >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCLeagueResults >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCTeamResults_Result*
Arena::CreateMaybeMessage< ::CMsgDOTADPCTeamResults_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCTeamResults_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCTeamResults*
Arena::CreateMaybeMessage< ::CMsgDOTADPCTeamResults >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCTeamResults >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCSeasonResults_TeamLeagueResult*
Arena::CreateMaybeMessage< ::CMsgDOTADPCSeasonResults_TeamLeagueResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCSeasonResults_TeamLeagueResult >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCSeasonResults_TeamResult*
Arena::CreateMaybeMessage< ::CMsgDOTADPCSeasonResults_TeamResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCSeasonResults_TeamResult >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCSeasonResults_StandingEntry*
Arena::CreateMaybeMessage< ::CMsgDOTADPCSeasonResults_StandingEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCSeasonResults_StandingEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCSeasonResults_Standing*
Arena::CreateMaybeMessage< ::CMsgDOTADPCSeasonResults_Standing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCSeasonResults_Standing >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCSeasonResults*
Arena::CreateMaybeMessage< ::CMsgDOTADPCSeasonResults >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCSeasonResults >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCSeasonSpoilerResults*
Arena::CreateMaybeMessage< ::CMsgDOTADPCSeasonSpoilerResults >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCSeasonSpoilerResults >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
