// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_webapi.proto

#include "dota_gcmessages_webapi.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CMsgArcanaVotes_Match::CMsgArcanaVotes_Match(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_id_)*/0u
  , /*decltype(_impl_.hero_id_0_)*/0u
  , /*decltype(_impl_.hero_id_1_)*/0u
  , /*decltype(_impl_.hero_seeding_0_)*/0u
  , /*decltype(_impl_.hero_seeding_1_)*/0u
  , /*decltype(_impl_.vote_count_0_)*/0u
  , /*decltype(_impl_.vote_count_1_)*/0u
  , /*decltype(_impl_.voting_state_)*/0u
  , /*decltype(_impl_.round_number_)*/0u
  , /*decltype(_impl_.is_votes_hidden_)*/false
  , /*decltype(_impl_.calibration_time_remaining_)*/0u} {}
struct CMsgArcanaVotes_MatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgArcanaVotes_MatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgArcanaVotes_MatchDefaultTypeInternal() {}
  union {
    CMsgArcanaVotes_Match _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgArcanaVotes_MatchDefaultTypeInternal _CMsgArcanaVotes_Match_default_instance_;
PROTOBUF_CONSTEXPR CMsgArcanaVotes::CMsgArcanaVotes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.matches_)*/{}
  , /*decltype(_impl_.round_time_remaining_)*/0u
  , /*decltype(_impl_.round_number_)*/0u
  , /*decltype(_impl_.voting_state_)*/0u
  , /*decltype(_impl_.is_current_round_calibrating_)*/false
  , /*decltype(_impl_.closest_active_match_id_)*/0u
  , /*decltype(_impl_.event_id_)*/0u
  , /*decltype(_impl_.voting_start_time_)*/0u} {}
struct CMsgArcanaVotesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgArcanaVotesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgArcanaVotesDefaultTypeInternal() {}
  union {
    CMsgArcanaVotes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgArcanaVotesDefaultTypeInternal _CMsgArcanaVotes_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCFeed_Element::CMsgDOTADPCFeed_Element(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/0u
  , /*decltype(_impl_.series_id_)*/0u
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.node_id_)*/0u
  , /*decltype(_impl_.data_1_)*/0u
  , /*decltype(_impl_.data_2_)*/0u
  , /*decltype(_impl_.data_3_)*/0u
  , /*decltype(_impl_.data_4_)*/0u
  , /*decltype(_impl_.server_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/1} {}
struct CMsgDOTADPCFeed_ElementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCFeed_ElementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCFeed_ElementDefaultTypeInternal() {}
  union {
    CMsgDOTADPCFeed_Element _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCFeed_ElementDefaultTypeInternal _CMsgDOTADPCFeed_Element_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCFeed::CMsgDOTADPCFeed(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.elements_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTADPCFeedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCFeedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCFeedDefaultTypeInternal() {}
  union {
    CMsgDOTADPCFeed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCFeedDefaultTypeInternal _CMsgDOTADPCFeed_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCUserInfo::CMsgDOTADPCUserInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.is_plus_subscriber_)*/false} {}
struct CMsgDOTADPCUserInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCUserInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCUserInfoDefaultTypeInternal() {}
  union {
    CMsgDOTADPCUserInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCUserInfoDefaultTypeInternal _CMsgDOTADPCUserInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgDraftTrivia_DraftTriviaHeroInfo::CMsgDraftTrivia_DraftTriviaHeroInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.role_)*/0u} {}
struct CMsgDraftTrivia_DraftTriviaHeroInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDraftTrivia_DraftTriviaHeroInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDraftTrivia_DraftTriviaHeroInfoDefaultTypeInternal() {}
  union {
    CMsgDraftTrivia_DraftTriviaHeroInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDraftTrivia_DraftTriviaHeroInfoDefaultTypeInternal _CMsgDraftTrivia_DraftTriviaHeroInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgDraftTrivia_DraftTriviaMatchInfo::CMsgDraftTrivia_DraftTriviaMatchInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.radiant_heroes_)*/{}
  , /*decltype(_impl_.dire_heroes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDraftTrivia_DraftTriviaMatchInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDraftTrivia_DraftTriviaMatchInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDraftTrivia_DraftTriviaMatchInfoDefaultTypeInternal() {}
  union {
    CMsgDraftTrivia_DraftTriviaMatchInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDraftTrivia_DraftTriviaMatchInfoDefaultTypeInternal _CMsgDraftTrivia_DraftTriviaMatchInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgDraftTrivia_PreviousResult::CMsgDraftTrivia_PreviousResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_hero_info_)*/nullptr
  , /*decltype(_impl_.voted_correctly_)*/false
  , /*decltype(_impl_.voted_radiant_)*/false
  , /*decltype(_impl_.match_rank_tier_)*/0u
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.end_time_)*/0u} {}
struct CMsgDraftTrivia_PreviousResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDraftTrivia_PreviousResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDraftTrivia_PreviousResultDefaultTypeInternal() {}
  union {
    CMsgDraftTrivia_PreviousResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDraftTrivia_PreviousResultDefaultTypeInternal _CMsgDraftTrivia_PreviousResult_default_instance_;
PROTOBUF_CONSTEXPR CMsgDraftTrivia::CMsgDraftTrivia(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_hero_info_)*/nullptr
  , /*decltype(_impl_.previous_result_)*/nullptr
  , /*decltype(_impl_.match_rank_tier_)*/0u
  , /*decltype(_impl_.has_valid_match_)*/false
  , /*decltype(_impl_.current_match_voted_radiant_)*/false
  , /*decltype(_impl_.end_time_)*/0u
  , /*decltype(_impl_.event_id_)*/0u
  , /*decltype(_impl_.current_streak_)*/0u} {}
struct CMsgDraftTriviaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDraftTriviaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDraftTriviaDefaultTypeInternal() {}
  union {
    CMsgDraftTrivia _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDraftTriviaDefaultTypeInternal _CMsgDraftTrivia_default_instance_;
PROTOBUF_CONSTEXPR CMsgTeamFanContentAssetStatus::CMsgTeamFanContentAssetStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.asset_index_)*/0u
  , /*decltype(_impl_.asset_status_)*/0
  , /*decltype(_impl_.crc_)*/0u
  , /*decltype(_impl_.asset_type_)*/1} {}
struct CMsgTeamFanContentAssetStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTeamFanContentAssetStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTeamFanContentAssetStatusDefaultTypeInternal() {}
  union {
    CMsgTeamFanContentAssetStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTeamFanContentAssetStatusDefaultTypeInternal _CMsgTeamFanContentAssetStatus_default_instance_;
PROTOBUF_CONSTEXPR CMsgTeamFanContentAssetStatusResponse::CMsgTeamFanContentAssetStatusResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct CMsgTeamFanContentAssetStatusResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTeamFanContentAssetStatusResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTeamFanContentAssetStatusResponseDefaultTypeInternal() {}
  union {
    CMsgTeamFanContentAssetStatusResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTeamFanContentAssetStatusResponseDefaultTypeInternal _CMsgTeamFanContentAssetStatusResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgTeamFanContentStatus_TeamStatus::CMsgTeamFanContentStatus_TeamStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.asset_status_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.logo_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.abbreviation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.languages_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.timestamp_)*/0u
  , /*decltype(_impl_.workshop_account_id_)*/0u
  , /*decltype(_impl_.ugc_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.voiceline_count_)*/0u
  , /*decltype(_impl_.spray_count_)*/0u
  , /*decltype(_impl_.emoticon_count_)*/0u
  , /*decltype(_impl_.wallpaper_count_)*/0u
  , /*decltype(_impl_.comment_timestamp_)*/0u
  , /*decltype(_impl_.email_timestamp_)*/0u
  , /*decltype(_impl_.email_tier_)*/0u} {}
struct CMsgTeamFanContentStatus_TeamStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTeamFanContentStatus_TeamStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTeamFanContentStatus_TeamStatusDefaultTypeInternal() {}
  union {
    CMsgTeamFanContentStatus_TeamStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTeamFanContentStatus_TeamStatusDefaultTypeInternal _CMsgTeamFanContentStatus_TeamStatus_default_instance_;
PROTOBUF_CONSTEXPR CMsgTeamFanContentStatus::CMsgTeamFanContentStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.team_status_list_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgTeamFanContentStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTeamFanContentStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTeamFanContentStatusDefaultTypeInternal() {}
  union {
    CMsgTeamFanContentStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTeamFanContentStatusDefaultTypeInternal _CMsgTeamFanContentStatus_default_instance_;
PROTOBUF_CONSTEXPR CMsgTeamFanContentAutographStatus_AutographStatus::CMsgTeamFanContentAutographStatus_AutographStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pro_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.timestamp_)*/0u} {}
struct CMsgTeamFanContentAutographStatus_AutographStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTeamFanContentAutographStatus_AutographStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTeamFanContentAutographStatus_AutographStatusDefaultTypeInternal() {}
  union {
    CMsgTeamFanContentAutographStatus_AutographStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTeamFanContentAutographStatus_AutographStatusDefaultTypeInternal _CMsgTeamFanContentAutographStatus_AutographStatus_default_instance_;
PROTOBUF_CONSTEXPR CMsgTeamFanContentAutographStatus_TeamStatus::CMsgTeamFanContentAutographStatus_TeamStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.autographs_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.workshop_account_id_)*/0u} {}
struct CMsgTeamFanContentAutographStatus_TeamStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTeamFanContentAutographStatus_TeamStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTeamFanContentAutographStatus_TeamStatusDefaultTypeInternal() {}
  union {
    CMsgTeamFanContentAutographStatus_TeamStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTeamFanContentAutographStatus_TeamStatusDefaultTypeInternal _CMsgTeamFanContentAutographStatus_TeamStatus_default_instance_;
PROTOBUF_CONSTEXPR CMsgTeamFanContentAutographStatus::CMsgTeamFanContentAutographStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.team_autographs_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgTeamFanContentAutographStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTeamFanContentAutographStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTeamFanContentAutographStatusDefaultTypeInternal() {}
  union {
    CMsgTeamFanContentAutographStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTeamFanContentAutographStatusDefaultTypeInternal _CMsgTeamFanContentAutographStatus_default_instance_;
PROTOBUF_CONSTEXPR CMsgDPCEvent_PhaseInfo::CMsgDPCEvent_PhaseInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.phase_)*/0
  , /*decltype(_impl_.node_group_id_)*/0u} {}
struct CMsgDPCEvent_PhaseInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDPCEvent_PhaseInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDPCEvent_PhaseInfoDefaultTypeInternal() {}
  union {
    CMsgDPCEvent_PhaseInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDPCEvent_PhaseInfoDefaultTypeInternal _CMsgDPCEvent_PhaseInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgDPCEvent_League::CMsgDPCEvent_League(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.phases_)*/{}
  , /*decltype(_impl_.region_)*/0
  , /*decltype(_impl_.division_)*/0
  , /*decltype(_impl_.league_id_)*/0u} {}
struct CMsgDPCEvent_LeagueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDPCEvent_LeagueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDPCEvent_LeagueDefaultTypeInternal() {}
  union {
    CMsgDPCEvent_League _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDPCEvent_LeagueDefaultTypeInternal _CMsgDPCEvent_League_default_instance_;
PROTOBUF_CONSTEXPR CMsgDPCEvent::CMsgDPCEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.leagues_)*/{}
  , /*decltype(_impl_.multicast_streams_)*/{}
  , /*decltype(_impl_.event_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.event_)*/0
  , /*decltype(_impl_.event_type_)*/0
  , /*decltype(_impl_.registration_period_)*/0u
  , /*decltype(_impl_.multicast_league_id_)*/0u
  , /*decltype(_impl_.is_event_upcoming_)*/false
  , /*decltype(_impl_.is_event_completed_)*/false
  , /*decltype(_impl_.is_fantasy_enabled_)*/false
  , /*decltype(_impl_.tour_)*/0
  , /*decltype(_impl_.timestamp_drop_lock_)*/0u
  , /*decltype(_impl_.timestamp_add_lock_)*/0u
  , /*decltype(_impl_.timestamp_content_deadline_)*/0u} {}
struct CMsgDPCEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDPCEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDPCEventDefaultTypeInternal() {}
  union {
    CMsgDPCEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDPCEventDefaultTypeInternal _CMsgDPCEvent_default_instance_;
PROTOBUF_CONSTEXPR CMsgDPCEventList::CMsgDPCEventList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.events_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDPCEventListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDPCEventListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDPCEventListDefaultTypeInternal() {}
  union {
    CMsgDPCEventList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDPCEventListDefaultTypeInternal _CMsgDPCEventList_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardLineup_CardBonus::CMsgDOTAFantasyCardLineup_CardBonus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bonus_stat_)*/0u
  , /*decltype(_impl_.bonus_value_)*/0u} {}
struct CMsgDOTAFantasyCardLineup_CardBonusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardLineup_CardBonusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAFantasyCardLineup_CardBonusDefaultTypeInternal() {}
  union {
    CMsgDOTAFantasyCardLineup_CardBonus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAFantasyCardLineup_CardBonusDefaultTypeInternal _CMsgDOTAFantasyCardLineup_CardBonus_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardLineup_Card::CMsgDOTAFantasyCardLineup_Card(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bonuses_)*/{}
  , /*decltype(_impl_.player_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.player_account_id_)*/0u
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.role_)*/0u
  , /*decltype(_impl_.score_)*/0
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.finalized_)*/false} {}
struct CMsgDOTAFantasyCardLineup_CardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardLineup_CardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAFantasyCardLineup_CardDefaultTypeInternal() {}
  union {
    CMsgDOTAFantasyCardLineup_Card _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAFantasyCardLineup_CardDefaultTypeInternal _CMsgDOTAFantasyCardLineup_Card_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardLineup_League::CMsgDOTAFantasyCardLineup_League(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cards_)*/{}
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.score_)*/0} {}
struct CMsgDOTAFantasyCardLineup_LeagueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardLineup_LeagueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAFantasyCardLineup_LeagueDefaultTypeInternal() {}
  union {
    CMsgDOTAFantasyCardLineup_League _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAFantasyCardLineup_LeagueDefaultTypeInternal _CMsgDOTAFantasyCardLineup_League_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardLineup_Period::CMsgDOTAFantasyCardLineup_Period(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.leagues_)*/{}
  , /*decltype(_impl_.timestamp_start_)*/0u
  , /*decltype(_impl_.timestamp_end_)*/0u
  , /*decltype(_impl_.fantasy_period_)*/4294967295u} {}
struct CMsgDOTAFantasyCardLineup_PeriodDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardLineup_PeriodDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAFantasyCardLineup_PeriodDefaultTypeInternal() {}
  union {
    CMsgDOTAFantasyCardLineup_Period _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAFantasyCardLineup_PeriodDefaultTypeInternal _CMsgDOTAFantasyCardLineup_Period_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardLineup::CMsgDOTAFantasyCardLineup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.periods_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTAFantasyCardLineupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardLineupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAFantasyCardLineupDefaultTypeInternal() {}
  union {
    CMsgDOTAFantasyCardLineup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAFantasyCardLineupDefaultTypeInternal _CMsgDOTAFantasyCardLineup_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardList_CardBonus::CMsgDOTAFantasyCardList_CardBonus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bonus_stat_)*/0u
  , /*decltype(_impl_.bonus_value_)*/0u} {}
struct CMsgDOTAFantasyCardList_CardBonusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardList_CardBonusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAFantasyCardList_CardBonusDefaultTypeInternal() {}
  union {
    CMsgDOTAFantasyCardList_CardBonus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAFantasyCardList_CardBonusDefaultTypeInternal _CMsgDOTAFantasyCardList_CardBonus_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardList_Card::CMsgDOTAFantasyCardList_Card(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bonuses_)*/{}
  , /*decltype(_impl_.player_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.player_account_id_)*/0u
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.role_)*/0u} {}
struct CMsgDOTAFantasyCardList_CardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardList_CardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAFantasyCardList_CardDefaultTypeInternal() {}
  union {
    CMsgDOTAFantasyCardList_Card _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAFantasyCardList_CardDefaultTypeInternal _CMsgDOTAFantasyCardList_Card_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardList::CMsgDOTAFantasyCardList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cards_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTAFantasyCardListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAFantasyCardListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAFantasyCardListDefaultTypeInternal() {}
  union {
    CMsgDOTAFantasyCardList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAFantasyCardListDefaultTypeInternal _CMsgDOTAFantasyCardList_default_instance_;
PROTOBUF_CONSTEXPR CMsgChatToxicityReport::CMsgChatToxicityReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.num_matches_seen_)*/0u
  , /*decltype(_impl_.num_messages_)*/0u
  , /*decltype(_impl_.num_messages_human_thinks_toxic_)*/0u
  , /*decltype(_impl_.num_messages_ml_thinks_toxic_)*/0u
  , /*decltype(_impl_.result_)*/0u} {}
struct CMsgChatToxicityReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgChatToxicityReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgChatToxicityReportDefaultTypeInternal() {}
  union {
    CMsgChatToxicityReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgChatToxicityReportDefaultTypeInternal _CMsgChatToxicityReport_default_instance_;
PROTOBUF_CONSTEXPR CMsgGetTeamAuditInformation_Action::CMsgGetTeamAuditInformation_Action(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.player_real_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.registration_period_)*/0u
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.action_)*/0u
  , /*decltype(_impl_.timestamp_)*/0u} {}
struct CMsgGetTeamAuditInformation_ActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGetTeamAuditInformation_ActionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGetTeamAuditInformation_ActionDefaultTypeInternal() {}
  union {
    CMsgGetTeamAuditInformation_Action _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGetTeamAuditInformation_ActionDefaultTypeInternal _CMsgGetTeamAuditInformation_Action_default_instance_;
PROTOBUF_CONSTEXPR CMsgGetTeamAuditInformation::CMsgGetTeamAuditInformation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.actions_)*/{}
  , /*decltype(_impl_.team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.last_updated_)*/0u} {}
struct CMsgGetTeamAuditInformationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGetTeamAuditInformationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGetTeamAuditInformationDefaultTypeInternal() {}
  union {
    CMsgGetTeamAuditInformation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGetTeamAuditInformationDefaultTypeInternal _CMsgGetTeamAuditInformation_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTADPCMatch::CMsgDOTADPCMatch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_)*/nullptr
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct CMsgDOTADPCMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTADPCMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTADPCMatchDefaultTypeInternal() {}
  union {
    CMsgDOTADPCMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTADPCMatchDefaultTypeInternal _CMsgDOTADPCMatch_default_instance_;
static ::_pb::Metadata file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[32];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_dota_5fgcmessages_5fwebapi_2eproto[10];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_dota_5fgcmessages_5fwebapi_2eproto = nullptr;

const uint32_t TableStruct_dota_5fgcmessages_5fwebapi_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _impl_.hero_id_0_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _impl_.hero_id_1_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _impl_.hero_seeding_0_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _impl_.hero_seeding_1_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _impl_.vote_count_0_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _impl_.vote_count_1_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _impl_.voting_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _impl_.round_number_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _impl_.is_votes_hidden_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes_Match, _impl_.calibration_time_remaining_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes, _impl_.matches_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes, _impl_.round_time_remaining_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes, _impl_.round_number_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes, _impl_.voting_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes, _impl_.is_current_round_calibrating_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes, _impl_.closest_active_match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes, _impl_.event_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVotes, _impl_.voting_start_time_),
  ~0u,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.series_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.server_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.data_1_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.data_2_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.data_3_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed_Element, _impl_.data_4_),
  12,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  11,
  7,
  8,
  9,
  10,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCFeed, _impl_.elements_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCUserInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCUserInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCUserInfo, _impl_.is_plus_subscriber_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_DraftTriviaHeroInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_DraftTriviaHeroInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_DraftTriviaHeroInfo, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_DraftTriviaHeroInfo, _impl_.role_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_DraftTriviaMatchInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_DraftTriviaMatchInfo, _impl_.radiant_heroes_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_DraftTriviaMatchInfo, _impl_.dire_heroes_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_PreviousResult, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_PreviousResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_PreviousResult, _impl_.voted_correctly_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_PreviousResult, _impl_.voted_radiant_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_PreviousResult, _impl_.match_hero_info_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_PreviousResult, _impl_.match_rank_tier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_PreviousResult, _impl_.end_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia_PreviousResult, _impl_.match_id_),
  1,
  2,
  0,
  3,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia, _impl_.has_valid_match_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia, _impl_.match_hero_info_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia, _impl_.match_rank_tier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia, _impl_.end_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia, _impl_.event_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia, _impl_.current_match_voted_radiant_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia, _impl_.previous_result_),
  PROTOBUF_FIELD_OFFSET(::CMsgDraftTrivia, _impl_.current_streak_),
  3,
  0,
  2,
  5,
  6,
  4,
  1,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAssetStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAssetStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAssetStatus, _impl_.asset_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAssetStatus, _impl_.asset_index_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAssetStatus, _impl_.asset_status_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAssetStatus, _impl_.crc_),
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAssetStatusResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAssetStatusResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAssetStatusResponse, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.logo_url_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.ugc_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.workshop_account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.abbreviation_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.voiceline_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.spray_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.emoticon_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.wallpaper_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.comment_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.comment_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.asset_status_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.email_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.email_tier_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus_TeamStatus, _impl_.languages_),
  0,
  5,
  1,
  6,
  7,
  9,
  8,
  2,
  10,
  11,
  12,
  13,
  3,
  14,
  ~0u,
  15,
  16,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentStatus, _impl_.team_status_list_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus_AutographStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus_AutographStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus_AutographStatus, _impl_.pro_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus_AutographStatus, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus_AutographStatus, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus_AutographStatus, _impl_.file_),
  0,
  2,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus_TeamStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus_TeamStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus_TeamStatus, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus_TeamStatus, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus_TeamStatus, _impl_.autographs_),
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus_TeamStatus, _impl_.workshop_account_id_),
  0,
  1,
  ~0u,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTeamFanContentAutographStatus, _impl_.team_autographs_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent_PhaseInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent_PhaseInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent_PhaseInfo, _impl_.phase_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent_PhaseInfo, _impl_.node_group_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent_League, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent_League, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent_League, _impl_.region_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent_League, _impl_.division_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent_League, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent_League, _impl_.phases_),
  0,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.event_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.event_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.leagues_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.registration_period_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.is_event_upcoming_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.is_event_completed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.event_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.multicast_league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.multicast_streams_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.tour_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.timestamp_drop_lock_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.timestamp_add_lock_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.timestamp_content_deadline_),
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEvent, _impl_.is_fantasy_enabled_),
  1,
  2,
  ~0u,
  3,
  5,
  6,
  0,
  4,
  ~0u,
  8,
  9,
  10,
  11,
  7,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEventList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDPCEventList, _impl_.events_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_CardBonus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_CardBonus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_CardBonus, _impl_.bonus_stat_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_CardBonus, _impl_.bonus_value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Card, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Card, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Card, _impl_.player_account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Card, _impl_.player_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Card, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Card, _impl_.team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Card, _impl_.role_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Card, _impl_.bonuses_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Card, _impl_.score_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Card, _impl_.finalized_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Card, _impl_.item_id_),
  2,
  0,
  3,
  1,
  4,
  ~0u,
  5,
  7,
  6,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_League, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_League, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_League, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_League, _impl_.cards_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_League, _impl_.score_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Period, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Period, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Period, _impl_.fantasy_period_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Period, _impl_.timestamp_start_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Period, _impl_.timestamp_end_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup_Period, _impl_.leagues_),
  2,
  0,
  1,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardLineup, _impl_.periods_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_CardBonus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_CardBonus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_CardBonus, _impl_.bonus_stat_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_CardBonus, _impl_.bonus_value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_Card, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_Card, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_Card, _impl_.player_account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_Card, _impl_.player_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_Card, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_Card, _impl_.team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_Card, _impl_.role_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_Card, _impl_.bonuses_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList_Card, _impl_.item_id_),
  2,
  0,
  3,
  1,
  5,
  ~0u,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyCardList, _impl_.cards_),
  PROTOBUF_FIELD_OFFSET(::CMsgChatToxicityReport, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgChatToxicityReport, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgChatToxicityReport, _impl_.num_matches_seen_),
  PROTOBUF_FIELD_OFFSET(::CMsgChatToxicityReport, _impl_.num_messages_),
  PROTOBUF_FIELD_OFFSET(::CMsgChatToxicityReport, _impl_.num_messages_human_thinks_toxic_),
  PROTOBUF_FIELD_OFFSET(::CMsgChatToxicityReport, _impl_.num_messages_ml_thinks_toxic_),
  PROTOBUF_FIELD_OFFSET(::CMsgChatToxicityReport, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::CMsgChatToxicityReport, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::CMsgChatToxicityReport, _impl_.message_),
  2,
  3,
  4,
  5,
  0,
  6,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation_Action, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation_Action, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation_Action, _impl_.registration_period_),
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation_Action, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation_Action, _impl_.action_),
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation_Action, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation_Action, _impl_.player_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation_Action, _impl_.player_real_name_),
  2,
  3,
  4,
  5,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation, _impl_.team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation, _impl_.actions_),
  PROTOBUF_FIELD_OFFSET(::CMsgGetTeamAuditInformation, _impl_.last_updated_),
  1,
  0,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCMatch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCMatch, _impl_.match_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTADPCMatch, _impl_.metadata_),
  0,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 17, -1, sizeof(::CMsgArcanaVotes_Match)},
  { 28, 42, -1, sizeof(::CMsgArcanaVotes)},
  { 50, 69, -1, sizeof(::CMsgDOTADPCFeed_Element)},
  { 82, -1, -1, sizeof(::CMsgDOTADPCFeed)},
  { 89, 96, -1, sizeof(::CMsgDOTADPCUserInfo)},
  { 97, 105, -1, sizeof(::CMsgDraftTrivia_DraftTriviaHeroInfo)},
  { 107, -1, -1, sizeof(::CMsgDraftTrivia_DraftTriviaMatchInfo)},
  { 115, 127, -1, sizeof(::CMsgDraftTrivia_PreviousResult)},
  { 133, 147, -1, sizeof(::CMsgDraftTrivia)},
  { 155, 165, -1, sizeof(::CMsgTeamFanContentAssetStatus)},
  { 169, 176, -1, sizeof(::CMsgTeamFanContentAssetStatusResponse)},
  { 177, 201, -1, sizeof(::CMsgTeamFanContentStatus_TeamStatus)},
  { 219, -1, -1, sizeof(::CMsgTeamFanContentStatus)},
  { 226, 236, -1, sizeof(::CMsgTeamFanContentAutographStatus_AutographStatus)},
  { 240, 250, -1, sizeof(::CMsgTeamFanContentAutographStatus_TeamStatus)},
  { 254, -1, -1, sizeof(::CMsgTeamFanContentAutographStatus)},
  { 261, 269, -1, sizeof(::CMsgDPCEvent_PhaseInfo)},
  { 271, 281, -1, sizeof(::CMsgDPCEvent_League)},
  { 285, 305, -1, sizeof(::CMsgDPCEvent)},
  { 319, -1, -1, sizeof(::CMsgDPCEventList)},
  { 326, 334, -1, sizeof(::CMsgDOTAFantasyCardLineup_CardBonus)},
  { 336, 351, -1, sizeof(::CMsgDOTAFantasyCardLineup_Card)},
  { 360, 369, -1, sizeof(::CMsgDOTAFantasyCardLineup_League)},
  { 372, 382, -1, sizeof(::CMsgDOTAFantasyCardLineup_Period)},
  { 386, -1, -1, sizeof(::CMsgDOTAFantasyCardLineup)},
  { 393, 401, -1, sizeof(::CMsgDOTAFantasyCardList_CardBonus)},
  { 403, 416, -1, sizeof(::CMsgDOTAFantasyCardList_Card)},
  { 423, -1, -1, sizeof(::CMsgDOTAFantasyCardList)},
  { 430, 443, -1, sizeof(::CMsgChatToxicityReport)},
  { 450, 462, -1, sizeof(::CMsgGetTeamAuditInformation_Action)},
  { 468, 478, -1, sizeof(::CMsgGetTeamAuditInformation)},
  { 482, 490, -1, sizeof(::CMsgDOTADPCMatch)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CMsgArcanaVotes_Match_default_instance_._instance,
  &::_CMsgArcanaVotes_default_instance_._instance,
  &::_CMsgDOTADPCFeed_Element_default_instance_._instance,
  &::_CMsgDOTADPCFeed_default_instance_._instance,
  &::_CMsgDOTADPCUserInfo_default_instance_._instance,
  &::_CMsgDraftTrivia_DraftTriviaHeroInfo_default_instance_._instance,
  &::_CMsgDraftTrivia_DraftTriviaMatchInfo_default_instance_._instance,
  &::_CMsgDraftTrivia_PreviousResult_default_instance_._instance,
  &::_CMsgDraftTrivia_default_instance_._instance,
  &::_CMsgTeamFanContentAssetStatus_default_instance_._instance,
  &::_CMsgTeamFanContentAssetStatusResponse_default_instance_._instance,
  &::_CMsgTeamFanContentStatus_TeamStatus_default_instance_._instance,
  &::_CMsgTeamFanContentStatus_default_instance_._instance,
  &::_CMsgTeamFanContentAutographStatus_AutographStatus_default_instance_._instance,
  &::_CMsgTeamFanContentAutographStatus_TeamStatus_default_instance_._instance,
  &::_CMsgTeamFanContentAutographStatus_default_instance_._instance,
  &::_CMsgDPCEvent_PhaseInfo_default_instance_._instance,
  &::_CMsgDPCEvent_League_default_instance_._instance,
  &::_CMsgDPCEvent_default_instance_._instance,
  &::_CMsgDPCEventList_default_instance_._instance,
  &::_CMsgDOTAFantasyCardLineup_CardBonus_default_instance_._instance,
  &::_CMsgDOTAFantasyCardLineup_Card_default_instance_._instance,
  &::_CMsgDOTAFantasyCardLineup_League_default_instance_._instance,
  &::_CMsgDOTAFantasyCardLineup_Period_default_instance_._instance,
  &::_CMsgDOTAFantasyCardLineup_default_instance_._instance,
  &::_CMsgDOTAFantasyCardList_CardBonus_default_instance_._instance,
  &::_CMsgDOTAFantasyCardList_Card_default_instance_._instance,
  &::_CMsgDOTAFantasyCardList_default_instance_._instance,
  &::_CMsgChatToxicityReport_default_instance_._instance,
  &::_CMsgGetTeamAuditInformation_Action_default_instance_._instance,
  &::_CMsgGetTeamAuditInformation_default_instance_._instance,
  &::_CMsgDOTADPCMatch_default_instance_._instance,
};

const char descriptor_table_protodef_dota_5fgcmessages_5fwebapi_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\034dota_gcmessages_webapi.proto\032\023steammes"
  "sages.proto\032\026gcsdk_gcmessages.proto\032\027dot"
  "a_shared_enums.proto\032\034dota_gcmessages_co"
  "mmon.proto\032\031dota_match_metadata.proto\"\274\004"
  "\n\017CMsgArcanaVotes\022\'\n\007matches\030\001 \003(\0132\026.CMs"
  "gArcanaVotes.Match\022\034\n\024round_time_remaini"
  "ng\030\002 \001(\r\022\024\n\014round_number\030\003 \001(\r\022\024\n\014voting"
  "_state\030\004 \001(\r\022$\n\034is_current_round_calibra"
  "ting\030\005 \001(\010\022\037\n\027closest_active_match_id\030\006 "
  "\001(\r\022\020\n\010event_id\030\007 \001(\r\022\031\n\021voting_start_ti"
  "me\030\010 \001(\r\032\204\002\n\005Match\022\020\n\010match_id\030\001 \001(\r\022\021\n\t"
  "hero_id_0\030\002 \001(\r\022\021\n\thero_id_1\030\003 \001(\r\022\026\n\016he"
  "ro_seeding_0\030\004 \001(\r\022\026\n\016hero_seeding_1\030\005 \001"
  "(\r\022\024\n\014vote_count_0\030\006 \001(\r\022\024\n\014vote_count_1"
  "\030\007 \001(\r\022\024\n\014voting_state\030\010 \001(\r\022\024\n\014round_nu"
  "mber\030\t \001(\r\022\027\n\017is_votes_hidden\030\n \001(\010\022\"\n\032c"
  "alibration_time_remaining\030\013 \001(\r\";\n\013Votin"
  "gState\022\014\n\010FINISHED\020\000\022\017\n\013IN_PROGRESS\020\001\022\r\n"
  "\tIN_FUTURE\020\002\"\366\005\n\017CMsgDOTADPCFeed\022*\n\010elem"
  "ents\030\001 \003(\0132\030.CMsgDOTADPCFeed.Element\032\250\002\n"
  "\007Element\022C\n\004type\030\001 \001(\0162!.CMsgDOTADPCFeed"
  ".EFeedElementType:\022FEED_SERIES_RESULT\022\021\n"
  "\ttimestamp\030\002 \001(\r\022\021\n\tseries_id\030\003 \001(\r\022\020\n\010m"
  "atch_id\030\004 \001(\004\022\017\n\007team_id\030\005 \001(\r\022\022\n\naccoun"
  "t_id\030\006 \001(\r\022\021\n\tleague_id\030\007 \001(\r\022\017\n\007node_id"
  "\030\010 \001(\r\022\027\n\017server_steam_id\030\r \001(\004\022\016\n\006data_"
  "1\030\t \001(\r\022\016\n\006data_2\030\n \001(\r\022\016\n\006data_3\030\013 \001(\r\022"
  "\016\n\006data_4\030\014 \001(\r\"\213\003\n\020EFeedElementType\022\026\n\022"
  "FEED_SERIES_RESULT\020\001\022\026\n\022FEED_MATCH_POPUL"
  "AR\020\002\022\034\n\030FEED_TEAM_UPCOMING_MATCH\020\003\022\033\n\027FE"
  "ED_TEAM_LEAGUE_RESULT\020\004\022\030\n\024FEED_TEAM_ADD"
  "_PLAYER\020\005\022\033\n\027FEED_TEAM_REMOVE_PLAYER\020\006\022\025"
  "\n\021FEED_TEAM_DISBAND\020\007\022\030\n\024FEED_LEAGUE_UPC"
  "OMING\020\010\022\031\n\025FEED_LEAGUE_CONCLUDED\020\t\022\026\n\022FE"
  "ED_DPC_STANDINGS\020\n\022\032\n\026FEED_ALERT_PREDICT"
  "IONS\020\013\022\026\n\022FEED_ALERT_FANTASY\020\014\022\032\n\026FEED_L"
  "EAGUE_LIVE_MATCH\020\r\022!\n\035FEED_LEAGUE_INPROG"
  "RESS_SERIES\020\016\"1\n\023CMsgDOTADPCUserInfo\022\032\n\022"
  "is_plus_subscriber\030\001 \001(\010\"\246\005\n\017CMsgDraftTr"
  "ivia\022\027\n\017has_valid_match\030\001 \001(\010\022>\n\017match_h"
  "ero_info\030\002 \001(\0132%.CMsgDraftTrivia.DraftTr"
  "iviaMatchInfo\022\027\n\017match_rank_tier\030\003 \001(\r\022\020"
  "\n\010end_time\030\004 \001(\r\022\020\n\010event_id\030\005 \001(\r\022#\n\033cu"
  "rrent_match_voted_radiant\030\006 \001(\010\0228\n\017previ"
  "ous_result\030\007 \001(\0132\037.CMsgDraftTrivia.Previ"
  "ousResult\022\026\n\016current_streak\030\010 \001(\r\0324\n\023Dra"
  "ftTriviaHeroInfo\022\017\n\007hero_id\030\001 \001(\r\022\014\n\004rol"
  "e\030\002 \001(\r\032\217\001\n\024DraftTriviaMatchInfo\022<\n\016radi"
  "ant_heroes\030\001 \003(\0132$.CMsgDraftTrivia.Draft"
  "TriviaHeroInfo\0229\n\013dire_heroes\030\002 \003(\0132$.CM"
  "sgDraftTrivia.DraftTriviaHeroInfo\032\275\001\n\016Pr"
  "eviousResult\022\027\n\017voted_correctly\030\001 \001(\010\022\025\n"
  "\rvoted_radiant\030\002 \001(\010\022>\n\017match_hero_info\030"
  "\003 \001(\0132%.CMsgDraftTrivia.DraftTriviaMatch"
  "Info\022\027\n\017match_rank_tier\030\004 \001(\r\022\020\n\010end_tim"
  "e\030\005 \001(\r\022\020\n\010match_id\030\006 \001(\004\"\342\001\n\035CMsgTeamFa"
  "nContentAssetStatus\022M\n\nasset_type\030\001 \001(\0162"
  "\031.ETeamFanContentAssetType:\036k_eFanConten"
  "tAssetType_LogoPNG\022\023\n\013asset_index\030\002 \001(\r\022"
  "P\n\014asset_status\030\003 \001(\0162\033.ETeamFanContentA"
  "ssetStatus:\035k_eFanContentAssetStatus_Non"
  "e\022\013\n\003crc\030\004 \001(\r\"\244\001\n%CMsgTeamFanContentAss"
  "etStatusResponse\022J\n\006result\030\001 \001(\0162..CMsgT"
  "eamFanContentAssetStatusResponse.EResult"
  ":\nk_eSuccess\"/\n\007EResult\022\016\n\nk_eSuccess\020\000\022"
  "\024\n\020k_eInternalError\020\001\"\274\004\n\030CMsgTeamFanCon"
  "tentStatus\022>\n\020team_status_list\030\001 \003(\0132$.C"
  "MsgTeamFanContentStatus.TeamStatus\032\337\003\n\nT"
  "eamStatus\022\014\n\004name\030\001 \001(\t\022\017\n\007team_id\030\002 \001(\r"
  "\022\020\n\010logo_url\030\003 \001(\t\022G\n\006status\030\004 \001(\0162\026.ETe"
  "amFanContentStatus:\037TEAM_FAN_CONTENT_STA"
  "TUS_INVALID\022\021\n\ttimestamp\030\005 \001(\r\022\020\n\010ugc_lo"
  "go\030\007 \001(\004\022\033\n\023workshop_account_id\030\010 \001(\r\022\024\n"
  "\014abbreviation\030\t \001(\t\022\027\n\017voiceline_count\030\n"
  " \001(\r\022\023\n\013spray_count\030\013 \001(\r\022\026\n\016emoticon_co"
  "unt\030\014 \001(\r\022\027\n\017wallpaper_count\030\r \001(\r\022\017\n\007co"
  "mment\030\016 \001(\t\022\031\n\021comment_timestamp\030\017 \001(\r\0224"
  "\n\014asset_status\030\020 \003(\0132\036.CMsgTeamFanConten"
  "tAssetStatus\022\027\n\017email_timestamp\030\021 \001(\r\022\022\n"
  "\nemail_tier\030\022 \001(\r\022\021\n\tlanguages\030\023 \001(\t\"\330\002\n"
  "!CMsgTeamFanContentAutographStatus\022F\n\017te"
  "am_autographs\030\001 \003(\0132-.CMsgTeamFanContent"
  "AutographStatus.TeamStatus\032X\n\017AutographS"
  "tatus\022\020\n\010pro_name\030\001 \001(\t\022\022\n\naccount_id\030\002 "
  "\001(\r\022\021\n\ttimestamp\030\003 \001(\r\022\014\n\004file\030\004 \001(\t\032\220\001\n"
  "\nTeamStatus\022\014\n\004name\030\001 \001(\t\022\017\n\007team_id\030\002 \001"
  "(\r\022F\n\nautographs\030\003 \003(\01322.CMsgTeamFanCont"
  "entAutographStatus.AutographStatus\022\033\n\023wo"
  "rkshop_account_id\030\004 \001(\r\"\245\r\n\014CMsgDPCEvent"
  "\0228\n\005event\030\001 \001(\0162\032.CMsgDPCEvent.ELeagueEv"
  "ent:\rEVENT_INVALID\022;\n\nevent_type\030\002 \001(\0162\036"
  ".CMsgDPCEvent.ELeagueEventType:\007UNKNOWN\022"
  "%\n\007leagues\030\003 \003(\0132\024.CMsgDPCEvent.League\022\033"
  "\n\023registration_period\030\004 \001(\r\022\031\n\021is_event_"
  "upcoming\030\005 \001(\010\022\032\n\022is_event_completed\030\006 \001"
  "(\010\022\022\n\nevent_name\030\007 \001(\t\022\033\n\023multicast_leag"
  "ue_id\030\010 \001(\r\022\031\n\021multicast_streams\030\t \003(\r\022,"
  "\n\004tour\030\n \001(\0162\023.CMsgDPCEvent.ETour:\tTOUR_"
  "NONE\022\033\n\023timestamp_drop_lock\030\014 \001(\r\022\032\n\022tim"
  "estamp_add_lock\030\r \001(\r\022\"\n\032timestamp_conte"
  "nt_deadline\030\016 \001(\r\022\032\n\022is_fantasy_enabled\030"
  "\017 \001(\010\032a\n\tPhaseInfo\022=\n\005phase\030\001 \001(\0162\037.CMsg"
  "DPCEvent.ELeagueEventPhase:\rPHASE_INVALI"
  "D\022\025\n\rnode_group_id\030\002 \001(\r\032\264\001\n\006League\0223\n\006r"
  "egion\030\001 \001(\0162\016.ELeagueRegion:\023LEAGUE_REGI"
  "ON_UNSET\0229\n\010division\030\002 \001(\0162\020.ELeagueDivi"
  "sion:\025LEAGUE_DIVISION_UNSET\022\021\n\tleague_id"
  "\030\003 \001(\r\022\'\n\006phases\030\004 \003(\0132\027.CMsgDPCEvent.Ph"
  "aseInfo\"\323\004\n\014ELeagueEvent\022\021\n\rEVENT_INVALI"
  "D\020\000\022\026\n\022SPRING_2021_LEAGUE\020\001\022\025\n\021SPRING_20"
  "21_MAJOR\020\002\022!\n\035INTERNATIONAL_2021_QUALIFI"
  "ERS\020\003\022\026\n\022INTERNATIONAL_2021\020\004\022\026\n\022WINTER_"
  "2021_LEAGUE\020\005\022\035\n\031WINTER_2021_LEAGUE_FINA"
  "LS\020\006\022\026\n\022SPRING_2022_LEAGUE\020\007\022\025\n\021SPRING_2"
  "022_MAJOR\020\010\022\026\n\022SUMMER_2022_LEAGUE\020\t\022\025\n\021S"
  "UMMER_2022_MAJOR\020\n\022\026\n\022INTERNATIONAL_2022"
  "\020\013\022\031\n\025CHINA_REGIONAL_FINALS\020\014\022*\n&INTERNA"
  "TIONAL_2022_REGIONAL_QUALIFIERS\020\r\022-\n)INT"
  "ERNATIONAL_2022_LAST_CHANCE_QUALIFIERS\020\016"
  "\022\026\n\022WINTER_2023_LEAGUE\020\017\022\025\n\021WINTER_2023_"
  "MAJOR\020\020\022\026\n\022SPRING_2023_LEAGUE\020\021\022\025\n\021SPRIN"
  "G_2023_MAJOR\020\022\022\026\n\022SUMMER_2023_LEAGUE\020\023\022\025"
  "\n\021SUMMER_2023_MAJOR\020\024\022\026\n\022INTERNATIONAL_2"
  "023\020\025\"\207\001\n\021ELeagueEventPhase\022\021\n\rPHASE_INV"
  "ALID\020\000\022\r\n\tWILD_CARD\020\001\022\017\n\013GROUP_STAGE\020\002\022\013"
  "\n\007GROUP_A\020\003\022\013\n\007GROUP_B\020\004\022\013\n\007OVERALL\020\005\022\013\n"
  "\007PLAYOFF\020\006\022\013\n\007RESULTS\020\007\"z\n\020ELeagueEventT"
  "ype\022\013\n\007UNKNOWN\020\000\022\n\n\006LEAGUE\020\001\022\t\n\005MAJOR\020\002\022"
  "\034\n\030INTERNATIONAL_QUALIFIERS\020\003\022\021\n\rINTERNA"
  "TIONAL\020\004\022\021\n\rLEAGUE_FINALS\020\005\":\n\005ETour\022\r\n\t"
  "TOUR_NONE\020\000\022\n\n\006TOUR_1\020\001\022\n\n\006TOUR_2\020\002\022\n\n\006T"
  "OUR_3\020\003\"1\n\020CMsgDPCEventList\022\035\n\006events\030\001 "
  "\003(\0132\r.CMsgDPCEvent\"\311\004\n\031CMsgDOTAFantasyCa"
  "rdLineup\0222\n\007periods\030\001 \003(\0132!.CMsgDOTAFant"
  "asyCardLineup.Period\0324\n\tCardBonus\022\022\n\nbon"
  "us_stat\030\001 \001(\r\022\023\n\013bonus_value\030\002 \001(\r\032\322\001\n\004C"
  "ard\022\031\n\021player_account_id\030\001 \001(\r\022\023\n\013player"
  "_name\030\002 \001(\t\022\017\n\007team_id\030\003 \001(\r\022\021\n\tteam_nam"
  "e\030\004 \001(\t\022\014\n\004role\030\005 \001(\r\0225\n\007bonuses\030\006 \003(\0132$"
  ".CMsgDOTAFantasyCardLineup.CardBonus\022\r\n\005"
  "score\030\007 \001(\002\022\021\n\tfinalized\030\010 \001(\010\022\017\n\007item_i"
  "d\030\t \001(\004\032Z\n\006League\022\021\n\tleague_id\030\001 \001(\r\022.\n\005"
  "cards\030\002 \003(\0132\037.CMsgDOTAFantasyCardLineup."
  "Card\022\r\n\005score\030\003 \001(\002\032\220\001\n\006Period\022\"\n\016fantas"
  "y_period\030\001 \001(\r:\n4294967295\022\027\n\017timestamp_"
  "start\030\002 \001(\r\022\025\n\rtimestamp_end\030\003 \001(\r\0222\n\007le"
  "agues\030\004 \003(\0132!.CMsgDOTAFantasyCardLineup."
  "League\"\256\002\n\027CMsgDOTAFantasyCardList\022,\n\005ca"
  "rds\030\001 \003(\0132\035.CMsgDOTAFantasyCardList.Card"
  "\0324\n\tCardBonus\022\022\n\nbonus_stat\030\001 \001(\r\022\023\n\013bon"
  "us_value\030\002 \001(\r\032\256\001\n\004Card\022\031\n\021player_accoun"
  "t_id\030\001 \001(\r\022\023\n\013player_name\030\002 \001(\t\022\017\n\007team_"
  "id\030\003 \001(\r\022\021\n\tteam_name\030\004 \001(\t\022\014\n\004role\030\005 \001("
  "\r\0223\n\007bonuses\030\006 \003(\0132\".CMsgDOTAFantasyCard"
  "List.CardBonus\022\017\n\007item_id\030\010 \001(\004\"\310\001\n\026CMsg"
  "ChatToxicityReport\022\030\n\020num_matches_seen\030\001"
  " \001(\r\022\024\n\014num_messages\030\002 \001(\r\022\'\n\037num_messag"
  "es_human_thinks_toxic\030\003 \001(\r\022$\n\034num_messa"
  "ges_ml_thinks_toxic\030\004 \001(\r\022\016\n\006status\030\005 \001("
  "\t\022\016\n\006result\030\006 \001(\r\022\017\n\007message\030\007 \001(\t\"\233\002\n\033C"
  "MsgGetTeamAuditInformation\022\017\n\007team_id\030\001 "
  "\001(\r\022\021\n\tteam_name\030\002 \001(\t\0224\n\007actions\030\003 \003(\0132"
  "#.CMsgGetTeamAuditInformation.Action\022\024\n\014"
  "last_updated\030\004 \001(\r\032\213\001\n\006Action\022\033\n\023registr"
  "ation_period\030\001 \001(\r\022\022\n\naccount_id\030\002 \001(\r\022\016"
  "\n\006action\030\003 \001(\r\022\021\n\ttimestamp\030\004 \001(\r\022\023\n\013pla"
  "yer_name\030\005 \001(\t\022\030\n\020player_real_name\030\006 \001(\t"
  "\"X\n\020CMsgDOTADPCMatch\022\035\n\005match\030\001 \001(\0132\016.CM"
  "sgDOTAMatch\022%\n\010metadata\030\002 \001(\0132\023.CDOTAMat"
  "chMetadata*\210\001\n\025ETeamFanContentStatus\022#\n\037"
  "TEAM_FAN_CONTENT_STATUS_INVALID\020\000\022#\n\037TEA"
  "M_FAN_CONTENT_STATUS_PENDING\020\001\022%\n!TEAM_F"
  "AN_CONTENT_STATUS_EVALUATED\020\002*\351\002\n\030ETeamF"
  "anContentAssetType\022\"\n\036k_eFanContentAsset"
  "Type_LogoPNG\020\001\022\"\n\036k_eFanContentAssetType"
  "_LogoSVG\020\002\022!\n\035k_eFanContentAssetType_Log"
  "o3D\020\003\022\"\n\036k_eFanContentAssetType_Players\020"
  "\004\022!\n\035k_eFanContentAssetType_Sprays\020\005\022%\n!"
  "k_eFanContentAssetType_Wallpapers\020\006\022$\n k"
  "_eFanContentAssetType_Emoticons\020\007\022%\n!k_e"
  "FanContentAssetType_VoiceLines\020\010\022\'\n#k_eF"
  "anContentAssetType_Localization\020\t*\215\001\n\032ET"
  "eamFanContentAssetStatus\022!\n\035k_eFanConten"
  "tAssetStatus_None\020\000\022%\n!k_eFanContentAsse"
  "tStatus_Approved\020\001\022%\n!k_eFanContentAsset"
  "Status_Rejected\020\002"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_deps[5] = {
  &::descriptor_table_dota_5fgcmessages_5fcommon_2eproto,
  &::descriptor_table_dota_5fmatch_5fmetadata_2eproto,
  &::descriptor_table_dota_5fshared_5fenums_2eproto,
  &::descriptor_table_gcsdk_5fgcmessages_2eproto,
  &::descriptor_table_steammessages_2eproto,
};
static ::_pbi::once_flag descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_dota_5fgcmessages_5fwebapi_2eproto = {
    false, false, 7417, descriptor_table_protodef_dota_5fgcmessages_5fwebapi_2eproto,
    "dota_gcmessages_webapi.proto",
    &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once, descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_deps, 5, 32,
    schemas, file_default_instances, TableStruct_dota_5fgcmessages_5fwebapi_2eproto::offsets,
    file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto, file_level_enum_descriptors_dota_5fgcmessages_5fwebapi_2eproto,
    file_level_service_descriptors_dota_5fgcmessages_5fwebapi_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter() {
  return &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_dota_5fgcmessages_5fwebapi_2eproto(&descriptor_table_dota_5fgcmessages_5fwebapi_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgArcanaVotes_VotingState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fwebapi_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fwebapi_2eproto[0];
}
bool CMsgArcanaVotes_VotingState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgArcanaVotes_VotingState CMsgArcanaVotes::FINISHED;
constexpr CMsgArcanaVotes_VotingState CMsgArcanaVotes::IN_PROGRESS;
constexpr CMsgArcanaVotes_VotingState CMsgArcanaVotes::IN_FUTURE;
constexpr CMsgArcanaVotes_VotingState CMsgArcanaVotes::VotingState_MIN;
constexpr CMsgArcanaVotes_VotingState CMsgArcanaVotes::VotingState_MAX;
constexpr int CMsgArcanaVotes::VotingState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTADPCFeed_EFeedElementType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fwebapi_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fwebapi_2eproto[1];
}
bool CMsgDOTADPCFeed_EFeedElementType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_SERIES_RESULT;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_MATCH_POPULAR;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_TEAM_UPCOMING_MATCH;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_TEAM_LEAGUE_RESULT;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_TEAM_ADD_PLAYER;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_TEAM_REMOVE_PLAYER;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_TEAM_DISBAND;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_LEAGUE_UPCOMING;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_LEAGUE_CONCLUDED;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_DPC_STANDINGS;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_ALERT_PREDICTIONS;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_ALERT_FANTASY;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_LEAGUE_LIVE_MATCH;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::FEED_LEAGUE_INPROGRESS_SERIES;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::EFeedElementType_MIN;
constexpr CMsgDOTADPCFeed_EFeedElementType CMsgDOTADPCFeed::EFeedElementType_MAX;
constexpr int CMsgDOTADPCFeed::EFeedElementType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgTeamFanContentAssetStatusResponse_EResult_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fwebapi_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fwebapi_2eproto[2];
}
bool CMsgTeamFanContentAssetStatusResponse_EResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgTeamFanContentAssetStatusResponse_EResult CMsgTeamFanContentAssetStatusResponse::k_eSuccess;
constexpr CMsgTeamFanContentAssetStatusResponse_EResult CMsgTeamFanContentAssetStatusResponse::k_eInternalError;
constexpr CMsgTeamFanContentAssetStatusResponse_EResult CMsgTeamFanContentAssetStatusResponse::EResult_MIN;
constexpr CMsgTeamFanContentAssetStatusResponse_EResult CMsgTeamFanContentAssetStatusResponse::EResult_MAX;
constexpr int CMsgTeamFanContentAssetStatusResponse::EResult_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDPCEvent_ELeagueEvent_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fwebapi_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fwebapi_2eproto[3];
}
bool CMsgDPCEvent_ELeagueEvent_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::EVENT_INVALID;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::SPRING_2021_LEAGUE;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::SPRING_2021_MAJOR;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::INTERNATIONAL_2021_QUALIFIERS;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::INTERNATIONAL_2021;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::WINTER_2021_LEAGUE;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::WINTER_2021_LEAGUE_FINALS;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::SPRING_2022_LEAGUE;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::SPRING_2022_MAJOR;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::SUMMER_2022_LEAGUE;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::SUMMER_2022_MAJOR;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::INTERNATIONAL_2022;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::CHINA_REGIONAL_FINALS;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::INTERNATIONAL_2022_REGIONAL_QUALIFIERS;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::INTERNATIONAL_2022_LAST_CHANCE_QUALIFIERS;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::WINTER_2023_LEAGUE;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::WINTER_2023_MAJOR;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::SPRING_2023_LEAGUE;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::SPRING_2023_MAJOR;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::SUMMER_2023_LEAGUE;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::SUMMER_2023_MAJOR;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::INTERNATIONAL_2023;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::ELeagueEvent_MIN;
constexpr CMsgDPCEvent_ELeagueEvent CMsgDPCEvent::ELeagueEvent_MAX;
constexpr int CMsgDPCEvent::ELeagueEvent_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDPCEvent_ELeagueEventPhase_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fwebapi_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fwebapi_2eproto[4];
}
bool CMsgDPCEvent_ELeagueEventPhase_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDPCEvent_ELeagueEventPhase CMsgDPCEvent::PHASE_INVALID;
constexpr CMsgDPCEvent_ELeagueEventPhase CMsgDPCEvent::WILD_CARD;
constexpr CMsgDPCEvent_ELeagueEventPhase CMsgDPCEvent::GROUP_STAGE;
constexpr CMsgDPCEvent_ELeagueEventPhase CMsgDPCEvent::GROUP_A;
constexpr CMsgDPCEvent_ELeagueEventPhase CMsgDPCEvent::GROUP_B;
constexpr CMsgDPCEvent_ELeagueEventPhase CMsgDPCEvent::OVERALL;
constexpr CMsgDPCEvent_ELeagueEventPhase CMsgDPCEvent::PLAYOFF;
constexpr CMsgDPCEvent_ELeagueEventPhase CMsgDPCEvent::RESULTS;
constexpr CMsgDPCEvent_ELeagueEventPhase CMsgDPCEvent::ELeagueEventPhase_MIN;
constexpr CMsgDPCEvent_ELeagueEventPhase CMsgDPCEvent::ELeagueEventPhase_MAX;
constexpr int CMsgDPCEvent::ELeagueEventPhase_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDPCEvent_ELeagueEventType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fwebapi_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fwebapi_2eproto[5];
}
bool CMsgDPCEvent_ELeagueEventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDPCEvent_ELeagueEventType CMsgDPCEvent::UNKNOWN;
constexpr CMsgDPCEvent_ELeagueEventType CMsgDPCEvent::LEAGUE;
constexpr CMsgDPCEvent_ELeagueEventType CMsgDPCEvent::MAJOR;
constexpr CMsgDPCEvent_ELeagueEventType CMsgDPCEvent::INTERNATIONAL_QUALIFIERS;
constexpr CMsgDPCEvent_ELeagueEventType CMsgDPCEvent::INTERNATIONAL;
constexpr CMsgDPCEvent_ELeagueEventType CMsgDPCEvent::LEAGUE_FINALS;
constexpr CMsgDPCEvent_ELeagueEventType CMsgDPCEvent::ELeagueEventType_MIN;
constexpr CMsgDPCEvent_ELeagueEventType CMsgDPCEvent::ELeagueEventType_MAX;
constexpr int CMsgDPCEvent::ELeagueEventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDPCEvent_ETour_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fwebapi_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fwebapi_2eproto[6];
}
bool CMsgDPCEvent_ETour_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDPCEvent_ETour CMsgDPCEvent::TOUR_NONE;
constexpr CMsgDPCEvent_ETour CMsgDPCEvent::TOUR_1;
constexpr CMsgDPCEvent_ETour CMsgDPCEvent::TOUR_2;
constexpr CMsgDPCEvent_ETour CMsgDPCEvent::TOUR_3;
constexpr CMsgDPCEvent_ETour CMsgDPCEvent::ETour_MIN;
constexpr CMsgDPCEvent_ETour CMsgDPCEvent::ETour_MAX;
constexpr int CMsgDPCEvent::ETour_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETeamFanContentStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fwebapi_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fwebapi_2eproto[7];
}
bool ETeamFanContentStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETeamFanContentAssetType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fwebapi_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fwebapi_2eproto[8];
}
bool ETeamFanContentAssetType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETeamFanContentAssetStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fwebapi_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fwebapi_2eproto[9];
}
bool ETeamFanContentAssetStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CMsgArcanaVotes_Match::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgArcanaVotes_Match>()._impl_._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hero_id_0(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hero_id_1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hero_seeding_0(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hero_seeding_1(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_vote_count_0(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_vote_count_1(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_voting_state(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_round_number(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_votes_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_calibration_time_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

CMsgArcanaVotes_Match::CMsgArcanaVotes_Match(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgArcanaVotes.Match)
}
CMsgArcanaVotes_Match::CMsgArcanaVotes_Match(const CMsgArcanaVotes_Match& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgArcanaVotes_Match* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.hero_id_0_){}
    , decltype(_impl_.hero_id_1_){}
    , decltype(_impl_.hero_seeding_0_){}
    , decltype(_impl_.hero_seeding_1_){}
    , decltype(_impl_.vote_count_0_){}
    , decltype(_impl_.vote_count_1_){}
    , decltype(_impl_.voting_state_){}
    , decltype(_impl_.round_number_){}
    , decltype(_impl_.is_votes_hidden_){}
    , decltype(_impl_.calibration_time_remaining_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.match_id_, &from._impl_.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.calibration_time_remaining_) -
    reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.calibration_time_remaining_));
  // @@protoc_insertion_point(copy_constructor:CMsgArcanaVotes.Match)
}

inline void CMsgArcanaVotes_Match::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){0u}
    , decltype(_impl_.hero_id_0_){0u}
    , decltype(_impl_.hero_id_1_){0u}
    , decltype(_impl_.hero_seeding_0_){0u}
    , decltype(_impl_.hero_seeding_1_){0u}
    , decltype(_impl_.vote_count_0_){0u}
    , decltype(_impl_.vote_count_1_){0u}
    , decltype(_impl_.voting_state_){0u}
    , decltype(_impl_.round_number_){0u}
    , decltype(_impl_.is_votes_hidden_){false}
    , decltype(_impl_.calibration_time_remaining_){0u}
  };
}

CMsgArcanaVotes_Match::~CMsgArcanaVotes_Match() {
  // @@protoc_insertion_point(destructor:CMsgArcanaVotes.Match)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgArcanaVotes_Match::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgArcanaVotes_Match::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgArcanaVotes_Match::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgArcanaVotes.Match)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.voting_state_) -
        reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.voting_state_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.round_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.calibration_time_remaining_) -
        reinterpret_cast<char*>(&_impl_.round_number_)) + sizeof(_impl_.calibration_time_remaining_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgArcanaVotes_Match::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 match_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id_0 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hero_id_0(&has_bits);
          _impl_.hero_id_0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id_1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hero_id_1(&has_bits);
          _impl_.hero_id_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_seeding_0 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hero_seeding_0(&has_bits);
          _impl_.hero_seeding_0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_seeding_1 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_hero_seeding_1(&has_bits);
          _impl_.hero_seeding_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 vote_count_0 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_vote_count_0(&has_bits);
          _impl_.vote_count_0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 vote_count_1 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_vote_count_1(&has_bits);
          _impl_.vote_count_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 voting_state = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_voting_state(&has_bits);
          _impl_.voting_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 round_number = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_round_number(&has_bits);
          _impl_.round_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_votes_hidden = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_is_votes_hidden(&has_bits);
          _impl_.is_votes_hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 calibration_time_remaining = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_calibration_time_remaining(&has_bits);
          _impl_.calibration_time_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgArcanaVotes_Match::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgArcanaVotes.Match)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 match_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_match_id(), target);
  }

  // optional uint32 hero_id_0 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hero_id_0(), target);
  }

  // optional uint32 hero_id_1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hero_id_1(), target);
  }

  // optional uint32 hero_seeding_0 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_hero_seeding_0(), target);
  }

  // optional uint32 hero_seeding_1 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_hero_seeding_1(), target);
  }

  // optional uint32 vote_count_0 = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_vote_count_0(), target);
  }

  // optional uint32 vote_count_1 = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_vote_count_1(), target);
  }

  // optional uint32 voting_state = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_voting_state(), target);
  }

  // optional uint32 round_number = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_round_number(), target);
  }

  // optional bool is_votes_hidden = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_is_votes_hidden(), target);
  }

  // optional uint32 calibration_time_remaining = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_calibration_time_remaining(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgArcanaVotes.Match)
  return target;
}

size_t CMsgArcanaVotes_Match::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgArcanaVotes.Match)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 match_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 hero_id_0 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id_0());
    }

    // optional uint32 hero_id_1 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id_1());
    }

    // optional uint32 hero_seeding_0 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_seeding_0());
    }

    // optional uint32 hero_seeding_1 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_seeding_1());
    }

    // optional uint32 vote_count_0 = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vote_count_0());
    }

    // optional uint32 vote_count_1 = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vote_count_1());
    }

    // optional uint32 voting_state = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_voting_state());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 round_number = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_round_number());
    }

    // optional bool is_votes_hidden = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional uint32 calibration_time_remaining = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_calibration_time_remaining());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgArcanaVotes_Match::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgArcanaVotes_Match::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgArcanaVotes_Match::GetClassData() const { return &_class_data_; }


void CMsgArcanaVotes_Match::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgArcanaVotes_Match*>(&to_msg);
  auto& from = static_cast<const CMsgArcanaVotes_Match&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgArcanaVotes.Match)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hero_id_0_ = from._impl_.hero_id_0_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hero_id_1_ = from._impl_.hero_id_1_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.hero_seeding_0_ = from._impl_.hero_seeding_0_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.hero_seeding_1_ = from._impl_.hero_seeding_1_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.vote_count_0_ = from._impl_.vote_count_0_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.vote_count_1_ = from._impl_.vote_count_1_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.voting_state_ = from._impl_.voting_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.round_number_ = from._impl_.round_number_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.is_votes_hidden_ = from._impl_.is_votes_hidden_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.calibration_time_remaining_ = from._impl_.calibration_time_remaining_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgArcanaVotes_Match::CopyFrom(const CMsgArcanaVotes_Match& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgArcanaVotes.Match)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgArcanaVotes_Match::IsInitialized() const {
  return true;
}

void CMsgArcanaVotes_Match::InternalSwap(CMsgArcanaVotes_Match* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgArcanaVotes_Match, _impl_.calibration_time_remaining_)
      + sizeof(CMsgArcanaVotes_Match::_impl_.calibration_time_remaining_)
      - PROTOBUF_FIELD_OFFSET(CMsgArcanaVotes_Match, _impl_.match_id_)>(
          reinterpret_cast<char*>(&_impl_.match_id_),
          reinterpret_cast<char*>(&other->_impl_.match_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgArcanaVotes_Match::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[0]);
}

// ===================================================================

class CMsgArcanaVotes::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgArcanaVotes>()._impl_._has_bits_);
  static void set_has_round_time_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_round_number(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_voting_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_current_round_calibrating(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_closest_active_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_voting_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CMsgArcanaVotes::CMsgArcanaVotes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgArcanaVotes)
}
CMsgArcanaVotes::CMsgArcanaVotes(const CMsgArcanaVotes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgArcanaVotes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.matches_){from._impl_.matches_}
    , decltype(_impl_.round_time_remaining_){}
    , decltype(_impl_.round_number_){}
    , decltype(_impl_.voting_state_){}
    , decltype(_impl_.is_current_round_calibrating_){}
    , decltype(_impl_.closest_active_match_id_){}
    , decltype(_impl_.event_id_){}
    , decltype(_impl_.voting_start_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.round_time_remaining_, &from._impl_.round_time_remaining_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.voting_start_time_) -
    reinterpret_cast<char*>(&_impl_.round_time_remaining_)) + sizeof(_impl_.voting_start_time_));
  // @@protoc_insertion_point(copy_constructor:CMsgArcanaVotes)
}

inline void CMsgArcanaVotes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.matches_){arena}
    , decltype(_impl_.round_time_remaining_){0u}
    , decltype(_impl_.round_number_){0u}
    , decltype(_impl_.voting_state_){0u}
    , decltype(_impl_.is_current_round_calibrating_){false}
    , decltype(_impl_.closest_active_match_id_){0u}
    , decltype(_impl_.event_id_){0u}
    , decltype(_impl_.voting_start_time_){0u}
  };
}

CMsgArcanaVotes::~CMsgArcanaVotes() {
  // @@protoc_insertion_point(destructor:CMsgArcanaVotes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgArcanaVotes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.matches_.~RepeatedPtrField();
}

void CMsgArcanaVotes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgArcanaVotes::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgArcanaVotes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matches_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.round_time_remaining_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.voting_start_time_) -
        reinterpret_cast<char*>(&_impl_.round_time_remaining_)) + sizeof(_impl_.voting_start_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgArcanaVotes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgArcanaVotes.Match matches = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 round_time_remaining = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_round_time_remaining(&has_bits);
          _impl_.round_time_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 round_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_round_number(&has_bits);
          _impl_.round_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 voting_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_voting_state(&has_bits);
          _impl_.voting_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_current_round_calibrating = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_current_round_calibrating(&has_bits);
          _impl_.is_current_round_calibrating_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 closest_active_match_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_closest_active_match_id(&has_bits);
          _impl_.closest_active_match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 event_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_event_id(&has_bits);
          _impl_.event_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 voting_start_time = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_voting_start_time(&has_bits);
          _impl_.voting_start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgArcanaVotes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgArcanaVotes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgArcanaVotes.Match matches = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_matches_size()); i < n; i++) {
    const auto& repfield = this->_internal_matches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 round_time_remaining = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_round_time_remaining(), target);
  }

  // optional uint32 round_number = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_round_number(), target);
  }

  // optional uint32 voting_state = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_voting_state(), target);
  }

  // optional bool is_current_round_calibrating = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_current_round_calibrating(), target);
  }

  // optional uint32 closest_active_match_id = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_closest_active_match_id(), target);
  }

  // optional uint32 event_id = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_event_id(), target);
  }

  // optional uint32 voting_start_time = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_voting_start_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgArcanaVotes)
  return target;
}

size_t CMsgArcanaVotes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgArcanaVotes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgArcanaVotes.Match matches = 1;
  total_size += 1UL * this->_internal_matches_size();
  for (const auto& msg : this->_impl_.matches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint32 round_time_remaining = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_round_time_remaining());
    }

    // optional uint32 round_number = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_round_number());
    }

    // optional uint32 voting_state = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_voting_state());
    }

    // optional bool is_current_round_calibrating = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional uint32 closest_active_match_id = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_closest_active_match_id());
    }

    // optional uint32 event_id = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_event_id());
    }

    // optional uint32 voting_start_time = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_voting_start_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgArcanaVotes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgArcanaVotes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgArcanaVotes::GetClassData() const { return &_class_data_; }


void CMsgArcanaVotes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgArcanaVotes*>(&to_msg);
  auto& from = static_cast<const CMsgArcanaVotes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgArcanaVotes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.matches_.MergeFrom(from._impl_.matches_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.round_time_remaining_ = from._impl_.round_time_remaining_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.round_number_ = from._impl_.round_number_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.voting_state_ = from._impl_.voting_state_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_current_round_calibrating_ = from._impl_.is_current_round_calibrating_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.closest_active_match_id_ = from._impl_.closest_active_match_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.voting_start_time_ = from._impl_.voting_start_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgArcanaVotes::CopyFrom(const CMsgArcanaVotes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgArcanaVotes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgArcanaVotes::IsInitialized() const {
  return true;
}

void CMsgArcanaVotes::InternalSwap(CMsgArcanaVotes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.matches_.InternalSwap(&other->_impl_.matches_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgArcanaVotes, _impl_.voting_start_time_)
      + sizeof(CMsgArcanaVotes::_impl_.voting_start_time_)
      - PROTOBUF_FIELD_OFFSET(CMsgArcanaVotes, _impl_.round_time_remaining_)>(
          reinterpret_cast<char*>(&_impl_.round_time_remaining_),
          reinterpret_cast<char*>(&other->_impl_.round_time_remaining_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgArcanaVotes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[1]);
}

// ===================================================================

class CMsgDOTADPCFeed_Element::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTADPCFeed_Element>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_series_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_server_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_data_1(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_data_2(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_data_3(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_data_4(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

CMsgDOTADPCFeed_Element::CMsgDOTADPCFeed_Element(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCFeed.Element)
}
CMsgDOTADPCFeed_Element::CMsgDOTADPCFeed_Element(const CMsgDOTADPCFeed_Element& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCFeed_Element* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.series_id_){}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.data_1_){}
    , decltype(_impl_.data_2_){}
    , decltype(_impl_.data_3_){}
    , decltype(_impl_.data_4_){}
    , decltype(_impl_.server_steam_id_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCFeed.Element)
}

inline void CMsgDOTADPCFeed_Element::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){0u}
    , decltype(_impl_.series_id_){0u}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.node_id_){0u}
    , decltype(_impl_.data_1_){0u}
    , decltype(_impl_.data_2_){0u}
    , decltype(_impl_.data_3_){0u}
    , decltype(_impl_.data_4_){0u}
    , decltype(_impl_.server_steam_id_){uint64_t{0u}}
    , decltype(_impl_.type_){1}
  };
}

CMsgDOTADPCFeed_Element::~CMsgDOTADPCFeed_Element() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCFeed.Element)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCFeed_Element::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTADPCFeed_Element::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCFeed_Element::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCFeed.Element)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.data_1_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.data_1_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.data_2_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.server_steam_id_) -
        reinterpret_cast<char*>(&_impl_.data_2_)) + sizeof(_impl_.server_steam_id_));
    _impl_.type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCFeed_Element::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgDOTADPCFeed.EFeedElementType type = 1 [default = FEED_SERIES_RESULT];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgDOTADPCFeed_EFeedElementType_IsValid(val))) {
            _internal_set_type(static_cast<::CMsgDOTADPCFeed_EFeedElementType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 series_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_series_id(&has_bits);
          _impl_.series_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 match_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 node_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 data_1 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_data_1(&has_bits);
          _impl_.data_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 data_2 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_data_2(&has_bits);
          _impl_.data_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 data_3 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_data_3(&has_bits);
          _impl_.data_3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 data_4 = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_data_4(&has_bits);
          _impl_.data_4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 server_steam_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_server_steam_id(&has_bits);
          _impl_.server_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCFeed_Element::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCFeed.Element)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgDOTADPCFeed.EFeedElementType type = 1 [default = FEED_SERIES_RESULT];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional uint32 timestamp = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_timestamp(), target);
  }

  // optional uint32 series_id = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_series_id(), target);
  }

  // optional uint64 match_id = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_match_id(), target);
  }

  // optional uint32 team_id = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_team_id(), target);
  }

  // optional uint32 account_id = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_account_id(), target);
  }

  // optional uint32 league_id = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_league_id(), target);
  }

  // optional uint32 node_id = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_node_id(), target);
  }

  // optional uint32 data_1 = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_data_1(), target);
  }

  // optional uint32 data_2 = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_data_2(), target);
  }

  // optional uint32 data_3 = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_data_3(), target);
  }

  // optional uint32 data_4 = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_data_4(), target);
  }

  // optional uint64 server_steam_id = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_server_steam_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCFeed.Element)
  return target;
}

size_t CMsgDOTADPCFeed_Element::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCFeed.Element)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 timestamp = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

    // optional uint32 series_id = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_series_id());
    }

    // optional uint64 match_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 team_id = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint32 account_id = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 league_id = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional uint32 node_id = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
    }

    // optional uint32 data_1 = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_data_1());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint32 data_2 = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_data_2());
    }

    // optional uint32 data_3 = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_data_3());
    }

    // optional uint32 data_4 = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_data_4());
    }

    // optional uint64 server_steam_id = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_server_steam_id());
    }

    // optional .CMsgDOTADPCFeed.EFeedElementType type = 1 [default = FEED_SERIES_RESULT];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCFeed_Element::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCFeed_Element::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCFeed_Element::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCFeed_Element::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCFeed_Element*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCFeed_Element&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCFeed.Element)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.series_id_ = from._impl_.series_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.node_id_ = from._impl_.node_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.data_1_ = from._impl_.data_1_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.data_2_ = from._impl_.data_2_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.data_3_ = from._impl_.data_3_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.data_4_ = from._impl_.data_4_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.server_steam_id_ = from._impl_.server_steam_id_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCFeed_Element::CopyFrom(const CMsgDOTADPCFeed_Element& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCFeed.Element)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCFeed_Element::IsInitialized() const {
  return true;
}

void CMsgDOTADPCFeed_Element::InternalSwap(CMsgDOTADPCFeed_Element* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTADPCFeed_Element, _impl_.server_steam_id_)
      + sizeof(CMsgDOTADPCFeed_Element::_impl_.server_steam_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTADPCFeed_Element, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCFeed_Element::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[2]);
}

// ===================================================================

class CMsgDOTADPCFeed::_Internal {
 public:
};

CMsgDOTADPCFeed::CMsgDOTADPCFeed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCFeed)
}
CMsgDOTADPCFeed::CMsgDOTADPCFeed(const CMsgDOTADPCFeed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCFeed* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.elements_){from._impl_.elements_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCFeed)
}

inline void CMsgDOTADPCFeed::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.elements_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTADPCFeed::~CMsgDOTADPCFeed() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCFeed)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCFeed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.elements_.~RepeatedPtrField();
}

void CMsgDOTADPCFeed::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCFeed::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCFeed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.elements_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCFeed::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTADPCFeed.Element elements = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_elements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCFeed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCFeed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTADPCFeed.Element elements = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_elements_size()); i < n; i++) {
    const auto& repfield = this->_internal_elements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCFeed)
  return target;
}

size_t CMsgDOTADPCFeed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCFeed)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTADPCFeed.Element elements = 1;
  total_size += 1UL * this->_internal_elements_size();
  for (const auto& msg : this->_impl_.elements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCFeed::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCFeed::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCFeed::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCFeed::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCFeed*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCFeed&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCFeed)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.elements_.MergeFrom(from._impl_.elements_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCFeed::CopyFrom(const CMsgDOTADPCFeed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCFeed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCFeed::IsInitialized() const {
  return true;
}

void CMsgDOTADPCFeed::InternalSwap(CMsgDOTADPCFeed* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.elements_.InternalSwap(&other->_impl_.elements_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCFeed::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[3]);
}

// ===================================================================

class CMsgDOTADPCUserInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTADPCUserInfo>()._impl_._has_bits_);
  static void set_has_is_plus_subscriber(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTADPCUserInfo::CMsgDOTADPCUserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCUserInfo)
}
CMsgDOTADPCUserInfo::CMsgDOTADPCUserInfo(const CMsgDOTADPCUserInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCUserInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.is_plus_subscriber_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.is_plus_subscriber_ = from._impl_.is_plus_subscriber_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCUserInfo)
}

inline void CMsgDOTADPCUserInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.is_plus_subscriber_){false}
  };
}

CMsgDOTADPCUserInfo::~CMsgDOTADPCUserInfo() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCUserInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCUserInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTADPCUserInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCUserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCUserInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.is_plus_subscriber_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCUserInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_plus_subscriber = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_plus_subscriber(&has_bits);
          _impl_.is_plus_subscriber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCUserInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCUserInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_plus_subscriber = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_plus_subscriber(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCUserInfo)
  return target;
}

size_t CMsgDOTADPCUserInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCUserInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool is_plus_subscriber = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCUserInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCUserInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCUserInfo::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCUserInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCUserInfo*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCUserInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCUserInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_is_plus_subscriber()) {
    _this->_internal_set_is_plus_subscriber(from._internal_is_plus_subscriber());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCUserInfo::CopyFrom(const CMsgDOTADPCUserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCUserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCUserInfo::IsInitialized() const {
  return true;
}

void CMsgDOTADPCUserInfo::InternalSwap(CMsgDOTADPCUserInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.is_plus_subscriber_, other->_impl_.is_plus_subscriber_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCUserInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[4]);
}

// ===================================================================

class CMsgDraftTrivia_DraftTriviaHeroInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDraftTrivia_DraftTriviaHeroInfo>()._impl_._has_bits_);
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_role(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDraftTrivia_DraftTriviaHeroInfo::CMsgDraftTrivia_DraftTriviaHeroInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDraftTrivia.DraftTriviaHeroInfo)
}
CMsgDraftTrivia_DraftTriviaHeroInfo::CMsgDraftTrivia_DraftTriviaHeroInfo(const CMsgDraftTrivia_DraftTriviaHeroInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDraftTrivia_DraftTriviaHeroInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.role_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hero_id_, &from._impl_.hero_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.role_) -
    reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.role_));
  // @@protoc_insertion_point(copy_constructor:CMsgDraftTrivia.DraftTriviaHeroInfo)
}

inline void CMsgDraftTrivia_DraftTriviaHeroInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.role_){0u}
  };
}

CMsgDraftTrivia_DraftTriviaHeroInfo::~CMsgDraftTrivia_DraftTriviaHeroInfo() {
  // @@protoc_insertion_point(destructor:CMsgDraftTrivia.DraftTriviaHeroInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDraftTrivia_DraftTriviaHeroInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDraftTrivia_DraftTriviaHeroInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDraftTrivia_DraftTriviaHeroInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDraftTrivia.DraftTriviaHeroInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.hero_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.role_) -
        reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.role_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDraftTrivia_DraftTriviaHeroInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 hero_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 role = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_role(&has_bits);
          _impl_.role_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDraftTrivia_DraftTriviaHeroInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDraftTrivia.DraftTriviaHeroInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 hero_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hero_id(), target);
  }

  // optional uint32 role = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_role(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDraftTrivia.DraftTriviaHeroInfo)
  return target;
}

size_t CMsgDraftTrivia_DraftTriviaHeroInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDraftTrivia.DraftTriviaHeroInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 hero_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional uint32 role = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_role());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDraftTrivia_DraftTriviaHeroInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDraftTrivia_DraftTriviaHeroInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDraftTrivia_DraftTriviaHeroInfo::GetClassData() const { return &_class_data_; }


void CMsgDraftTrivia_DraftTriviaHeroInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDraftTrivia_DraftTriviaHeroInfo*>(&to_msg);
  auto& from = static_cast<const CMsgDraftTrivia_DraftTriviaHeroInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDraftTrivia.DraftTriviaHeroInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.role_ = from._impl_.role_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDraftTrivia_DraftTriviaHeroInfo::CopyFrom(const CMsgDraftTrivia_DraftTriviaHeroInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDraftTrivia.DraftTriviaHeroInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDraftTrivia_DraftTriviaHeroInfo::IsInitialized() const {
  return true;
}

void CMsgDraftTrivia_DraftTriviaHeroInfo::InternalSwap(CMsgDraftTrivia_DraftTriviaHeroInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDraftTrivia_DraftTriviaHeroInfo, _impl_.role_)
      + sizeof(CMsgDraftTrivia_DraftTriviaHeroInfo::_impl_.role_)
      - PROTOBUF_FIELD_OFFSET(CMsgDraftTrivia_DraftTriviaHeroInfo, _impl_.hero_id_)>(
          reinterpret_cast<char*>(&_impl_.hero_id_),
          reinterpret_cast<char*>(&other->_impl_.hero_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDraftTrivia_DraftTriviaHeroInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[5]);
}

// ===================================================================

class CMsgDraftTrivia_DraftTriviaMatchInfo::_Internal {
 public:
};

CMsgDraftTrivia_DraftTriviaMatchInfo::CMsgDraftTrivia_DraftTriviaMatchInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDraftTrivia.DraftTriviaMatchInfo)
}
CMsgDraftTrivia_DraftTriviaMatchInfo::CMsgDraftTrivia_DraftTriviaMatchInfo(const CMsgDraftTrivia_DraftTriviaMatchInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDraftTrivia_DraftTriviaMatchInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.radiant_heroes_){from._impl_.radiant_heroes_}
    , decltype(_impl_.dire_heroes_){from._impl_.dire_heroes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDraftTrivia.DraftTriviaMatchInfo)
}

inline void CMsgDraftTrivia_DraftTriviaMatchInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.radiant_heroes_){arena}
    , decltype(_impl_.dire_heroes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDraftTrivia_DraftTriviaMatchInfo::~CMsgDraftTrivia_DraftTriviaMatchInfo() {
  // @@protoc_insertion_point(destructor:CMsgDraftTrivia.DraftTriviaMatchInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDraftTrivia_DraftTriviaMatchInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.radiant_heroes_.~RepeatedPtrField();
  _impl_.dire_heroes_.~RepeatedPtrField();
}

void CMsgDraftTrivia_DraftTriviaMatchInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDraftTrivia_DraftTriviaMatchInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDraftTrivia.DraftTriviaMatchInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.radiant_heroes_.Clear();
  _impl_.dire_heroes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDraftTrivia_DraftTriviaMatchInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDraftTrivia.DraftTriviaHeroInfo radiant_heroes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_radiant_heroes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDraftTrivia.DraftTriviaHeroInfo dire_heroes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dire_heroes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDraftTrivia_DraftTriviaMatchInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDraftTrivia.DraftTriviaMatchInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDraftTrivia.DraftTriviaHeroInfo radiant_heroes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_radiant_heroes_size()); i < n; i++) {
    const auto& repfield = this->_internal_radiant_heroes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDraftTrivia.DraftTriviaHeroInfo dire_heroes = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dire_heroes_size()); i < n; i++) {
    const auto& repfield = this->_internal_dire_heroes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDraftTrivia.DraftTriviaMatchInfo)
  return target;
}

size_t CMsgDraftTrivia_DraftTriviaMatchInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDraftTrivia.DraftTriviaMatchInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDraftTrivia.DraftTriviaHeroInfo radiant_heroes = 1;
  total_size += 1UL * this->_internal_radiant_heroes_size();
  for (const auto& msg : this->_impl_.radiant_heroes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDraftTrivia.DraftTriviaHeroInfo dire_heroes = 2;
  total_size += 1UL * this->_internal_dire_heroes_size();
  for (const auto& msg : this->_impl_.dire_heroes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDraftTrivia_DraftTriviaMatchInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDraftTrivia_DraftTriviaMatchInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDraftTrivia_DraftTriviaMatchInfo::GetClassData() const { return &_class_data_; }


void CMsgDraftTrivia_DraftTriviaMatchInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDraftTrivia_DraftTriviaMatchInfo*>(&to_msg);
  auto& from = static_cast<const CMsgDraftTrivia_DraftTriviaMatchInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDraftTrivia.DraftTriviaMatchInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.radiant_heroes_.MergeFrom(from._impl_.radiant_heroes_);
  _this->_impl_.dire_heroes_.MergeFrom(from._impl_.dire_heroes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDraftTrivia_DraftTriviaMatchInfo::CopyFrom(const CMsgDraftTrivia_DraftTriviaMatchInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDraftTrivia.DraftTriviaMatchInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDraftTrivia_DraftTriviaMatchInfo::IsInitialized() const {
  return true;
}

void CMsgDraftTrivia_DraftTriviaMatchInfo::InternalSwap(CMsgDraftTrivia_DraftTriviaMatchInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.radiant_heroes_.InternalSwap(&other->_impl_.radiant_heroes_);
  _impl_.dire_heroes_.InternalSwap(&other->_impl_.dire_heroes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDraftTrivia_DraftTriviaMatchInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[6]);
}

// ===================================================================

class CMsgDraftTrivia_PreviousResult::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDraftTrivia_PreviousResult>()._impl_._has_bits_);
  static void set_has_voted_correctly(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_voted_radiant(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgDraftTrivia_DraftTriviaMatchInfo& match_hero_info(const CMsgDraftTrivia_PreviousResult* msg);
  static void set_has_match_hero_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_match_rank_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgDraftTrivia_DraftTriviaMatchInfo&
CMsgDraftTrivia_PreviousResult::_Internal::match_hero_info(const CMsgDraftTrivia_PreviousResult* msg) {
  return *msg->_impl_.match_hero_info_;
}
CMsgDraftTrivia_PreviousResult::CMsgDraftTrivia_PreviousResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDraftTrivia.PreviousResult)
}
CMsgDraftTrivia_PreviousResult::CMsgDraftTrivia_PreviousResult(const CMsgDraftTrivia_PreviousResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDraftTrivia_PreviousResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_hero_info_){nullptr}
    , decltype(_impl_.voted_correctly_){}
    , decltype(_impl_.voted_radiant_){}
    , decltype(_impl_.match_rank_tier_){}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.end_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_match_hero_info()) {
    _this->_impl_.match_hero_info_ = new ::CMsgDraftTrivia_DraftTriviaMatchInfo(*from._impl_.match_hero_info_);
  }
  ::memcpy(&_impl_.voted_correctly_, &from._impl_.voted_correctly_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.end_time_) -
    reinterpret_cast<char*>(&_impl_.voted_correctly_)) + sizeof(_impl_.end_time_));
  // @@protoc_insertion_point(copy_constructor:CMsgDraftTrivia.PreviousResult)
}

inline void CMsgDraftTrivia_PreviousResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_hero_info_){nullptr}
    , decltype(_impl_.voted_correctly_){false}
    , decltype(_impl_.voted_radiant_){false}
    , decltype(_impl_.match_rank_tier_){0u}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.end_time_){0u}
  };
}

CMsgDraftTrivia_PreviousResult::~CMsgDraftTrivia_PreviousResult() {
  // @@protoc_insertion_point(destructor:CMsgDraftTrivia.PreviousResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDraftTrivia_PreviousResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.match_hero_info_;
}

void CMsgDraftTrivia_PreviousResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDraftTrivia_PreviousResult::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDraftTrivia.PreviousResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.match_hero_info_ != nullptr);
    _impl_.match_hero_info_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.voted_correctly_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.end_time_) -
        reinterpret_cast<char*>(&_impl_.voted_correctly_)) + sizeof(_impl_.end_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDraftTrivia_PreviousResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool voted_correctly = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_voted_correctly(&has_bits);
          _impl_.voted_correctly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool voted_radiant = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_voted_radiant(&has_bits);
          _impl_.voted_radiant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDraftTrivia.DraftTriviaMatchInfo match_hero_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_match_hero_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 match_rank_tier = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_match_rank_tier(&has_bits);
          _impl_.match_rank_tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 end_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_end_time(&has_bits);
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 match_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDraftTrivia_PreviousResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDraftTrivia.PreviousResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool voted_correctly = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_voted_correctly(), target);
  }

  // optional bool voted_radiant = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_voted_radiant(), target);
  }

  // optional .CMsgDraftTrivia.DraftTriviaMatchInfo match_hero_info = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::match_hero_info(this),
        _Internal::match_hero_info(this).GetCachedSize(), target, stream);
  }

  // optional uint32 match_rank_tier = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_match_rank_tier(), target);
  }

  // optional uint32 end_time = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_end_time(), target);
  }

  // optional uint64 match_id = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_match_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDraftTrivia.PreviousResult)
  return target;
}

size_t CMsgDraftTrivia_PreviousResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDraftTrivia.PreviousResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .CMsgDraftTrivia.DraftTriviaMatchInfo match_hero_info = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.match_hero_info_);
    }

    // optional bool voted_correctly = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool voted_radiant = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 match_rank_tier = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_match_rank_tier());
    }

    // optional uint64 match_id = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 end_time = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDraftTrivia_PreviousResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDraftTrivia_PreviousResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDraftTrivia_PreviousResult::GetClassData() const { return &_class_data_; }


void CMsgDraftTrivia_PreviousResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDraftTrivia_PreviousResult*>(&to_msg);
  auto& from = static_cast<const CMsgDraftTrivia_PreviousResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDraftTrivia.PreviousResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_match_hero_info()->::CMsgDraftTrivia_DraftTriviaMatchInfo::MergeFrom(
          from._internal_match_hero_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.voted_correctly_ = from._impl_.voted_correctly_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.voted_radiant_ = from._impl_.voted_radiant_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.match_rank_tier_ = from._impl_.match_rank_tier_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.end_time_ = from._impl_.end_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDraftTrivia_PreviousResult::CopyFrom(const CMsgDraftTrivia_PreviousResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDraftTrivia.PreviousResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDraftTrivia_PreviousResult::IsInitialized() const {
  return true;
}

void CMsgDraftTrivia_PreviousResult::InternalSwap(CMsgDraftTrivia_PreviousResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDraftTrivia_PreviousResult, _impl_.end_time_)
      + sizeof(CMsgDraftTrivia_PreviousResult::_impl_.end_time_)
      - PROTOBUF_FIELD_OFFSET(CMsgDraftTrivia_PreviousResult, _impl_.match_hero_info_)>(
          reinterpret_cast<char*>(&_impl_.match_hero_info_),
          reinterpret_cast<char*>(&other->_impl_.match_hero_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDraftTrivia_PreviousResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[7]);
}

// ===================================================================

class CMsgDraftTrivia::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDraftTrivia>()._impl_._has_bits_);
  static void set_has_has_valid_match(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgDraftTrivia_DraftTriviaMatchInfo& match_hero_info(const CMsgDraftTrivia* msg);
  static void set_has_match_hero_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_match_rank_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_current_match_voted_radiant(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgDraftTrivia_PreviousResult& previous_result(const CMsgDraftTrivia* msg);
  static void set_has_previous_result(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_current_streak(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::CMsgDraftTrivia_DraftTriviaMatchInfo&
CMsgDraftTrivia::_Internal::match_hero_info(const CMsgDraftTrivia* msg) {
  return *msg->_impl_.match_hero_info_;
}
const ::CMsgDraftTrivia_PreviousResult&
CMsgDraftTrivia::_Internal::previous_result(const CMsgDraftTrivia* msg) {
  return *msg->_impl_.previous_result_;
}
CMsgDraftTrivia::CMsgDraftTrivia(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDraftTrivia)
}
CMsgDraftTrivia::CMsgDraftTrivia(const CMsgDraftTrivia& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDraftTrivia* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_hero_info_){nullptr}
    , decltype(_impl_.previous_result_){nullptr}
    , decltype(_impl_.match_rank_tier_){}
    , decltype(_impl_.has_valid_match_){}
    , decltype(_impl_.current_match_voted_radiant_){}
    , decltype(_impl_.end_time_){}
    , decltype(_impl_.event_id_){}
    , decltype(_impl_.current_streak_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_match_hero_info()) {
    _this->_impl_.match_hero_info_ = new ::CMsgDraftTrivia_DraftTriviaMatchInfo(*from._impl_.match_hero_info_);
  }
  if (from._internal_has_previous_result()) {
    _this->_impl_.previous_result_ = new ::CMsgDraftTrivia_PreviousResult(*from._impl_.previous_result_);
  }
  ::memcpy(&_impl_.match_rank_tier_, &from._impl_.match_rank_tier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.current_streak_) -
    reinterpret_cast<char*>(&_impl_.match_rank_tier_)) + sizeof(_impl_.current_streak_));
  // @@protoc_insertion_point(copy_constructor:CMsgDraftTrivia)
}

inline void CMsgDraftTrivia::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_hero_info_){nullptr}
    , decltype(_impl_.previous_result_){nullptr}
    , decltype(_impl_.match_rank_tier_){0u}
    , decltype(_impl_.has_valid_match_){false}
    , decltype(_impl_.current_match_voted_radiant_){false}
    , decltype(_impl_.end_time_){0u}
    , decltype(_impl_.event_id_){0u}
    , decltype(_impl_.current_streak_){0u}
  };
}

CMsgDraftTrivia::~CMsgDraftTrivia() {
  // @@protoc_insertion_point(destructor:CMsgDraftTrivia)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDraftTrivia::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.match_hero_info_;
  if (this != internal_default_instance()) delete _impl_.previous_result_;
}

void CMsgDraftTrivia::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDraftTrivia::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDraftTrivia)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.match_hero_info_ != nullptr);
      _impl_.match_hero_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.previous_result_ != nullptr);
      _impl_.previous_result_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.match_rank_tier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.current_streak_) -
        reinterpret_cast<char*>(&_impl_.match_rank_tier_)) + sizeof(_impl_.current_streak_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDraftTrivia::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool has_valid_match = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_has_valid_match(&has_bits);
          _impl_.has_valid_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDraftTrivia.DraftTriviaMatchInfo match_hero_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_match_hero_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 match_rank_tier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_match_rank_tier(&has_bits);
          _impl_.match_rank_tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 end_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_end_time(&has_bits);
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 event_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_event_id(&has_bits);
          _impl_.event_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool current_match_voted_radiant = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_current_match_voted_radiant(&has_bits);
          _impl_.current_match_voted_radiant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDraftTrivia.PreviousResult previous_result = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_previous_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 current_streak = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_current_streak(&has_bits);
          _impl_.current_streak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDraftTrivia::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDraftTrivia)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool has_valid_match = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_has_valid_match(), target);
  }

  // optional .CMsgDraftTrivia.DraftTriviaMatchInfo match_hero_info = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::match_hero_info(this),
        _Internal::match_hero_info(this).GetCachedSize(), target, stream);
  }

  // optional uint32 match_rank_tier = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_match_rank_tier(), target);
  }

  // optional uint32 end_time = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_end_time(), target);
  }

  // optional uint32 event_id = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_event_id(), target);
  }

  // optional bool current_match_voted_radiant = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_current_match_voted_radiant(), target);
  }

  // optional .CMsgDraftTrivia.PreviousResult previous_result = 7;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::previous_result(this),
        _Internal::previous_result(this).GetCachedSize(), target, stream);
  }

  // optional uint32 current_streak = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_current_streak(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDraftTrivia)
  return target;
}

size_t CMsgDraftTrivia::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDraftTrivia)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgDraftTrivia.DraftTriviaMatchInfo match_hero_info = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.match_hero_info_);
    }

    // optional .CMsgDraftTrivia.PreviousResult previous_result = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.previous_result_);
    }

    // optional uint32 match_rank_tier = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_match_rank_tier());
    }

    // optional bool has_valid_match = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool current_match_voted_radiant = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint32 end_time = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_time());
    }

    // optional uint32 event_id = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_event_id());
    }

    // optional uint32 current_streak = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_current_streak());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDraftTrivia::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDraftTrivia::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDraftTrivia::GetClassData() const { return &_class_data_; }


void CMsgDraftTrivia::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDraftTrivia*>(&to_msg);
  auto& from = static_cast<const CMsgDraftTrivia&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDraftTrivia)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_match_hero_info()->::CMsgDraftTrivia_DraftTriviaMatchInfo::MergeFrom(
          from._internal_match_hero_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_previous_result()->::CMsgDraftTrivia_PreviousResult::MergeFrom(
          from._internal_previous_result());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.match_rank_tier_ = from._impl_.match_rank_tier_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.has_valid_match_ = from._impl_.has_valid_match_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.current_match_voted_radiant_ = from._impl_.current_match_voted_radiant_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.end_time_ = from._impl_.end_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.current_streak_ = from._impl_.current_streak_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDraftTrivia::CopyFrom(const CMsgDraftTrivia& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDraftTrivia)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDraftTrivia::IsInitialized() const {
  return true;
}

void CMsgDraftTrivia::InternalSwap(CMsgDraftTrivia* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDraftTrivia, _impl_.current_streak_)
      + sizeof(CMsgDraftTrivia::_impl_.current_streak_)
      - PROTOBUF_FIELD_OFFSET(CMsgDraftTrivia, _impl_.match_hero_info_)>(
          reinterpret_cast<char*>(&_impl_.match_hero_info_),
          reinterpret_cast<char*>(&other->_impl_.match_hero_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDraftTrivia::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[8]);
}

// ===================================================================

class CMsgTeamFanContentAssetStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTeamFanContentAssetStatus>()._impl_._has_bits_);
  static void set_has_asset_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_asset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_asset_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_crc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgTeamFanContentAssetStatus::CMsgTeamFanContentAssetStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTeamFanContentAssetStatus)
}
CMsgTeamFanContentAssetStatus::CMsgTeamFanContentAssetStatus(const CMsgTeamFanContentAssetStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTeamFanContentAssetStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.asset_index_){}
    , decltype(_impl_.asset_status_){}
    , decltype(_impl_.crc_){}
    , decltype(_impl_.asset_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.asset_index_, &from._impl_.asset_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.asset_type_) -
    reinterpret_cast<char*>(&_impl_.asset_index_)) + sizeof(_impl_.asset_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgTeamFanContentAssetStatus)
}

inline void CMsgTeamFanContentAssetStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.asset_index_){0u}
    , decltype(_impl_.asset_status_){0}
    , decltype(_impl_.crc_){0u}
    , decltype(_impl_.asset_type_){1}
  };
}

CMsgTeamFanContentAssetStatus::~CMsgTeamFanContentAssetStatus() {
  // @@protoc_insertion_point(destructor:CMsgTeamFanContentAssetStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTeamFanContentAssetStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgTeamFanContentAssetStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTeamFanContentAssetStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTeamFanContentAssetStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.asset_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.crc_) -
        reinterpret_cast<char*>(&_impl_.asset_index_)) + sizeof(_impl_.crc_));
    _impl_.asset_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTeamFanContentAssetStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ETeamFanContentAssetType asset_type = 1 [default = k_eFanContentAssetType_LogoPNG];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ETeamFanContentAssetType_IsValid(val))) {
            _internal_set_asset_type(static_cast<::ETeamFanContentAssetType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 asset_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_asset_index(&has_bits);
          _impl_.asset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ETeamFanContentAssetStatus asset_status = 3 [default = k_eFanContentAssetStatus_None];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ETeamFanContentAssetStatus_IsValid(val))) {
            _internal_set_asset_status(static_cast<::ETeamFanContentAssetStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 crc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_crc(&has_bits);
          _impl_.crc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTeamFanContentAssetStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTeamFanContentAssetStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .ETeamFanContentAssetType asset_type = 1 [default = k_eFanContentAssetType_LogoPNG];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_asset_type(), target);
  }

  // optional uint32 asset_index = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_asset_index(), target);
  }

  // optional .ETeamFanContentAssetStatus asset_status = 3 [default = k_eFanContentAssetStatus_None];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_asset_status(), target);
  }

  // optional uint32 crc = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_crc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTeamFanContentAssetStatus)
  return target;
}

size_t CMsgTeamFanContentAssetStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTeamFanContentAssetStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 asset_index = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_asset_index());
    }

    // optional .ETeamFanContentAssetStatus asset_status = 3 [default = k_eFanContentAssetStatus_None];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_asset_status());
    }

    // optional uint32 crc = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_crc());
    }

    // optional .ETeamFanContentAssetType asset_type = 1 [default = k_eFanContentAssetType_LogoPNG];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_asset_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTeamFanContentAssetStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTeamFanContentAssetStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTeamFanContentAssetStatus::GetClassData() const { return &_class_data_; }


void CMsgTeamFanContentAssetStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTeamFanContentAssetStatus*>(&to_msg);
  auto& from = static_cast<const CMsgTeamFanContentAssetStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTeamFanContentAssetStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.asset_index_ = from._impl_.asset_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.asset_status_ = from._impl_.asset_status_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.crc_ = from._impl_.crc_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.asset_type_ = from._impl_.asset_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTeamFanContentAssetStatus::CopyFrom(const CMsgTeamFanContentAssetStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTeamFanContentAssetStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTeamFanContentAssetStatus::IsInitialized() const {
  return true;
}

void CMsgTeamFanContentAssetStatus::InternalSwap(CMsgTeamFanContentAssetStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTeamFanContentAssetStatus, _impl_.crc_)
      + sizeof(CMsgTeamFanContentAssetStatus::_impl_.crc_)
      - PROTOBUF_FIELD_OFFSET(CMsgTeamFanContentAssetStatus, _impl_.asset_index_)>(
          reinterpret_cast<char*>(&_impl_.asset_index_),
          reinterpret_cast<char*>(&other->_impl_.asset_index_));
  swap(_impl_.asset_type_, other->_impl_.asset_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTeamFanContentAssetStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[9]);
}

// ===================================================================

class CMsgTeamFanContentAssetStatusResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTeamFanContentAssetStatusResponse>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgTeamFanContentAssetStatusResponse::CMsgTeamFanContentAssetStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTeamFanContentAssetStatusResponse)
}
CMsgTeamFanContentAssetStatusResponse::CMsgTeamFanContentAssetStatusResponse(const CMsgTeamFanContentAssetStatusResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTeamFanContentAssetStatusResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:CMsgTeamFanContentAssetStatusResponse)
}

inline void CMsgTeamFanContentAssetStatusResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

CMsgTeamFanContentAssetStatusResponse::~CMsgTeamFanContentAssetStatusResponse() {
  // @@protoc_insertion_point(destructor:CMsgTeamFanContentAssetStatusResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTeamFanContentAssetStatusResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgTeamFanContentAssetStatusResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTeamFanContentAssetStatusResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTeamFanContentAssetStatusResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTeamFanContentAssetStatusResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgTeamFanContentAssetStatusResponse.EResult result = 1 [default = k_eSuccess];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgTeamFanContentAssetStatusResponse_EResult_IsValid(val))) {
            _internal_set_result(static_cast<::CMsgTeamFanContentAssetStatusResponse_EResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTeamFanContentAssetStatusResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTeamFanContentAssetStatusResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgTeamFanContentAssetStatusResponse.EResult result = 1 [default = k_eSuccess];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTeamFanContentAssetStatusResponse)
  return target;
}

size_t CMsgTeamFanContentAssetStatusResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTeamFanContentAssetStatusResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgTeamFanContentAssetStatusResponse.EResult result = 1 [default = k_eSuccess];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTeamFanContentAssetStatusResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTeamFanContentAssetStatusResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTeamFanContentAssetStatusResponse::GetClassData() const { return &_class_data_; }


void CMsgTeamFanContentAssetStatusResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTeamFanContentAssetStatusResponse*>(&to_msg);
  auto& from = static_cast<const CMsgTeamFanContentAssetStatusResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTeamFanContentAssetStatusResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTeamFanContentAssetStatusResponse::CopyFrom(const CMsgTeamFanContentAssetStatusResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTeamFanContentAssetStatusResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTeamFanContentAssetStatusResponse::IsInitialized() const {
  return true;
}

void CMsgTeamFanContentAssetStatusResponse::InternalSwap(CMsgTeamFanContentAssetStatusResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTeamFanContentAssetStatusResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[10]);
}

// ===================================================================

class CMsgTeamFanContentStatus_TeamStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTeamFanContentStatus_TeamStatus>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_logo_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ugc_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_workshop_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_abbreviation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_voiceline_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_spray_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_emoticon_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_wallpaper_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_comment_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_email_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_email_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_languages(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgTeamFanContentStatus_TeamStatus::CMsgTeamFanContentStatus_TeamStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTeamFanContentStatus.TeamStatus)
}
CMsgTeamFanContentStatus_TeamStatus::CMsgTeamFanContentStatus_TeamStatus(const CMsgTeamFanContentStatus_TeamStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTeamFanContentStatus_TeamStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.asset_status_){from._impl_.asset_status_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.logo_url_){}
    , decltype(_impl_.abbreviation_){}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.languages_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.workshop_account_id_){}
    , decltype(_impl_.ugc_logo_){}
    , decltype(_impl_.voiceline_count_){}
    , decltype(_impl_.spray_count_){}
    , decltype(_impl_.emoticon_count_){}
    , decltype(_impl_.wallpaper_count_){}
    , decltype(_impl_.comment_timestamp_){}
    , decltype(_impl_.email_timestamp_){}
    , decltype(_impl_.email_tier_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_logo_url()) {
    _this->_impl_.logo_url_.Set(from._internal_logo_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.abbreviation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.abbreviation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_abbreviation()) {
    _this->_impl_.abbreviation_.Set(from._internal_abbreviation(), 
      _this->GetArenaForAllocation());
  }
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comment()) {
    _this->_impl_.comment_.Set(from._internal_comment(), 
      _this->GetArenaForAllocation());
  }
  _impl_.languages_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.languages_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_languages()) {
    _this->_impl_.languages_.Set(from._internal_languages(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.team_id_, &from._impl_.team_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.email_tier_) -
    reinterpret_cast<char*>(&_impl_.team_id_)) + sizeof(_impl_.email_tier_));
  // @@protoc_insertion_point(copy_constructor:CMsgTeamFanContentStatus.TeamStatus)
}

inline void CMsgTeamFanContentStatus_TeamStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.asset_status_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.logo_url_){}
    , decltype(_impl_.abbreviation_){}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.languages_){}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.timestamp_){0u}
    , decltype(_impl_.workshop_account_id_){0u}
    , decltype(_impl_.ugc_logo_){uint64_t{0u}}
    , decltype(_impl_.voiceline_count_){0u}
    , decltype(_impl_.spray_count_){0u}
    , decltype(_impl_.emoticon_count_){0u}
    , decltype(_impl_.wallpaper_count_){0u}
    , decltype(_impl_.comment_timestamp_){0u}
    , decltype(_impl_.email_timestamp_){0u}
    , decltype(_impl_.email_tier_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.abbreviation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.abbreviation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.languages_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.languages_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgTeamFanContentStatus_TeamStatus::~CMsgTeamFanContentStatus_TeamStatus() {
  // @@protoc_insertion_point(destructor:CMsgTeamFanContentStatus.TeamStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTeamFanContentStatus_TeamStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.asset_status_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.logo_url_.Destroy();
  _impl_.abbreviation_.Destroy();
  _impl_.comment_.Destroy();
  _impl_.languages_.Destroy();
}

void CMsgTeamFanContentStatus_TeamStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTeamFanContentStatus_TeamStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTeamFanContentStatus.TeamStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.asset_status_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.logo_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.abbreviation_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.comment_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.languages_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.team_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timestamp_) -
        reinterpret_cast<char*>(&_impl_.team_id_)) + sizeof(_impl_.timestamp_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.workshop_account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.email_timestamp_) -
        reinterpret_cast<char*>(&_impl_.workshop_account_id_)) + sizeof(_impl_.email_timestamp_));
  }
  _impl_.email_tier_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTeamFanContentStatus_TeamStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgTeamFanContentStatus.TeamStatus.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string logo_url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_logo_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgTeamFanContentStatus.TeamStatus.logo_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ETeamFanContentStatus status = 4 [default = TEAM_FAN_CONTENT_STATUS_INVALID];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ETeamFanContentStatus_IsValid(val))) {
            _internal_set_status(static_cast<::ETeamFanContentStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ugc_logo = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_ugc_logo(&has_bits);
          _impl_.ugc_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 workshop_account_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_workshop_account_id(&has_bits);
          _impl_.workshop_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string abbreviation = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_abbreviation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgTeamFanContentStatus.TeamStatus.abbreviation");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 voiceline_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_voiceline_count(&has_bits);
          _impl_.voiceline_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 spray_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_spray_count(&has_bits);
          _impl_.spray_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 emoticon_count = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_emoticon_count(&has_bits);
          _impl_.emoticon_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 wallpaper_count = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_wallpaper_count(&has_bits);
          _impl_.wallpaper_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string comment = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgTeamFanContentStatus.TeamStatus.comment");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 comment_timestamp = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_comment_timestamp(&has_bits);
          _impl_.comment_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgTeamFanContentAssetStatus asset_status = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_asset_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 email_timestamp = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_email_timestamp(&has_bits);
          _impl_.email_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 email_tier = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_email_tier(&has_bits);
          _impl_.email_tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string languages = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_languages();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgTeamFanContentStatus.TeamStatus.languages");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTeamFanContentStatus_TeamStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTeamFanContentStatus.TeamStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTeamFanContentStatus.TeamStatus.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 team_id = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_team_id(), target);
  }

  // optional string logo_url = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_logo_url().data(), static_cast<int>(this->_internal_logo_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTeamFanContentStatus.TeamStatus.logo_url");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_logo_url(), target);
  }

  // optional .ETeamFanContentStatus status = 4 [default = TEAM_FAN_CONTENT_STATUS_INVALID];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_status(), target);
  }

  // optional uint32 timestamp = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_timestamp(), target);
  }

  // optional uint64 ugc_logo = 7;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_ugc_logo(), target);
  }

  // optional uint32 workshop_account_id = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_workshop_account_id(), target);
  }

  // optional string abbreviation = 9;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_abbreviation().data(), static_cast<int>(this->_internal_abbreviation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTeamFanContentStatus.TeamStatus.abbreviation");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_abbreviation(), target);
  }

  // optional uint32 voiceline_count = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_voiceline_count(), target);
  }

  // optional uint32 spray_count = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_spray_count(), target);
  }

  // optional uint32 emoticon_count = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_emoticon_count(), target);
  }

  // optional uint32 wallpaper_count = 13;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_wallpaper_count(), target);
  }

  // optional string comment = 14;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTeamFanContentStatus.TeamStatus.comment");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_comment(), target);
  }

  // optional uint32 comment_timestamp = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_comment_timestamp(), target);
  }

  // repeated .CMsgTeamFanContentAssetStatus asset_status = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_asset_status_size()); i < n; i++) {
    const auto& repfield = this->_internal_asset_status(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 email_timestamp = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_email_timestamp(), target);
  }

  // optional uint32 email_tier = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_email_tier(), target);
  }

  // optional string languages = 19;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_languages().data(), static_cast<int>(this->_internal_languages().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTeamFanContentStatus.TeamStatus.languages");
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_languages(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTeamFanContentStatus.TeamStatus)
  return target;
}

size_t CMsgTeamFanContentStatus_TeamStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTeamFanContentStatus.TeamStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgTeamFanContentAssetStatus asset_status = 16;
  total_size += 2UL * this->_internal_asset_status_size();
  for (const auto& msg : this->_impl_.asset_status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string logo_url = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_logo_url());
    }

    // optional string abbreviation = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_abbreviation());
    }

    // optional string comment = 14;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comment());
    }

    // optional string languages = 19;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_languages());
    }

    // optional uint32 team_id = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional .ETeamFanContentStatus status = 4 [default = TEAM_FAN_CONTENT_STATUS_INVALID];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional uint32 timestamp = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 workshop_account_id = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_workshop_account_id());
    }

    // optional uint64 ugc_logo = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ugc_logo());
    }

    // optional uint32 voiceline_count = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_voiceline_count());
    }

    // optional uint32 spray_count = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_spray_count());
    }

    // optional uint32 emoticon_count = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_emoticon_count());
    }

    // optional uint32 wallpaper_count = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_wallpaper_count());
    }

    // optional uint32 comment_timestamp = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_comment_timestamp());
    }

    // optional uint32 email_timestamp = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_email_timestamp());
    }

  }
  // optional uint32 email_tier = 18;
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_email_tier());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTeamFanContentStatus_TeamStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTeamFanContentStatus_TeamStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTeamFanContentStatus_TeamStatus::GetClassData() const { return &_class_data_; }


void CMsgTeamFanContentStatus_TeamStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTeamFanContentStatus_TeamStatus*>(&to_msg);
  auto& from = static_cast<const CMsgTeamFanContentStatus_TeamStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTeamFanContentStatus.TeamStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.asset_status_.MergeFrom(from._impl_.asset_status_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_logo_url(from._internal_logo_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_abbreviation(from._internal_abbreviation());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_comment(from._internal_comment());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_languages(from._internal_languages());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.workshop_account_id_ = from._impl_.workshop_account_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.ugc_logo_ = from._impl_.ugc_logo_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.voiceline_count_ = from._impl_.voiceline_count_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.spray_count_ = from._impl_.spray_count_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.emoticon_count_ = from._impl_.emoticon_count_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.wallpaper_count_ = from._impl_.wallpaper_count_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.comment_timestamp_ = from._impl_.comment_timestamp_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.email_timestamp_ = from._impl_.email_timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _this->_internal_set_email_tier(from._internal_email_tier());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTeamFanContentStatus_TeamStatus::CopyFrom(const CMsgTeamFanContentStatus_TeamStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTeamFanContentStatus.TeamStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTeamFanContentStatus_TeamStatus::IsInitialized() const {
  return true;
}

void CMsgTeamFanContentStatus_TeamStatus::InternalSwap(CMsgTeamFanContentStatus_TeamStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.asset_status_.InternalSwap(&other->_impl_.asset_status_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.logo_url_, lhs_arena,
      &other->_impl_.logo_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.abbreviation_, lhs_arena,
      &other->_impl_.abbreviation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_, lhs_arena,
      &other->_impl_.comment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.languages_, lhs_arena,
      &other->_impl_.languages_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTeamFanContentStatus_TeamStatus, _impl_.email_tier_)
      + sizeof(CMsgTeamFanContentStatus_TeamStatus::_impl_.email_tier_)
      - PROTOBUF_FIELD_OFFSET(CMsgTeamFanContentStatus_TeamStatus, _impl_.team_id_)>(
          reinterpret_cast<char*>(&_impl_.team_id_),
          reinterpret_cast<char*>(&other->_impl_.team_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTeamFanContentStatus_TeamStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[11]);
}

// ===================================================================

class CMsgTeamFanContentStatus::_Internal {
 public:
};

CMsgTeamFanContentStatus::CMsgTeamFanContentStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTeamFanContentStatus)
}
CMsgTeamFanContentStatus::CMsgTeamFanContentStatus(const CMsgTeamFanContentStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTeamFanContentStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.team_status_list_){from._impl_.team_status_list_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgTeamFanContentStatus)
}

inline void CMsgTeamFanContentStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.team_status_list_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgTeamFanContentStatus::~CMsgTeamFanContentStatus() {
  // @@protoc_insertion_point(destructor:CMsgTeamFanContentStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTeamFanContentStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.team_status_list_.~RepeatedPtrField();
}

void CMsgTeamFanContentStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTeamFanContentStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTeamFanContentStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.team_status_list_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTeamFanContentStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgTeamFanContentStatus.TeamStatus team_status_list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_team_status_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTeamFanContentStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTeamFanContentStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgTeamFanContentStatus.TeamStatus team_status_list = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_team_status_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_team_status_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTeamFanContentStatus)
  return target;
}

size_t CMsgTeamFanContentStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTeamFanContentStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgTeamFanContentStatus.TeamStatus team_status_list = 1;
  total_size += 1UL * this->_internal_team_status_list_size();
  for (const auto& msg : this->_impl_.team_status_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTeamFanContentStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTeamFanContentStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTeamFanContentStatus::GetClassData() const { return &_class_data_; }


void CMsgTeamFanContentStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTeamFanContentStatus*>(&to_msg);
  auto& from = static_cast<const CMsgTeamFanContentStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTeamFanContentStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.team_status_list_.MergeFrom(from._impl_.team_status_list_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTeamFanContentStatus::CopyFrom(const CMsgTeamFanContentStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTeamFanContentStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTeamFanContentStatus::IsInitialized() const {
  return true;
}

void CMsgTeamFanContentStatus::InternalSwap(CMsgTeamFanContentStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.team_status_list_.InternalSwap(&other->_impl_.team_status_list_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTeamFanContentStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[12]);
}

// ===================================================================

class CMsgTeamFanContentAutographStatus_AutographStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTeamFanContentAutographStatus_AutographStatus>()._impl_._has_bits_);
  static void set_has_pro_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_file(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgTeamFanContentAutographStatus_AutographStatus::CMsgTeamFanContentAutographStatus_AutographStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTeamFanContentAutographStatus.AutographStatus)
}
CMsgTeamFanContentAutographStatus_AutographStatus::CMsgTeamFanContentAutographStatus_AutographStatus(const CMsgTeamFanContentAutographStatus_AutographStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTeamFanContentAutographStatus_AutographStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pro_name_){}
    , decltype(_impl_.file_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.timestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pro_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pro_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pro_name()) {
    _this->_impl_.pro_name_.Set(from._internal_pro_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file()) {
    _this->_impl_.file_.Set(from._internal_file(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timestamp_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.timestamp_));
  // @@protoc_insertion_point(copy_constructor:CMsgTeamFanContentAutographStatus.AutographStatus)
}

inline void CMsgTeamFanContentAutographStatus_AutographStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pro_name_){}
    , decltype(_impl_.file_){}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.timestamp_){0u}
  };
  _impl_.pro_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pro_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgTeamFanContentAutographStatus_AutographStatus::~CMsgTeamFanContentAutographStatus_AutographStatus() {
  // @@protoc_insertion_point(destructor:CMsgTeamFanContentAutographStatus.AutographStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTeamFanContentAutographStatus_AutographStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pro_name_.Destroy();
  _impl_.file_.Destroy();
}

void CMsgTeamFanContentAutographStatus_AutographStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTeamFanContentAutographStatus_AutographStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTeamFanContentAutographStatus.AutographStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.pro_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.file_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timestamp_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.timestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTeamFanContentAutographStatus_AutographStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string pro_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pro_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgTeamFanContentAutographStatus.AutographStatus.pro_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string file = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_file();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgTeamFanContentAutographStatus.AutographStatus.file");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTeamFanContentAutographStatus_AutographStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTeamFanContentAutographStatus.AutographStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string pro_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pro_name().data(), static_cast<int>(this->_internal_pro_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTeamFanContentAutographStatus.AutographStatus.pro_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_pro_name(), target);
  }

  // optional uint32 account_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_account_id(), target);
  }

  // optional uint32 timestamp = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_timestamp(), target);
  }

  // optional string file = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_file().data(), static_cast<int>(this->_internal_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTeamFanContentAutographStatus.AutographStatus.file");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_file(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTeamFanContentAutographStatus.AutographStatus)
  return target;
}

size_t CMsgTeamFanContentAutographStatus_AutographStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTeamFanContentAutographStatus.AutographStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string pro_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pro_name());
    }

    // optional string file = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_file());
    }

    // optional uint32 account_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 timestamp = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTeamFanContentAutographStatus_AutographStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTeamFanContentAutographStatus_AutographStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTeamFanContentAutographStatus_AutographStatus::GetClassData() const { return &_class_data_; }


void CMsgTeamFanContentAutographStatus_AutographStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTeamFanContentAutographStatus_AutographStatus*>(&to_msg);
  auto& from = static_cast<const CMsgTeamFanContentAutographStatus_AutographStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTeamFanContentAutographStatus.AutographStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_pro_name(from._internal_pro_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_file(from._internal_file());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTeamFanContentAutographStatus_AutographStatus::CopyFrom(const CMsgTeamFanContentAutographStatus_AutographStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTeamFanContentAutographStatus.AutographStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTeamFanContentAutographStatus_AutographStatus::IsInitialized() const {
  return true;
}

void CMsgTeamFanContentAutographStatus_AutographStatus::InternalSwap(CMsgTeamFanContentAutographStatus_AutographStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pro_name_, lhs_arena,
      &other->_impl_.pro_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_, lhs_arena,
      &other->_impl_.file_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTeamFanContentAutographStatus_AutographStatus, _impl_.timestamp_)
      + sizeof(CMsgTeamFanContentAutographStatus_AutographStatus::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(CMsgTeamFanContentAutographStatus_AutographStatus, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTeamFanContentAutographStatus_AutographStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[13]);
}

// ===================================================================

class CMsgTeamFanContentAutographStatus_TeamStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTeamFanContentAutographStatus_TeamStatus>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_workshop_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgTeamFanContentAutographStatus_TeamStatus::CMsgTeamFanContentAutographStatus_TeamStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTeamFanContentAutographStatus.TeamStatus)
}
CMsgTeamFanContentAutographStatus_TeamStatus::CMsgTeamFanContentAutographStatus_TeamStatus(const CMsgTeamFanContentAutographStatus_TeamStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTeamFanContentAutographStatus_TeamStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.autographs_){from._impl_.autographs_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.workshop_account_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.team_id_, &from._impl_.team_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.workshop_account_id_) -
    reinterpret_cast<char*>(&_impl_.team_id_)) + sizeof(_impl_.workshop_account_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgTeamFanContentAutographStatus.TeamStatus)
}

inline void CMsgTeamFanContentAutographStatus_TeamStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.autographs_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.workshop_account_id_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgTeamFanContentAutographStatus_TeamStatus::~CMsgTeamFanContentAutographStatus_TeamStatus() {
  // @@protoc_insertion_point(destructor:CMsgTeamFanContentAutographStatus.TeamStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTeamFanContentAutographStatus_TeamStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.autographs_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void CMsgTeamFanContentAutographStatus_TeamStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTeamFanContentAutographStatus_TeamStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTeamFanContentAutographStatus.TeamStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.autographs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.team_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.workshop_account_id_) -
        reinterpret_cast<char*>(&_impl_.team_id_)) + sizeof(_impl_.workshop_account_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTeamFanContentAutographStatus_TeamStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgTeamFanContentAutographStatus.TeamStatus.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgTeamFanContentAutographStatus.AutographStatus autographs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_autographs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 workshop_account_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_workshop_account_id(&has_bits);
          _impl_.workshop_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTeamFanContentAutographStatus_TeamStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTeamFanContentAutographStatus.TeamStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTeamFanContentAutographStatus.TeamStatus.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 team_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_team_id(), target);
  }

  // repeated .CMsgTeamFanContentAutographStatus.AutographStatus autographs = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_autographs_size()); i < n; i++) {
    const auto& repfield = this->_internal_autographs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 workshop_account_id = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_workshop_account_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTeamFanContentAutographStatus.TeamStatus)
  return target;
}

size_t CMsgTeamFanContentAutographStatus_TeamStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTeamFanContentAutographStatus.TeamStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgTeamFanContentAutographStatus.AutographStatus autographs = 3;
  total_size += 1UL * this->_internal_autographs_size();
  for (const auto& msg : this->_impl_.autographs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 team_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint32 workshop_account_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_workshop_account_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTeamFanContentAutographStatus_TeamStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTeamFanContentAutographStatus_TeamStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTeamFanContentAutographStatus_TeamStatus::GetClassData() const { return &_class_data_; }


void CMsgTeamFanContentAutographStatus_TeamStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTeamFanContentAutographStatus_TeamStatus*>(&to_msg);
  auto& from = static_cast<const CMsgTeamFanContentAutographStatus_TeamStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTeamFanContentAutographStatus.TeamStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.autographs_.MergeFrom(from._impl_.autographs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.workshop_account_id_ = from._impl_.workshop_account_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTeamFanContentAutographStatus_TeamStatus::CopyFrom(const CMsgTeamFanContentAutographStatus_TeamStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTeamFanContentAutographStatus.TeamStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTeamFanContentAutographStatus_TeamStatus::IsInitialized() const {
  return true;
}

void CMsgTeamFanContentAutographStatus_TeamStatus::InternalSwap(CMsgTeamFanContentAutographStatus_TeamStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.autographs_.InternalSwap(&other->_impl_.autographs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTeamFanContentAutographStatus_TeamStatus, _impl_.workshop_account_id_)
      + sizeof(CMsgTeamFanContentAutographStatus_TeamStatus::_impl_.workshop_account_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgTeamFanContentAutographStatus_TeamStatus, _impl_.team_id_)>(
          reinterpret_cast<char*>(&_impl_.team_id_),
          reinterpret_cast<char*>(&other->_impl_.team_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTeamFanContentAutographStatus_TeamStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[14]);
}

// ===================================================================

class CMsgTeamFanContentAutographStatus::_Internal {
 public:
};

CMsgTeamFanContentAutographStatus::CMsgTeamFanContentAutographStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTeamFanContentAutographStatus)
}
CMsgTeamFanContentAutographStatus::CMsgTeamFanContentAutographStatus(const CMsgTeamFanContentAutographStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTeamFanContentAutographStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.team_autographs_){from._impl_.team_autographs_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgTeamFanContentAutographStatus)
}

inline void CMsgTeamFanContentAutographStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.team_autographs_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgTeamFanContentAutographStatus::~CMsgTeamFanContentAutographStatus() {
  // @@protoc_insertion_point(destructor:CMsgTeamFanContentAutographStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTeamFanContentAutographStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.team_autographs_.~RepeatedPtrField();
}

void CMsgTeamFanContentAutographStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTeamFanContentAutographStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTeamFanContentAutographStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.team_autographs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTeamFanContentAutographStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgTeamFanContentAutographStatus.TeamStatus team_autographs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_team_autographs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTeamFanContentAutographStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTeamFanContentAutographStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgTeamFanContentAutographStatus.TeamStatus team_autographs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_team_autographs_size()); i < n; i++) {
    const auto& repfield = this->_internal_team_autographs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTeamFanContentAutographStatus)
  return target;
}

size_t CMsgTeamFanContentAutographStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTeamFanContentAutographStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgTeamFanContentAutographStatus.TeamStatus team_autographs = 1;
  total_size += 1UL * this->_internal_team_autographs_size();
  for (const auto& msg : this->_impl_.team_autographs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTeamFanContentAutographStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTeamFanContentAutographStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTeamFanContentAutographStatus::GetClassData() const { return &_class_data_; }


void CMsgTeamFanContentAutographStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTeamFanContentAutographStatus*>(&to_msg);
  auto& from = static_cast<const CMsgTeamFanContentAutographStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTeamFanContentAutographStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.team_autographs_.MergeFrom(from._impl_.team_autographs_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTeamFanContentAutographStatus::CopyFrom(const CMsgTeamFanContentAutographStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTeamFanContentAutographStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTeamFanContentAutographStatus::IsInitialized() const {
  return true;
}

void CMsgTeamFanContentAutographStatus::InternalSwap(CMsgTeamFanContentAutographStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.team_autographs_.InternalSwap(&other->_impl_.team_autographs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTeamFanContentAutographStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[15]);
}

// ===================================================================

class CMsgDPCEvent_PhaseInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDPCEvent_PhaseInfo>()._impl_._has_bits_);
  static void set_has_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_node_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDPCEvent_PhaseInfo::CMsgDPCEvent_PhaseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDPCEvent.PhaseInfo)
}
CMsgDPCEvent_PhaseInfo::CMsgDPCEvent_PhaseInfo(const CMsgDPCEvent_PhaseInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDPCEvent_PhaseInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phase_){}
    , decltype(_impl_.node_group_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.phase_, &from._impl_.phase_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.node_group_id_) -
    reinterpret_cast<char*>(&_impl_.phase_)) + sizeof(_impl_.node_group_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDPCEvent.PhaseInfo)
}

inline void CMsgDPCEvent_PhaseInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phase_){0}
    , decltype(_impl_.node_group_id_){0u}
  };
}

CMsgDPCEvent_PhaseInfo::~CMsgDPCEvent_PhaseInfo() {
  // @@protoc_insertion_point(destructor:CMsgDPCEvent.PhaseInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDPCEvent_PhaseInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDPCEvent_PhaseInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDPCEvent_PhaseInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDPCEvent.PhaseInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.phase_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.node_group_id_) -
        reinterpret_cast<char*>(&_impl_.phase_)) + sizeof(_impl_.node_group_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDPCEvent_PhaseInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgDPCEvent.ELeagueEventPhase phase = 1 [default = PHASE_INVALID];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgDPCEvent_ELeagueEventPhase_IsValid(val))) {
            _internal_set_phase(static_cast<::CMsgDPCEvent_ELeagueEventPhase>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 node_group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_node_group_id(&has_bits);
          _impl_.node_group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDPCEvent_PhaseInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDPCEvent.PhaseInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgDPCEvent.ELeagueEventPhase phase = 1 [default = PHASE_INVALID];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_phase(), target);
  }

  // optional uint32 node_group_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_node_group_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDPCEvent.PhaseInfo)
  return target;
}

size_t CMsgDPCEvent_PhaseInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDPCEvent.PhaseInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgDPCEvent.ELeagueEventPhase phase = 1 [default = PHASE_INVALID];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_phase());
    }

    // optional uint32 node_group_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_group_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDPCEvent_PhaseInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDPCEvent_PhaseInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDPCEvent_PhaseInfo::GetClassData() const { return &_class_data_; }


void CMsgDPCEvent_PhaseInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDPCEvent_PhaseInfo*>(&to_msg);
  auto& from = static_cast<const CMsgDPCEvent_PhaseInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDPCEvent.PhaseInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.phase_ = from._impl_.phase_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.node_group_id_ = from._impl_.node_group_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDPCEvent_PhaseInfo::CopyFrom(const CMsgDPCEvent_PhaseInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDPCEvent.PhaseInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDPCEvent_PhaseInfo::IsInitialized() const {
  return true;
}

void CMsgDPCEvent_PhaseInfo::InternalSwap(CMsgDPCEvent_PhaseInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDPCEvent_PhaseInfo, _impl_.node_group_id_)
      + sizeof(CMsgDPCEvent_PhaseInfo::_impl_.node_group_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDPCEvent_PhaseInfo, _impl_.phase_)>(
          reinterpret_cast<char*>(&_impl_.phase_),
          reinterpret_cast<char*>(&other->_impl_.phase_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDPCEvent_PhaseInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[16]);
}

// ===================================================================

class CMsgDPCEvent_League::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDPCEvent_League>()._impl_._has_bits_);
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_division(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDPCEvent_League::CMsgDPCEvent_League(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDPCEvent.League)
}
CMsgDPCEvent_League::CMsgDPCEvent_League(const CMsgDPCEvent_League& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDPCEvent_League* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phases_){from._impl_.phases_}
    , decltype(_impl_.region_){}
    , decltype(_impl_.division_){}
    , decltype(_impl_.league_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.region_, &from._impl_.region_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.league_id_) -
    reinterpret_cast<char*>(&_impl_.region_)) + sizeof(_impl_.league_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDPCEvent.League)
}

inline void CMsgDPCEvent_League::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phases_){arena}
    , decltype(_impl_.region_){0}
    , decltype(_impl_.division_){0}
    , decltype(_impl_.league_id_){0u}
  };
}

CMsgDPCEvent_League::~CMsgDPCEvent_League() {
  // @@protoc_insertion_point(destructor:CMsgDPCEvent.League)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDPCEvent_League::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.phases_.~RepeatedPtrField();
}

void CMsgDPCEvent_League::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDPCEvent_League::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDPCEvent.League)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.phases_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.region_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.league_id_) -
        reinterpret_cast<char*>(&_impl_.region_)) + sizeof(_impl_.league_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDPCEvent_League::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ELeagueRegion region = 1 [default = LEAGUE_REGION_UNSET];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueRegion_IsValid(val))) {
            _internal_set_region(static_cast<::ELeagueRegion>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueDivision division = 2 [default = LEAGUE_DIVISION_UNSET];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueDivision_IsValid(val))) {
            _internal_set_division(static_cast<::ELeagueDivision>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDPCEvent.PhaseInfo phases = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_phases(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDPCEvent_League::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDPCEvent.League)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .ELeagueRegion region = 1 [default = LEAGUE_REGION_UNSET];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_region(), target);
  }

  // optional .ELeagueDivision division = 2 [default = LEAGUE_DIVISION_UNSET];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_division(), target);
  }

  // optional uint32 league_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_league_id(), target);
  }

  // repeated .CMsgDPCEvent.PhaseInfo phases = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_phases_size()); i < n; i++) {
    const auto& repfield = this->_internal_phases(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDPCEvent.League)
  return target;
}

size_t CMsgDPCEvent_League::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDPCEvent.League)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDPCEvent.PhaseInfo phases = 4;
  total_size += 1UL * this->_internal_phases_size();
  for (const auto& msg : this->_impl_.phases_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .ELeagueRegion region = 1 [default = LEAGUE_REGION_UNSET];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_region());
    }

    // optional .ELeagueDivision division = 2 [default = LEAGUE_DIVISION_UNSET];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_division());
    }

    // optional uint32 league_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDPCEvent_League::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDPCEvent_League::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDPCEvent_League::GetClassData() const { return &_class_data_; }


void CMsgDPCEvent_League::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDPCEvent_League*>(&to_msg);
  auto& from = static_cast<const CMsgDPCEvent_League&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDPCEvent.League)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.phases_.MergeFrom(from._impl_.phases_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.region_ = from._impl_.region_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.division_ = from._impl_.division_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDPCEvent_League::CopyFrom(const CMsgDPCEvent_League& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDPCEvent.League)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDPCEvent_League::IsInitialized() const {
  return true;
}

void CMsgDPCEvent_League::InternalSwap(CMsgDPCEvent_League* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.phases_.InternalSwap(&other->_impl_.phases_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDPCEvent_League, _impl_.league_id_)
      + sizeof(CMsgDPCEvent_League::_impl_.league_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDPCEvent_League, _impl_.region_)>(
          reinterpret_cast<char*>(&_impl_.region_),
          reinterpret_cast<char*>(&other->_impl_.region_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDPCEvent_League::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[17]);
}

// ===================================================================

class CMsgDPCEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDPCEvent>()._impl_._has_bits_);
  static void set_has_event(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_registration_period(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_event_upcoming(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_event_completed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_event_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_multicast_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_tour(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_timestamp_drop_lock(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_timestamp_add_lock(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_timestamp_content_deadline(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_is_fantasy_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgDPCEvent::CMsgDPCEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDPCEvent)
}
CMsgDPCEvent::CMsgDPCEvent(const CMsgDPCEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDPCEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.leagues_){from._impl_.leagues_}
    , decltype(_impl_.multicast_streams_){from._impl_.multicast_streams_}
    , decltype(_impl_.event_name_){}
    , decltype(_impl_.event_){}
    , decltype(_impl_.event_type_){}
    , decltype(_impl_.registration_period_){}
    , decltype(_impl_.multicast_league_id_){}
    , decltype(_impl_.is_event_upcoming_){}
    , decltype(_impl_.is_event_completed_){}
    , decltype(_impl_.is_fantasy_enabled_){}
    , decltype(_impl_.tour_){}
    , decltype(_impl_.timestamp_drop_lock_){}
    , decltype(_impl_.timestamp_add_lock_){}
    , decltype(_impl_.timestamp_content_deadline_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.event_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_event_name()) {
    _this->_impl_.event_name_.Set(from._internal_event_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.event_, &from._impl_.event_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timestamp_content_deadline_) -
    reinterpret_cast<char*>(&_impl_.event_)) + sizeof(_impl_.timestamp_content_deadline_));
  // @@protoc_insertion_point(copy_constructor:CMsgDPCEvent)
}

inline void CMsgDPCEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.leagues_){arena}
    , decltype(_impl_.multicast_streams_){arena}
    , decltype(_impl_.event_name_){}
    , decltype(_impl_.event_){0}
    , decltype(_impl_.event_type_){0}
    , decltype(_impl_.registration_period_){0u}
    , decltype(_impl_.multicast_league_id_){0u}
    , decltype(_impl_.is_event_upcoming_){false}
    , decltype(_impl_.is_event_completed_){false}
    , decltype(_impl_.is_fantasy_enabled_){false}
    , decltype(_impl_.tour_){0}
    , decltype(_impl_.timestamp_drop_lock_){0u}
    , decltype(_impl_.timestamp_add_lock_){0u}
    , decltype(_impl_.timestamp_content_deadline_){0u}
  };
  _impl_.event_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDPCEvent::~CMsgDPCEvent() {
  // @@protoc_insertion_point(destructor:CMsgDPCEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDPCEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.leagues_.~RepeatedPtrField();
  _impl_.multicast_streams_.~RepeatedField();
  _impl_.event_name_.Destroy();
}

void CMsgDPCEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDPCEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDPCEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.leagues_.Clear();
  _impl_.multicast_streams_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.event_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.event_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_fantasy_enabled_) -
        reinterpret_cast<char*>(&_impl_.event_)) + sizeof(_impl_.is_fantasy_enabled_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.tour_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timestamp_content_deadline_) -
        reinterpret_cast<char*>(&_impl_.tour_)) + sizeof(_impl_.timestamp_content_deadline_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDPCEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgDPCEvent.ELeagueEvent event = 1 [default = EVENT_INVALID];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgDPCEvent_ELeagueEvent_IsValid(val))) {
            _internal_set_event(static_cast<::CMsgDPCEvent_ELeagueEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDPCEvent.ELeagueEventType event_type = 2 [default = UNKNOWN];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgDPCEvent_ELeagueEventType_IsValid(val))) {
            _internal_set_event_type(static_cast<::CMsgDPCEvent_ELeagueEventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDPCEvent.League leagues = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_leagues(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 registration_period = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_registration_period(&has_bits);
          _impl_.registration_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_event_upcoming = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_event_upcoming(&has_bits);
          _impl_.is_event_upcoming_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_event_completed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_event_completed(&has_bits);
          _impl_.is_event_completed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string event_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_event_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDPCEvent.event_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 multicast_league_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_multicast_league_id(&has_bits);
          _impl_.multicast_league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 multicast_streams = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_multicast_streams(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<72>(ptr));
        } else if (static_cast<uint8_t>(tag) == 74) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_multicast_streams(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDPCEvent.ETour tour = 10 [default = TOUR_NONE];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgDPCEvent_ETour_IsValid(val))) {
            _internal_set_tour(static_cast<::CMsgDPCEvent_ETour>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp_drop_lock = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_timestamp_drop_lock(&has_bits);
          _impl_.timestamp_drop_lock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp_add_lock = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_timestamp_add_lock(&has_bits);
          _impl_.timestamp_add_lock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp_content_deadline = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_timestamp_content_deadline(&has_bits);
          _impl_.timestamp_content_deadline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_fantasy_enabled = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_is_fantasy_enabled(&has_bits);
          _impl_.is_fantasy_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDPCEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDPCEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgDPCEvent.ELeagueEvent event = 1 [default = EVENT_INVALID];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event(), target);
  }

  // optional .CMsgDPCEvent.ELeagueEventType event_type = 2 [default = UNKNOWN];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_event_type(), target);
  }

  // repeated .CMsgDPCEvent.League leagues = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_leagues_size()); i < n; i++) {
    const auto& repfield = this->_internal_leagues(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 registration_period = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_registration_period(), target);
  }

  // optional bool is_event_upcoming = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_event_upcoming(), target);
  }

  // optional bool is_event_completed = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_event_completed(), target);
  }

  // optional string event_name = 7;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_event_name().data(), static_cast<int>(this->_internal_event_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDPCEvent.event_name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_event_name(), target);
  }

  // optional uint32 multicast_league_id = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_multicast_league_id(), target);
  }

  // repeated uint32 multicast_streams = 9;
  for (int i = 0, n = this->_internal_multicast_streams_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_multicast_streams(i), target);
  }

  // optional .CMsgDPCEvent.ETour tour = 10 [default = TOUR_NONE];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_tour(), target);
  }

  // optional uint32 timestamp_drop_lock = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_timestamp_drop_lock(), target);
  }

  // optional uint32 timestamp_add_lock = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_timestamp_add_lock(), target);
  }

  // optional uint32 timestamp_content_deadline = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_timestamp_content_deadline(), target);
  }

  // optional bool is_fantasy_enabled = 15;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_is_fantasy_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDPCEvent)
  return target;
}

size_t CMsgDPCEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDPCEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDPCEvent.League leagues = 3;
  total_size += 1UL * this->_internal_leagues_size();
  for (const auto& msg : this->_impl_.leagues_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 multicast_streams = 9;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.multicast_streams_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_multicast_streams_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string event_name = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_event_name());
    }

    // optional .CMsgDPCEvent.ELeagueEvent event = 1 [default = EVENT_INVALID];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event());
    }

    // optional .CMsgDPCEvent.ELeagueEventType event_type = 2 [default = UNKNOWN];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event_type());
    }

    // optional uint32 registration_period = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_registration_period());
    }

    // optional uint32 multicast_league_id = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_multicast_league_id());
    }

    // optional bool is_event_upcoming = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool is_event_completed = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_fantasy_enabled = 15;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional .CMsgDPCEvent.ETour tour = 10 [default = TOUR_NONE];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_tour());
    }

    // optional uint32 timestamp_drop_lock = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp_drop_lock());
    }

    // optional uint32 timestamp_add_lock = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp_add_lock());
    }

    // optional uint32 timestamp_content_deadline = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp_content_deadline());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDPCEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDPCEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDPCEvent::GetClassData() const { return &_class_data_; }


void CMsgDPCEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDPCEvent*>(&to_msg);
  auto& from = static_cast<const CMsgDPCEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDPCEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.leagues_.MergeFrom(from._impl_.leagues_);
  _this->_impl_.multicast_streams_.MergeFrom(from._impl_.multicast_streams_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_event_name(from._internal_event_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.event_ = from._impl_.event_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.event_type_ = from._impl_.event_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.registration_period_ = from._impl_.registration_period_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.multicast_league_id_ = from._impl_.multicast_league_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_event_upcoming_ = from._impl_.is_event_upcoming_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_event_completed_ = from._impl_.is_event_completed_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_fantasy_enabled_ = from._impl_.is_fantasy_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.tour_ = from._impl_.tour_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.timestamp_drop_lock_ = from._impl_.timestamp_drop_lock_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.timestamp_add_lock_ = from._impl_.timestamp_add_lock_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.timestamp_content_deadline_ = from._impl_.timestamp_content_deadline_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDPCEvent::CopyFrom(const CMsgDPCEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDPCEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDPCEvent::IsInitialized() const {
  return true;
}

void CMsgDPCEvent::InternalSwap(CMsgDPCEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.leagues_.InternalSwap(&other->_impl_.leagues_);
  _impl_.multicast_streams_.InternalSwap(&other->_impl_.multicast_streams_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.event_name_, lhs_arena,
      &other->_impl_.event_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDPCEvent, _impl_.timestamp_content_deadline_)
      + sizeof(CMsgDPCEvent::_impl_.timestamp_content_deadline_)
      - PROTOBUF_FIELD_OFFSET(CMsgDPCEvent, _impl_.event_)>(
          reinterpret_cast<char*>(&_impl_.event_),
          reinterpret_cast<char*>(&other->_impl_.event_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDPCEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[18]);
}

// ===================================================================

class CMsgDPCEventList::_Internal {
 public:
};

CMsgDPCEventList::CMsgDPCEventList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDPCEventList)
}
CMsgDPCEventList::CMsgDPCEventList(const CMsgDPCEventList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDPCEventList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.events_){from._impl_.events_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDPCEventList)
}

inline void CMsgDPCEventList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.events_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDPCEventList::~CMsgDPCEventList() {
  // @@protoc_insertion_point(destructor:CMsgDPCEventList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDPCEventList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.events_.~RepeatedPtrField();
}

void CMsgDPCEventList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDPCEventList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDPCEventList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.events_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDPCEventList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDPCEvent events = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDPCEventList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDPCEventList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDPCEvent events = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDPCEventList)
  return target;
}

size_t CMsgDPCEventList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDPCEventList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDPCEvent events = 1;
  total_size += 1UL * this->_internal_events_size();
  for (const auto& msg : this->_impl_.events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDPCEventList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDPCEventList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDPCEventList::GetClassData() const { return &_class_data_; }


void CMsgDPCEventList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDPCEventList*>(&to_msg);
  auto& from = static_cast<const CMsgDPCEventList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDPCEventList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.events_.MergeFrom(from._impl_.events_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDPCEventList::CopyFrom(const CMsgDPCEventList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDPCEventList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDPCEventList::IsInitialized() const {
  return true;
}

void CMsgDPCEventList::InternalSwap(CMsgDPCEventList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.events_.InternalSwap(&other->_impl_.events_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDPCEventList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[19]);
}

// ===================================================================

class CMsgDOTAFantasyCardLineup_CardBonus::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAFantasyCardLineup_CardBonus>()._impl_._has_bits_);
  static void set_has_bonus_stat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bonus_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTAFantasyCardLineup_CardBonus::CMsgDOTAFantasyCardLineup_CardBonus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAFantasyCardLineup.CardBonus)
}
CMsgDOTAFantasyCardLineup_CardBonus::CMsgDOTAFantasyCardLineup_CardBonus(const CMsgDOTAFantasyCardLineup_CardBonus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAFantasyCardLineup_CardBonus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonus_stat_){}
    , decltype(_impl_.bonus_value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.bonus_stat_, &from._impl_.bonus_stat_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bonus_value_) -
    reinterpret_cast<char*>(&_impl_.bonus_stat_)) + sizeof(_impl_.bonus_value_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAFantasyCardLineup.CardBonus)
}

inline void CMsgDOTAFantasyCardLineup_CardBonus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonus_stat_){0u}
    , decltype(_impl_.bonus_value_){0u}
  };
}

CMsgDOTAFantasyCardLineup_CardBonus::~CMsgDOTAFantasyCardLineup_CardBonus() {
  // @@protoc_insertion_point(destructor:CMsgDOTAFantasyCardLineup.CardBonus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAFantasyCardLineup_CardBonus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAFantasyCardLineup_CardBonus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAFantasyCardLineup_CardBonus::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAFantasyCardLineup.CardBonus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.bonus_stat_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bonus_value_) -
        reinterpret_cast<char*>(&_impl_.bonus_stat_)) + sizeof(_impl_.bonus_value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAFantasyCardLineup_CardBonus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 bonus_stat = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_bonus_stat(&has_bits);
          _impl_.bonus_stat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bonus_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bonus_value(&has_bits);
          _impl_.bonus_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAFantasyCardLineup_CardBonus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAFantasyCardLineup.CardBonus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 bonus_stat = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_bonus_stat(), target);
  }

  // optional uint32 bonus_value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_bonus_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAFantasyCardLineup.CardBonus)
  return target;
}

size_t CMsgDOTAFantasyCardLineup_CardBonus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAFantasyCardLineup.CardBonus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 bonus_stat = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bonus_stat());
    }

    // optional uint32 bonus_value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bonus_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAFantasyCardLineup_CardBonus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAFantasyCardLineup_CardBonus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAFantasyCardLineup_CardBonus::GetClassData() const { return &_class_data_; }


void CMsgDOTAFantasyCardLineup_CardBonus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAFantasyCardLineup_CardBonus*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAFantasyCardLineup_CardBonus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAFantasyCardLineup.CardBonus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bonus_stat_ = from._impl_.bonus_stat_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bonus_value_ = from._impl_.bonus_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAFantasyCardLineup_CardBonus::CopyFrom(const CMsgDOTAFantasyCardLineup_CardBonus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAFantasyCardLineup.CardBonus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAFantasyCardLineup_CardBonus::IsInitialized() const {
  return true;
}

void CMsgDOTAFantasyCardLineup_CardBonus::InternalSwap(CMsgDOTAFantasyCardLineup_CardBonus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyCardLineup_CardBonus, _impl_.bonus_value_)
      + sizeof(CMsgDOTAFantasyCardLineup_CardBonus::_impl_.bonus_value_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyCardLineup_CardBonus, _impl_.bonus_stat_)>(
          reinterpret_cast<char*>(&_impl_.bonus_stat_),
          reinterpret_cast<char*>(&other->_impl_.bonus_stat_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAFantasyCardLineup_CardBonus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[20]);
}

// ===================================================================

class CMsgDOTAFantasyCardLineup_Card::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAFantasyCardLineup_Card>()._impl_._has_bits_);
  static void set_has_player_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_player_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_role(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_finalized(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CMsgDOTAFantasyCardLineup_Card::CMsgDOTAFantasyCardLineup_Card(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAFantasyCardLineup.Card)
}
CMsgDOTAFantasyCardLineup_Card::CMsgDOTAFantasyCardLineup_Card(const CMsgDOTAFantasyCardLineup_Card& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAFantasyCardLineup_Card* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonuses_){from._impl_.bonuses_}
    , decltype(_impl_.player_name_){}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.player_account_id_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.role_){}
    , decltype(_impl_.score_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.finalized_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_player_name()) {
    _this->_impl_.player_name_.Set(from._internal_player_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_name()) {
    _this->_impl_.team_name_.Set(from._internal_team_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.player_account_id_, &from._impl_.player_account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.finalized_) -
    reinterpret_cast<char*>(&_impl_.player_account_id_)) + sizeof(_impl_.finalized_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAFantasyCardLineup.Card)
}

inline void CMsgDOTAFantasyCardLineup_Card::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonuses_){arena}
    , decltype(_impl_.player_name_){}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.player_account_id_){0u}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.role_){0u}
    , decltype(_impl_.score_){0}
    , decltype(_impl_.item_id_){uint64_t{0u}}
    , decltype(_impl_.finalized_){false}
  };
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTAFantasyCardLineup_Card::~CMsgDOTAFantasyCardLineup_Card() {
  // @@protoc_insertion_point(destructor:CMsgDOTAFantasyCardLineup.Card)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAFantasyCardLineup_Card::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bonuses_.~RepeatedPtrField();
  _impl_.player_name_.Destroy();
  _impl_.team_name_.Destroy();
}

void CMsgDOTAFantasyCardLineup_Card::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAFantasyCardLineup_Card::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAFantasyCardLineup.Card)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bonuses_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.player_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.team_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.player_account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.finalized_) -
        reinterpret_cast<char*>(&_impl_.player_account_id_)) + sizeof(_impl_.finalized_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAFantasyCardLineup_Card::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 player_account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_account_id(&has_bits);
          _impl_.player_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string player_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_player_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAFantasyCardLineup.Card.player_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAFantasyCardLineup.Card.team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 role = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_role(&has_bits);
          _impl_.role_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAFantasyCardLineup.CardBonus bonuses = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bonuses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional float score = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_score(&has_bits);
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool finalized = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_finalized(&has_bits);
          _impl_.finalized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAFantasyCardLineup_Card::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAFantasyCardLineup.Card)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 player_account_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_player_account_id(), target);
  }

  // optional string player_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_player_name().data(), static_cast<int>(this->_internal_player_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAFantasyCardLineup.Card.player_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_player_name(), target);
  }

  // optional uint32 team_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_team_id(), target);
  }

  // optional string team_name = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_name().data(), static_cast<int>(this->_internal_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAFantasyCardLineup.Card.team_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_team_name(), target);
  }

  // optional uint32 role = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_role(), target);
  }

  // repeated .CMsgDOTAFantasyCardLineup.CardBonus bonuses = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bonuses_size()); i < n; i++) {
    const auto& repfield = this->_internal_bonuses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional float score = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_score(), target);
  }

  // optional bool finalized = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_finalized(), target);
  }

  // optional uint64 item_id = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAFantasyCardLineup.Card)
  return target;
}

size_t CMsgDOTAFantasyCardLineup_Card::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAFantasyCardLineup.Card)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAFantasyCardLineup.CardBonus bonuses = 6;
  total_size += 1UL * this->_internal_bonuses_size();
  for (const auto& msg : this->_impl_.bonuses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string player_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_player_name());
    }

    // optional string team_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_name());
    }

    // optional uint32 player_account_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_player_account_id());
    }

    // optional uint32 team_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint32 role = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_role());
    }

    // optional float score = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional uint64 item_id = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional bool finalized = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAFantasyCardLineup_Card::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAFantasyCardLineup_Card::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAFantasyCardLineup_Card::GetClassData() const { return &_class_data_; }


void CMsgDOTAFantasyCardLineup_Card::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAFantasyCardLineup_Card*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAFantasyCardLineup_Card&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAFantasyCardLineup.Card)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bonuses_.MergeFrom(from._impl_.bonuses_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_player_name(from._internal_player_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_team_name(from._internal_team_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.player_account_id_ = from._impl_.player_account_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.role_ = from._impl_.role_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.score_ = from._impl_.score_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.finalized_ = from._impl_.finalized_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAFantasyCardLineup_Card::CopyFrom(const CMsgDOTAFantasyCardLineup_Card& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAFantasyCardLineup.Card)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAFantasyCardLineup_Card::IsInitialized() const {
  return true;
}

void CMsgDOTAFantasyCardLineup_Card::InternalSwap(CMsgDOTAFantasyCardLineup_Card* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.bonuses_.InternalSwap(&other->_impl_.bonuses_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.player_name_, lhs_arena,
      &other->_impl_.player_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_name_, lhs_arena,
      &other->_impl_.team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyCardLineup_Card, _impl_.finalized_)
      + sizeof(CMsgDOTAFantasyCardLineup_Card::_impl_.finalized_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyCardLineup_Card, _impl_.player_account_id_)>(
          reinterpret_cast<char*>(&_impl_.player_account_id_),
          reinterpret_cast<char*>(&other->_impl_.player_account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAFantasyCardLineup_Card::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[21]);
}

// ===================================================================

class CMsgDOTAFantasyCardLineup_League::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAFantasyCardLineup_League>()._impl_._has_bits_);
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTAFantasyCardLineup_League::CMsgDOTAFantasyCardLineup_League(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAFantasyCardLineup.League)
}
CMsgDOTAFantasyCardLineup_League::CMsgDOTAFantasyCardLineup_League(const CMsgDOTAFantasyCardLineup_League& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAFantasyCardLineup_League* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cards_){from._impl_.cards_}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.score_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.league_id_, &from._impl_.league_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.score_) -
    reinterpret_cast<char*>(&_impl_.league_id_)) + sizeof(_impl_.score_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAFantasyCardLineup.League)
}

inline void CMsgDOTAFantasyCardLineup_League::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cards_){arena}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.score_){0}
  };
}

CMsgDOTAFantasyCardLineup_League::~CMsgDOTAFantasyCardLineup_League() {
  // @@protoc_insertion_point(destructor:CMsgDOTAFantasyCardLineup.League)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAFantasyCardLineup_League::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cards_.~RepeatedPtrField();
}

void CMsgDOTAFantasyCardLineup_League::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAFantasyCardLineup_League::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAFantasyCardLineup.League)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cards_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.league_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.score_) -
        reinterpret_cast<char*>(&_impl_.league_id_)) + sizeof(_impl_.score_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAFantasyCardLineup_League::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 league_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAFantasyCardLineup.Card cards = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional float score = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_score(&has_bits);
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAFantasyCardLineup_League::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAFantasyCardLineup.League)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 league_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_league_id(), target);
  }

  // repeated .CMsgDOTAFantasyCardLineup.Card cards = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cards_size()); i < n; i++) {
    const auto& repfield = this->_internal_cards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional float score = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAFantasyCardLineup.League)
  return target;
}

size_t CMsgDOTAFantasyCardLineup_League::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAFantasyCardLineup.League)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAFantasyCardLineup.Card cards = 2;
  total_size += 1UL * this->_internal_cards_size();
  for (const auto& msg : this->_impl_.cards_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 league_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional float score = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAFantasyCardLineup_League::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAFantasyCardLineup_League::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAFantasyCardLineup_League::GetClassData() const { return &_class_data_; }


void CMsgDOTAFantasyCardLineup_League::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAFantasyCardLineup_League*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAFantasyCardLineup_League&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAFantasyCardLineup.League)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cards_.MergeFrom(from._impl_.cards_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.score_ = from._impl_.score_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAFantasyCardLineup_League::CopyFrom(const CMsgDOTAFantasyCardLineup_League& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAFantasyCardLineup.League)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAFantasyCardLineup_League::IsInitialized() const {
  return true;
}

void CMsgDOTAFantasyCardLineup_League::InternalSwap(CMsgDOTAFantasyCardLineup_League* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.cards_.InternalSwap(&other->_impl_.cards_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyCardLineup_League, _impl_.score_)
      + sizeof(CMsgDOTAFantasyCardLineup_League::_impl_.score_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyCardLineup_League, _impl_.league_id_)>(
          reinterpret_cast<char*>(&_impl_.league_id_),
          reinterpret_cast<char*>(&other->_impl_.league_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAFantasyCardLineup_League::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[22]);
}

// ===================================================================

class CMsgDOTAFantasyCardLineup_Period::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAFantasyCardLineup_Period>()._impl_._has_bits_);
  static void set_has_fantasy_period(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_timestamp_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTAFantasyCardLineup_Period::CMsgDOTAFantasyCardLineup_Period(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAFantasyCardLineup.Period)
}
CMsgDOTAFantasyCardLineup_Period::CMsgDOTAFantasyCardLineup_Period(const CMsgDOTAFantasyCardLineup_Period& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAFantasyCardLineup_Period* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.leagues_){from._impl_.leagues_}
    , decltype(_impl_.timestamp_start_){}
    , decltype(_impl_.timestamp_end_){}
    , decltype(_impl_.fantasy_period_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_start_, &from._impl_.timestamp_start_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fantasy_period_) -
    reinterpret_cast<char*>(&_impl_.timestamp_start_)) + sizeof(_impl_.fantasy_period_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAFantasyCardLineup.Period)
}

inline void CMsgDOTAFantasyCardLineup_Period::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.leagues_){arena}
    , decltype(_impl_.timestamp_start_){0u}
    , decltype(_impl_.timestamp_end_){0u}
    , decltype(_impl_.fantasy_period_){4294967295u}
  };
}

CMsgDOTAFantasyCardLineup_Period::~CMsgDOTAFantasyCardLineup_Period() {
  // @@protoc_insertion_point(destructor:CMsgDOTAFantasyCardLineup.Period)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAFantasyCardLineup_Period::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.leagues_.~RepeatedPtrField();
}

void CMsgDOTAFantasyCardLineup_Period::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAFantasyCardLineup_Period::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAFantasyCardLineup.Period)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.leagues_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.timestamp_start_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timestamp_end_) -
        reinterpret_cast<char*>(&_impl_.timestamp_start_)) + sizeof(_impl_.timestamp_end_));
    _impl_.fantasy_period_ = 4294967295u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAFantasyCardLineup_Period::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 fantasy_period = 1 [default = 4294967295];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_fantasy_period(&has_bits);
          _impl_.fantasy_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp_start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp_start(&has_bits);
          _impl_.timestamp_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp_end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timestamp_end(&has_bits);
          _impl_.timestamp_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAFantasyCardLineup.League leagues = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_leagues(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAFantasyCardLineup_Period::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAFantasyCardLineup.Period)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 fantasy_period = 1 [default = 4294967295];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_fantasy_period(), target);
  }

  // optional uint32 timestamp_start = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_timestamp_start(), target);
  }

  // optional uint32 timestamp_end = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_timestamp_end(), target);
  }

  // repeated .CMsgDOTAFantasyCardLineup.League leagues = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_leagues_size()); i < n; i++) {
    const auto& repfield = this->_internal_leagues(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAFantasyCardLineup.Period)
  return target;
}

size_t CMsgDOTAFantasyCardLineup_Period::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAFantasyCardLineup.Period)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAFantasyCardLineup.League leagues = 4;
  total_size += 1UL * this->_internal_leagues_size();
  for (const auto& msg : this->_impl_.leagues_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 timestamp_start = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp_start());
    }

    // optional uint32 timestamp_end = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp_end());
    }

    // optional uint32 fantasy_period = 1 [default = 4294967295];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fantasy_period());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAFantasyCardLineup_Period::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAFantasyCardLineup_Period::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAFantasyCardLineup_Period::GetClassData() const { return &_class_data_; }


void CMsgDOTAFantasyCardLineup_Period::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAFantasyCardLineup_Period*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAFantasyCardLineup_Period&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAFantasyCardLineup.Period)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.leagues_.MergeFrom(from._impl_.leagues_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_start_ = from._impl_.timestamp_start_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_end_ = from._impl_.timestamp_end_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.fantasy_period_ = from._impl_.fantasy_period_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAFantasyCardLineup_Period::CopyFrom(const CMsgDOTAFantasyCardLineup_Period& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAFantasyCardLineup.Period)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAFantasyCardLineup_Period::IsInitialized() const {
  return true;
}

void CMsgDOTAFantasyCardLineup_Period::InternalSwap(CMsgDOTAFantasyCardLineup_Period* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.leagues_.InternalSwap(&other->_impl_.leagues_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyCardLineup_Period, _impl_.timestamp_end_)
      + sizeof(CMsgDOTAFantasyCardLineup_Period::_impl_.timestamp_end_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyCardLineup_Period, _impl_.timestamp_start_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_start_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_start_));
  swap(_impl_.fantasy_period_, other->_impl_.fantasy_period_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAFantasyCardLineup_Period::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[23]);
}

// ===================================================================

class CMsgDOTAFantasyCardLineup::_Internal {
 public:
};

CMsgDOTAFantasyCardLineup::CMsgDOTAFantasyCardLineup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAFantasyCardLineup)
}
CMsgDOTAFantasyCardLineup::CMsgDOTAFantasyCardLineup(const CMsgDOTAFantasyCardLineup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAFantasyCardLineup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.periods_){from._impl_.periods_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAFantasyCardLineup)
}

inline void CMsgDOTAFantasyCardLineup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.periods_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTAFantasyCardLineup::~CMsgDOTAFantasyCardLineup() {
  // @@protoc_insertion_point(destructor:CMsgDOTAFantasyCardLineup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAFantasyCardLineup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.periods_.~RepeatedPtrField();
}

void CMsgDOTAFantasyCardLineup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAFantasyCardLineup::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAFantasyCardLineup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.periods_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAFantasyCardLineup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTAFantasyCardLineup.Period periods = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_periods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAFantasyCardLineup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAFantasyCardLineup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTAFantasyCardLineup.Period periods = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_periods_size()); i < n; i++) {
    const auto& repfield = this->_internal_periods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAFantasyCardLineup)
  return target;
}

size_t CMsgDOTAFantasyCardLineup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAFantasyCardLineup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAFantasyCardLineup.Period periods = 1;
  total_size += 1UL * this->_internal_periods_size();
  for (const auto& msg : this->_impl_.periods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAFantasyCardLineup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAFantasyCardLineup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAFantasyCardLineup::GetClassData() const { return &_class_data_; }


void CMsgDOTAFantasyCardLineup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAFantasyCardLineup*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAFantasyCardLineup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAFantasyCardLineup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.periods_.MergeFrom(from._impl_.periods_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAFantasyCardLineup::CopyFrom(const CMsgDOTAFantasyCardLineup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAFantasyCardLineup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAFantasyCardLineup::IsInitialized() const {
  return true;
}

void CMsgDOTAFantasyCardLineup::InternalSwap(CMsgDOTAFantasyCardLineup* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.periods_.InternalSwap(&other->_impl_.periods_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAFantasyCardLineup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[24]);
}

// ===================================================================

class CMsgDOTAFantasyCardList_CardBonus::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAFantasyCardList_CardBonus>()._impl_._has_bits_);
  static void set_has_bonus_stat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bonus_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTAFantasyCardList_CardBonus::CMsgDOTAFantasyCardList_CardBonus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAFantasyCardList.CardBonus)
}
CMsgDOTAFantasyCardList_CardBonus::CMsgDOTAFantasyCardList_CardBonus(const CMsgDOTAFantasyCardList_CardBonus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAFantasyCardList_CardBonus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonus_stat_){}
    , decltype(_impl_.bonus_value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.bonus_stat_, &from._impl_.bonus_stat_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bonus_value_) -
    reinterpret_cast<char*>(&_impl_.bonus_stat_)) + sizeof(_impl_.bonus_value_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAFantasyCardList.CardBonus)
}

inline void CMsgDOTAFantasyCardList_CardBonus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonus_stat_){0u}
    , decltype(_impl_.bonus_value_){0u}
  };
}

CMsgDOTAFantasyCardList_CardBonus::~CMsgDOTAFantasyCardList_CardBonus() {
  // @@protoc_insertion_point(destructor:CMsgDOTAFantasyCardList.CardBonus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAFantasyCardList_CardBonus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAFantasyCardList_CardBonus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAFantasyCardList_CardBonus::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAFantasyCardList.CardBonus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.bonus_stat_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bonus_value_) -
        reinterpret_cast<char*>(&_impl_.bonus_stat_)) + sizeof(_impl_.bonus_value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAFantasyCardList_CardBonus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 bonus_stat = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_bonus_stat(&has_bits);
          _impl_.bonus_stat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bonus_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bonus_value(&has_bits);
          _impl_.bonus_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAFantasyCardList_CardBonus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAFantasyCardList.CardBonus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 bonus_stat = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_bonus_stat(), target);
  }

  // optional uint32 bonus_value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_bonus_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAFantasyCardList.CardBonus)
  return target;
}

size_t CMsgDOTAFantasyCardList_CardBonus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAFantasyCardList.CardBonus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 bonus_stat = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bonus_stat());
    }

    // optional uint32 bonus_value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bonus_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAFantasyCardList_CardBonus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAFantasyCardList_CardBonus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAFantasyCardList_CardBonus::GetClassData() const { return &_class_data_; }


void CMsgDOTAFantasyCardList_CardBonus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAFantasyCardList_CardBonus*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAFantasyCardList_CardBonus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAFantasyCardList.CardBonus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bonus_stat_ = from._impl_.bonus_stat_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bonus_value_ = from._impl_.bonus_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAFantasyCardList_CardBonus::CopyFrom(const CMsgDOTAFantasyCardList_CardBonus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAFantasyCardList.CardBonus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAFantasyCardList_CardBonus::IsInitialized() const {
  return true;
}

void CMsgDOTAFantasyCardList_CardBonus::InternalSwap(CMsgDOTAFantasyCardList_CardBonus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyCardList_CardBonus, _impl_.bonus_value_)
      + sizeof(CMsgDOTAFantasyCardList_CardBonus::_impl_.bonus_value_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyCardList_CardBonus, _impl_.bonus_stat_)>(
          reinterpret_cast<char*>(&_impl_.bonus_stat_),
          reinterpret_cast<char*>(&other->_impl_.bonus_stat_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAFantasyCardList_CardBonus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[25]);
}

// ===================================================================

class CMsgDOTAFantasyCardList_Card::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAFantasyCardList_Card>()._impl_._has_bits_);
  static void set_has_player_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_player_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_role(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgDOTAFantasyCardList_Card::CMsgDOTAFantasyCardList_Card(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAFantasyCardList.Card)
}
CMsgDOTAFantasyCardList_Card::CMsgDOTAFantasyCardList_Card(const CMsgDOTAFantasyCardList_Card& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAFantasyCardList_Card* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonuses_){from._impl_.bonuses_}
    , decltype(_impl_.player_name_){}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.player_account_id_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.role_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_player_name()) {
    _this->_impl_.player_name_.Set(from._internal_player_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_name()) {
    _this->_impl_.team_name_.Set(from._internal_team_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.player_account_id_, &from._impl_.player_account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.role_) -
    reinterpret_cast<char*>(&_impl_.player_account_id_)) + sizeof(_impl_.role_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAFantasyCardList.Card)
}

inline void CMsgDOTAFantasyCardList_Card::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonuses_){arena}
    , decltype(_impl_.player_name_){}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.player_account_id_){0u}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.item_id_){uint64_t{0u}}
    , decltype(_impl_.role_){0u}
  };
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTAFantasyCardList_Card::~CMsgDOTAFantasyCardList_Card() {
  // @@protoc_insertion_point(destructor:CMsgDOTAFantasyCardList.Card)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAFantasyCardList_Card::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bonuses_.~RepeatedPtrField();
  _impl_.player_name_.Destroy();
  _impl_.team_name_.Destroy();
}

void CMsgDOTAFantasyCardList_Card::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAFantasyCardList_Card::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAFantasyCardList.Card)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bonuses_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.player_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.team_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.player_account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.role_) -
        reinterpret_cast<char*>(&_impl_.player_account_id_)) + sizeof(_impl_.role_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAFantasyCardList_Card::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 player_account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_account_id(&has_bits);
          _impl_.player_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string player_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_player_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAFantasyCardList.Card.player_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAFantasyCardList.Card.team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 role = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_role(&has_bits);
          _impl_.role_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAFantasyCardList.CardBonus bonuses = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bonuses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAFantasyCardList_Card::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAFantasyCardList.Card)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 player_account_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_player_account_id(), target);
  }

  // optional string player_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_player_name().data(), static_cast<int>(this->_internal_player_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAFantasyCardList.Card.player_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_player_name(), target);
  }

  // optional uint32 team_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_team_id(), target);
  }

  // optional string team_name = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_name().data(), static_cast<int>(this->_internal_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAFantasyCardList.Card.team_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_team_name(), target);
  }

  // optional uint32 role = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_role(), target);
  }

  // repeated .CMsgDOTAFantasyCardList.CardBonus bonuses = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bonuses_size()); i < n; i++) {
    const auto& repfield = this->_internal_bonuses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 item_id = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAFantasyCardList.Card)
  return target;
}

size_t CMsgDOTAFantasyCardList_Card::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAFantasyCardList.Card)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAFantasyCardList.CardBonus bonuses = 6;
  total_size += 1UL * this->_internal_bonuses_size();
  for (const auto& msg : this->_impl_.bonuses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string player_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_player_name());
    }

    // optional string team_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_name());
    }

    // optional uint32 player_account_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_player_account_id());
    }

    // optional uint32 team_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint64 item_id = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional uint32 role = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_role());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAFantasyCardList_Card::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAFantasyCardList_Card::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAFantasyCardList_Card::GetClassData() const { return &_class_data_; }


void CMsgDOTAFantasyCardList_Card::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAFantasyCardList_Card*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAFantasyCardList_Card&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAFantasyCardList.Card)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bonuses_.MergeFrom(from._impl_.bonuses_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_player_name(from._internal_player_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_team_name(from._internal_team_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.player_account_id_ = from._impl_.player_account_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.role_ = from._impl_.role_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAFantasyCardList_Card::CopyFrom(const CMsgDOTAFantasyCardList_Card& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAFantasyCardList.Card)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAFantasyCardList_Card::IsInitialized() const {
  return true;
}

void CMsgDOTAFantasyCardList_Card::InternalSwap(CMsgDOTAFantasyCardList_Card* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.bonuses_.InternalSwap(&other->_impl_.bonuses_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.player_name_, lhs_arena,
      &other->_impl_.player_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_name_, lhs_arena,
      &other->_impl_.team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyCardList_Card, _impl_.role_)
      + sizeof(CMsgDOTAFantasyCardList_Card::_impl_.role_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyCardList_Card, _impl_.player_account_id_)>(
          reinterpret_cast<char*>(&_impl_.player_account_id_),
          reinterpret_cast<char*>(&other->_impl_.player_account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAFantasyCardList_Card::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[26]);
}

// ===================================================================

class CMsgDOTAFantasyCardList::_Internal {
 public:
};

CMsgDOTAFantasyCardList::CMsgDOTAFantasyCardList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAFantasyCardList)
}
CMsgDOTAFantasyCardList::CMsgDOTAFantasyCardList(const CMsgDOTAFantasyCardList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAFantasyCardList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cards_){from._impl_.cards_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAFantasyCardList)
}

inline void CMsgDOTAFantasyCardList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.cards_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTAFantasyCardList::~CMsgDOTAFantasyCardList() {
  // @@protoc_insertion_point(destructor:CMsgDOTAFantasyCardList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAFantasyCardList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cards_.~RepeatedPtrField();
}

void CMsgDOTAFantasyCardList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAFantasyCardList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAFantasyCardList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cards_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAFantasyCardList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTAFantasyCardList.Card cards = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAFantasyCardList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAFantasyCardList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTAFantasyCardList.Card cards = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cards_size()); i < n; i++) {
    const auto& repfield = this->_internal_cards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAFantasyCardList)
  return target;
}

size_t CMsgDOTAFantasyCardList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAFantasyCardList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAFantasyCardList.Card cards = 1;
  total_size += 1UL * this->_internal_cards_size();
  for (const auto& msg : this->_impl_.cards_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAFantasyCardList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAFantasyCardList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAFantasyCardList::GetClassData() const { return &_class_data_; }


void CMsgDOTAFantasyCardList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAFantasyCardList*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAFantasyCardList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAFantasyCardList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cards_.MergeFrom(from._impl_.cards_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAFantasyCardList::CopyFrom(const CMsgDOTAFantasyCardList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAFantasyCardList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAFantasyCardList::IsInitialized() const {
  return true;
}

void CMsgDOTAFantasyCardList::InternalSwap(CMsgDOTAFantasyCardList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.cards_.InternalSwap(&other->_impl_.cards_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAFantasyCardList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[27]);
}

// ===================================================================

class CMsgChatToxicityReport::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgChatToxicityReport>()._impl_._has_bits_);
  static void set_has_num_matches_seen(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_messages(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_num_messages_human_thinks_toxic(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_num_messages_ml_thinks_toxic(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgChatToxicityReport::CMsgChatToxicityReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgChatToxicityReport)
}
CMsgChatToxicityReport::CMsgChatToxicityReport(const CMsgChatToxicityReport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgChatToxicityReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.num_matches_seen_){}
    , decltype(_impl_.num_messages_){}
    , decltype(_impl_.num_messages_human_thinks_toxic_){}
    , decltype(_impl_.num_messages_ml_thinks_toxic_){}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.num_matches_seen_, &from._impl_.num_matches_seen_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.result_) -
    reinterpret_cast<char*>(&_impl_.num_matches_seen_)) + sizeof(_impl_.result_));
  // @@protoc_insertion_point(copy_constructor:CMsgChatToxicityReport)
}

inline void CMsgChatToxicityReport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){}
    , decltype(_impl_.message_){}
    , decltype(_impl_.num_matches_seen_){0u}
    , decltype(_impl_.num_messages_){0u}
    , decltype(_impl_.num_messages_human_thinks_toxic_){0u}
    , decltype(_impl_.num_messages_ml_thinks_toxic_){0u}
    , decltype(_impl_.result_){0u}
  };
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgChatToxicityReport::~CMsgChatToxicityReport() {
  // @@protoc_insertion_point(destructor:CMsgChatToxicityReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgChatToxicityReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_.Destroy();
  _impl_.message_.Destroy();
}

void CMsgChatToxicityReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgChatToxicityReport::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgChatToxicityReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_.num_matches_seen_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.result_) -
        reinterpret_cast<char*>(&_impl_.num_matches_seen_)) + sizeof(_impl_.result_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgChatToxicityReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 num_matches_seen = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_num_matches_seen(&has_bits);
          _impl_.num_matches_seen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_messages = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_messages(&has_bits);
          _impl_.num_messages_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_messages_human_thinks_toxic = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_num_messages_human_thinks_toxic(&has_bits);
          _impl_.num_messages_human_thinks_toxic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_messages_ml_thinks_toxic = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_num_messages_ml_thinks_toxic(&has_bits);
          _impl_.num_messages_ml_thinks_toxic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgChatToxicityReport.status");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 result = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgChatToxicityReport.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgChatToxicityReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgChatToxicityReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 num_matches_seen = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num_matches_seen(), target);
  }

  // optional uint32 num_messages = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_num_messages(), target);
  }

  // optional uint32 num_messages_human_thinks_toxic = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_num_messages_human_thinks_toxic(), target);
  }

  // optional uint32 num_messages_ml_thinks_toxic = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_num_messages_ml_thinks_toxic(), target);
  }

  // optional string status = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgChatToxicityReport.status");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_status(), target);
  }

  // optional uint32 result = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_result(), target);
  }

  // optional string message = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgChatToxicityReport.message");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgChatToxicityReport)
  return target;
}

size_t CMsgChatToxicityReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgChatToxicityReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string status = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

    // optional string message = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional uint32 num_matches_seen = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_matches_seen());
    }

    // optional uint32 num_messages = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_messages());
    }

    // optional uint32 num_messages_human_thinks_toxic = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_messages_human_thinks_toxic());
    }

    // optional uint32 num_messages_ml_thinks_toxic = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_messages_ml_thinks_toxic());
    }

    // optional uint32 result = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgChatToxicityReport::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgChatToxicityReport::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgChatToxicityReport::GetClassData() const { return &_class_data_; }


void CMsgChatToxicityReport::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgChatToxicityReport*>(&to_msg);
  auto& from = static_cast<const CMsgChatToxicityReport&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgChatToxicityReport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_matches_seen_ = from._impl_.num_matches_seen_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.num_messages_ = from._impl_.num_messages_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.num_messages_human_thinks_toxic_ = from._impl_.num_messages_human_thinks_toxic_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.num_messages_ml_thinks_toxic_ = from._impl_.num_messages_ml_thinks_toxic_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.result_ = from._impl_.result_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgChatToxicityReport::CopyFrom(const CMsgChatToxicityReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgChatToxicityReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgChatToxicityReport::IsInitialized() const {
  return true;
}

void CMsgChatToxicityReport::InternalSwap(CMsgChatToxicityReport* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgChatToxicityReport, _impl_.result_)
      + sizeof(CMsgChatToxicityReport::_impl_.result_)
      - PROTOBUF_FIELD_OFFSET(CMsgChatToxicityReport, _impl_.num_matches_seen_)>(
          reinterpret_cast<char*>(&_impl_.num_matches_seen_),
          reinterpret_cast<char*>(&other->_impl_.num_matches_seen_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgChatToxicityReport::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[28]);
}

// ===================================================================

class CMsgGetTeamAuditInformation_Action::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGetTeamAuditInformation_Action>()._impl_._has_bits_);
  static void set_has_registration_period(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_player_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_player_real_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGetTeamAuditInformation_Action::CMsgGetTeamAuditInformation_Action(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGetTeamAuditInformation.Action)
}
CMsgGetTeamAuditInformation_Action::CMsgGetTeamAuditInformation_Action(const CMsgGetTeamAuditInformation_Action& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGetTeamAuditInformation_Action* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_name_){}
    , decltype(_impl_.player_real_name_){}
    , decltype(_impl_.registration_period_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.action_){}
    , decltype(_impl_.timestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_player_name()) {
    _this->_impl_.player_name_.Set(from._internal_player_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.player_real_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_real_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_player_real_name()) {
    _this->_impl_.player_real_name_.Set(from._internal_player_real_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.registration_period_, &from._impl_.registration_period_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timestamp_) -
    reinterpret_cast<char*>(&_impl_.registration_period_)) + sizeof(_impl_.timestamp_));
  // @@protoc_insertion_point(copy_constructor:CMsgGetTeamAuditInformation.Action)
}

inline void CMsgGetTeamAuditInformation_Action::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_name_){}
    , decltype(_impl_.player_real_name_){}
    , decltype(_impl_.registration_period_){0u}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.action_){0u}
    , decltype(_impl_.timestamp_){0u}
  };
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.player_real_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_real_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGetTeamAuditInformation_Action::~CMsgGetTeamAuditInformation_Action() {
  // @@protoc_insertion_point(destructor:CMsgGetTeamAuditInformation.Action)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGetTeamAuditInformation_Action::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.player_name_.Destroy();
  _impl_.player_real_name_.Destroy();
}

void CMsgGetTeamAuditInformation_Action::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGetTeamAuditInformation_Action::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGetTeamAuditInformation.Action)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.player_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.player_real_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.registration_period_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timestamp_) -
        reinterpret_cast<char*>(&_impl_.registration_period_)) + sizeof(_impl_.timestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGetTeamAuditInformation_Action::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 registration_period = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_registration_period(&has_bits);
          _impl_.registration_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 action = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_action(&has_bits);
          _impl_.action_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string player_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_player_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGetTeamAuditInformation.Action.player_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string player_real_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_player_real_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGetTeamAuditInformation.Action.player_real_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGetTeamAuditInformation_Action::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGetTeamAuditInformation.Action)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 registration_period = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_registration_period(), target);
  }

  // optional uint32 account_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_account_id(), target);
  }

  // optional uint32 action = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_action(), target);
  }

  // optional uint32 timestamp = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_timestamp(), target);
  }

  // optional string player_name = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_player_name().data(), static_cast<int>(this->_internal_player_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGetTeamAuditInformation.Action.player_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_player_name(), target);
  }

  // optional string player_real_name = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_player_real_name().data(), static_cast<int>(this->_internal_player_real_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGetTeamAuditInformation.Action.player_real_name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_player_real_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGetTeamAuditInformation.Action)
  return target;
}

size_t CMsgGetTeamAuditInformation_Action::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGetTeamAuditInformation.Action)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string player_name = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_player_name());
    }

    // optional string player_real_name = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_player_real_name());
    }

    // optional uint32 registration_period = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_registration_period());
    }

    // optional uint32 account_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 action = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_action());
    }

    // optional uint32 timestamp = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGetTeamAuditInformation_Action::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGetTeamAuditInformation_Action::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGetTeamAuditInformation_Action::GetClassData() const { return &_class_data_; }


void CMsgGetTeamAuditInformation_Action::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGetTeamAuditInformation_Action*>(&to_msg);
  auto& from = static_cast<const CMsgGetTeamAuditInformation_Action&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGetTeamAuditInformation.Action)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_player_name(from._internal_player_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_player_real_name(from._internal_player_real_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.registration_period_ = from._impl_.registration_period_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.action_ = from._impl_.action_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGetTeamAuditInformation_Action::CopyFrom(const CMsgGetTeamAuditInformation_Action& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGetTeamAuditInformation.Action)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGetTeamAuditInformation_Action::IsInitialized() const {
  return true;
}

void CMsgGetTeamAuditInformation_Action::InternalSwap(CMsgGetTeamAuditInformation_Action* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.player_name_, lhs_arena,
      &other->_impl_.player_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.player_real_name_, lhs_arena,
      &other->_impl_.player_real_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGetTeamAuditInformation_Action, _impl_.timestamp_)
      + sizeof(CMsgGetTeamAuditInformation_Action::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(CMsgGetTeamAuditInformation_Action, _impl_.registration_period_)>(
          reinterpret_cast<char*>(&_impl_.registration_period_),
          reinterpret_cast<char*>(&other->_impl_.registration_period_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGetTeamAuditInformation_Action::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[29]);
}

// ===================================================================

class CMsgGetTeamAuditInformation::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGetTeamAuditInformation>()._impl_._has_bits_);
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_updated(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgGetTeamAuditInformation::CMsgGetTeamAuditInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGetTeamAuditInformation)
}
CMsgGetTeamAuditInformation::CMsgGetTeamAuditInformation(const CMsgGetTeamAuditInformation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGetTeamAuditInformation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.actions_){from._impl_.actions_}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.last_updated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_name()) {
    _this->_impl_.team_name_.Set(from._internal_team_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.team_id_, &from._impl_.team_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_updated_) -
    reinterpret_cast<char*>(&_impl_.team_id_)) + sizeof(_impl_.last_updated_));
  // @@protoc_insertion_point(copy_constructor:CMsgGetTeamAuditInformation)
}

inline void CMsgGetTeamAuditInformation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.actions_){arena}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.last_updated_){0u}
  };
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGetTeamAuditInformation::~CMsgGetTeamAuditInformation() {
  // @@protoc_insertion_point(destructor:CMsgGetTeamAuditInformation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGetTeamAuditInformation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.actions_.~RepeatedPtrField();
  _impl_.team_name_.Destroy();
}

void CMsgGetTeamAuditInformation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGetTeamAuditInformation::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGetTeamAuditInformation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.actions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.team_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.team_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.last_updated_) -
        reinterpret_cast<char*>(&_impl_.team_id_)) + sizeof(_impl_.last_updated_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGetTeamAuditInformation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 team_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGetTeamAuditInformation.team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgGetTeamAuditInformation.Action actions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_updated = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_last_updated(&has_bits);
          _impl_.last_updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGetTeamAuditInformation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGetTeamAuditInformation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 team_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_team_id(), target);
  }

  // optional string team_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_name().data(), static_cast<int>(this->_internal_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGetTeamAuditInformation.team_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_team_name(), target);
  }

  // repeated .CMsgGetTeamAuditInformation.Action actions = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 last_updated = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_last_updated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGetTeamAuditInformation)
  return target;
}

size_t CMsgGetTeamAuditInformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGetTeamAuditInformation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGetTeamAuditInformation.Action actions = 3;
  total_size += 1UL * this->_internal_actions_size();
  for (const auto& msg : this->_impl_.actions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string team_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_name());
    }

    // optional uint32 team_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint32 last_updated = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_updated());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGetTeamAuditInformation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGetTeamAuditInformation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGetTeamAuditInformation::GetClassData() const { return &_class_data_; }


void CMsgGetTeamAuditInformation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGetTeamAuditInformation*>(&to_msg);
  auto& from = static_cast<const CMsgGetTeamAuditInformation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGetTeamAuditInformation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.actions_.MergeFrom(from._impl_.actions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_team_name(from._internal_team_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.last_updated_ = from._impl_.last_updated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGetTeamAuditInformation::CopyFrom(const CMsgGetTeamAuditInformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGetTeamAuditInformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGetTeamAuditInformation::IsInitialized() const {
  return true;
}

void CMsgGetTeamAuditInformation::InternalSwap(CMsgGetTeamAuditInformation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.actions_.InternalSwap(&other->_impl_.actions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_name_, lhs_arena,
      &other->_impl_.team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGetTeamAuditInformation, _impl_.last_updated_)
      + sizeof(CMsgGetTeamAuditInformation::_impl_.last_updated_)
      - PROTOBUF_FIELD_OFFSET(CMsgGetTeamAuditInformation, _impl_.team_id_)>(
          reinterpret_cast<char*>(&_impl_.team_id_),
          reinterpret_cast<char*>(&other->_impl_.team_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGetTeamAuditInformation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[30]);
}

// ===================================================================

class CMsgDOTADPCMatch::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTADPCMatch>()._impl_._has_bits_);
  static const ::CMsgDOTAMatch& match(const CMsgDOTADPCMatch* msg);
  static void set_has_match(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CDOTAMatchMetadata& metadata(const CMsgDOTADPCMatch* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgDOTAMatch&
CMsgDOTADPCMatch::_Internal::match(const CMsgDOTADPCMatch* msg) {
  return *msg->_impl_.match_;
}
const ::CDOTAMatchMetadata&
CMsgDOTADPCMatch::_Internal::metadata(const CMsgDOTADPCMatch* msg) {
  return *msg->_impl_.metadata_;
}
void CMsgDOTADPCMatch::clear_match() {
  if (_impl_.match_ != nullptr) _impl_.match_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgDOTADPCMatch::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgDOTADPCMatch::CMsgDOTADPCMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTADPCMatch)
}
CMsgDOTADPCMatch::CMsgDOTADPCMatch(const CMsgDOTADPCMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTADPCMatch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_){nullptr}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_match()) {
    _this->_impl_.match_ = new ::CMsgDOTAMatch(*from._impl_.match_);
  }
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::CDOTAMatchMetadata(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgDOTADPCMatch)
}

inline void CMsgDOTADPCMatch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_){nullptr}
    , decltype(_impl_.metadata_){nullptr}
  };
}

CMsgDOTADPCMatch::~CMsgDOTADPCMatch() {
  // @@protoc_insertion_point(destructor:CMsgDOTADPCMatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTADPCMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.match_;
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void CMsgDOTADPCMatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTADPCMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTADPCMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.match_ != nullptr);
      _impl_.match_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTADPCMatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgDOTAMatch match = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CDOTAMatchMetadata metadata = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTADPCMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTADPCMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgDOTAMatch match = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::match(this),
        _Internal::match(this).GetCachedSize(), target, stream);
  }

  // optional .CDOTAMatchMetadata metadata = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTADPCMatch)
  return target;
}

size_t CMsgDOTADPCMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTADPCMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgDOTAMatch match = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.match_);
    }

    // optional .CDOTAMatchMetadata metadata = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTADPCMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTADPCMatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTADPCMatch::GetClassData() const { return &_class_data_; }


void CMsgDOTADPCMatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTADPCMatch*>(&to_msg);
  auto& from = static_cast<const CMsgDOTADPCMatch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTADPCMatch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_match()->::CMsgDOTAMatch::MergeFrom(
          from._internal_match());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_metadata()->::CDOTAMatchMetadata::MergeFrom(
          from._internal_metadata());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTADPCMatch::CopyFrom(const CMsgDOTADPCMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTADPCMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTADPCMatch::IsInitialized() const {
  return true;
}

void CMsgDOTADPCMatch::InternalSwap(CMsgDOTADPCMatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTADPCMatch, _impl_.metadata_)
      + sizeof(CMsgDOTADPCMatch::_impl_.metadata_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTADPCMatch, _impl_.match_)>(
          reinterpret_cast<char*>(&_impl_.match_),
          reinterpret_cast<char*>(&other->_impl_.match_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTADPCMatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fwebapi_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fwebapi_2eproto[31]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgArcanaVotes_Match*
Arena::CreateMaybeMessage< ::CMsgArcanaVotes_Match >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgArcanaVotes_Match >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgArcanaVotes*
Arena::CreateMaybeMessage< ::CMsgArcanaVotes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgArcanaVotes >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCFeed_Element*
Arena::CreateMaybeMessage< ::CMsgDOTADPCFeed_Element >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCFeed_Element >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCFeed*
Arena::CreateMaybeMessage< ::CMsgDOTADPCFeed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCFeed >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCUserInfo*
Arena::CreateMaybeMessage< ::CMsgDOTADPCUserInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCUserInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDraftTrivia_DraftTriviaHeroInfo*
Arena::CreateMaybeMessage< ::CMsgDraftTrivia_DraftTriviaHeroInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDraftTrivia_DraftTriviaHeroInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDraftTrivia_DraftTriviaMatchInfo*
Arena::CreateMaybeMessage< ::CMsgDraftTrivia_DraftTriviaMatchInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDraftTrivia_DraftTriviaMatchInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDraftTrivia_PreviousResult*
Arena::CreateMaybeMessage< ::CMsgDraftTrivia_PreviousResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDraftTrivia_PreviousResult >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDraftTrivia*
Arena::CreateMaybeMessage< ::CMsgDraftTrivia >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDraftTrivia >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTeamFanContentAssetStatus*
Arena::CreateMaybeMessage< ::CMsgTeamFanContentAssetStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTeamFanContentAssetStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTeamFanContentAssetStatusResponse*
Arena::CreateMaybeMessage< ::CMsgTeamFanContentAssetStatusResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTeamFanContentAssetStatusResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTeamFanContentStatus_TeamStatus*
Arena::CreateMaybeMessage< ::CMsgTeamFanContentStatus_TeamStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTeamFanContentStatus_TeamStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTeamFanContentStatus*
Arena::CreateMaybeMessage< ::CMsgTeamFanContentStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTeamFanContentStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTeamFanContentAutographStatus_AutographStatus*
Arena::CreateMaybeMessage< ::CMsgTeamFanContentAutographStatus_AutographStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTeamFanContentAutographStatus_AutographStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTeamFanContentAutographStatus_TeamStatus*
Arena::CreateMaybeMessage< ::CMsgTeamFanContentAutographStatus_TeamStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTeamFanContentAutographStatus_TeamStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTeamFanContentAutographStatus*
Arena::CreateMaybeMessage< ::CMsgTeamFanContentAutographStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTeamFanContentAutographStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDPCEvent_PhaseInfo*
Arena::CreateMaybeMessage< ::CMsgDPCEvent_PhaseInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDPCEvent_PhaseInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDPCEvent_League*
Arena::CreateMaybeMessage< ::CMsgDPCEvent_League >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDPCEvent_League >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDPCEvent*
Arena::CreateMaybeMessage< ::CMsgDPCEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDPCEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDPCEventList*
Arena::CreateMaybeMessage< ::CMsgDPCEventList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDPCEventList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAFantasyCardLineup_CardBonus*
Arena::CreateMaybeMessage< ::CMsgDOTAFantasyCardLineup_CardBonus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAFantasyCardLineup_CardBonus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAFantasyCardLineup_Card*
Arena::CreateMaybeMessage< ::CMsgDOTAFantasyCardLineup_Card >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAFantasyCardLineup_Card >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAFantasyCardLineup_League*
Arena::CreateMaybeMessage< ::CMsgDOTAFantasyCardLineup_League >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAFantasyCardLineup_League >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAFantasyCardLineup_Period*
Arena::CreateMaybeMessage< ::CMsgDOTAFantasyCardLineup_Period >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAFantasyCardLineup_Period >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAFantasyCardLineup*
Arena::CreateMaybeMessage< ::CMsgDOTAFantasyCardLineup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAFantasyCardLineup >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAFantasyCardList_CardBonus*
Arena::CreateMaybeMessage< ::CMsgDOTAFantasyCardList_CardBonus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAFantasyCardList_CardBonus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAFantasyCardList_Card*
Arena::CreateMaybeMessage< ::CMsgDOTAFantasyCardList_Card >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAFantasyCardList_Card >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAFantasyCardList*
Arena::CreateMaybeMessage< ::CMsgDOTAFantasyCardList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAFantasyCardList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgChatToxicityReport*
Arena::CreateMaybeMessage< ::CMsgChatToxicityReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgChatToxicityReport >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGetTeamAuditInformation_Action*
Arena::CreateMaybeMessage< ::CMsgGetTeamAuditInformation_Action >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGetTeamAuditInformation_Action >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGetTeamAuditInformation*
Arena::CreateMaybeMessage< ::CMsgGetTeamAuditInformation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGetTeamAuditInformation >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTADPCMatch*
Arena::CreateMaybeMessage< ::CMsgDOTADPCMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTADPCMatch >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
