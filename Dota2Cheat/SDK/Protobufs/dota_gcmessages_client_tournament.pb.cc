// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_client_tournament.proto

#include "dota_gcmessages_client_tournament.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CMsgRequestWeekendTourneySchedule::CMsgRequestWeekendTourneySchedule(
    ::_pbi::ConstantInitialized) {}
struct CMsgRequestWeekendTourneyScheduleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgRequestWeekendTourneyScheduleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgRequestWeekendTourneyScheduleDefaultTypeInternal() {}
  union {
    CMsgRequestWeekendTourneySchedule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgRequestWeekendTourneyScheduleDefaultTypeInternal _CMsgRequestWeekendTourneySchedule_default_instance_;
PROTOBUF_CONSTEXPR CMsgWeekendTourneySchedule_Division::CMsgWeekendTourneySchedule_Division(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.division_code_)*/0u
  , /*decltype(_impl_.time_window_open_)*/0u
  , /*decltype(_impl_.time_window_close_)*/0u
  , /*decltype(_impl_.time_window_open_next_)*/0u
  , /*decltype(_impl_.trophy_id_)*/0u
  , /*decltype(_impl_.free_weekend_)*/false} {}
struct CMsgWeekendTourneySchedule_DivisionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgWeekendTourneySchedule_DivisionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgWeekendTourneySchedule_DivisionDefaultTypeInternal() {}
  union {
    CMsgWeekendTourneySchedule_Division _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgWeekendTourneySchedule_DivisionDefaultTypeInternal _CMsgWeekendTourneySchedule_Division_default_instance_;
PROTOBUF_CONSTEXPR CMsgWeekendTourneySchedule::CMsgWeekendTourneySchedule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.divisions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgWeekendTourneyScheduleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgWeekendTourneyScheduleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgWeekendTourneyScheduleDefaultTypeInternal() {}
  union {
    CMsgWeekendTourneySchedule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgWeekendTourneyScheduleDefaultTypeInternal _CMsgWeekendTourneySchedule_default_instance_;
PROTOBUF_CONSTEXPR CMsgWeekendTourneyOpts::CMsgWeekendTourneyOpts(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pickup_team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.participating_)*/false
  , /*decltype(_impl_.division_id_)*/0u
  , /*decltype(_impl_.buyin_)*/0u
  , /*decltype(_impl_.skill_level_)*/0u
  , /*decltype(_impl_.match_groups_)*/0u
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.pickup_team_logo_)*/uint64_t{0u}} {}
struct CMsgWeekendTourneyOptsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgWeekendTourneyOptsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgWeekendTourneyOptsDefaultTypeInternal() {}
  union {
    CMsgWeekendTourneyOpts _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgWeekendTourneyOptsDefaultTypeInternal _CMsgWeekendTourneyOpts_default_instance_;
PROTOBUF_CONSTEXPR CMsgWeekendTourneyLeave::CMsgWeekendTourneyLeave(
    ::_pbi::ConstantInitialized) {}
struct CMsgWeekendTourneyLeaveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgWeekendTourneyLeaveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgWeekendTourneyLeaveDefaultTypeInternal() {}
  union {
    CMsgWeekendTourneyLeave _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgWeekendTourneyLeaveDefaultTypeInternal _CMsgWeekendTourneyLeave_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTATournament_Team::CMsgDOTATournament_Team(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_._players_cached_byte_size_)*/{0}
  , /*decltype(_impl_.player_buyin_)*/{}
  , /*decltype(_impl_._player_buyin_cached_byte_size_)*/{0}
  , /*decltype(_impl_.player_skill_level_)*/{}
  , /*decltype(_impl_._player_skill_level_cached_byte_size_)*/{0}
  , /*decltype(_impl_.team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_gid_)*/uint64_t{0u}
  , /*decltype(_impl_.node_or_state_)*/0u
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.team_base_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.team_ui_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.match_group_mask_)*/0u} {}
struct CMsgDOTATournament_TeamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTATournament_TeamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTATournament_TeamDefaultTypeInternal() {}
  union {
    CMsgDOTATournament_Team _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTATournament_TeamDefaultTypeInternal _CMsgDOTATournament_Team_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTATournament_Game::CMsgDOTATournament_Game(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lobby_id_)*/uint64_t{0u}
  , /*decltype(_impl_.node_idx_)*/0u
  , /*decltype(_impl_.team_a_good_)*/false
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.state_)*/0
  , /*decltype(_impl_.start_time_)*/0u} {}
struct CMsgDOTATournament_GameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTATournament_GameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTATournament_GameDefaultTypeInternal() {}
  union {
    CMsgDOTATournament_Game _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTATournament_GameDefaultTypeInternal _CMsgDOTATournament_Game_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTATournament_Node::CMsgDOTATournament_Node(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.node_id_)*/0u
  , /*decltype(_impl_.team_idx_a_)*/0u
  , /*decltype(_impl_.team_idx_b_)*/0u
  , /*decltype(_impl_.node_state_)*/0} {}
struct CMsgDOTATournament_NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTATournament_NodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTATournament_NodeDefaultTypeInternal() {}
  union {
    CMsgDOTATournament_Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTATournament_NodeDefaultTypeInternal _CMsgDOTATournament_Node_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTATournament::CMsgDOTATournament(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.teams_)*/{}
  , /*decltype(_impl_.games_)*/{}
  , /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_.tournament_id_)*/0u
  , /*decltype(_impl_.division_id_)*/0u
  , /*decltype(_impl_.schedule_time_)*/0u
  , /*decltype(_impl_.skill_level_)*/0u
  , /*decltype(_impl_.tournament_template_)*/0
  , /*decltype(_impl_.state_)*/0
  , /*decltype(_impl_.state_seq_num_)*/0u
  , /*decltype(_impl_.season_trophy_id_)*/0u} {}
struct CMsgDOTATournamentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTATournamentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTATournamentDefaultTypeInternal() {}
  union {
    CMsgDOTATournament _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTATournamentDefaultTypeInternal _CMsgDOTATournament_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTATournamentStateChange_GameChange::CMsgDOTATournamentStateChange_GameChange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.new_state_)*/0} {}
struct CMsgDOTATournamentStateChange_GameChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTATournamentStateChange_GameChangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTATournamentStateChange_GameChangeDefaultTypeInternal() {}
  union {
    CMsgDOTATournamentStateChange_GameChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTATournamentStateChange_GameChangeDefaultTypeInternal _CMsgDOTATournamentStateChange_GameChange_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTATournamentStateChange_TeamChange::CMsgDOTATournamentStateChange_TeamChange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.team_gid_)*/uint64_t{0u}
  , /*decltype(_impl_.new_node_or_state_)*/0u
  , /*decltype(_impl_.old_node_or_state_)*/0u} {}
struct CMsgDOTATournamentStateChange_TeamChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTATournamentStateChange_TeamChangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTATournamentStateChange_TeamChangeDefaultTypeInternal() {}
  union {
    CMsgDOTATournamentStateChange_TeamChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTATournamentStateChange_TeamChangeDefaultTypeInternal _CMsgDOTATournamentStateChange_TeamChange_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTATournamentStateChange::CMsgDOTATournamentStateChange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.game_changes_)*/{}
  , /*decltype(_impl_.team_changes_)*/{}
  , /*decltype(_impl_.merged_tournament_ids_)*/{}
  , /*decltype(_impl_._merged_tournament_ids_cached_byte_size_)*/{0}
  , /*decltype(_impl_.new_tournament_id_)*/0u
  , /*decltype(_impl_.event_)*/0
  , /*decltype(_impl_.new_tournament_state_)*/0
  , /*decltype(_impl_.state_seq_num_)*/0u} {}
struct CMsgDOTATournamentStateChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTATournamentStateChangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTATournamentStateChangeDefaultTypeInternal() {}
  union {
    CMsgDOTATournamentStateChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTATournamentStateChangeDefaultTypeInternal _CMsgDOTATournamentStateChange_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyPlayerSkillLevelStats::CMsgDOTAWeekendTourneyPlayerSkillLevelStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.skill_level_)*/0u
  , /*decltype(_impl_.times_won_0_)*/0u
  , /*decltype(_impl_.times_won_1_)*/0u
  , /*decltype(_impl_.times_won_2_)*/0u
  , /*decltype(_impl_.times_won_3_)*/0u
  , /*decltype(_impl_.times_bye_and_lost_)*/0u
  , /*decltype(_impl_.times_bye_and_won_)*/0u
  , /*decltype(_impl_.total_games_won_)*/0u
  , /*decltype(_impl_.score_)*/0u
  , /*decltype(_impl_.times_unusual_champ_)*/0u} {}
struct CMsgDOTAWeekendTourneyPlayerSkillLevelStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyPlayerSkillLevelStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAWeekendTourneyPlayerSkillLevelStatsDefaultTypeInternal() {}
  union {
    CMsgDOTAWeekendTourneyPlayerSkillLevelStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAWeekendTourneyPlayerSkillLevelStatsDefaultTypeInternal _CMsgDOTAWeekendTourneyPlayerSkillLevelStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyPlayerStats::CMsgDOTAWeekendTourneyPlayerStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.skill_levels_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.season_trophy_id_)*/0u
  , /*decltype(_impl_.current_tier_)*/0u} {}
struct CMsgDOTAWeekendTourneyPlayerStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyPlayerStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAWeekendTourneyPlayerStatsDefaultTypeInternal() {}
  union {
    CMsgDOTAWeekendTourneyPlayerStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAWeekendTourneyPlayerStatsDefaultTypeInternal _CMsgDOTAWeekendTourneyPlayerStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyPlayerStatsRequest::CMsgDOTAWeekendTourneyPlayerStatsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.season_trophy_id_)*/0u} {}
struct CMsgDOTAWeekendTourneyPlayerStatsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyPlayerStatsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAWeekendTourneyPlayerStatsRequestDefaultTypeInternal() {}
  union {
    CMsgDOTAWeekendTourneyPlayerStatsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAWeekendTourneyPlayerStatsRequestDefaultTypeInternal _CMsgDOTAWeekendTourneyPlayerStatsRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyPlayerHistory_Tournament::CMsgDOTAWeekendTourneyPlayerHistory_Tournament(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/{}
  , /*decltype(_impl_.team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tournament_id_)*/0u
  , /*decltype(_impl_.start_time_)*/0u
  , /*decltype(_impl_.tournament_tier_)*/0u
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.team_date_)*/0u
  , /*decltype(_impl_.team_result_)*/0u
  , /*decltype(_impl_.season_trophy_id_)*/0u} {}
struct CMsgDOTAWeekendTourneyPlayerHistory_TournamentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyPlayerHistory_TournamentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAWeekendTourneyPlayerHistory_TournamentDefaultTypeInternal() {}
  union {
    CMsgDOTAWeekendTourneyPlayerHistory_Tournament _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAWeekendTourneyPlayerHistory_TournamentDefaultTypeInternal _CMsgDOTAWeekendTourneyPlayerHistory_Tournament_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyPlayerHistory::CMsgDOTAWeekendTourneyPlayerHistory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tournaments_)*/{}
  , /*decltype(_impl_.account_id_)*/0u} {}
struct CMsgDOTAWeekendTourneyPlayerHistoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyPlayerHistoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAWeekendTourneyPlayerHistoryDefaultTypeInternal() {}
  union {
    CMsgDOTAWeekendTourneyPlayerHistory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAWeekendTourneyPlayerHistoryDefaultTypeInternal _CMsgDOTAWeekendTourneyPlayerHistory_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyParticipationDetails_Tier::CMsgDOTAWeekendTourneyParticipationDetails_Tier(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tier_)*/0u
  , /*decltype(_impl_.players_)*/0u
  , /*decltype(_impl_.teams_)*/0u
  , /*decltype(_impl_.winning_teams_)*/0u
  , /*decltype(_impl_.players_streak_2_)*/0u
  , /*decltype(_impl_.players_streak_3_)*/0u
  , /*decltype(_impl_.players_streak_4_)*/0u
  , /*decltype(_impl_.players_streak_5_)*/0u} {}
struct CMsgDOTAWeekendTourneyParticipationDetails_TierDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyParticipationDetails_TierDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAWeekendTourneyParticipationDetails_TierDefaultTypeInternal() {}
  union {
    CMsgDOTAWeekendTourneyParticipationDetails_Tier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAWeekendTourneyParticipationDetails_TierDefaultTypeInternal _CMsgDOTAWeekendTourneyParticipationDetails_Tier_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyParticipationDetails_Division::CMsgDOTAWeekendTourneyParticipationDetails_Division(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tiers_)*/{}
  , /*decltype(_impl_.division_id_)*/0u
  , /*decltype(_impl_.schedule_time_)*/0u} {}
struct CMsgDOTAWeekendTourneyParticipationDetails_DivisionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyParticipationDetails_DivisionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAWeekendTourneyParticipationDetails_DivisionDefaultTypeInternal() {}
  union {
    CMsgDOTAWeekendTourneyParticipationDetails_Division _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAWeekendTourneyParticipationDetails_DivisionDefaultTypeInternal _CMsgDOTAWeekendTourneyParticipationDetails_Division_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyParticipationDetails::CMsgDOTAWeekendTourneyParticipationDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.divisions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTAWeekendTourneyParticipationDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAWeekendTourneyParticipationDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAWeekendTourneyParticipationDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTAWeekendTourneyParticipationDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAWeekendTourneyParticipationDetailsDefaultTypeInternal _CMsgDOTAWeekendTourneyParticipationDetails_default_instance_;
static ::_pb::Metadata file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[20];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_dota_5fgcmessages_5fclient_5ftournament_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_dota_5fgcmessages_5fclient_5ftournament_2eproto = nullptr;

const uint32_t TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgRequestWeekendTourneySchedule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneySchedule_Division, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneySchedule_Division, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneySchedule_Division, _impl_.division_code_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneySchedule_Division, _impl_.time_window_open_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneySchedule_Division, _impl_.time_window_close_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneySchedule_Division, _impl_.time_window_open_next_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneySchedule_Division, _impl_.trophy_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneySchedule_Division, _impl_.free_weekend_),
  0,
  1,
  2,
  3,
  4,
  5,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneySchedule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneySchedule, _impl_.divisions_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneyOpts, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneyOpts, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneyOpts, _impl_.participating_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneyOpts, _impl_.division_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneyOpts, _impl_.buyin_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneyOpts, _impl_.skill_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneyOpts, _impl_.match_groups_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneyOpts, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneyOpts, _impl_.pickup_team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneyOpts, _impl_.pickup_team_logo_),
  1,
  2,
  3,
  4,
  5,
  6,
  0,
  7,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgWeekendTourneyLeave, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Team, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Team, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Team, _impl_.team_gid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Team, _impl_.node_or_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Team, _impl_.players_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Team, _impl_.player_buyin_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Team, _impl_.player_skill_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Team, _impl_.match_group_mask_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Team, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Team, _impl_.team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Team, _impl_.team_base_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Team, _impl_.team_ui_logo_),
  1,
  2,
  ~0u,
  ~0u,
  ~0u,
  6,
  3,
  0,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Game, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Game, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Game, _impl_.node_idx_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Game, _impl_.lobby_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Game, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Game, _impl_.team_a_good_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Game, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Game, _impl_.start_time_),
  1,
  0,
  3,
  2,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Node, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Node, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Node, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Node, _impl_.team_idx_a_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Node, _impl_.team_idx_b_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament_Node, _impl_.node_state_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _impl_.tournament_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _impl_.division_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _impl_.schedule_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _impl_.skill_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _impl_.tournament_template_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _impl_.state_seq_num_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _impl_.season_trophy_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _impl_.teams_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _impl_.games_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournament, _impl_.nodes_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange_GameChange, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange_GameChange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange_GameChange, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange_GameChange, _impl_.new_state_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange_TeamChange, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange_TeamChange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange_TeamChange, _impl_.team_gid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange_TeamChange, _impl_.new_node_or_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange_TeamChange, _impl_.old_node_or_state_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange, _impl_.new_tournament_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange, _impl_.event_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange, _impl_.new_tournament_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange, _impl_.game_changes_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange, _impl_.team_changes_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange, _impl_.merged_tournament_ids_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATournamentStateChange, _impl_.state_seq_num_),
  0,
  1,
  2,
  ~0u,
  ~0u,
  ~0u,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_.skill_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_.times_won_0_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_.times_won_1_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_.times_won_2_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_.times_won_3_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_.times_bye_and_lost_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_.times_bye_and_won_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_.times_unusual_champ_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_.total_games_won_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_.score_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  9,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerStats, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerStats, _impl_.season_trophy_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerStats, _impl_.skill_levels_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerStats, _impl_.current_tier_),
  0,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerStatsRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerStatsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerStatsRequest, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerStatsRequest, _impl_.season_trophy_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _impl_.tournament_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _impl_.start_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _impl_.tournament_tier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _impl_.team_date_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _impl_.team_result_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _impl_.team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _impl_.season_trophy_id_),
  1,
  2,
  3,
  4,
  5,
  6,
  ~0u,
  0,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyPlayerHistory, _impl_.tournaments_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Tier, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Tier, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Tier, _impl_.tier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Tier, _impl_.players_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Tier, _impl_.teams_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Tier, _impl_.winning_teams_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Tier, _impl_.players_streak_2_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Tier, _impl_.players_streak_3_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Tier, _impl_.players_streak_4_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Tier, _impl_.players_streak_5_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Division, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Division, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Division, _impl_.division_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Division, _impl_.schedule_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails_Division, _impl_.tiers_),
  0,
  1,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAWeekendTourneyParticipationDetails, _impl_.divisions_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::CMsgRequestWeekendTourneySchedule)},
  { 6, 18, -1, sizeof(::CMsgWeekendTourneySchedule_Division)},
  { 24, -1, -1, sizeof(::CMsgWeekendTourneySchedule)},
  { 31, 45, -1, sizeof(::CMsgWeekendTourneyOpts)},
  { 53, -1, -1, sizeof(::CMsgWeekendTourneyLeave)},
  { 59, 75, -1, sizeof(::CMsgDOTATournament_Team)},
  { 85, 97, -1, sizeof(::CMsgDOTATournament_Game)},
  { 103, 113, -1, sizeof(::CMsgDOTATournament_Node)},
  { 117, 134, -1, sizeof(::CMsgDOTATournament)},
  { 145, 153, -1, sizeof(::CMsgDOTATournamentStateChange_GameChange)},
  { 155, 164, -1, sizeof(::CMsgDOTATournamentStateChange_TeamChange)},
  { 167, 180, -1, sizeof(::CMsgDOTATournamentStateChange)},
  { 187, 203, -1, sizeof(::CMsgDOTAWeekendTourneyPlayerSkillLevelStats)},
  { 213, 223, -1, sizeof(::CMsgDOTAWeekendTourneyPlayerStats)},
  { 227, 235, -1, sizeof(::CMsgDOTAWeekendTourneyPlayerStatsRequest)},
  { 237, 252, -1, sizeof(::CMsgDOTAWeekendTourneyPlayerHistory_Tournament)},
  { 261, 269, -1, sizeof(::CMsgDOTAWeekendTourneyPlayerHistory)},
  { 271, 285, -1, sizeof(::CMsgDOTAWeekendTourneyParticipationDetails_Tier)},
  { 293, 302, -1, sizeof(::CMsgDOTAWeekendTourneyParticipationDetails_Division)},
  { 305, -1, -1, sizeof(::CMsgDOTAWeekendTourneyParticipationDetails)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CMsgRequestWeekendTourneySchedule_default_instance_._instance,
  &::_CMsgWeekendTourneySchedule_Division_default_instance_._instance,
  &::_CMsgWeekendTourneySchedule_default_instance_._instance,
  &::_CMsgWeekendTourneyOpts_default_instance_._instance,
  &::_CMsgWeekendTourneyLeave_default_instance_._instance,
  &::_CMsgDOTATournament_Team_default_instance_._instance,
  &::_CMsgDOTATournament_Game_default_instance_._instance,
  &::_CMsgDOTATournament_Node_default_instance_._instance,
  &::_CMsgDOTATournament_default_instance_._instance,
  &::_CMsgDOTATournamentStateChange_GameChange_default_instance_._instance,
  &::_CMsgDOTATournamentStateChange_TeamChange_default_instance_._instance,
  &::_CMsgDOTATournamentStateChange_default_instance_._instance,
  &::_CMsgDOTAWeekendTourneyPlayerSkillLevelStats_default_instance_._instance,
  &::_CMsgDOTAWeekendTourneyPlayerStats_default_instance_._instance,
  &::_CMsgDOTAWeekendTourneyPlayerStatsRequest_default_instance_._instance,
  &::_CMsgDOTAWeekendTourneyPlayerHistory_Tournament_default_instance_._instance,
  &::_CMsgDOTAWeekendTourneyPlayerHistory_default_instance_._instance,
  &::_CMsgDOTAWeekendTourneyParticipationDetails_Tier_default_instance_._instance,
  &::_CMsgDOTAWeekendTourneyParticipationDetails_Division_default_instance_._instance,
  &::_CMsgDOTAWeekendTourneyParticipationDetails_default_instance_._instance,
};

const char descriptor_table_protodef_dota_5fgcmessages_5fclient_5ftournament_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\'dota_gcmessages_client_tournament.prot"
  "o\032\027dota_client_enums.proto\"#\n!CMsgReques"
  "tWeekendTourneySchedule\"\366\001\n\032CMsgWeekendT"
  "ourneySchedule\0227\n\tdivisions\030\001 \003(\0132$.CMsg"
  "WeekendTourneySchedule.Division\032\236\001\n\010Divi"
  "sion\022\025\n\rdivision_code\030\001 \001(\r\022\030\n\020time_wind"
  "ow_open\030\002 \001(\r\022\031\n\021time_window_close\030\003 \001(\r"
  "\022\035\n\025time_window_open_next\030\004 \001(\r\022\021\n\ttroph"
  "y_id\030\005 \001(\r\022\024\n\014free_weekend\030\006 \001(\010\"\303\001\n\026CMs"
  "gWeekendTourneyOpts\022\025\n\rparticipating\030\001 \001"
  "(\010\022\023\n\013division_id\030\002 \001(\r\022\r\n\005buyin\030\003 \001(\r\022\023"
  "\n\013skill_level\030\004 \001(\r\022\024\n\014match_groups\030\005 \001("
  "\r\022\017\n\007team_id\030\006 \001(\r\022\030\n\020pickup_team_name\030\007"
  " \001(\t\022\030\n\020pickup_team_logo\030\010 \001(\004\"\031\n\027CMsgWe"
  "ekendTourneyLeave\"\315\007\n\022CMsgDOTATournament"
  "\022\025\n\rtournament_id\030\001 \001(\r\022\023\n\013division_id\030\002"
  " \001(\r\022\025\n\rschedule_time\030\003 \001(\r\022\023\n\013skill_lev"
  "el\030\004 \001(\r\022M\n\023tournament_template\030\005 \001(\0162\024."
  "ETournamentTemplate:\032k_ETournamentTempla"
  "te_None\022<\n\005state\030\006 \001(\0162\021.ETournamentStat"
  "e:\032k_ETournamentState_Unknown\022\025\n\rstate_s"
  "eq_num\030\n \001(\r\022\030\n\020season_trophy_id\030\013 \001(\r\022\'"
  "\n\005teams\030\007 \003(\0132\030.CMsgDOTATournament.Team\022"
  "\'\n\005games\030\010 \003(\0132\030.CMsgDOTATournament.Game"
  "\022\'\n\005nodes\030\t \003(\0132\030.CMsgDOTATournament.Nod"
  "e\032\352\001\n\004Team\022\020\n\010team_gid\030\001 \001(\006\022\025\n\rnode_or_"
  "state\030\002 \001(\r\022\023\n\007players\030\003 \003(\rB\002\020\001\022\030\n\014play"
  "er_buyin\030\t \003(\rB\002\020\001\022\036\n\022player_skill_level"
  "\030\n \003(\rB\002\020\001\022\030\n\020match_group_mask\030\014 \001(\r\022\017\n\007"
  "team_id\030\004 \001(\r\022\021\n\tteam_name\030\005 \001(\t\022\026\n\016team"
  "_base_logo\030\007 \001(\004\022\024\n\014team_ui_logo\030\010 \001(\004\032\253"
  "\001\n\004Game\022\020\n\010node_idx\030\001 \001(\r\022\020\n\010lobby_id\030\002 "
  "\001(\006\022\020\n\010match_id\030\003 \001(\004\022\023\n\013team_a_good\030\004 \001"
  "(\010\022D\n\005state\030\005 \001(\0162\025.ETournamentGameState"
  ":\036k_ETournamentGameState_Unknown\022\022\n\nstar"
  "t_time\030\006 \001(\r\032\212\001\n\004Node\022\017\n\007node_id\030\001 \001(\r\022\022"
  "\n\nteam_idx_a\030\002 \001(\r\022\022\n\nteam_idx_b\030\003 \001(\r\022I"
  "\n\nnode_state\030\004 \001(\0162\025.ETournamentNodeStat"
  "e:\036k_ETournamentNodeState_Unknown\"\276\004\n\035CM"
  "sgDOTATournamentStateChange\022\031\n\021new_tourn"
  "ament_id\030\001 \001(\r\0229\n\005event\030\002 \001(\0162\021.ETournam"
  "entEvent:\027k_ETournamentEvent_None\022K\n\024new"
  "_tournament_state\030\003 \001(\0162\021.ETournamentSta"
  "te:\032k_ETournamentState_Unknown\022\?\n\014game_c"
  "hanges\030\004 \003(\0132).CMsgDOTATournamentStateCh"
  "ange.GameChange\022\?\n\014team_changes\030\005 \003(\0132)."
  "CMsgDOTATournamentStateChange.TeamChange"
  "\022!\n\025merged_tournament_ids\030\006 \003(\rB\002\020\001\022\025\n\rs"
  "tate_seq_num\030\007 \001(\r\032h\n\nGameChange\022\020\n\010matc"
  "h_id\030\001 \001(\004\022H\n\tnew_state\030\002 \001(\0162\025.ETournam"
  "entGameState:\036k_ETournamentGameState_Unk"
  "nown\032T\n\nTeamChange\022\020\n\010team_gid\030\001 \001(\004\022\031\n\021"
  "new_node_or_state\030\002 \001(\r\022\031\n\021old_node_or_s"
  "tate\030\003 \001(\r\"\222\002\n+CMsgDOTAWeekendTourneyPla"
  "yerSkillLevelStats\022\023\n\013skill_level\030\001 \001(\r\022"
  "\023\n\013times_won_0\030\002 \001(\r\022\023\n\013times_won_1\030\003 \001("
  "\r\022\023\n\013times_won_2\030\004 \001(\r\022\023\n\013times_won_3\030\005 "
  "\001(\r\022\032\n\022times_bye_and_lost\030\006 \001(\r\022\031\n\021times"
  "_bye_and_won\030\007 \001(\r\022\033\n\023times_unusual_cham"
  "p\030\n \001(\r\022\027\n\017total_games_won\030\010 \001(\r\022\r\n\005scor"
  "e\030\t \001(\r\"\253\001\n!CMsgDOTAWeekendTourneyPlayer"
  "Stats\022\022\n\naccount_id\030\001 \001(\r\022\030\n\020season_trop"
  "hy_id\030\002 \001(\r\022B\n\014skill_levels\030\003 \003(\0132,.CMsg"
  "DOTAWeekendTourneyPlayerSkillLevelStats\022"
  "\024\n\014current_tier\030\004 \001(\r\"X\n(CMsgDOTAWeekend"
  "TourneyPlayerStatsRequest\022\022\n\naccount_id\030"
  "\001 \001(\r\022\030\n\020season_trophy_id\030\002 \001(\r\"\314\002\n#CMsg"
  "DOTAWeekendTourneyPlayerHistory\022\022\n\naccou"
  "nt_id\030\001 \001(\r\022D\n\013tournaments\030\003 \003(\0132/.CMsgD"
  "OTAWeekendTourneyPlayerHistory.Tournamen"
  "t\032\312\001\n\nTournament\022\025\n\rtournament_id\030\001 \001(\r\022"
  "\022\n\nstart_time\030\002 \001(\r\022\027\n\017tournament_tier\030\003"
  " \001(\r\022\017\n\007team_id\030\004 \001(\r\022\021\n\tteam_date\030\005 \001(\r"
  "\022\023\n\013team_result\030\006 \001(\r\022\022\n\naccount_id\030\007 \003("
  "\r\022\021\n\tteam_name\030\010 \001(\t\022\030\n\020season_trophy_id"
  "\030\t \001(\r\"\244\003\n*CMsgDOTAWeekendTourneyPartici"
  "pationDetails\022G\n\tdivisions\030\001 \003(\01324.CMsgD"
  "OTAWeekendTourneyParticipationDetails.Di"
  "vision\032\263\001\n\004Tier\022\014\n\004tier\030\001 \001(\r\022\017\n\007players"
  "\030\002 \001(\r\022\r\n\005teams\030\003 \001(\r\022\025\n\rwinning_teams\030\004"
  " \001(\r\022\030\n\020players_streak_2\030\005 \001(\r\022\030\n\020player"
  "s_streak_3\030\006 \001(\r\022\030\n\020players_streak_4\030\007 \001"
  "(\r\022\030\n\020players_streak_5\030\010 \001(\r\032w\n\010Division"
  "\022\023\n\013division_id\030\001 \001(\r\022\025\n\rschedule_time\030\002"
  " \001(\r\022\?\n\005tiers\030\003 \003(\01320.CMsgDOTAWeekendTou"
  "rneyParticipationDetails.Tier*\266\004\n\020ETourn"
  "amentEvent\022\033\n\027k_ETournamentEvent_None\020\000\022"
  "(\n$k_ETournamentEvent_TournamentCreated\020"
  "\001\022(\n$k_ETournamentEvent_TournamentsMerge"
  "d\020\002\022\"\n\036k_ETournamentEvent_GameOutcome\020\003\022"
  "#\n\037k_ETournamentEvent_TeamGivenBye\020\004\0220\n,"
  "k_ETournamentEvent_TournamentCanceledByA"
  "dmin\020\005\022$\n k_ETournamentEvent_TeamAbandon"
  "ed\020\006\022+\n\'k_ETournamentEvent_ScheduledGame"
  "Started\020\007\022\037\n\033k_ETournamentEvent_Canceled"
  "\020\010\022\?\n;k_ETournamentEvent_TeamParticipati"
  "onTimedOut_EntryFeeRefund\020\t\022@\n<k_ETourna"
  "mentEvent_TeamParticipationTimedOut_Entr"
  "yFeeForfeit\020\n\022\?\n;k_ETournamentEvent_Team"
  "ParticipationTimedOut_GrantedVictory\020\013"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_deps[1] = {
  &::descriptor_table_dota_5fclient_5fenums_2eproto,
};
static ::_pbi::once_flag descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto = {
    false, false, 3998, descriptor_table_protodef_dota_5fgcmessages_5fclient_5ftournament_2eproto,
    "dota_gcmessages_client_tournament.proto",
    &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once, descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_deps, 1, 20,
    schemas, file_default_instances, TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto::offsets,
    file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto, file_level_enum_descriptors_dota_5fgcmessages_5fclient_5ftournament_2eproto,
    file_level_service_descriptors_dota_5fgcmessages_5fclient_5ftournament_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter() {
  return &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_dota_5fgcmessages_5fclient_5ftournament_2eproto(&descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETournamentEvent_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fclient_5ftournament_2eproto[0];
}
bool ETournamentEvent_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CMsgRequestWeekendTourneySchedule::_Internal {
 public:
};

CMsgRequestWeekendTourneySchedule::CMsgRequestWeekendTourneySchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgRequestWeekendTourneySchedule)
}
CMsgRequestWeekendTourneySchedule::CMsgRequestWeekendTourneySchedule(const CMsgRequestWeekendTourneySchedule& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgRequestWeekendTourneySchedule* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgRequestWeekendTourneySchedule)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRequestWeekendTourneySchedule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRequestWeekendTourneySchedule::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgRequestWeekendTourneySchedule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[0]);
}

// ===================================================================

class CMsgWeekendTourneySchedule_Division::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgWeekendTourneySchedule_Division>()._impl_._has_bits_);
  static void set_has_division_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_time_window_open(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_time_window_close(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time_window_open_next(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_trophy_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_free_weekend(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CMsgWeekendTourneySchedule_Division::CMsgWeekendTourneySchedule_Division(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgWeekendTourneySchedule.Division)
}
CMsgWeekendTourneySchedule_Division::CMsgWeekendTourneySchedule_Division(const CMsgWeekendTourneySchedule_Division& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgWeekendTourneySchedule_Division* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.division_code_){}
    , decltype(_impl_.time_window_open_){}
    , decltype(_impl_.time_window_close_){}
    , decltype(_impl_.time_window_open_next_){}
    , decltype(_impl_.trophy_id_){}
    , decltype(_impl_.free_weekend_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.division_code_, &from._impl_.division_code_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.free_weekend_) -
    reinterpret_cast<char*>(&_impl_.division_code_)) + sizeof(_impl_.free_weekend_));
  // @@protoc_insertion_point(copy_constructor:CMsgWeekendTourneySchedule.Division)
}

inline void CMsgWeekendTourneySchedule_Division::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.division_code_){0u}
    , decltype(_impl_.time_window_open_){0u}
    , decltype(_impl_.time_window_close_){0u}
    , decltype(_impl_.time_window_open_next_){0u}
    , decltype(_impl_.trophy_id_){0u}
    , decltype(_impl_.free_weekend_){false}
  };
}

CMsgWeekendTourneySchedule_Division::~CMsgWeekendTourneySchedule_Division() {
  // @@protoc_insertion_point(destructor:CMsgWeekendTourneySchedule.Division)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgWeekendTourneySchedule_Division::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgWeekendTourneySchedule_Division::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgWeekendTourneySchedule_Division::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgWeekendTourneySchedule.Division)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.division_code_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.free_weekend_) -
        reinterpret_cast<char*>(&_impl_.division_code_)) + sizeof(_impl_.free_weekend_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgWeekendTourneySchedule_Division::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 division_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_division_code(&has_bits);
          _impl_.division_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_window_open = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_time_window_open(&has_bits);
          _impl_.time_window_open_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_window_close = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_time_window_close(&has_bits);
          _impl_.time_window_close_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_window_open_next = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_time_window_open_next(&has_bits);
          _impl_.time_window_open_next_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 trophy_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_trophy_id(&has_bits);
          _impl_.trophy_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool free_weekend = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_free_weekend(&has_bits);
          _impl_.free_weekend_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgWeekendTourneySchedule_Division::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgWeekendTourneySchedule.Division)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 division_code = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_division_code(), target);
  }

  // optional uint32 time_window_open = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_time_window_open(), target);
  }

  // optional uint32 time_window_close = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_time_window_close(), target);
  }

  // optional uint32 time_window_open_next = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_time_window_open_next(), target);
  }

  // optional uint32 trophy_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_trophy_id(), target);
  }

  // optional bool free_weekend = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_free_weekend(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgWeekendTourneySchedule.Division)
  return target;
}

size_t CMsgWeekendTourneySchedule_Division::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgWeekendTourneySchedule.Division)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint32 division_code = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_division_code());
    }

    // optional uint32 time_window_open = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time_window_open());
    }

    // optional uint32 time_window_close = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time_window_close());
    }

    // optional uint32 time_window_open_next = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time_window_open_next());
    }

    // optional uint32 trophy_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_trophy_id());
    }

    // optional bool free_weekend = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgWeekendTourneySchedule_Division::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgWeekendTourneySchedule_Division::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgWeekendTourneySchedule_Division::GetClassData() const { return &_class_data_; }


void CMsgWeekendTourneySchedule_Division::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgWeekendTourneySchedule_Division*>(&to_msg);
  auto& from = static_cast<const CMsgWeekendTourneySchedule_Division&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgWeekendTourneySchedule.Division)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.division_code_ = from._impl_.division_code_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.time_window_open_ = from._impl_.time_window_open_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.time_window_close_ = from._impl_.time_window_close_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.time_window_open_next_ = from._impl_.time_window_open_next_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.trophy_id_ = from._impl_.trophy_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.free_weekend_ = from._impl_.free_weekend_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgWeekendTourneySchedule_Division::CopyFrom(const CMsgWeekendTourneySchedule_Division& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgWeekendTourneySchedule.Division)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgWeekendTourneySchedule_Division::IsInitialized() const {
  return true;
}

void CMsgWeekendTourneySchedule_Division::InternalSwap(CMsgWeekendTourneySchedule_Division* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgWeekendTourneySchedule_Division, _impl_.free_weekend_)
      + sizeof(CMsgWeekendTourneySchedule_Division::_impl_.free_weekend_)
      - PROTOBUF_FIELD_OFFSET(CMsgWeekendTourneySchedule_Division, _impl_.division_code_)>(
          reinterpret_cast<char*>(&_impl_.division_code_),
          reinterpret_cast<char*>(&other->_impl_.division_code_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgWeekendTourneySchedule_Division::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[1]);
}

// ===================================================================

class CMsgWeekendTourneySchedule::_Internal {
 public:
};

CMsgWeekendTourneySchedule::CMsgWeekendTourneySchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgWeekendTourneySchedule)
}
CMsgWeekendTourneySchedule::CMsgWeekendTourneySchedule(const CMsgWeekendTourneySchedule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgWeekendTourneySchedule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.divisions_){from._impl_.divisions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgWeekendTourneySchedule)
}

inline void CMsgWeekendTourneySchedule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.divisions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgWeekendTourneySchedule::~CMsgWeekendTourneySchedule() {
  // @@protoc_insertion_point(destructor:CMsgWeekendTourneySchedule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgWeekendTourneySchedule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.divisions_.~RepeatedPtrField();
}

void CMsgWeekendTourneySchedule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgWeekendTourneySchedule::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgWeekendTourneySchedule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.divisions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgWeekendTourneySchedule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgWeekendTourneySchedule.Division divisions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_divisions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgWeekendTourneySchedule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgWeekendTourneySchedule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgWeekendTourneySchedule.Division divisions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_divisions_size()); i < n; i++) {
    const auto& repfield = this->_internal_divisions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgWeekendTourneySchedule)
  return target;
}

size_t CMsgWeekendTourneySchedule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgWeekendTourneySchedule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgWeekendTourneySchedule.Division divisions = 1;
  total_size += 1UL * this->_internal_divisions_size();
  for (const auto& msg : this->_impl_.divisions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgWeekendTourneySchedule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgWeekendTourneySchedule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgWeekendTourneySchedule::GetClassData() const { return &_class_data_; }


void CMsgWeekendTourneySchedule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgWeekendTourneySchedule*>(&to_msg);
  auto& from = static_cast<const CMsgWeekendTourneySchedule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgWeekendTourneySchedule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.divisions_.MergeFrom(from._impl_.divisions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgWeekendTourneySchedule::CopyFrom(const CMsgWeekendTourneySchedule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgWeekendTourneySchedule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgWeekendTourneySchedule::IsInitialized() const {
  return true;
}

void CMsgWeekendTourneySchedule::InternalSwap(CMsgWeekendTourneySchedule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.divisions_.InternalSwap(&other->_impl_.divisions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgWeekendTourneySchedule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[2]);
}

// ===================================================================

class CMsgWeekendTourneyOpts::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgWeekendTourneyOpts>()._impl_._has_bits_);
  static void set_has_participating(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_division_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_buyin(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_skill_level(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_match_groups(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pickup_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pickup_team_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgWeekendTourneyOpts::CMsgWeekendTourneyOpts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgWeekendTourneyOpts)
}
CMsgWeekendTourneyOpts::CMsgWeekendTourneyOpts(const CMsgWeekendTourneyOpts& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgWeekendTourneyOpts* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pickup_team_name_){}
    , decltype(_impl_.participating_){}
    , decltype(_impl_.division_id_){}
    , decltype(_impl_.buyin_){}
    , decltype(_impl_.skill_level_){}
    , decltype(_impl_.match_groups_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.pickup_team_logo_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pickup_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pickup_team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pickup_team_name()) {
    _this->_impl_.pickup_team_name_.Set(from._internal_pickup_team_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.participating_, &from._impl_.participating_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pickup_team_logo_) -
    reinterpret_cast<char*>(&_impl_.participating_)) + sizeof(_impl_.pickup_team_logo_));
  // @@protoc_insertion_point(copy_constructor:CMsgWeekendTourneyOpts)
}

inline void CMsgWeekendTourneyOpts::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pickup_team_name_){}
    , decltype(_impl_.participating_){false}
    , decltype(_impl_.division_id_){0u}
    , decltype(_impl_.buyin_){0u}
    , decltype(_impl_.skill_level_){0u}
    , decltype(_impl_.match_groups_){0u}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.pickup_team_logo_){uint64_t{0u}}
  };
  _impl_.pickup_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pickup_team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgWeekendTourneyOpts::~CMsgWeekendTourneyOpts() {
  // @@protoc_insertion_point(destructor:CMsgWeekendTourneyOpts)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgWeekendTourneyOpts::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pickup_team_name_.Destroy();
}

void CMsgWeekendTourneyOpts::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgWeekendTourneyOpts::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgWeekendTourneyOpts)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.pickup_team_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.participating_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pickup_team_logo_) -
        reinterpret_cast<char*>(&_impl_.participating_)) + sizeof(_impl_.pickup_team_logo_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgWeekendTourneyOpts::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool participating = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_participating(&has_bits);
          _impl_.participating_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 division_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_division_id(&has_bits);
          _impl_.division_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 buyin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_buyin(&has_bits);
          _impl_.buyin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 skill_level = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_skill_level(&has_bits);
          _impl_.skill_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 match_groups = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_match_groups(&has_bits);
          _impl_.match_groups_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string pickup_team_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_pickup_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgWeekendTourneyOpts.pickup_team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pickup_team_logo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_pickup_team_logo(&has_bits);
          _impl_.pickup_team_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgWeekendTourneyOpts::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgWeekendTourneyOpts)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool participating = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_participating(), target);
  }

  // optional uint32 division_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_division_id(), target);
  }

  // optional uint32 buyin = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_buyin(), target);
  }

  // optional uint32 skill_level = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_skill_level(), target);
  }

  // optional uint32 match_groups = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_match_groups(), target);
  }

  // optional uint32 team_id = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_team_id(), target);
  }

  // optional string pickup_team_name = 7;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pickup_team_name().data(), static_cast<int>(this->_internal_pickup_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgWeekendTourneyOpts.pickup_team_name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_pickup_team_name(), target);
  }

  // optional uint64 pickup_team_logo = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_pickup_team_logo(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgWeekendTourneyOpts)
  return target;
}

size_t CMsgWeekendTourneyOpts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgWeekendTourneyOpts)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string pickup_team_name = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pickup_team_name());
    }

    // optional bool participating = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 division_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_division_id());
    }

    // optional uint32 buyin = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_buyin());
    }

    // optional uint32 skill_level = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_skill_level());
    }

    // optional uint32 match_groups = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_match_groups());
    }

    // optional uint32 team_id = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint64 pickup_team_logo = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pickup_team_logo());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgWeekendTourneyOpts::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgWeekendTourneyOpts::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgWeekendTourneyOpts::GetClassData() const { return &_class_data_; }


void CMsgWeekendTourneyOpts::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgWeekendTourneyOpts*>(&to_msg);
  auto& from = static_cast<const CMsgWeekendTourneyOpts&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgWeekendTourneyOpts)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_pickup_team_name(from._internal_pickup_team_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.participating_ = from._impl_.participating_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.division_id_ = from._impl_.division_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.buyin_ = from._impl_.buyin_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.skill_level_ = from._impl_.skill_level_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.match_groups_ = from._impl_.match_groups_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.pickup_team_logo_ = from._impl_.pickup_team_logo_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgWeekendTourneyOpts::CopyFrom(const CMsgWeekendTourneyOpts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgWeekendTourneyOpts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgWeekendTourneyOpts::IsInitialized() const {
  return true;
}

void CMsgWeekendTourneyOpts::InternalSwap(CMsgWeekendTourneyOpts* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pickup_team_name_, lhs_arena,
      &other->_impl_.pickup_team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgWeekendTourneyOpts, _impl_.pickup_team_logo_)
      + sizeof(CMsgWeekendTourneyOpts::_impl_.pickup_team_logo_)
      - PROTOBUF_FIELD_OFFSET(CMsgWeekendTourneyOpts, _impl_.participating_)>(
          reinterpret_cast<char*>(&_impl_.participating_),
          reinterpret_cast<char*>(&other->_impl_.participating_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgWeekendTourneyOpts::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[3]);
}

// ===================================================================

class CMsgWeekendTourneyLeave::_Internal {
 public:
};

CMsgWeekendTourneyLeave::CMsgWeekendTourneyLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgWeekendTourneyLeave)
}
CMsgWeekendTourneyLeave::CMsgWeekendTourneyLeave(const CMsgWeekendTourneyLeave& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgWeekendTourneyLeave* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgWeekendTourneyLeave)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgWeekendTourneyLeave::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgWeekendTourneyLeave::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgWeekendTourneyLeave::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[4]);
}

// ===================================================================

class CMsgDOTATournament_Team::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTATournament_Team>()._impl_._has_bits_);
  static void set_has_team_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_node_or_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_match_group_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_base_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_team_ui_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CMsgDOTATournament_Team::CMsgDOTATournament_Team(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTATournament.Team)
}
CMsgDOTATournament_Team::CMsgDOTATournament_Team(const CMsgDOTATournament_Team& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTATournament_Team* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.players_){from._impl_.players_}
    , /*decltype(_impl_._players_cached_byte_size_)*/{0}
    , decltype(_impl_.player_buyin_){from._impl_.player_buyin_}
    , /*decltype(_impl_._player_buyin_cached_byte_size_)*/{0}
    , decltype(_impl_.player_skill_level_){from._impl_.player_skill_level_}
    , /*decltype(_impl_._player_skill_level_cached_byte_size_)*/{0}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_gid_){}
    , decltype(_impl_.node_or_state_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.team_base_logo_){}
    , decltype(_impl_.team_ui_logo_){}
    , decltype(_impl_.match_group_mask_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_name()) {
    _this->_impl_.team_name_.Set(from._internal_team_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.team_gid_, &from._impl_.team_gid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.match_group_mask_) -
    reinterpret_cast<char*>(&_impl_.team_gid_)) + sizeof(_impl_.match_group_mask_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTATournament.Team)
}

inline void CMsgDOTATournament_Team::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.players_){arena}
    , /*decltype(_impl_._players_cached_byte_size_)*/{0}
    , decltype(_impl_.player_buyin_){arena}
    , /*decltype(_impl_._player_buyin_cached_byte_size_)*/{0}
    , decltype(_impl_.player_skill_level_){arena}
    , /*decltype(_impl_._player_skill_level_cached_byte_size_)*/{0}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_gid_){uint64_t{0u}}
    , decltype(_impl_.node_or_state_){0u}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.team_base_logo_){uint64_t{0u}}
    , decltype(_impl_.team_ui_logo_){uint64_t{0u}}
    , decltype(_impl_.match_group_mask_){0u}
  };
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTATournament_Team::~CMsgDOTATournament_Team() {
  // @@protoc_insertion_point(destructor:CMsgDOTATournament.Team)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTATournament_Team::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.players_.~RepeatedField();
  _impl_.player_buyin_.~RepeatedField();
  _impl_.player_skill_level_.~RepeatedField();
  _impl_.team_name_.Destroy();
}

void CMsgDOTATournament_Team::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTATournament_Team::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTATournament.Team)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.players_.Clear();
  _impl_.player_buyin_.Clear();
  _impl_.player_skill_level_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.team_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.team_gid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.match_group_mask_) -
        reinterpret_cast<char*>(&_impl_.team_gid_)) + sizeof(_impl_.match_group_mask_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTATournament_Team::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 team_gid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_team_gid(&has_bits);
          _impl_.team_gid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 node_or_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_node_or_state(&has_bits);
          _impl_.node_or_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 players = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_players(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_players(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTATournament.Team.team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 team_base_logo = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_team_base_logo(&has_bits);
          _impl_.team_base_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 team_ui_logo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_team_ui_logo(&has_bits);
          _impl_.team_ui_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 player_buyin = 9 [packed = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_player_buyin(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 72) {
          _internal_add_player_buyin(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 player_skill_level = 10 [packed = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_player_skill_level(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 80) {
          _internal_add_player_skill_level(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 match_group_mask = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_match_group_mask(&has_bits);
          _impl_.match_group_mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTATournament_Team::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTATournament.Team)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 team_gid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_team_gid(), target);
  }

  // optional uint32 node_or_state = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_node_or_state(), target);
  }

  // repeated uint32 players = 3 [packed = true];
  {
    int byte_size = _impl_._players_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_players(), byte_size, target);
    }
  }

  // optional uint32 team_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_team_id(), target);
  }

  // optional string team_name = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_name().data(), static_cast<int>(this->_internal_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTATournament.Team.team_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_team_name(), target);
  }

  // optional uint64 team_base_logo = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_team_base_logo(), target);
  }

  // optional uint64 team_ui_logo = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_team_ui_logo(), target);
  }

  // repeated uint32 player_buyin = 9 [packed = true];
  {
    int byte_size = _impl_._player_buyin_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          9, _internal_player_buyin(), byte_size, target);
    }
  }

  // repeated uint32 player_skill_level = 10 [packed = true];
  {
    int byte_size = _impl_._player_skill_level_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          10, _internal_player_skill_level(), byte_size, target);
    }
  }

  // optional uint32 match_group_mask = 12;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_match_group_mask(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTATournament.Team)
  return target;
}

size_t CMsgDOTATournament_Team::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTATournament.Team)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 players = 3 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.players_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._players_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 player_buyin = 9 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.player_buyin_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._player_buyin_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 player_skill_level = 10 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.player_skill_level_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._player_skill_level_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string team_name = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_name());
    }

    // optional fixed64 team_gid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 node_or_state = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_or_state());
    }

    // optional uint32 team_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint64 team_base_logo = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_team_base_logo());
    }

    // optional uint64 team_ui_logo = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_team_ui_logo());
    }

    // optional uint32 match_group_mask = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_match_group_mask());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTATournament_Team::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTATournament_Team::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTATournament_Team::GetClassData() const { return &_class_data_; }


void CMsgDOTATournament_Team::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTATournament_Team*>(&to_msg);
  auto& from = static_cast<const CMsgDOTATournament_Team&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTATournament.Team)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  _this->_impl_.player_buyin_.MergeFrom(from._impl_.player_buyin_);
  _this->_impl_.player_skill_level_.MergeFrom(from._impl_.player_skill_level_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_team_name(from._internal_team_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.team_gid_ = from._impl_.team_gid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.node_or_state_ = from._impl_.node_or_state_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.team_base_logo_ = from._impl_.team_base_logo_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.team_ui_logo_ = from._impl_.team_ui_logo_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.match_group_mask_ = from._impl_.match_group_mask_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTATournament_Team::CopyFrom(const CMsgDOTATournament_Team& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTATournament.Team)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTATournament_Team::IsInitialized() const {
  return true;
}

void CMsgDOTATournament_Team::InternalSwap(CMsgDOTATournament_Team* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
  _impl_.player_buyin_.InternalSwap(&other->_impl_.player_buyin_);
  _impl_.player_skill_level_.InternalSwap(&other->_impl_.player_skill_level_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_name_, lhs_arena,
      &other->_impl_.team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTATournament_Team, _impl_.match_group_mask_)
      + sizeof(CMsgDOTATournament_Team::_impl_.match_group_mask_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTATournament_Team, _impl_.team_gid_)>(
          reinterpret_cast<char*>(&_impl_.team_gid_),
          reinterpret_cast<char*>(&other->_impl_.team_gid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTATournament_Team::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[5]);
}

// ===================================================================

class CMsgDOTATournament_Game::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTATournament_Game>()._impl_._has_bits_);
  static void set_has_node_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lobby_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_team_a_good(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CMsgDOTATournament_Game::CMsgDOTATournament_Game(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTATournament.Game)
}
CMsgDOTATournament_Game::CMsgDOTATournament_Game(const CMsgDOTATournament_Game& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTATournament_Game* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lobby_id_){}
    , decltype(_impl_.node_idx_){}
    , decltype(_impl_.team_a_good_){}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.start_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.lobby_id_, &from._impl_.lobby_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.start_time_) -
    reinterpret_cast<char*>(&_impl_.lobby_id_)) + sizeof(_impl_.start_time_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTATournament.Game)
}

inline void CMsgDOTATournament_Game::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lobby_id_){uint64_t{0u}}
    , decltype(_impl_.node_idx_){0u}
    , decltype(_impl_.team_a_good_){false}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.state_){0}
    , decltype(_impl_.start_time_){0u}
  };
}

CMsgDOTATournament_Game::~CMsgDOTATournament_Game() {
  // @@protoc_insertion_point(destructor:CMsgDOTATournament.Game)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTATournament_Game::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTATournament_Game::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTATournament_Game::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTATournament.Game)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.lobby_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.start_time_) -
        reinterpret_cast<char*>(&_impl_.lobby_id_)) + sizeof(_impl_.start_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTATournament_Game::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 node_idx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_node_idx(&has_bits);
          _impl_.node_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 lobby_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_lobby_id(&has_bits);
          _impl_.lobby_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 match_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool team_a_good = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_team_a_good(&has_bits);
          _impl_.team_a_good_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ETournamentGameState state = 5 [default = k_ETournamentGameState_Unknown];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ETournamentGameState_IsValid(val))) {
            _internal_set_state(static_cast<::ETournamentGameState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_start_time(&has_bits);
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTATournament_Game::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTATournament.Game)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 node_idx = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_node_idx(), target);
  }

  // optional fixed64 lobby_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_lobby_id(), target);
  }

  // optional uint64 match_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_match_id(), target);
  }

  // optional bool team_a_good = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_team_a_good(), target);
  }

  // optional .ETournamentGameState state = 5 [default = k_ETournamentGameState_Unknown];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_state(), target);
  }

  // optional uint32 start_time = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_start_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTATournament.Game)
  return target;
}

size_t CMsgDOTATournament_Game::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTATournament.Game)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional fixed64 lobby_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 node_idx = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_idx());
    }

    // optional bool team_a_good = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint64 match_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional .ETournamentGameState state = 5 [default = k_ETournamentGameState_Unknown];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
    }

    // optional uint32 start_time = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTATournament_Game::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTATournament_Game::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTATournament_Game::GetClassData() const { return &_class_data_; }


void CMsgDOTATournament_Game::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTATournament_Game*>(&to_msg);
  auto& from = static_cast<const CMsgDOTATournament_Game&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTATournament.Game)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.lobby_id_ = from._impl_.lobby_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.node_idx_ = from._impl_.node_idx_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.team_a_good_ = from._impl_.team_a_good_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.start_time_ = from._impl_.start_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTATournament_Game::CopyFrom(const CMsgDOTATournament_Game& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTATournament.Game)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTATournament_Game::IsInitialized() const {
  return true;
}

void CMsgDOTATournament_Game::InternalSwap(CMsgDOTATournament_Game* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTATournament_Game, _impl_.start_time_)
      + sizeof(CMsgDOTATournament_Game::_impl_.start_time_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTATournament_Game, _impl_.lobby_id_)>(
          reinterpret_cast<char*>(&_impl_.lobby_id_),
          reinterpret_cast<char*>(&other->_impl_.lobby_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTATournament_Game::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[6]);
}

// ===================================================================

class CMsgDOTATournament_Node::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTATournament_Node>()._impl_._has_bits_);
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_idx_a(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team_idx_b(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_node_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgDOTATournament_Node::CMsgDOTATournament_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTATournament.Node)
}
CMsgDOTATournament_Node::CMsgDOTATournament_Node(const CMsgDOTATournament_Node& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTATournament_Node* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.team_idx_a_){}
    , decltype(_impl_.team_idx_b_){}
    , decltype(_impl_.node_state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.node_id_, &from._impl_.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.node_state_) -
    reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.node_state_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTATournament.Node)
}

inline void CMsgDOTATournament_Node::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.node_id_){0u}
    , decltype(_impl_.team_idx_a_){0u}
    , decltype(_impl_.team_idx_b_){0u}
    , decltype(_impl_.node_state_){0}
  };
}

CMsgDOTATournament_Node::~CMsgDOTATournament_Node() {
  // @@protoc_insertion_point(destructor:CMsgDOTATournament.Node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTATournament_Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTATournament_Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTATournament_Node::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTATournament.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.node_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.node_state_) -
        reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.node_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTATournament_Node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 node_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_idx_a = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team_idx_a(&has_bits);
          _impl_.team_idx_a_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_idx_b = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_team_idx_b(&has_bits);
          _impl_.team_idx_b_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ETournamentNodeState node_state = 4 [default = k_ETournamentNodeState_Unknown];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ETournamentNodeState_IsValid(val))) {
            _internal_set_node_state(static_cast<::ETournamentNodeState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTATournament_Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTATournament.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 node_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_node_id(), target);
  }

  // optional uint32 team_idx_a = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_team_idx_a(), target);
  }

  // optional uint32 team_idx_b = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_team_idx_b(), target);
  }

  // optional .ETournamentNodeState node_state = 4 [default = k_ETournamentNodeState_Unknown];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_node_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTATournament.Node)
  return target;
}

size_t CMsgDOTATournament_Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTATournament.Node)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 node_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
    }

    // optional uint32 team_idx_a = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_idx_a());
    }

    // optional uint32 team_idx_b = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_idx_b());
    }

    // optional .ETournamentNodeState node_state = 4 [default = k_ETournamentNodeState_Unknown];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_node_state());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTATournament_Node::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTATournament_Node::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTATournament_Node::GetClassData() const { return &_class_data_; }


void CMsgDOTATournament_Node::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTATournament_Node*>(&to_msg);
  auto& from = static_cast<const CMsgDOTATournament_Node&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTATournament.Node)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.node_id_ = from._impl_.node_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.team_idx_a_ = from._impl_.team_idx_a_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.team_idx_b_ = from._impl_.team_idx_b_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.node_state_ = from._impl_.node_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTATournament_Node::CopyFrom(const CMsgDOTATournament_Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTATournament.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTATournament_Node::IsInitialized() const {
  return true;
}

void CMsgDOTATournament_Node::InternalSwap(CMsgDOTATournament_Node* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTATournament_Node, _impl_.node_state_)
      + sizeof(CMsgDOTATournament_Node::_impl_.node_state_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTATournament_Node, _impl_.node_id_)>(
          reinterpret_cast<char*>(&_impl_.node_id_),
          reinterpret_cast<char*>(&other->_impl_.node_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTATournament_Node::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[7]);
}

// ===================================================================

class CMsgDOTATournament::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTATournament>()._impl_._has_bits_);
  static void set_has_tournament_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_division_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_schedule_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_skill_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tournament_template(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_state_seq_num(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_season_trophy_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgDOTATournament::CMsgDOTATournament(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTATournament)
}
CMsgDOTATournament::CMsgDOTATournament(const CMsgDOTATournament& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTATournament* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teams_){from._impl_.teams_}
    , decltype(_impl_.games_){from._impl_.games_}
    , decltype(_impl_.nodes_){from._impl_.nodes_}
    , decltype(_impl_.tournament_id_){}
    , decltype(_impl_.division_id_){}
    , decltype(_impl_.schedule_time_){}
    , decltype(_impl_.skill_level_){}
    , decltype(_impl_.tournament_template_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.state_seq_num_){}
    , decltype(_impl_.season_trophy_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.tournament_id_, &from._impl_.tournament_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.season_trophy_id_) -
    reinterpret_cast<char*>(&_impl_.tournament_id_)) + sizeof(_impl_.season_trophy_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTATournament)
}

inline void CMsgDOTATournament::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teams_){arena}
    , decltype(_impl_.games_){arena}
    , decltype(_impl_.nodes_){arena}
    , decltype(_impl_.tournament_id_){0u}
    , decltype(_impl_.division_id_){0u}
    , decltype(_impl_.schedule_time_){0u}
    , decltype(_impl_.skill_level_){0u}
    , decltype(_impl_.tournament_template_){0}
    , decltype(_impl_.state_){0}
    , decltype(_impl_.state_seq_num_){0u}
    , decltype(_impl_.season_trophy_id_){0u}
  };
}

CMsgDOTATournament::~CMsgDOTATournament() {
  // @@protoc_insertion_point(destructor:CMsgDOTATournament)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTATournament::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.teams_.~RepeatedPtrField();
  _impl_.games_.~RepeatedPtrField();
  _impl_.nodes_.~RepeatedPtrField();
}

void CMsgDOTATournament::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTATournament::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTATournament)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.teams_.Clear();
  _impl_.games_.Clear();
  _impl_.nodes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.tournament_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.season_trophy_id_) -
        reinterpret_cast<char*>(&_impl_.tournament_id_)) + sizeof(_impl_.season_trophy_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTATournament::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 tournament_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tournament_id(&has_bits);
          _impl_.tournament_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 division_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_division_id(&has_bits);
          _impl_.division_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 schedule_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_schedule_time(&has_bits);
          _impl_.schedule_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 skill_level = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_skill_level(&has_bits);
          _impl_.skill_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ETournamentTemplate tournament_template = 5 [default = k_ETournamentTemplate_None];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ETournamentTemplate_IsValid(val))) {
            _internal_set_tournament_template(static_cast<::ETournamentTemplate>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ETournamentState state = 6 [default = k_ETournamentState_Unknown];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ETournamentState_IsValid(val))) {
            _internal_set_state(static_cast<::ETournamentState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTATournament.Team teams = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_teams(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTATournament.Game games = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_games(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTATournament.Node nodes = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 state_seq_num = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_state_seq_num(&has_bits);
          _impl_.state_seq_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 season_trophy_id = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_season_trophy_id(&has_bits);
          _impl_.season_trophy_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTATournament::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTATournament)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 tournament_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_tournament_id(), target);
  }

  // optional uint32 division_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_division_id(), target);
  }

  // optional uint32 schedule_time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_schedule_time(), target);
  }

  // optional uint32 skill_level = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_skill_level(), target);
  }

  // optional .ETournamentTemplate tournament_template = 5 [default = k_ETournamentTemplate_None];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_tournament_template(), target);
  }

  // optional .ETournamentState state = 6 [default = k_ETournamentState_Unknown];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_state(), target);
  }

  // repeated .CMsgDOTATournament.Team teams = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_teams_size()); i < n; i++) {
    const auto& repfield = this->_internal_teams(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTATournament.Game games = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_games_size()); i < n; i++) {
    const auto& repfield = this->_internal_games(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTATournament.Node nodes = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 state_seq_num = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_state_seq_num(), target);
  }

  // optional uint32 season_trophy_id = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_season_trophy_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTATournament)
  return target;
}

size_t CMsgDOTATournament::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTATournament)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTATournament.Team teams = 7;
  total_size += 1UL * this->_internal_teams_size();
  for (const auto& msg : this->_impl_.teams_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTATournament.Game games = 8;
  total_size += 1UL * this->_internal_games_size();
  for (const auto& msg : this->_impl_.games_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTATournament.Node nodes = 9;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->_impl_.nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 tournament_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tournament_id());
    }

    // optional uint32 division_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_division_id());
    }

    // optional uint32 schedule_time = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_schedule_time());
    }

    // optional uint32 skill_level = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_skill_level());
    }

    // optional .ETournamentTemplate tournament_template = 5 [default = k_ETournamentTemplate_None];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_tournament_template());
    }

    // optional .ETournamentState state = 6 [default = k_ETournamentState_Unknown];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
    }

    // optional uint32 state_seq_num = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_state_seq_num());
    }

    // optional uint32 season_trophy_id = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_season_trophy_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTATournament::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTATournament::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTATournament::GetClassData() const { return &_class_data_; }


void CMsgDOTATournament::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTATournament*>(&to_msg);
  auto& from = static_cast<const CMsgDOTATournament&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTATournament)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.teams_.MergeFrom(from._impl_.teams_);
  _this->_impl_.games_.MergeFrom(from._impl_.games_);
  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.tournament_id_ = from._impl_.tournament_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.division_id_ = from._impl_.division_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.schedule_time_ = from._impl_.schedule_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.skill_level_ = from._impl_.skill_level_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tournament_template_ = from._impl_.tournament_template_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.state_seq_num_ = from._impl_.state_seq_num_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.season_trophy_id_ = from._impl_.season_trophy_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTATournament::CopyFrom(const CMsgDOTATournament& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTATournament)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTATournament::IsInitialized() const {
  return true;
}

void CMsgDOTATournament::InternalSwap(CMsgDOTATournament* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.teams_.InternalSwap(&other->_impl_.teams_);
  _impl_.games_.InternalSwap(&other->_impl_.games_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTATournament, _impl_.season_trophy_id_)
      + sizeof(CMsgDOTATournament::_impl_.season_trophy_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTATournament, _impl_.tournament_id_)>(
          reinterpret_cast<char*>(&_impl_.tournament_id_),
          reinterpret_cast<char*>(&other->_impl_.tournament_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTATournament::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[8]);
}

// ===================================================================

class CMsgDOTATournamentStateChange_GameChange::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTATournamentStateChange_GameChange>()._impl_._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_new_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTATournamentStateChange_GameChange::CMsgDOTATournamentStateChange_GameChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTATournamentStateChange.GameChange)
}
CMsgDOTATournamentStateChange_GameChange::CMsgDOTATournamentStateChange_GameChange(const CMsgDOTATournamentStateChange_GameChange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTATournamentStateChange_GameChange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.new_state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.match_id_, &from._impl_.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.new_state_) -
    reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.new_state_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTATournamentStateChange.GameChange)
}

inline void CMsgDOTATournamentStateChange_GameChange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.new_state_){0}
  };
}

CMsgDOTATournamentStateChange_GameChange::~CMsgDOTATournamentStateChange_GameChange() {
  // @@protoc_insertion_point(destructor:CMsgDOTATournamentStateChange.GameChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTATournamentStateChange_GameChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTATournamentStateChange_GameChange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTATournamentStateChange_GameChange::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTATournamentStateChange.GameChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.new_state_) -
        reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.new_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTATournamentStateChange_GameChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 match_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ETournamentGameState new_state = 2 [default = k_ETournamentGameState_Unknown];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ETournamentGameState_IsValid(val))) {
            _internal_set_new_state(static_cast<::ETournamentGameState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTATournamentStateChange_GameChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTATournamentStateChange.GameChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 match_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_match_id(), target);
  }

  // optional .ETournamentGameState new_state = 2 [default = k_ETournamentGameState_Unknown];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_new_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTATournamentStateChange.GameChange)
  return target;
}

size_t CMsgDOTATournamentStateChange_GameChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTATournamentStateChange.GameChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 match_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional .ETournamentGameState new_state = 2 [default = k_ETournamentGameState_Unknown];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_new_state());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTATournamentStateChange_GameChange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTATournamentStateChange_GameChange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTATournamentStateChange_GameChange::GetClassData() const { return &_class_data_; }


void CMsgDOTATournamentStateChange_GameChange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTATournamentStateChange_GameChange*>(&to_msg);
  auto& from = static_cast<const CMsgDOTATournamentStateChange_GameChange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTATournamentStateChange.GameChange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.new_state_ = from._impl_.new_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTATournamentStateChange_GameChange::CopyFrom(const CMsgDOTATournamentStateChange_GameChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTATournamentStateChange.GameChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTATournamentStateChange_GameChange::IsInitialized() const {
  return true;
}

void CMsgDOTATournamentStateChange_GameChange::InternalSwap(CMsgDOTATournamentStateChange_GameChange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTATournamentStateChange_GameChange, _impl_.new_state_)
      + sizeof(CMsgDOTATournamentStateChange_GameChange::_impl_.new_state_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTATournamentStateChange_GameChange, _impl_.match_id_)>(
          reinterpret_cast<char*>(&_impl_.match_id_),
          reinterpret_cast<char*>(&other->_impl_.match_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTATournamentStateChange_GameChange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[9]);
}

// ===================================================================

class CMsgDOTATournamentStateChange_TeamChange::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTATournamentStateChange_TeamChange>()._impl_._has_bits_);
  static void set_has_team_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_new_node_or_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_old_node_or_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDOTATournamentStateChange_TeamChange::CMsgDOTATournamentStateChange_TeamChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTATournamentStateChange.TeamChange)
}
CMsgDOTATournamentStateChange_TeamChange::CMsgDOTATournamentStateChange_TeamChange(const CMsgDOTATournamentStateChange_TeamChange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTATournamentStateChange_TeamChange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_gid_){}
    , decltype(_impl_.new_node_or_state_){}
    , decltype(_impl_.old_node_or_state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.team_gid_, &from._impl_.team_gid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.old_node_or_state_) -
    reinterpret_cast<char*>(&_impl_.team_gid_)) + sizeof(_impl_.old_node_or_state_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTATournamentStateChange.TeamChange)
}

inline void CMsgDOTATournamentStateChange_TeamChange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_gid_){uint64_t{0u}}
    , decltype(_impl_.new_node_or_state_){0u}
    , decltype(_impl_.old_node_or_state_){0u}
  };
}

CMsgDOTATournamentStateChange_TeamChange::~CMsgDOTATournamentStateChange_TeamChange() {
  // @@protoc_insertion_point(destructor:CMsgDOTATournamentStateChange.TeamChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTATournamentStateChange_TeamChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTATournamentStateChange_TeamChange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTATournamentStateChange_TeamChange::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTATournamentStateChange.TeamChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.team_gid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.old_node_or_state_) -
        reinterpret_cast<char*>(&_impl_.team_gid_)) + sizeof(_impl_.old_node_or_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTATournamentStateChange_TeamChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 team_gid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_team_gid(&has_bits);
          _impl_.team_gid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 new_node_or_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_new_node_or_state(&has_bits);
          _impl_.new_node_or_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 old_node_or_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_old_node_or_state(&has_bits);
          _impl_.old_node_or_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTATournamentStateChange_TeamChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTATournamentStateChange.TeamChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 team_gid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_team_gid(), target);
  }

  // optional uint32 new_node_or_state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_new_node_or_state(), target);
  }

  // optional uint32 old_node_or_state = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_old_node_or_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTATournamentStateChange.TeamChange)
  return target;
}

size_t CMsgDOTATournamentStateChange_TeamChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTATournamentStateChange.TeamChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 team_gid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_team_gid());
    }

    // optional uint32 new_node_or_state = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_new_node_or_state());
    }

    // optional uint32 old_node_or_state = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_old_node_or_state());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTATournamentStateChange_TeamChange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTATournamentStateChange_TeamChange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTATournamentStateChange_TeamChange::GetClassData() const { return &_class_data_; }


void CMsgDOTATournamentStateChange_TeamChange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTATournamentStateChange_TeamChange*>(&to_msg);
  auto& from = static_cast<const CMsgDOTATournamentStateChange_TeamChange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTATournamentStateChange.TeamChange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.team_gid_ = from._impl_.team_gid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.new_node_or_state_ = from._impl_.new_node_or_state_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.old_node_or_state_ = from._impl_.old_node_or_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTATournamentStateChange_TeamChange::CopyFrom(const CMsgDOTATournamentStateChange_TeamChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTATournamentStateChange.TeamChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTATournamentStateChange_TeamChange::IsInitialized() const {
  return true;
}

void CMsgDOTATournamentStateChange_TeamChange::InternalSwap(CMsgDOTATournamentStateChange_TeamChange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTATournamentStateChange_TeamChange, _impl_.old_node_or_state_)
      + sizeof(CMsgDOTATournamentStateChange_TeamChange::_impl_.old_node_or_state_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTATournamentStateChange_TeamChange, _impl_.team_gid_)>(
          reinterpret_cast<char*>(&_impl_.team_gid_),
          reinterpret_cast<char*>(&other->_impl_.team_gid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTATournamentStateChange_TeamChange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[10]);
}

// ===================================================================

class CMsgDOTATournamentStateChange::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTATournamentStateChange>()._impl_._has_bits_);
  static void set_has_new_tournament_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_event(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_tournament_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_state_seq_num(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgDOTATournamentStateChange::CMsgDOTATournamentStateChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTATournamentStateChange)
}
CMsgDOTATournamentStateChange::CMsgDOTATournamentStateChange(const CMsgDOTATournamentStateChange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTATournamentStateChange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.game_changes_){from._impl_.game_changes_}
    , decltype(_impl_.team_changes_){from._impl_.team_changes_}
    , decltype(_impl_.merged_tournament_ids_){from._impl_.merged_tournament_ids_}
    , /*decltype(_impl_._merged_tournament_ids_cached_byte_size_)*/{0}
    , decltype(_impl_.new_tournament_id_){}
    , decltype(_impl_.event_){}
    , decltype(_impl_.new_tournament_state_){}
    , decltype(_impl_.state_seq_num_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.new_tournament_id_, &from._impl_.new_tournament_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_seq_num_) -
    reinterpret_cast<char*>(&_impl_.new_tournament_id_)) + sizeof(_impl_.state_seq_num_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTATournamentStateChange)
}

inline void CMsgDOTATournamentStateChange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.game_changes_){arena}
    , decltype(_impl_.team_changes_){arena}
    , decltype(_impl_.merged_tournament_ids_){arena}
    , /*decltype(_impl_._merged_tournament_ids_cached_byte_size_)*/{0}
    , decltype(_impl_.new_tournament_id_){0u}
    , decltype(_impl_.event_){0}
    , decltype(_impl_.new_tournament_state_){0}
    , decltype(_impl_.state_seq_num_){0u}
  };
}

CMsgDOTATournamentStateChange::~CMsgDOTATournamentStateChange() {
  // @@protoc_insertion_point(destructor:CMsgDOTATournamentStateChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTATournamentStateChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.game_changes_.~RepeatedPtrField();
  _impl_.team_changes_.~RepeatedPtrField();
  _impl_.merged_tournament_ids_.~RepeatedField();
}

void CMsgDOTATournamentStateChange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTATournamentStateChange::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTATournamentStateChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.game_changes_.Clear();
  _impl_.team_changes_.Clear();
  _impl_.merged_tournament_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.new_tournament_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.state_seq_num_) -
        reinterpret_cast<char*>(&_impl_.new_tournament_id_)) + sizeof(_impl_.state_seq_num_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTATournamentStateChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 new_tournament_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_new_tournament_id(&has_bits);
          _impl_.new_tournament_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ETournamentEvent event = 2 [default = k_ETournamentEvent_None];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ETournamentEvent_IsValid(val))) {
            _internal_set_event(static_cast<::ETournamentEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ETournamentState new_tournament_state = 3 [default = k_ETournamentState_Unknown];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ETournamentState_IsValid(val))) {
            _internal_set_new_tournament_state(static_cast<::ETournamentState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTATournamentStateChange.GameChange game_changes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_game_changes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTATournamentStateChange.TeamChange team_changes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_team_changes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 merged_tournament_ids = 6 [packed = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_merged_tournament_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 48) {
          _internal_add_merged_tournament_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 state_seq_num = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_state_seq_num(&has_bits);
          _impl_.state_seq_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTATournamentStateChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTATournamentStateChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 new_tournament_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_new_tournament_id(), target);
  }

  // optional .ETournamentEvent event = 2 [default = k_ETournamentEvent_None];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_event(), target);
  }

  // optional .ETournamentState new_tournament_state = 3 [default = k_ETournamentState_Unknown];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_new_tournament_state(), target);
  }

  // repeated .CMsgDOTATournamentStateChange.GameChange game_changes = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_game_changes_size()); i < n; i++) {
    const auto& repfield = this->_internal_game_changes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTATournamentStateChange.TeamChange team_changes = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_team_changes_size()); i < n; i++) {
    const auto& repfield = this->_internal_team_changes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated uint32 merged_tournament_ids = 6 [packed = true];
  {
    int byte_size = _impl_._merged_tournament_ids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          6, _internal_merged_tournament_ids(), byte_size, target);
    }
  }

  // optional uint32 state_seq_num = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_state_seq_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTATournamentStateChange)
  return target;
}

size_t CMsgDOTATournamentStateChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTATournamentStateChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTATournamentStateChange.GameChange game_changes = 4;
  total_size += 1UL * this->_internal_game_changes_size();
  for (const auto& msg : this->_impl_.game_changes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTATournamentStateChange.TeamChange team_changes = 5;
  total_size += 1UL * this->_internal_team_changes_size();
  for (const auto& msg : this->_impl_.team_changes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 merged_tournament_ids = 6 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.merged_tournament_ids_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._merged_tournament_ids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 new_tournament_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_new_tournament_id());
    }

    // optional .ETournamentEvent event = 2 [default = k_ETournamentEvent_None];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event());
    }

    // optional .ETournamentState new_tournament_state = 3 [default = k_ETournamentState_Unknown];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_new_tournament_state());
    }

    // optional uint32 state_seq_num = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_state_seq_num());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTATournamentStateChange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTATournamentStateChange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTATournamentStateChange::GetClassData() const { return &_class_data_; }


void CMsgDOTATournamentStateChange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTATournamentStateChange*>(&to_msg);
  auto& from = static_cast<const CMsgDOTATournamentStateChange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTATournamentStateChange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.game_changes_.MergeFrom(from._impl_.game_changes_);
  _this->_impl_.team_changes_.MergeFrom(from._impl_.team_changes_);
  _this->_impl_.merged_tournament_ids_.MergeFrom(from._impl_.merged_tournament_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.new_tournament_id_ = from._impl_.new_tournament_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.event_ = from._impl_.event_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.new_tournament_state_ = from._impl_.new_tournament_state_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.state_seq_num_ = from._impl_.state_seq_num_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTATournamentStateChange::CopyFrom(const CMsgDOTATournamentStateChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTATournamentStateChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTATournamentStateChange::IsInitialized() const {
  return true;
}

void CMsgDOTATournamentStateChange::InternalSwap(CMsgDOTATournamentStateChange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.game_changes_.InternalSwap(&other->_impl_.game_changes_);
  _impl_.team_changes_.InternalSwap(&other->_impl_.team_changes_);
  _impl_.merged_tournament_ids_.InternalSwap(&other->_impl_.merged_tournament_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTATournamentStateChange, _impl_.state_seq_num_)
      + sizeof(CMsgDOTATournamentStateChange::_impl_.state_seq_num_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTATournamentStateChange, _impl_.new_tournament_id_)>(
          reinterpret_cast<char*>(&_impl_.new_tournament_id_),
          reinterpret_cast<char*>(&other->_impl_.new_tournament_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTATournamentStateChange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[11]);
}

// ===================================================================

class CMsgDOTAWeekendTourneyPlayerSkillLevelStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAWeekendTourneyPlayerSkillLevelStats>()._impl_._has_bits_);
  static void set_has_skill_level(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_times_won_0(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_times_won_1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_times_won_2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_times_won_3(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_times_bye_and_lost(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_times_bye_and_won(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_times_unusual_champ(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_total_games_won(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CMsgDOTAWeekendTourneyPlayerSkillLevelStats::CMsgDOTAWeekendTourneyPlayerSkillLevelStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAWeekendTourneyPlayerSkillLevelStats)
}
CMsgDOTAWeekendTourneyPlayerSkillLevelStats::CMsgDOTAWeekendTourneyPlayerSkillLevelStats(const CMsgDOTAWeekendTourneyPlayerSkillLevelStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAWeekendTourneyPlayerSkillLevelStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.skill_level_){}
    , decltype(_impl_.times_won_0_){}
    , decltype(_impl_.times_won_1_){}
    , decltype(_impl_.times_won_2_){}
    , decltype(_impl_.times_won_3_){}
    , decltype(_impl_.times_bye_and_lost_){}
    , decltype(_impl_.times_bye_and_won_){}
    , decltype(_impl_.total_games_won_){}
    , decltype(_impl_.score_){}
    , decltype(_impl_.times_unusual_champ_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.skill_level_, &from._impl_.skill_level_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.times_unusual_champ_) -
    reinterpret_cast<char*>(&_impl_.skill_level_)) + sizeof(_impl_.times_unusual_champ_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAWeekendTourneyPlayerSkillLevelStats)
}

inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.skill_level_){0u}
    , decltype(_impl_.times_won_0_){0u}
    , decltype(_impl_.times_won_1_){0u}
    , decltype(_impl_.times_won_2_){0u}
    , decltype(_impl_.times_won_3_){0u}
    , decltype(_impl_.times_bye_and_lost_){0u}
    , decltype(_impl_.times_bye_and_won_){0u}
    , decltype(_impl_.total_games_won_){0u}
    , decltype(_impl_.score_){0u}
    , decltype(_impl_.times_unusual_champ_){0u}
  };
}

CMsgDOTAWeekendTourneyPlayerSkillLevelStats::~CMsgDOTAWeekendTourneyPlayerSkillLevelStats() {
  // @@protoc_insertion_point(destructor:CMsgDOTAWeekendTourneyPlayerSkillLevelStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAWeekendTourneyPlayerSkillLevelStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.skill_level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.total_games_won_) -
        reinterpret_cast<char*>(&_impl_.skill_level_)) + sizeof(_impl_.total_games_won_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.score_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.times_unusual_champ_) -
        reinterpret_cast<char*>(&_impl_.score_)) + sizeof(_impl_.times_unusual_champ_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAWeekendTourneyPlayerSkillLevelStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 skill_level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_skill_level(&has_bits);
          _impl_.skill_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 times_won_0 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_times_won_0(&has_bits);
          _impl_.times_won_0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 times_won_1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_times_won_1(&has_bits);
          _impl_.times_won_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 times_won_2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_times_won_2(&has_bits);
          _impl_.times_won_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 times_won_3 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_times_won_3(&has_bits);
          _impl_.times_won_3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 times_bye_and_lost = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_times_bye_and_lost(&has_bits);
          _impl_.times_bye_and_lost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 times_bye_and_won = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_times_bye_and_won(&has_bits);
          _impl_.times_bye_and_won_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 total_games_won = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_total_games_won(&has_bits);
          _impl_.total_games_won_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 score = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_score(&has_bits);
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 times_unusual_champ = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_times_unusual_champ(&has_bits);
          _impl_.times_unusual_champ_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAWeekendTourneyPlayerSkillLevelStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAWeekendTourneyPlayerSkillLevelStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 skill_level = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_skill_level(), target);
  }

  // optional uint32 times_won_0 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_times_won_0(), target);
  }

  // optional uint32 times_won_1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_times_won_1(), target);
  }

  // optional uint32 times_won_2 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_times_won_2(), target);
  }

  // optional uint32 times_won_3 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_times_won_3(), target);
  }

  // optional uint32 times_bye_and_lost = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_times_bye_and_lost(), target);
  }

  // optional uint32 times_bye_and_won = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_times_bye_and_won(), target);
  }

  // optional uint32 total_games_won = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_total_games_won(), target);
  }

  // optional uint32 score = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_score(), target);
  }

  // optional uint32 times_unusual_champ = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_times_unusual_champ(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAWeekendTourneyPlayerSkillLevelStats)
  return target;
}

size_t CMsgDOTAWeekendTourneyPlayerSkillLevelStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAWeekendTourneyPlayerSkillLevelStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 skill_level = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_skill_level());
    }

    // optional uint32 times_won_0 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_times_won_0());
    }

    // optional uint32 times_won_1 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_times_won_1());
    }

    // optional uint32 times_won_2 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_times_won_2());
    }

    // optional uint32 times_won_3 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_times_won_3());
    }

    // optional uint32 times_bye_and_lost = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_times_bye_and_lost());
    }

    // optional uint32 times_bye_and_won = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_times_bye_and_won());
    }

    // optional uint32 total_games_won = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_games_won());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 score = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_score());
    }

    // optional uint32 times_unusual_champ = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_times_unusual_champ());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAWeekendTourneyPlayerSkillLevelStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAWeekendTourneyPlayerSkillLevelStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAWeekendTourneyPlayerSkillLevelStats::GetClassData() const { return &_class_data_; }


void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAWeekendTourneyPlayerSkillLevelStats*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAWeekendTourneyPlayerSkillLevelStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAWeekendTourneyPlayerSkillLevelStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.skill_level_ = from._impl_.skill_level_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.times_won_0_ = from._impl_.times_won_0_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.times_won_1_ = from._impl_.times_won_1_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.times_won_2_ = from._impl_.times_won_2_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.times_won_3_ = from._impl_.times_won_3_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.times_bye_and_lost_ = from._impl_.times_bye_and_lost_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.times_bye_and_won_ = from._impl_.times_bye_and_won_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.total_games_won_ = from._impl_.total_games_won_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.score_ = from._impl_.score_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.times_unusual_champ_ = from._impl_.times_unusual_champ_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::CopyFrom(const CMsgDOTAWeekendTourneyPlayerSkillLevelStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAWeekendTourneyPlayerSkillLevelStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAWeekendTourneyPlayerSkillLevelStats::IsInitialized() const {
  return true;
}

void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::InternalSwap(CMsgDOTAWeekendTourneyPlayerSkillLevelStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_.times_unusual_champ_)
      + sizeof(CMsgDOTAWeekendTourneyPlayerSkillLevelStats::_impl_.times_unusual_champ_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAWeekendTourneyPlayerSkillLevelStats, _impl_.skill_level_)>(
          reinterpret_cast<char*>(&_impl_.skill_level_),
          reinterpret_cast<char*>(&other->_impl_.skill_level_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAWeekendTourneyPlayerSkillLevelStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[12]);
}

// ===================================================================

class CMsgDOTAWeekendTourneyPlayerStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAWeekendTourneyPlayerStats>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_season_trophy_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_current_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDOTAWeekendTourneyPlayerStats::CMsgDOTAWeekendTourneyPlayerStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAWeekendTourneyPlayerStats)
}
CMsgDOTAWeekendTourneyPlayerStats::CMsgDOTAWeekendTourneyPlayerStats(const CMsgDOTAWeekendTourneyPlayerStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAWeekendTourneyPlayerStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.skill_levels_){from._impl_.skill_levels_}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.season_trophy_id_){}
    , decltype(_impl_.current_tier_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.current_tier_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.current_tier_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAWeekendTourneyPlayerStats)
}

inline void CMsgDOTAWeekendTourneyPlayerStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.skill_levels_){arena}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.season_trophy_id_){0u}
    , decltype(_impl_.current_tier_){0u}
  };
}

CMsgDOTAWeekendTourneyPlayerStats::~CMsgDOTAWeekendTourneyPlayerStats() {
  // @@protoc_insertion_point(destructor:CMsgDOTAWeekendTourneyPlayerStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAWeekendTourneyPlayerStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.skill_levels_.~RepeatedPtrField();
}

void CMsgDOTAWeekendTourneyPlayerStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAWeekendTourneyPlayerStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAWeekendTourneyPlayerStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.skill_levels_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.current_tier_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.current_tier_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAWeekendTourneyPlayerStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 season_trophy_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_season_trophy_id(&has_bits);
          _impl_.season_trophy_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAWeekendTourneyPlayerSkillLevelStats skill_levels = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_skill_levels(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 current_tier = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_current_tier(&has_bits);
          _impl_.current_tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAWeekendTourneyPlayerStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAWeekendTourneyPlayerStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 season_trophy_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_season_trophy_id(), target);
  }

  // repeated .CMsgDOTAWeekendTourneyPlayerSkillLevelStats skill_levels = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_skill_levels_size()); i < n; i++) {
    const auto& repfield = this->_internal_skill_levels(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 current_tier = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_current_tier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAWeekendTourneyPlayerStats)
  return target;
}

size_t CMsgDOTAWeekendTourneyPlayerStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAWeekendTourneyPlayerStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAWeekendTourneyPlayerSkillLevelStats skill_levels = 3;
  total_size += 1UL * this->_internal_skill_levels_size();
  for (const auto& msg : this->_impl_.skill_levels_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 season_trophy_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_season_trophy_id());
    }

    // optional uint32 current_tier = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_current_tier());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAWeekendTourneyPlayerStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAWeekendTourneyPlayerStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAWeekendTourneyPlayerStats::GetClassData() const { return &_class_data_; }


void CMsgDOTAWeekendTourneyPlayerStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAWeekendTourneyPlayerStats*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAWeekendTourneyPlayerStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAWeekendTourneyPlayerStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.skill_levels_.MergeFrom(from._impl_.skill_levels_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.season_trophy_id_ = from._impl_.season_trophy_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.current_tier_ = from._impl_.current_tier_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAWeekendTourneyPlayerStats::CopyFrom(const CMsgDOTAWeekendTourneyPlayerStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAWeekendTourneyPlayerStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAWeekendTourneyPlayerStats::IsInitialized() const {
  return true;
}

void CMsgDOTAWeekendTourneyPlayerStats::InternalSwap(CMsgDOTAWeekendTourneyPlayerStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.skill_levels_.InternalSwap(&other->_impl_.skill_levels_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAWeekendTourneyPlayerStats, _impl_.current_tier_)
      + sizeof(CMsgDOTAWeekendTourneyPlayerStats::_impl_.current_tier_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAWeekendTourneyPlayerStats, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAWeekendTourneyPlayerStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[13]);
}

// ===================================================================

class CMsgDOTAWeekendTourneyPlayerStatsRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAWeekendTourneyPlayerStatsRequest>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_season_trophy_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTAWeekendTourneyPlayerStatsRequest::CMsgDOTAWeekendTourneyPlayerStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAWeekendTourneyPlayerStatsRequest)
}
CMsgDOTAWeekendTourneyPlayerStatsRequest::CMsgDOTAWeekendTourneyPlayerStatsRequest(const CMsgDOTAWeekendTourneyPlayerStatsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAWeekendTourneyPlayerStatsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.season_trophy_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.season_trophy_id_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.season_trophy_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAWeekendTourneyPlayerStatsRequest)
}

inline void CMsgDOTAWeekendTourneyPlayerStatsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.season_trophy_id_){0u}
  };
}

CMsgDOTAWeekendTourneyPlayerStatsRequest::~CMsgDOTAWeekendTourneyPlayerStatsRequest() {
  // @@protoc_insertion_point(destructor:CMsgDOTAWeekendTourneyPlayerStatsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAWeekendTourneyPlayerStatsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAWeekendTourneyPlayerStatsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAWeekendTourneyPlayerStatsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAWeekendTourneyPlayerStatsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.season_trophy_id_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.season_trophy_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAWeekendTourneyPlayerStatsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 season_trophy_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_season_trophy_id(&has_bits);
          _impl_.season_trophy_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAWeekendTourneyPlayerStatsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAWeekendTourneyPlayerStatsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 season_trophy_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_season_trophy_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAWeekendTourneyPlayerStatsRequest)
  return target;
}

size_t CMsgDOTAWeekendTourneyPlayerStatsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAWeekendTourneyPlayerStatsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 season_trophy_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_season_trophy_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAWeekendTourneyPlayerStatsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAWeekendTourneyPlayerStatsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAWeekendTourneyPlayerStatsRequest::GetClassData() const { return &_class_data_; }


void CMsgDOTAWeekendTourneyPlayerStatsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAWeekendTourneyPlayerStatsRequest*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAWeekendTourneyPlayerStatsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAWeekendTourneyPlayerStatsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.season_trophy_id_ = from._impl_.season_trophy_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAWeekendTourneyPlayerStatsRequest::CopyFrom(const CMsgDOTAWeekendTourneyPlayerStatsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAWeekendTourneyPlayerStatsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAWeekendTourneyPlayerStatsRequest::IsInitialized() const {
  return true;
}

void CMsgDOTAWeekendTourneyPlayerStatsRequest::InternalSwap(CMsgDOTAWeekendTourneyPlayerStatsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAWeekendTourneyPlayerStatsRequest, _impl_.season_trophy_id_)
      + sizeof(CMsgDOTAWeekendTourneyPlayerStatsRequest::_impl_.season_trophy_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAWeekendTourneyPlayerStatsRequest, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAWeekendTourneyPlayerStatsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[14]);
}

// ===================================================================

class CMsgDOTAWeekendTourneyPlayerHistory_Tournament::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAWeekendTourneyPlayerHistory_Tournament>()._impl_._has_bits_);
  static void set_has_tournament_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tournament_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_team_date(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_team_result(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_season_trophy_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgDOTAWeekendTourneyPlayerHistory_Tournament::CMsgDOTAWeekendTourneyPlayerHistory_Tournament(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAWeekendTourneyPlayerHistory.Tournament)
}
CMsgDOTAWeekendTourneyPlayerHistory_Tournament::CMsgDOTAWeekendTourneyPlayerHistory_Tournament(const CMsgDOTAWeekendTourneyPlayerHistory_Tournament& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAWeekendTourneyPlayerHistory_Tournament* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){from._impl_.account_id_}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.tournament_id_){}
    , decltype(_impl_.start_time_){}
    , decltype(_impl_.tournament_tier_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.team_date_){}
    , decltype(_impl_.team_result_){}
    , decltype(_impl_.season_trophy_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_name()) {
    _this->_impl_.team_name_.Set(from._internal_team_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.tournament_id_, &from._impl_.tournament_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.season_trophy_id_) -
    reinterpret_cast<char*>(&_impl_.tournament_id_)) + sizeof(_impl_.season_trophy_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAWeekendTourneyPlayerHistory.Tournament)
}

inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){arena}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.tournament_id_){0u}
    , decltype(_impl_.start_time_){0u}
    , decltype(_impl_.tournament_tier_){0u}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.team_date_){0u}
    , decltype(_impl_.team_result_){0u}
    , decltype(_impl_.season_trophy_id_){0u}
  };
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTAWeekendTourneyPlayerHistory_Tournament::~CMsgDOTAWeekendTourneyPlayerHistory_Tournament() {
  // @@protoc_insertion_point(destructor:CMsgDOTAWeekendTourneyPlayerHistory.Tournament)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_id_.~RepeatedField();
  _impl_.team_name_.Destroy();
}

void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAWeekendTourneyPlayerHistory.Tournament)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_id_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.team_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.tournament_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.season_trophy_id_) -
        reinterpret_cast<char*>(&_impl_.tournament_id_)) + sizeof(_impl_.season_trophy_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAWeekendTourneyPlayerHistory_Tournament::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 tournament_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tournament_id(&has_bits);
          _impl_.tournament_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_start_time(&has_bits);
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tournament_tier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_tournament_tier(&has_bits);
          _impl_.tournament_tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_date = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_team_date(&has_bits);
          _impl_.team_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_result = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_team_result(&has_bits);
          _impl_.team_result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 account_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_account_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_account_id(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 season_trophy_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_season_trophy_id(&has_bits);
          _impl_.season_trophy_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAWeekendTourneyPlayerHistory_Tournament::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAWeekendTourneyPlayerHistory.Tournament)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 tournament_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_tournament_id(), target);
  }

  // optional uint32 start_time = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_start_time(), target);
  }

  // optional uint32 tournament_tier = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_tournament_tier(), target);
  }

  // optional uint32 team_id = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_team_id(), target);
  }

  // optional uint32 team_date = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_team_date(), target);
  }

  // optional uint32 team_result = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_team_result(), target);
  }

  // repeated uint32 account_id = 7;
  for (int i = 0, n = this->_internal_account_id_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_account_id(i), target);
  }

  // optional string team_name = 8;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_name().data(), static_cast<int>(this->_internal_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_name");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_team_name(), target);
  }

  // optional uint32 season_trophy_id = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_season_trophy_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAWeekendTourneyPlayerHistory.Tournament)
  return target;
}

size_t CMsgDOTAWeekendTourneyPlayerHistory_Tournament::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAWeekendTourneyPlayerHistory.Tournament)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 account_id = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.account_id_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_account_id_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string team_name = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_name());
    }

    // optional uint32 tournament_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tournament_id());
    }

    // optional uint32 start_time = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_time());
    }

    // optional uint32 tournament_tier = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tournament_tier());
    }

    // optional uint32 team_id = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint32 team_date = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_date());
    }

    // optional uint32 team_result = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_result());
    }

    // optional uint32 season_trophy_id = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_season_trophy_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAWeekendTourneyPlayerHistory_Tournament::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAWeekendTourneyPlayerHistory_Tournament::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAWeekendTourneyPlayerHistory_Tournament::GetClassData() const { return &_class_data_; }


void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAWeekendTourneyPlayerHistory_Tournament*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAWeekendTourneyPlayerHistory_Tournament&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAWeekendTourneyPlayerHistory.Tournament)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.account_id_.MergeFrom(from._impl_.account_id_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_team_name(from._internal_team_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tournament_id_ = from._impl_.tournament_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.start_time_ = from._impl_.start_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.tournament_tier_ = from._impl_.tournament_tier_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.team_date_ = from._impl_.team_date_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.team_result_ = from._impl_.team_result_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.season_trophy_id_ = from._impl_.season_trophy_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::CopyFrom(const CMsgDOTAWeekendTourneyPlayerHistory_Tournament& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAWeekendTourneyPlayerHistory.Tournament)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAWeekendTourneyPlayerHistory_Tournament::IsInitialized() const {
  return true;
}

void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::InternalSwap(CMsgDOTAWeekendTourneyPlayerHistory_Tournament* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.account_id_.InternalSwap(&other->_impl_.account_id_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_name_, lhs_arena,
      &other->_impl_.team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _impl_.season_trophy_id_)
      + sizeof(CMsgDOTAWeekendTourneyPlayerHistory_Tournament::_impl_.season_trophy_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAWeekendTourneyPlayerHistory_Tournament, _impl_.tournament_id_)>(
          reinterpret_cast<char*>(&_impl_.tournament_id_),
          reinterpret_cast<char*>(&other->_impl_.tournament_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAWeekendTourneyPlayerHistory_Tournament::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[15]);
}

// ===================================================================

class CMsgDOTAWeekendTourneyPlayerHistory::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAWeekendTourneyPlayerHistory>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTAWeekendTourneyPlayerHistory::CMsgDOTAWeekendTourneyPlayerHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAWeekendTourneyPlayerHistory)
}
CMsgDOTAWeekendTourneyPlayerHistory::CMsgDOTAWeekendTourneyPlayerHistory(const CMsgDOTAWeekendTourneyPlayerHistory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAWeekendTourneyPlayerHistory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tournaments_){from._impl_.tournaments_}
    , decltype(_impl_.account_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.account_id_ = from._impl_.account_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAWeekendTourneyPlayerHistory)
}

inline void CMsgDOTAWeekendTourneyPlayerHistory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tournaments_){arena}
    , decltype(_impl_.account_id_){0u}
  };
}

CMsgDOTAWeekendTourneyPlayerHistory::~CMsgDOTAWeekendTourneyPlayerHistory() {
  // @@protoc_insertion_point(destructor:CMsgDOTAWeekendTourneyPlayerHistory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAWeekendTourneyPlayerHistory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tournaments_.~RepeatedPtrField();
}

void CMsgDOTAWeekendTourneyPlayerHistory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAWeekendTourneyPlayerHistory::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAWeekendTourneyPlayerHistory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tournaments_.Clear();
  _impl_.account_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAWeekendTourneyPlayerHistory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAWeekendTourneyPlayerHistory.Tournament tournaments = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tournaments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAWeekendTourneyPlayerHistory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAWeekendTourneyPlayerHistory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // repeated .CMsgDOTAWeekendTourneyPlayerHistory.Tournament tournaments = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tournaments_size()); i < n; i++) {
    const auto& repfield = this->_internal_tournaments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAWeekendTourneyPlayerHistory)
  return target;
}

size_t CMsgDOTAWeekendTourneyPlayerHistory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAWeekendTourneyPlayerHistory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAWeekendTourneyPlayerHistory.Tournament tournaments = 3;
  total_size += 1UL * this->_internal_tournaments_size();
  for (const auto& msg : this->_impl_.tournaments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 account_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAWeekendTourneyPlayerHistory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAWeekendTourneyPlayerHistory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAWeekendTourneyPlayerHistory::GetClassData() const { return &_class_data_; }


void CMsgDOTAWeekendTourneyPlayerHistory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAWeekendTourneyPlayerHistory*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAWeekendTourneyPlayerHistory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAWeekendTourneyPlayerHistory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tournaments_.MergeFrom(from._impl_.tournaments_);
  if (from._internal_has_account_id()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAWeekendTourneyPlayerHistory::CopyFrom(const CMsgDOTAWeekendTourneyPlayerHistory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAWeekendTourneyPlayerHistory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAWeekendTourneyPlayerHistory::IsInitialized() const {
  return true;
}

void CMsgDOTAWeekendTourneyPlayerHistory::InternalSwap(CMsgDOTAWeekendTourneyPlayerHistory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.tournaments_.InternalSwap(&other->_impl_.tournaments_);
  swap(_impl_.account_id_, other->_impl_.account_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAWeekendTourneyPlayerHistory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[16]);
}

// ===================================================================

class CMsgDOTAWeekendTourneyParticipationDetails_Tier::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAWeekendTourneyParticipationDetails_Tier>()._impl_._has_bits_);
  static void set_has_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_players(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_teams(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_winning_teams(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_players_streak_2(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_players_streak_3(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_players_streak_4(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_players_streak_5(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgDOTAWeekendTourneyParticipationDetails_Tier::CMsgDOTAWeekendTourneyParticipationDetails_Tier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAWeekendTourneyParticipationDetails.Tier)
}
CMsgDOTAWeekendTourneyParticipationDetails_Tier::CMsgDOTAWeekendTourneyParticipationDetails_Tier(const CMsgDOTAWeekendTourneyParticipationDetails_Tier& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAWeekendTourneyParticipationDetails_Tier* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tier_){}
    , decltype(_impl_.players_){}
    , decltype(_impl_.teams_){}
    , decltype(_impl_.winning_teams_){}
    , decltype(_impl_.players_streak_2_){}
    , decltype(_impl_.players_streak_3_){}
    , decltype(_impl_.players_streak_4_){}
    , decltype(_impl_.players_streak_5_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.tier_, &from._impl_.tier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.players_streak_5_) -
    reinterpret_cast<char*>(&_impl_.tier_)) + sizeof(_impl_.players_streak_5_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAWeekendTourneyParticipationDetails.Tier)
}

inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tier_){0u}
    , decltype(_impl_.players_){0u}
    , decltype(_impl_.teams_){0u}
    , decltype(_impl_.winning_teams_){0u}
    , decltype(_impl_.players_streak_2_){0u}
    , decltype(_impl_.players_streak_3_){0u}
    , decltype(_impl_.players_streak_4_){0u}
    , decltype(_impl_.players_streak_5_){0u}
  };
}

CMsgDOTAWeekendTourneyParticipationDetails_Tier::~CMsgDOTAWeekendTourneyParticipationDetails_Tier() {
  // @@protoc_insertion_point(destructor:CMsgDOTAWeekendTourneyParticipationDetails.Tier)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAWeekendTourneyParticipationDetails_Tier::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAWeekendTourneyParticipationDetails_Tier::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAWeekendTourneyParticipationDetails.Tier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.tier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.players_streak_5_) -
        reinterpret_cast<char*>(&_impl_.tier_)) + sizeof(_impl_.players_streak_5_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAWeekendTourneyParticipationDetails_Tier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 tier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tier(&has_bits);
          _impl_.tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 players = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_players(&has_bits);
          _impl_.players_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 teams = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_teams(&has_bits);
          _impl_.teams_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 winning_teams = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_winning_teams(&has_bits);
          _impl_.winning_teams_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 players_streak_2 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_players_streak_2(&has_bits);
          _impl_.players_streak_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 players_streak_3 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_players_streak_3(&has_bits);
          _impl_.players_streak_3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 players_streak_4 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_players_streak_4(&has_bits);
          _impl_.players_streak_4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 players_streak_5 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_players_streak_5(&has_bits);
          _impl_.players_streak_5_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAWeekendTourneyParticipationDetails_Tier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAWeekendTourneyParticipationDetails.Tier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 tier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_tier(), target);
  }

  // optional uint32 players = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_players(), target);
  }

  // optional uint32 teams = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_teams(), target);
  }

  // optional uint32 winning_teams = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_winning_teams(), target);
  }

  // optional uint32 players_streak_2 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_players_streak_2(), target);
  }

  // optional uint32 players_streak_3 = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_players_streak_3(), target);
  }

  // optional uint32 players_streak_4 = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_players_streak_4(), target);
  }

  // optional uint32 players_streak_5 = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_players_streak_5(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAWeekendTourneyParticipationDetails.Tier)
  return target;
}

size_t CMsgDOTAWeekendTourneyParticipationDetails_Tier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAWeekendTourneyParticipationDetails.Tier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 tier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tier());
    }

    // optional uint32 players = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_players());
    }

    // optional uint32 teams = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_teams());
    }

    // optional uint32 winning_teams = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_winning_teams());
    }

    // optional uint32 players_streak_2 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_players_streak_2());
    }

    // optional uint32 players_streak_3 = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_players_streak_3());
    }

    // optional uint32 players_streak_4 = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_players_streak_4());
    }

    // optional uint32 players_streak_5 = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_players_streak_5());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAWeekendTourneyParticipationDetails_Tier::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAWeekendTourneyParticipationDetails_Tier::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAWeekendTourneyParticipationDetails_Tier::GetClassData() const { return &_class_data_; }


void CMsgDOTAWeekendTourneyParticipationDetails_Tier::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAWeekendTourneyParticipationDetails_Tier*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAWeekendTourneyParticipationDetails_Tier&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAWeekendTourneyParticipationDetails.Tier)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.tier_ = from._impl_.tier_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.players_ = from._impl_.players_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.teams_ = from._impl_.teams_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.winning_teams_ = from._impl_.winning_teams_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.players_streak_2_ = from._impl_.players_streak_2_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.players_streak_3_ = from._impl_.players_streak_3_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.players_streak_4_ = from._impl_.players_streak_4_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.players_streak_5_ = from._impl_.players_streak_5_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAWeekendTourneyParticipationDetails_Tier::CopyFrom(const CMsgDOTAWeekendTourneyParticipationDetails_Tier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAWeekendTourneyParticipationDetails.Tier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAWeekendTourneyParticipationDetails_Tier::IsInitialized() const {
  return true;
}

void CMsgDOTAWeekendTourneyParticipationDetails_Tier::InternalSwap(CMsgDOTAWeekendTourneyParticipationDetails_Tier* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAWeekendTourneyParticipationDetails_Tier, _impl_.players_streak_5_)
      + sizeof(CMsgDOTAWeekendTourneyParticipationDetails_Tier::_impl_.players_streak_5_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAWeekendTourneyParticipationDetails_Tier, _impl_.tier_)>(
          reinterpret_cast<char*>(&_impl_.tier_),
          reinterpret_cast<char*>(&other->_impl_.tier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAWeekendTourneyParticipationDetails_Tier::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[17]);
}

// ===================================================================

class CMsgDOTAWeekendTourneyParticipationDetails_Division::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAWeekendTourneyParticipationDetails_Division>()._impl_._has_bits_);
  static void set_has_division_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_schedule_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTAWeekendTourneyParticipationDetails_Division::CMsgDOTAWeekendTourneyParticipationDetails_Division(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAWeekendTourneyParticipationDetails.Division)
}
CMsgDOTAWeekendTourneyParticipationDetails_Division::CMsgDOTAWeekendTourneyParticipationDetails_Division(const CMsgDOTAWeekendTourneyParticipationDetails_Division& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAWeekendTourneyParticipationDetails_Division* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tiers_){from._impl_.tiers_}
    , decltype(_impl_.division_id_){}
    , decltype(_impl_.schedule_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.division_id_, &from._impl_.division_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.schedule_time_) -
    reinterpret_cast<char*>(&_impl_.division_id_)) + sizeof(_impl_.schedule_time_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAWeekendTourneyParticipationDetails.Division)
}

inline void CMsgDOTAWeekendTourneyParticipationDetails_Division::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tiers_){arena}
    , decltype(_impl_.division_id_){0u}
    , decltype(_impl_.schedule_time_){0u}
  };
}

CMsgDOTAWeekendTourneyParticipationDetails_Division::~CMsgDOTAWeekendTourneyParticipationDetails_Division() {
  // @@protoc_insertion_point(destructor:CMsgDOTAWeekendTourneyParticipationDetails.Division)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAWeekendTourneyParticipationDetails_Division::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tiers_.~RepeatedPtrField();
}

void CMsgDOTAWeekendTourneyParticipationDetails_Division::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAWeekendTourneyParticipationDetails_Division::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAWeekendTourneyParticipationDetails.Division)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tiers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.division_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.schedule_time_) -
        reinterpret_cast<char*>(&_impl_.division_id_)) + sizeof(_impl_.schedule_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAWeekendTourneyParticipationDetails_Division::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 division_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_division_id(&has_bits);
          _impl_.division_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 schedule_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_schedule_time(&has_bits);
          _impl_.schedule_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAWeekendTourneyParticipationDetails.Tier tiers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tiers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAWeekendTourneyParticipationDetails_Division::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAWeekendTourneyParticipationDetails.Division)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 division_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_division_id(), target);
  }

  // optional uint32 schedule_time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_schedule_time(), target);
  }

  // repeated .CMsgDOTAWeekendTourneyParticipationDetails.Tier tiers = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tiers_size()); i < n; i++) {
    const auto& repfield = this->_internal_tiers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAWeekendTourneyParticipationDetails.Division)
  return target;
}

size_t CMsgDOTAWeekendTourneyParticipationDetails_Division::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAWeekendTourneyParticipationDetails.Division)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAWeekendTourneyParticipationDetails.Tier tiers = 3;
  total_size += 1UL * this->_internal_tiers_size();
  for (const auto& msg : this->_impl_.tiers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 division_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_division_id());
    }

    // optional uint32 schedule_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_schedule_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAWeekendTourneyParticipationDetails_Division::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAWeekendTourneyParticipationDetails_Division::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAWeekendTourneyParticipationDetails_Division::GetClassData() const { return &_class_data_; }


void CMsgDOTAWeekendTourneyParticipationDetails_Division::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAWeekendTourneyParticipationDetails_Division*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAWeekendTourneyParticipationDetails_Division&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAWeekendTourneyParticipationDetails.Division)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tiers_.MergeFrom(from._impl_.tiers_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.division_id_ = from._impl_.division_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.schedule_time_ = from._impl_.schedule_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAWeekendTourneyParticipationDetails_Division::CopyFrom(const CMsgDOTAWeekendTourneyParticipationDetails_Division& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAWeekendTourneyParticipationDetails.Division)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAWeekendTourneyParticipationDetails_Division::IsInitialized() const {
  return true;
}

void CMsgDOTAWeekendTourneyParticipationDetails_Division::InternalSwap(CMsgDOTAWeekendTourneyParticipationDetails_Division* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.tiers_.InternalSwap(&other->_impl_.tiers_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAWeekendTourneyParticipationDetails_Division, _impl_.schedule_time_)
      + sizeof(CMsgDOTAWeekendTourneyParticipationDetails_Division::_impl_.schedule_time_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAWeekendTourneyParticipationDetails_Division, _impl_.division_id_)>(
          reinterpret_cast<char*>(&_impl_.division_id_),
          reinterpret_cast<char*>(&other->_impl_.division_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAWeekendTourneyParticipationDetails_Division::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[18]);
}

// ===================================================================

class CMsgDOTAWeekendTourneyParticipationDetails::_Internal {
 public:
};

CMsgDOTAWeekendTourneyParticipationDetails::CMsgDOTAWeekendTourneyParticipationDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAWeekendTourneyParticipationDetails)
}
CMsgDOTAWeekendTourneyParticipationDetails::CMsgDOTAWeekendTourneyParticipationDetails(const CMsgDOTAWeekendTourneyParticipationDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAWeekendTourneyParticipationDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.divisions_){from._impl_.divisions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAWeekendTourneyParticipationDetails)
}

inline void CMsgDOTAWeekendTourneyParticipationDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.divisions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTAWeekendTourneyParticipationDetails::~CMsgDOTAWeekendTourneyParticipationDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTAWeekendTourneyParticipationDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAWeekendTourneyParticipationDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.divisions_.~RepeatedPtrField();
}

void CMsgDOTAWeekendTourneyParticipationDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAWeekendTourneyParticipationDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAWeekendTourneyParticipationDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.divisions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAWeekendTourneyParticipationDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTAWeekendTourneyParticipationDetails.Division divisions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_divisions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAWeekendTourneyParticipationDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAWeekendTourneyParticipationDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTAWeekendTourneyParticipationDetails.Division divisions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_divisions_size()); i < n; i++) {
    const auto& repfield = this->_internal_divisions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAWeekendTourneyParticipationDetails)
  return target;
}

size_t CMsgDOTAWeekendTourneyParticipationDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAWeekendTourneyParticipationDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAWeekendTourneyParticipationDetails.Division divisions = 1;
  total_size += 1UL * this->_internal_divisions_size();
  for (const auto& msg : this->_impl_.divisions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAWeekendTourneyParticipationDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAWeekendTourneyParticipationDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAWeekendTourneyParticipationDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTAWeekendTourneyParticipationDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAWeekendTourneyParticipationDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAWeekendTourneyParticipationDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAWeekendTourneyParticipationDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.divisions_.MergeFrom(from._impl_.divisions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAWeekendTourneyParticipationDetails::CopyFrom(const CMsgDOTAWeekendTourneyParticipationDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAWeekendTourneyParticipationDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAWeekendTourneyParticipationDetails::IsInitialized() const {
  return true;
}

void CMsgDOTAWeekendTourneyParticipationDetails::InternalSwap(CMsgDOTAWeekendTourneyParticipationDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.divisions_.InternalSwap(&other->_impl_.divisions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAWeekendTourneyParticipationDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fclient_5ftournament_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fclient_5ftournament_2eproto[19]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgRequestWeekendTourneySchedule*
Arena::CreateMaybeMessage< ::CMsgRequestWeekendTourneySchedule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRequestWeekendTourneySchedule >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgWeekendTourneySchedule_Division*
Arena::CreateMaybeMessage< ::CMsgWeekendTourneySchedule_Division >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgWeekendTourneySchedule_Division >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgWeekendTourneySchedule*
Arena::CreateMaybeMessage< ::CMsgWeekendTourneySchedule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgWeekendTourneySchedule >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgWeekendTourneyOpts*
Arena::CreateMaybeMessage< ::CMsgWeekendTourneyOpts >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgWeekendTourneyOpts >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgWeekendTourneyLeave*
Arena::CreateMaybeMessage< ::CMsgWeekendTourneyLeave >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgWeekendTourneyLeave >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTATournament_Team*
Arena::CreateMaybeMessage< ::CMsgDOTATournament_Team >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTATournament_Team >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTATournament_Game*
Arena::CreateMaybeMessage< ::CMsgDOTATournament_Game >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTATournament_Game >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTATournament_Node*
Arena::CreateMaybeMessage< ::CMsgDOTATournament_Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTATournament_Node >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTATournament*
Arena::CreateMaybeMessage< ::CMsgDOTATournament >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTATournament >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTATournamentStateChange_GameChange*
Arena::CreateMaybeMessage< ::CMsgDOTATournamentStateChange_GameChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTATournamentStateChange_GameChange >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTATournamentStateChange_TeamChange*
Arena::CreateMaybeMessage< ::CMsgDOTATournamentStateChange_TeamChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTATournamentStateChange_TeamChange >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTATournamentStateChange*
Arena::CreateMaybeMessage< ::CMsgDOTATournamentStateChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTATournamentStateChange >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAWeekendTourneyPlayerSkillLevelStats*
Arena::CreateMaybeMessage< ::CMsgDOTAWeekendTourneyPlayerSkillLevelStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAWeekendTourneyPlayerSkillLevelStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAWeekendTourneyPlayerStats*
Arena::CreateMaybeMessage< ::CMsgDOTAWeekendTourneyPlayerStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAWeekendTourneyPlayerStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAWeekendTourneyPlayerStatsRequest*
Arena::CreateMaybeMessage< ::CMsgDOTAWeekendTourneyPlayerStatsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAWeekendTourneyPlayerStatsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAWeekendTourneyPlayerHistory_Tournament*
Arena::CreateMaybeMessage< ::CMsgDOTAWeekendTourneyPlayerHistory_Tournament >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAWeekendTourneyPlayerHistory_Tournament >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAWeekendTourneyPlayerHistory*
Arena::CreateMaybeMessage< ::CMsgDOTAWeekendTourneyPlayerHistory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAWeekendTourneyPlayerHistory >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAWeekendTourneyParticipationDetails_Tier*
Arena::CreateMaybeMessage< ::CMsgDOTAWeekendTourneyParticipationDetails_Tier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAWeekendTourneyParticipationDetails_Tier >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAWeekendTourneyParticipationDetails_Division*
Arena::CreateMaybeMessage< ::CMsgDOTAWeekendTourneyParticipationDetails_Division >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAWeekendTourneyParticipationDetails_Division >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAWeekendTourneyParticipationDetails*
Arena::CreateMaybeMessage< ::CMsgDOTAWeekendTourneyParticipationDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAWeekendTourneyParticipationDetails >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
