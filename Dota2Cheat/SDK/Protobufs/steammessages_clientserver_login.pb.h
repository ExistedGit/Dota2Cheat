// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_clientserver_login.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_steammessages_5fclientserver_5flogin_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_steammessages_5fclientserver_5flogin_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "steammessages_base.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_steammessages_5fclientserver_5flogin_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_steammessages_5fclientserver_5flogin_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fclientserver_5flogin_2eproto;
class CMsgClientAccountInfo;
struct CMsgClientAccountInfoDefaultTypeInternal;
extern CMsgClientAccountInfoDefaultTypeInternal _CMsgClientAccountInfo_default_instance_;
class CMsgClientChallengeRequest;
struct CMsgClientChallengeRequestDefaultTypeInternal;
extern CMsgClientChallengeRequestDefaultTypeInternal _CMsgClientChallengeRequest_default_instance_;
class CMsgClientChallengeResponse;
struct CMsgClientChallengeResponseDefaultTypeInternal;
extern CMsgClientChallengeResponseDefaultTypeInternal _CMsgClientChallengeResponse_default_instance_;
class CMsgClientHeartBeat;
struct CMsgClientHeartBeatDefaultTypeInternal;
extern CMsgClientHeartBeatDefaultTypeInternal _CMsgClientHeartBeat_default_instance_;
class CMsgClientLogOff;
struct CMsgClientLogOffDefaultTypeInternal;
extern CMsgClientLogOffDefaultTypeInternal _CMsgClientLogOff_default_instance_;
class CMsgClientLoggedOff;
struct CMsgClientLoggedOffDefaultTypeInternal;
extern CMsgClientLoggedOffDefaultTypeInternal _CMsgClientLoggedOff_default_instance_;
class CMsgClientLogon;
struct CMsgClientLogonDefaultTypeInternal;
extern CMsgClientLogonDefaultTypeInternal _CMsgClientLogon_default_instance_;
class CMsgClientLogonResponse;
struct CMsgClientLogonResponseDefaultTypeInternal;
extern CMsgClientLogonResponseDefaultTypeInternal _CMsgClientLogonResponse_default_instance_;
class CMsgClientNewLoginKey;
struct CMsgClientNewLoginKeyDefaultTypeInternal;
extern CMsgClientNewLoginKeyDefaultTypeInternal _CMsgClientNewLoginKey_default_instance_;
class CMsgClientNewLoginKeyAccepted;
struct CMsgClientNewLoginKeyAcceptedDefaultTypeInternal;
extern CMsgClientNewLoginKeyAcceptedDefaultTypeInternal _CMsgClientNewLoginKeyAccepted_default_instance_;
class CMsgClientRequestWebAPIAuthenticateUserNonce;
struct CMsgClientRequestWebAPIAuthenticateUserNonceDefaultTypeInternal;
extern CMsgClientRequestWebAPIAuthenticateUserNonceDefaultTypeInternal _CMsgClientRequestWebAPIAuthenticateUserNonce_default_instance_;
class CMsgClientRequestWebAPIAuthenticateUserNonceResponse;
struct CMsgClientRequestWebAPIAuthenticateUserNonceResponseDefaultTypeInternal;
extern CMsgClientRequestWebAPIAuthenticateUserNonceResponseDefaultTypeInternal _CMsgClientRequestWebAPIAuthenticateUserNonceResponse_default_instance_;
class CMsgClientSecret;
struct CMsgClientSecretDefaultTypeInternal;
extern CMsgClientSecretDefaultTypeInternal _CMsgClientSecret_default_instance_;
class CMsgClientServerTimestampRequest;
struct CMsgClientServerTimestampRequestDefaultTypeInternal;
extern CMsgClientServerTimestampRequestDefaultTypeInternal _CMsgClientServerTimestampRequest_default_instance_;
class CMsgClientServerTimestampResponse;
struct CMsgClientServerTimestampResponseDefaultTypeInternal;
extern CMsgClientServerTimestampResponseDefaultTypeInternal _CMsgClientServerTimestampResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CMsgClientAccountInfo* Arena::CreateMaybeMessage<::CMsgClientAccountInfo>(Arena*);
template<> ::CMsgClientChallengeRequest* Arena::CreateMaybeMessage<::CMsgClientChallengeRequest>(Arena*);
template<> ::CMsgClientChallengeResponse* Arena::CreateMaybeMessage<::CMsgClientChallengeResponse>(Arena*);
template<> ::CMsgClientHeartBeat* Arena::CreateMaybeMessage<::CMsgClientHeartBeat>(Arena*);
template<> ::CMsgClientLogOff* Arena::CreateMaybeMessage<::CMsgClientLogOff>(Arena*);
template<> ::CMsgClientLoggedOff* Arena::CreateMaybeMessage<::CMsgClientLoggedOff>(Arena*);
template<> ::CMsgClientLogon* Arena::CreateMaybeMessage<::CMsgClientLogon>(Arena*);
template<> ::CMsgClientLogonResponse* Arena::CreateMaybeMessage<::CMsgClientLogonResponse>(Arena*);
template<> ::CMsgClientNewLoginKey* Arena::CreateMaybeMessage<::CMsgClientNewLoginKey>(Arena*);
template<> ::CMsgClientNewLoginKeyAccepted* Arena::CreateMaybeMessage<::CMsgClientNewLoginKeyAccepted>(Arena*);
template<> ::CMsgClientRequestWebAPIAuthenticateUserNonce* Arena::CreateMaybeMessage<::CMsgClientRequestWebAPIAuthenticateUserNonce>(Arena*);
template<> ::CMsgClientRequestWebAPIAuthenticateUserNonceResponse* Arena::CreateMaybeMessage<::CMsgClientRequestWebAPIAuthenticateUserNonceResponse>(Arena*);
template<> ::CMsgClientSecret* Arena::CreateMaybeMessage<::CMsgClientSecret>(Arena*);
template<> ::CMsgClientServerTimestampRequest* Arena::CreateMaybeMessage<::CMsgClientServerTimestampRequest>(Arena*);
template<> ::CMsgClientServerTimestampResponse* Arena::CreateMaybeMessage<::CMsgClientServerTimestampResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class CMsgClientHeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CMsgClientHeartBeat) */ {
 public:
  inline CMsgClientHeartBeat() : CMsgClientHeartBeat(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CMsgClientHeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientHeartBeat(const CMsgClientHeartBeat& from);
  CMsgClientHeartBeat(CMsgClientHeartBeat&& from) noexcept
    : CMsgClientHeartBeat() {
    *this = ::std::move(from);
  }

  inline CMsgClientHeartBeat& operator=(const CMsgClientHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientHeartBeat& operator=(CMsgClientHeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientHeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientHeartBeat* internal_default_instance() {
    return reinterpret_cast<const CMsgClientHeartBeat*>(
               &_CMsgClientHeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CMsgClientHeartBeat& a, CMsgClientHeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientHeartBeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientHeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientHeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientHeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CMsgClientHeartBeat& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CMsgClientHeartBeat& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientHeartBeat";
  }
  protected:
  explicit CMsgClientHeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CMsgClientHeartBeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientServerTimestampRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientServerTimestampRequest) */ {
 public:
  inline CMsgClientServerTimestampRequest() : CMsgClientServerTimestampRequest(nullptr) {}
  ~CMsgClientServerTimestampRequest() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientServerTimestampRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientServerTimestampRequest(const CMsgClientServerTimestampRequest& from);
  CMsgClientServerTimestampRequest(CMsgClientServerTimestampRequest&& from) noexcept
    : CMsgClientServerTimestampRequest() {
    *this = ::std::move(from);
  }

  inline CMsgClientServerTimestampRequest& operator=(const CMsgClientServerTimestampRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientServerTimestampRequest& operator=(CMsgClientServerTimestampRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientServerTimestampRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientServerTimestampRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgClientServerTimestampRequest*>(
               &_CMsgClientServerTimestampRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CMsgClientServerTimestampRequest& a, CMsgClientServerTimestampRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientServerTimestampRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientServerTimestampRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientServerTimestampRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientServerTimestampRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientServerTimestampRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientServerTimestampRequest& from) {
    CMsgClientServerTimestampRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientServerTimestampRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientServerTimestampRequest";
  }
  protected:
  explicit CMsgClientServerTimestampRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientRequestTimestampFieldNumber = 1,
  };
  // optional uint64 client_request_timestamp = 1;
  bool has_client_request_timestamp() const;
  private:
  bool _internal_has_client_request_timestamp() const;
  public:
  void clear_client_request_timestamp();
  uint64_t client_request_timestamp() const;
  void set_client_request_timestamp(uint64_t value);
  private:
  uint64_t _internal_client_request_timestamp() const;
  void _internal_set_client_request_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientServerTimestampRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t client_request_timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientServerTimestampResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientServerTimestampResponse) */ {
 public:
  inline CMsgClientServerTimestampResponse() : CMsgClientServerTimestampResponse(nullptr) {}
  ~CMsgClientServerTimestampResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientServerTimestampResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientServerTimestampResponse(const CMsgClientServerTimestampResponse& from);
  CMsgClientServerTimestampResponse(CMsgClientServerTimestampResponse&& from) noexcept
    : CMsgClientServerTimestampResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientServerTimestampResponse& operator=(const CMsgClientServerTimestampResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientServerTimestampResponse& operator=(CMsgClientServerTimestampResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientServerTimestampResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientServerTimestampResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientServerTimestampResponse*>(
               &_CMsgClientServerTimestampResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CMsgClientServerTimestampResponse& a, CMsgClientServerTimestampResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientServerTimestampResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientServerTimestampResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientServerTimestampResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientServerTimestampResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientServerTimestampResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientServerTimestampResponse& from) {
    CMsgClientServerTimestampResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientServerTimestampResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientServerTimestampResponse";
  }
  protected:
  explicit CMsgClientServerTimestampResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientRequestTimestampFieldNumber = 1,
    kServerTimestampMsFieldNumber = 2,
  };
  // optional uint64 client_request_timestamp = 1;
  bool has_client_request_timestamp() const;
  private:
  bool _internal_has_client_request_timestamp() const;
  public:
  void clear_client_request_timestamp();
  uint64_t client_request_timestamp() const;
  void set_client_request_timestamp(uint64_t value);
  private:
  uint64_t _internal_client_request_timestamp() const;
  void _internal_set_client_request_timestamp(uint64_t value);
  public:

  // optional uint64 server_timestamp_ms = 2;
  bool has_server_timestamp_ms() const;
  private:
  bool _internal_has_server_timestamp_ms() const;
  public:
  void clear_server_timestamp_ms();
  uint64_t server_timestamp_ms() const;
  void set_server_timestamp_ms(uint64_t value);
  private:
  uint64_t _internal_server_timestamp_ms() const;
  void _internal_set_server_timestamp_ms(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientServerTimestampResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t client_request_timestamp_;
    uint64_t server_timestamp_ms_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientSecret final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientSecret) */ {
 public:
  inline CMsgClientSecret() : CMsgClientSecret(nullptr) {}
  ~CMsgClientSecret() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientSecret(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientSecret(const CMsgClientSecret& from);
  CMsgClientSecret(CMsgClientSecret&& from) noexcept
    : CMsgClientSecret() {
    *this = ::std::move(from);
  }

  inline CMsgClientSecret& operator=(const CMsgClientSecret& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientSecret& operator=(CMsgClientSecret&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientSecret& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientSecret* internal_default_instance() {
    return reinterpret_cast<const CMsgClientSecret*>(
               &_CMsgClientSecret_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CMsgClientSecret& a, CMsgClientSecret& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientSecret* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientSecret* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientSecret* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientSecret>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientSecret& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientSecret& from) {
    CMsgClientSecret::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientSecret* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientSecret";
  }
  protected:
  explicit CMsgClientSecret(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHmacFieldNumber = 5,
    kVersionFieldNumber = 1,
    kAppidFieldNumber = 2,
    kNonceFieldNumber = 4,
    kDeviceidFieldNumber = 3,
  };
  // optional bytes hmac = 5;
  bool has_hmac() const;
  private:
  bool _internal_has_hmac() const;
  public:
  void clear_hmac();
  const std::string& hmac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hmac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hmac();
  PROTOBUF_NODISCARD std::string* release_hmac();
  void set_allocated_hmac(std::string* hmac);
  private:
  const std::string& _internal_hmac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hmac(const std::string& value);
  std::string* _internal_mutable_hmac();
  public:

  // optional uint32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // optional uint32 appid = 2;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional fixed64 nonce = 4;
  bool has_nonce() const;
  private:
  bool _internal_has_nonce() const;
  public:
  void clear_nonce();
  uint64_t nonce() const;
  void set_nonce(uint64_t value);
  private:
  uint64_t _internal_nonce() const;
  void _internal_set_nonce(uint64_t value);
  public:

  // optional uint32 deviceid = 3;
  bool has_deviceid() const;
  private:
  bool _internal_has_deviceid() const;
  public:
  void clear_deviceid();
  uint32_t deviceid() const;
  void set_deviceid(uint32_t value);
  private:
  uint32_t _internal_deviceid() const;
  void _internal_set_deviceid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientSecret)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hmac_;
    uint32_t version_;
    uint32_t appid_;
    uint64_t nonce_;
    uint32_t deviceid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientLogon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientLogon) */ {
 public:
  inline CMsgClientLogon() : CMsgClientLogon(nullptr) {}
  ~CMsgClientLogon() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientLogon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientLogon(const CMsgClientLogon& from);
  CMsgClientLogon(CMsgClientLogon&& from) noexcept
    : CMsgClientLogon() {
    *this = ::std::move(from);
  }

  inline CMsgClientLogon& operator=(const CMsgClientLogon& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientLogon& operator=(CMsgClientLogon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientLogon& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientLogon* internal_default_instance() {
    return reinterpret_cast<const CMsgClientLogon*>(
               &_CMsgClientLogon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CMsgClientLogon& a, CMsgClientLogon& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientLogon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientLogon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientLogon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientLogon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientLogon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientLogon& from) {
    CMsgClientLogon::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientLogon* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientLogon";
  }
  protected:
  explicit CMsgClientLogon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientLanguageFieldNumber = 6,
    kWineVersionFieldNumber = 9,
    kMachineIdFieldNumber = 30,
    kSteam2AuthTicketFieldNumber = 41,
    kEmailAddressFieldNumber = 42,
    kAccountNameFieldNumber = 50,
    kPasswordFieldNumber = 51,
    kGameServerTokenFieldNumber = 52,
    kLoginKeyFieldNumber = 60,
    kAnonUserTargetAccountNameFieldNumber = 80,
    kShaSentryfileFieldNumber = 83,
    kAuthCodeFieldNumber = 84,
    kOtpIdentifierFieldNumber = 87,
    kSonyPsnTicketFieldNumber = 90,
    kSonyPsnServiceIdFieldNumber = 91,
    kSonyPsnNameFieldNumber = 93,
    kMachineNameFieldNumber = 96,
    kMachineNameUserchosenFieldNumber = 97,
    kCountryOverrideFieldNumber = 98,
    kTwoFactorCodeFieldNumber = 101,
    kWebLogonNonceFieldNumber = 103,
    kObfuscatedPrivateIpFieldNumber = 11,
    kPublicIpFieldNumber = 23,
    kEmbeddedClientSecretFieldNumber = 105,
    kProtocolVersionFieldNumber = 1,
    kDeprecatedObfustucatedPrivateIpFieldNumber = 2,
    kCellIdFieldNumber = 3,
    kLastSessionIdFieldNumber = 4,
    kClientPackageVersionFieldNumber = 5,
    kClientOsTypeFieldNumber = 7,
    kDeprecated10FieldNumber = 10,
    kDeprecatedPublicIpFieldNumber = 20,
    kClientSuppliedSteamIdFieldNumber = 22,
    kQosLevelFieldNumber = 21,
    kLauncherTypeFieldNumber = 31,
    kUiModeFieldNumber = 32,
    kChatModeFieldNumber = 33,
    kRtime32AccountCreationFieldNumber = 43,
    kShouldRememberPasswordFieldNumber = 8,
    kWasConvertedDeprecatedMsgFieldNumber = 70,
    kSteam2TicketRequestFieldNumber = 88,
    kCreateNewPsnLinkedAccountIfNeededFieldNumber = 92,
    kResolvedUserSteamIdFieldNumber = 81,
    kEresultSentryfileFieldNumber = 82,
    kOtpTypeFieldNumber = 85,
    kOtpValueFieldNumber = 86,
    kGameServerAppIdFieldNumber = 94,
    kClientInstanceIdFieldNumber = 100,
    kSteamguardDontRememberComputerFieldNumber = 95,
    kIsSteamBoxFieldNumber = 99,
    kSupportsRateLimitResponseFieldNumber = 102,
    kPriorityReasonFieldNumber = 104,
  };
  // optional string client_language = 6;
  bool has_client_language() const;
  private:
  bool _internal_has_client_language() const;
  public:
  void clear_client_language();
  const std::string& client_language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_language();
  PROTOBUF_NODISCARD std::string* release_client_language();
  void set_allocated_client_language(std::string* client_language);
  private:
  const std::string& _internal_client_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_language(const std::string& value);
  std::string* _internal_mutable_client_language();
  public:

  // optional string wine_version = 9;
  bool has_wine_version() const;
  private:
  bool _internal_has_wine_version() const;
  public:
  void clear_wine_version();
  const std::string& wine_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wine_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wine_version();
  PROTOBUF_NODISCARD std::string* release_wine_version();
  void set_allocated_wine_version(std::string* wine_version);
  private:
  const std::string& _internal_wine_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wine_version(const std::string& value);
  std::string* _internal_mutable_wine_version();
  public:

  // optional bytes machine_id = 30;
  bool has_machine_id() const;
  private:
  bool _internal_has_machine_id() const;
  public:
  void clear_machine_id();
  const std::string& machine_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_id();
  PROTOBUF_NODISCARD std::string* release_machine_id();
  void set_allocated_machine_id(std::string* machine_id);
  private:
  const std::string& _internal_machine_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_id(const std::string& value);
  std::string* _internal_mutable_machine_id();
  public:

  // optional bytes steam2_auth_ticket = 41;
  bool has_steam2_auth_ticket() const;
  private:
  bool _internal_has_steam2_auth_ticket() const;
  public:
  void clear_steam2_auth_ticket();
  const std::string& steam2_auth_ticket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_steam2_auth_ticket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_steam2_auth_ticket();
  PROTOBUF_NODISCARD std::string* release_steam2_auth_ticket();
  void set_allocated_steam2_auth_ticket(std::string* steam2_auth_ticket);
  private:
  const std::string& _internal_steam2_auth_ticket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_steam2_auth_ticket(const std::string& value);
  std::string* _internal_mutable_steam2_auth_ticket();
  public:

  // optional string email_address = 42;
  bool has_email_address() const;
  private:
  bool _internal_has_email_address() const;
  public:
  void clear_email_address();
  const std::string& email_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email_address();
  PROTOBUF_NODISCARD std::string* release_email_address();
  void set_allocated_email_address(std::string* email_address);
  private:
  const std::string& _internal_email_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email_address(const std::string& value);
  std::string* _internal_mutable_email_address();
  public:

  // optional string account_name = 50;
  bool has_account_name() const;
  private:
  bool _internal_has_account_name() const;
  public:
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // optional string password = 51;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string game_server_token = 52;
  bool has_game_server_token() const;
  private:
  bool _internal_has_game_server_token() const;
  public:
  void clear_game_server_token();
  const std::string& game_server_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_server_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_server_token();
  PROTOBUF_NODISCARD std::string* release_game_server_token();
  void set_allocated_game_server_token(std::string* game_server_token);
  private:
  const std::string& _internal_game_server_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_server_token(const std::string& value);
  std::string* _internal_mutable_game_server_token();
  public:

  // optional string login_key = 60;
  bool has_login_key() const;
  private:
  bool _internal_has_login_key() const;
  public:
  void clear_login_key();
  const std::string& login_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_key();
  PROTOBUF_NODISCARD std::string* release_login_key();
  void set_allocated_login_key(std::string* login_key);
  private:
  const std::string& _internal_login_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_key(const std::string& value);
  std::string* _internal_mutable_login_key();
  public:

  // optional string anon_user_target_account_name = 80;
  bool has_anon_user_target_account_name() const;
  private:
  bool _internal_has_anon_user_target_account_name() const;
  public:
  void clear_anon_user_target_account_name();
  const std::string& anon_user_target_account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_anon_user_target_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_anon_user_target_account_name();
  PROTOBUF_NODISCARD std::string* release_anon_user_target_account_name();
  void set_allocated_anon_user_target_account_name(std::string* anon_user_target_account_name);
  private:
  const std::string& _internal_anon_user_target_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_anon_user_target_account_name(const std::string& value);
  std::string* _internal_mutable_anon_user_target_account_name();
  public:

  // optional bytes sha_sentryfile = 83;
  bool has_sha_sentryfile() const;
  private:
  bool _internal_has_sha_sentryfile() const;
  public:
  void clear_sha_sentryfile();
  const std::string& sha_sentryfile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sha_sentryfile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sha_sentryfile();
  PROTOBUF_NODISCARD std::string* release_sha_sentryfile();
  void set_allocated_sha_sentryfile(std::string* sha_sentryfile);
  private:
  const std::string& _internal_sha_sentryfile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha_sentryfile(const std::string& value);
  std::string* _internal_mutable_sha_sentryfile();
  public:

  // optional string auth_code = 84;
  bool has_auth_code() const;
  private:
  bool _internal_has_auth_code() const;
  public:
  void clear_auth_code();
  const std::string& auth_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_code();
  PROTOBUF_NODISCARD std::string* release_auth_code();
  void set_allocated_auth_code(std::string* auth_code);
  private:
  const std::string& _internal_auth_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_code(const std::string& value);
  std::string* _internal_mutable_auth_code();
  public:

  // optional string otp_identifier = 87;
  bool has_otp_identifier() const;
  private:
  bool _internal_has_otp_identifier() const;
  public:
  void clear_otp_identifier();
  const std::string& otp_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_otp_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_otp_identifier();
  PROTOBUF_NODISCARD std::string* release_otp_identifier();
  void set_allocated_otp_identifier(std::string* otp_identifier);
  private:
  const std::string& _internal_otp_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_otp_identifier(const std::string& value);
  std::string* _internal_mutable_otp_identifier();
  public:

  // optional bytes sony_psn_ticket = 90;
  bool has_sony_psn_ticket() const;
  private:
  bool _internal_has_sony_psn_ticket() const;
  public:
  void clear_sony_psn_ticket();
  const std::string& sony_psn_ticket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sony_psn_ticket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sony_psn_ticket();
  PROTOBUF_NODISCARD std::string* release_sony_psn_ticket();
  void set_allocated_sony_psn_ticket(std::string* sony_psn_ticket);
  private:
  const std::string& _internal_sony_psn_ticket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sony_psn_ticket(const std::string& value);
  std::string* _internal_mutable_sony_psn_ticket();
  public:

  // optional string sony_psn_service_id = 91;
  bool has_sony_psn_service_id() const;
  private:
  bool _internal_has_sony_psn_service_id() const;
  public:
  void clear_sony_psn_service_id();
  const std::string& sony_psn_service_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sony_psn_service_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sony_psn_service_id();
  PROTOBUF_NODISCARD std::string* release_sony_psn_service_id();
  void set_allocated_sony_psn_service_id(std::string* sony_psn_service_id);
  private:
  const std::string& _internal_sony_psn_service_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sony_psn_service_id(const std::string& value);
  std::string* _internal_mutable_sony_psn_service_id();
  public:

  // optional string sony_psn_name = 93;
  bool has_sony_psn_name() const;
  private:
  bool _internal_has_sony_psn_name() const;
  public:
  void clear_sony_psn_name();
  const std::string& sony_psn_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sony_psn_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sony_psn_name();
  PROTOBUF_NODISCARD std::string* release_sony_psn_name();
  void set_allocated_sony_psn_name(std::string* sony_psn_name);
  private:
  const std::string& _internal_sony_psn_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sony_psn_name(const std::string& value);
  std::string* _internal_mutable_sony_psn_name();
  public:

  // optional string machine_name = 96;
  bool has_machine_name() const;
  private:
  bool _internal_has_machine_name() const;
  public:
  void clear_machine_name();
  const std::string& machine_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_name();
  PROTOBUF_NODISCARD std::string* release_machine_name();
  void set_allocated_machine_name(std::string* machine_name);
  private:
  const std::string& _internal_machine_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_name(const std::string& value);
  std::string* _internal_mutable_machine_name();
  public:

  // optional string machine_name_userchosen = 97;
  bool has_machine_name_userchosen() const;
  private:
  bool _internal_has_machine_name_userchosen() const;
  public:
  void clear_machine_name_userchosen();
  const std::string& machine_name_userchosen() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_name_userchosen(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_name_userchosen();
  PROTOBUF_NODISCARD std::string* release_machine_name_userchosen();
  void set_allocated_machine_name_userchosen(std::string* machine_name_userchosen);
  private:
  const std::string& _internal_machine_name_userchosen() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_name_userchosen(const std::string& value);
  std::string* _internal_mutable_machine_name_userchosen();
  public:

  // optional string country_override = 98;
  bool has_country_override() const;
  private:
  bool _internal_has_country_override() const;
  public:
  void clear_country_override();
  const std::string& country_override() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_override(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_override();
  PROTOBUF_NODISCARD std::string* release_country_override();
  void set_allocated_country_override(std::string* country_override);
  private:
  const std::string& _internal_country_override() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_override(const std::string& value);
  std::string* _internal_mutable_country_override();
  public:

  // optional string two_factor_code = 101;
  bool has_two_factor_code() const;
  private:
  bool _internal_has_two_factor_code() const;
  public:
  void clear_two_factor_code();
  const std::string& two_factor_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_two_factor_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_two_factor_code();
  PROTOBUF_NODISCARD std::string* release_two_factor_code();
  void set_allocated_two_factor_code(std::string* two_factor_code);
  private:
  const std::string& _internal_two_factor_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_two_factor_code(const std::string& value);
  std::string* _internal_mutable_two_factor_code();
  public:

  // optional string web_logon_nonce = 103;
  bool has_web_logon_nonce() const;
  private:
  bool _internal_has_web_logon_nonce() const;
  public:
  void clear_web_logon_nonce();
  const std::string& web_logon_nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_web_logon_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_web_logon_nonce();
  PROTOBUF_NODISCARD std::string* release_web_logon_nonce();
  void set_allocated_web_logon_nonce(std::string* web_logon_nonce);
  private:
  const std::string& _internal_web_logon_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_web_logon_nonce(const std::string& value);
  std::string* _internal_mutable_web_logon_nonce();
  public:

  // optional .CMsgIPAddress obfuscated_private_ip = 11;
  bool has_obfuscated_private_ip() const;
  private:
  bool _internal_has_obfuscated_private_ip() const;
  public:
  void clear_obfuscated_private_ip();
  const ::CMsgIPAddress& obfuscated_private_ip() const;
  PROTOBUF_NODISCARD ::CMsgIPAddress* release_obfuscated_private_ip();
  ::CMsgIPAddress* mutable_obfuscated_private_ip();
  void set_allocated_obfuscated_private_ip(::CMsgIPAddress* obfuscated_private_ip);
  private:
  const ::CMsgIPAddress& _internal_obfuscated_private_ip() const;
  ::CMsgIPAddress* _internal_mutable_obfuscated_private_ip();
  public:
  void unsafe_arena_set_allocated_obfuscated_private_ip(
      ::CMsgIPAddress* obfuscated_private_ip);
  ::CMsgIPAddress* unsafe_arena_release_obfuscated_private_ip();

  // optional .CMsgIPAddress public_ip = 23;
  bool has_public_ip() const;
  private:
  bool _internal_has_public_ip() const;
  public:
  void clear_public_ip();
  const ::CMsgIPAddress& public_ip() const;
  PROTOBUF_NODISCARD ::CMsgIPAddress* release_public_ip();
  ::CMsgIPAddress* mutable_public_ip();
  void set_allocated_public_ip(::CMsgIPAddress* public_ip);
  private:
  const ::CMsgIPAddress& _internal_public_ip() const;
  ::CMsgIPAddress* _internal_mutable_public_ip();
  public:
  void unsafe_arena_set_allocated_public_ip(
      ::CMsgIPAddress* public_ip);
  ::CMsgIPAddress* unsafe_arena_release_public_ip();

  // optional .CMsgClientSecret embedded_client_secret = 105;
  bool has_embedded_client_secret() const;
  private:
  bool _internal_has_embedded_client_secret() const;
  public:
  void clear_embedded_client_secret();
  const ::CMsgClientSecret& embedded_client_secret() const;
  PROTOBUF_NODISCARD ::CMsgClientSecret* release_embedded_client_secret();
  ::CMsgClientSecret* mutable_embedded_client_secret();
  void set_allocated_embedded_client_secret(::CMsgClientSecret* embedded_client_secret);
  private:
  const ::CMsgClientSecret& _internal_embedded_client_secret() const;
  ::CMsgClientSecret* _internal_mutable_embedded_client_secret();
  public:
  void unsafe_arena_set_allocated_embedded_client_secret(
      ::CMsgClientSecret* embedded_client_secret);
  ::CMsgClientSecret* unsafe_arena_release_embedded_client_secret();

  // optional uint32 protocol_version = 1;
  bool has_protocol_version() const;
  private:
  bool _internal_has_protocol_version() const;
  public:
  void clear_protocol_version();
  uint32_t protocol_version() const;
  void set_protocol_version(uint32_t value);
  private:
  uint32_t _internal_protocol_version() const;
  void _internal_set_protocol_version(uint32_t value);
  public:

  // optional uint32 deprecated_obfustucated_private_ip = 2;
  bool has_deprecated_obfustucated_private_ip() const;
  private:
  bool _internal_has_deprecated_obfustucated_private_ip() const;
  public:
  void clear_deprecated_obfustucated_private_ip();
  uint32_t deprecated_obfustucated_private_ip() const;
  void set_deprecated_obfustucated_private_ip(uint32_t value);
  private:
  uint32_t _internal_deprecated_obfustucated_private_ip() const;
  void _internal_set_deprecated_obfustucated_private_ip(uint32_t value);
  public:

  // optional uint32 cell_id = 3;
  bool has_cell_id() const;
  private:
  bool _internal_has_cell_id() const;
  public:
  void clear_cell_id();
  uint32_t cell_id() const;
  void set_cell_id(uint32_t value);
  private:
  uint32_t _internal_cell_id() const;
  void _internal_set_cell_id(uint32_t value);
  public:

  // optional uint32 last_session_id = 4;
  bool has_last_session_id() const;
  private:
  bool _internal_has_last_session_id() const;
  public:
  void clear_last_session_id();
  uint32_t last_session_id() const;
  void set_last_session_id(uint32_t value);
  private:
  uint32_t _internal_last_session_id() const;
  void _internal_set_last_session_id(uint32_t value);
  public:

  // optional uint32 client_package_version = 5;
  bool has_client_package_version() const;
  private:
  bool _internal_has_client_package_version() const;
  public:
  void clear_client_package_version();
  uint32_t client_package_version() const;
  void set_client_package_version(uint32_t value);
  private:
  uint32_t _internal_client_package_version() const;
  void _internal_set_client_package_version(uint32_t value);
  public:

  // optional uint32 client_os_type = 7;
  bool has_client_os_type() const;
  private:
  bool _internal_has_client_os_type() const;
  public:
  void clear_client_os_type();
  uint32_t client_os_type() const;
  void set_client_os_type(uint32_t value);
  private:
  uint32_t _internal_client_os_type() const;
  void _internal_set_client_os_type(uint32_t value);
  public:

  // optional uint32 deprecated_10 = 10;
  bool has_deprecated_10() const;
  private:
  bool _internal_has_deprecated_10() const;
  public:
  void clear_deprecated_10();
  uint32_t deprecated_10() const;
  void set_deprecated_10(uint32_t value);
  private:
  uint32_t _internal_deprecated_10() const;
  void _internal_set_deprecated_10(uint32_t value);
  public:

  // optional uint32 deprecated_public_ip = 20;
  bool has_deprecated_public_ip() const;
  private:
  bool _internal_has_deprecated_public_ip() const;
  public:
  void clear_deprecated_public_ip();
  uint32_t deprecated_public_ip() const;
  void set_deprecated_public_ip(uint32_t value);
  private:
  uint32_t _internal_deprecated_public_ip() const;
  void _internal_set_deprecated_public_ip(uint32_t value);
  public:

  // optional fixed64 client_supplied_steam_id = 22;
  bool has_client_supplied_steam_id() const;
  private:
  bool _internal_has_client_supplied_steam_id() const;
  public:
  void clear_client_supplied_steam_id();
  uint64_t client_supplied_steam_id() const;
  void set_client_supplied_steam_id(uint64_t value);
  private:
  uint64_t _internal_client_supplied_steam_id() const;
  void _internal_set_client_supplied_steam_id(uint64_t value);
  public:

  // optional uint32 qos_level = 21;
  bool has_qos_level() const;
  private:
  bool _internal_has_qos_level() const;
  public:
  void clear_qos_level();
  uint32_t qos_level() const;
  void set_qos_level(uint32_t value);
  private:
  uint32_t _internal_qos_level() const;
  void _internal_set_qos_level(uint32_t value);
  public:

  // optional uint32 launcher_type = 31 [default = 0];
  bool has_launcher_type() const;
  private:
  bool _internal_has_launcher_type() const;
  public:
  void clear_launcher_type();
  uint32_t launcher_type() const;
  void set_launcher_type(uint32_t value);
  private:
  uint32_t _internal_launcher_type() const;
  void _internal_set_launcher_type(uint32_t value);
  public:

  // optional uint32 ui_mode = 32 [default = 0];
  bool has_ui_mode() const;
  private:
  bool _internal_has_ui_mode() const;
  public:
  void clear_ui_mode();
  uint32_t ui_mode() const;
  void set_ui_mode(uint32_t value);
  private:
  uint32_t _internal_ui_mode() const;
  void _internal_set_ui_mode(uint32_t value);
  public:

  // optional uint32 chat_mode = 33 [default = 0];
  bool has_chat_mode() const;
  private:
  bool _internal_has_chat_mode() const;
  public:
  void clear_chat_mode();
  uint32_t chat_mode() const;
  void set_chat_mode(uint32_t value);
  private:
  uint32_t _internal_chat_mode() const;
  void _internal_set_chat_mode(uint32_t value);
  public:

  // optional fixed32 rtime32_account_creation = 43;
  bool has_rtime32_account_creation() const;
  private:
  bool _internal_has_rtime32_account_creation() const;
  public:
  void clear_rtime32_account_creation();
  uint32_t rtime32_account_creation() const;
  void set_rtime32_account_creation(uint32_t value);
  private:
  uint32_t _internal_rtime32_account_creation() const;
  void _internal_set_rtime32_account_creation(uint32_t value);
  public:

  // optional bool should_remember_password = 8 [default = false];
  bool has_should_remember_password() const;
  private:
  bool _internal_has_should_remember_password() const;
  public:
  void clear_should_remember_password();
  bool should_remember_password() const;
  void set_should_remember_password(bool value);
  private:
  bool _internal_should_remember_password() const;
  void _internal_set_should_remember_password(bool value);
  public:

  // optional bool was_converted_deprecated_msg = 70 [default = false];
  bool has_was_converted_deprecated_msg() const;
  private:
  bool _internal_has_was_converted_deprecated_msg() const;
  public:
  void clear_was_converted_deprecated_msg();
  bool was_converted_deprecated_msg() const;
  void set_was_converted_deprecated_msg(bool value);
  private:
  bool _internal_was_converted_deprecated_msg() const;
  void _internal_set_was_converted_deprecated_msg(bool value);
  public:

  // optional bool steam2_ticket_request = 88;
  bool has_steam2_ticket_request() const;
  private:
  bool _internal_has_steam2_ticket_request() const;
  public:
  void clear_steam2_ticket_request();
  bool steam2_ticket_request() const;
  void set_steam2_ticket_request(bool value);
  private:
  bool _internal_steam2_ticket_request() const;
  void _internal_set_steam2_ticket_request(bool value);
  public:

  // optional bool create_new_psn_linked_account_if_needed = 92 [default = false];
  bool has_create_new_psn_linked_account_if_needed() const;
  private:
  bool _internal_has_create_new_psn_linked_account_if_needed() const;
  public:
  void clear_create_new_psn_linked_account_if_needed();
  bool create_new_psn_linked_account_if_needed() const;
  void set_create_new_psn_linked_account_if_needed(bool value);
  private:
  bool _internal_create_new_psn_linked_account_if_needed() const;
  void _internal_set_create_new_psn_linked_account_if_needed(bool value);
  public:

  // optional fixed64 resolved_user_steam_id = 81;
  bool has_resolved_user_steam_id() const;
  private:
  bool _internal_has_resolved_user_steam_id() const;
  public:
  void clear_resolved_user_steam_id();
  uint64_t resolved_user_steam_id() const;
  void set_resolved_user_steam_id(uint64_t value);
  private:
  uint64_t _internal_resolved_user_steam_id() const;
  void _internal_set_resolved_user_steam_id(uint64_t value);
  public:

  // optional int32 eresult_sentryfile = 82;
  bool has_eresult_sentryfile() const;
  private:
  bool _internal_has_eresult_sentryfile() const;
  public:
  void clear_eresult_sentryfile();
  int32_t eresult_sentryfile() const;
  void set_eresult_sentryfile(int32_t value);
  private:
  int32_t _internal_eresult_sentryfile() const;
  void _internal_set_eresult_sentryfile(int32_t value);
  public:

  // optional int32 otp_type = 85;
  bool has_otp_type() const;
  private:
  bool _internal_has_otp_type() const;
  public:
  void clear_otp_type();
  int32_t otp_type() const;
  void set_otp_type(int32_t value);
  private:
  int32_t _internal_otp_type() const;
  void _internal_set_otp_type(int32_t value);
  public:

  // optional uint32 otp_value = 86;
  bool has_otp_value() const;
  private:
  bool _internal_has_otp_value() const;
  public:
  void clear_otp_value();
  uint32_t otp_value() const;
  void set_otp_value(uint32_t value);
  private:
  uint32_t _internal_otp_value() const;
  void _internal_set_otp_value(uint32_t value);
  public:

  // optional int32 game_server_app_id = 94;
  bool has_game_server_app_id() const;
  private:
  bool _internal_has_game_server_app_id() const;
  public:
  void clear_game_server_app_id();
  int32_t game_server_app_id() const;
  void set_game_server_app_id(int32_t value);
  private:
  int32_t _internal_game_server_app_id() const;
  void _internal_set_game_server_app_id(int32_t value);
  public:

  // optional uint64 client_instance_id = 100;
  bool has_client_instance_id() const;
  private:
  bool _internal_has_client_instance_id() const;
  public:
  void clear_client_instance_id();
  uint64_t client_instance_id() const;
  void set_client_instance_id(uint64_t value);
  private:
  uint64_t _internal_client_instance_id() const;
  void _internal_set_client_instance_id(uint64_t value);
  public:

  // optional bool steamguard_dont_remember_computer = 95;
  bool has_steamguard_dont_remember_computer() const;
  private:
  bool _internal_has_steamguard_dont_remember_computer() const;
  public:
  void clear_steamguard_dont_remember_computer();
  bool steamguard_dont_remember_computer() const;
  void set_steamguard_dont_remember_computer(bool value);
  private:
  bool _internal_steamguard_dont_remember_computer() const;
  void _internal_set_steamguard_dont_remember_computer(bool value);
  public:

  // optional bool is_steam_box = 99;
  bool has_is_steam_box() const;
  private:
  bool _internal_has_is_steam_box() const;
  public:
  void clear_is_steam_box();
  bool is_steam_box() const;
  void set_is_steam_box(bool value);
  private:
  bool _internal_is_steam_box() const;
  void _internal_set_is_steam_box(bool value);
  public:

  // optional bool supports_rate_limit_response = 102;
  bool has_supports_rate_limit_response() const;
  private:
  bool _internal_has_supports_rate_limit_response() const;
  public:
  void clear_supports_rate_limit_response();
  bool supports_rate_limit_response() const;
  void set_supports_rate_limit_response(bool value);
  private:
  bool _internal_supports_rate_limit_response() const;
  void _internal_set_supports_rate_limit_response(bool value);
  public:

  // optional int32 priority_reason = 104;
  bool has_priority_reason() const;
  private:
  bool _internal_has_priority_reason() const;
  public:
  void clear_priority_reason();
  int32_t priority_reason() const;
  void set_priority_reason(int32_t value);
  private:
  int32_t _internal_priority_reason() const;
  void _internal_set_priority_reason(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientLogon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wine_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr steam2_auth_ticket_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_server_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr anon_user_target_account_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha_sentryfile_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr otp_identifier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sony_psn_ticket_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sony_psn_service_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sony_psn_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_name_userchosen_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_override_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr two_factor_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr web_logon_nonce_;
    ::CMsgIPAddress* obfuscated_private_ip_;
    ::CMsgIPAddress* public_ip_;
    ::CMsgClientSecret* embedded_client_secret_;
    uint32_t protocol_version_;
    uint32_t deprecated_obfustucated_private_ip_;
    uint32_t cell_id_;
    uint32_t last_session_id_;
    uint32_t client_package_version_;
    uint32_t client_os_type_;
    uint32_t deprecated_10_;
    uint32_t deprecated_public_ip_;
    uint64_t client_supplied_steam_id_;
    uint32_t qos_level_;
    uint32_t launcher_type_;
    uint32_t ui_mode_;
    uint32_t chat_mode_;
    uint32_t rtime32_account_creation_;
    bool should_remember_password_;
    bool was_converted_deprecated_msg_;
    bool steam2_ticket_request_;
    bool create_new_psn_linked_account_if_needed_;
    uint64_t resolved_user_steam_id_;
    int32_t eresult_sentryfile_;
    int32_t otp_type_;
    uint32_t otp_value_;
    int32_t game_server_app_id_;
    uint64_t client_instance_id_;
    bool steamguard_dont_remember_computer_;
    bool is_steam_box_;
    bool supports_rate_limit_response_;
    int32_t priority_reason_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientLogonResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientLogonResponse) */ {
 public:
  inline CMsgClientLogonResponse() : CMsgClientLogonResponse(nullptr) {}
  ~CMsgClientLogonResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientLogonResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientLogonResponse(const CMsgClientLogonResponse& from);
  CMsgClientLogonResponse(CMsgClientLogonResponse&& from) noexcept
    : CMsgClientLogonResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientLogonResponse& operator=(const CMsgClientLogonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientLogonResponse& operator=(CMsgClientLogonResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientLogonResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientLogonResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientLogonResponse*>(
               &_CMsgClientLogonResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CMsgClientLogonResponse& a, CMsgClientLogonResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientLogonResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientLogonResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientLogonResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientLogonResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientLogonResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientLogonResponse& from) {
    CMsgClientLogonResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientLogonResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientLogonResponse";
  }
  protected:
  explicit CMsgClientLogonResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailDomainFieldNumber = 8,
    kSteam2TicketFieldNumber = 9,
    kWebapiAuthenticateUserNonceFieldNumber = 11,
    kVanityUrlFieldNumber = 14,
    kIpCountryCodeFieldNumber = 21,
    kParentalSettingsFieldNumber = 22,
    kParentalSettingSignatureFieldNumber = 23,
    kPublicIpFieldNumber = 15,
    kOutOfGameHeartbeatSecondsFieldNumber = 2,
    kInGameHeartbeatSecondsFieldNumber = 3,
    kDeprecatedPublicIpFieldNumber = 4,
    kRtime32ServerTimeFieldNumber = 5,
    kAccountFlagsFieldNumber = 6,
    kCellIdFieldNumber = 7,
    kEresultExtendedFieldNumber = 10,
    kCellIdPingThresholdFieldNumber = 12,
    kClientSuppliedSteamidFieldNumber = 20,
    kUsePicsFieldNumber = 13,
    kForceClientUpdateCheckFieldNumber = 28,
    kCountLoginfailuresToMigrateFieldNumber = 24,
    kCountDisconnectsToMigrateFieldNumber = 25,
    kOgsDataReportTimeWindowFieldNumber = 26,
    kClientInstanceIdFieldNumber = 27,
    kEresultFieldNumber = 1,
  };
  // optional string email_domain = 8;
  bool has_email_domain() const;
  private:
  bool _internal_has_email_domain() const;
  public:
  void clear_email_domain();
  const std::string& email_domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email_domain();
  PROTOBUF_NODISCARD std::string* release_email_domain();
  void set_allocated_email_domain(std::string* email_domain);
  private:
  const std::string& _internal_email_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email_domain(const std::string& value);
  std::string* _internal_mutable_email_domain();
  public:

  // optional bytes steam2_ticket = 9;
  bool has_steam2_ticket() const;
  private:
  bool _internal_has_steam2_ticket() const;
  public:
  void clear_steam2_ticket();
  const std::string& steam2_ticket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_steam2_ticket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_steam2_ticket();
  PROTOBUF_NODISCARD std::string* release_steam2_ticket();
  void set_allocated_steam2_ticket(std::string* steam2_ticket);
  private:
  const std::string& _internal_steam2_ticket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_steam2_ticket(const std::string& value);
  std::string* _internal_mutable_steam2_ticket();
  public:

  // optional string webapi_authenticate_user_nonce = 11;
  bool has_webapi_authenticate_user_nonce() const;
  private:
  bool _internal_has_webapi_authenticate_user_nonce() const;
  public:
  void clear_webapi_authenticate_user_nonce();
  const std::string& webapi_authenticate_user_nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_webapi_authenticate_user_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_webapi_authenticate_user_nonce();
  PROTOBUF_NODISCARD std::string* release_webapi_authenticate_user_nonce();
  void set_allocated_webapi_authenticate_user_nonce(std::string* webapi_authenticate_user_nonce);
  private:
  const std::string& _internal_webapi_authenticate_user_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_webapi_authenticate_user_nonce(const std::string& value);
  std::string* _internal_mutable_webapi_authenticate_user_nonce();
  public:

  // optional string vanity_url = 14;
  bool has_vanity_url() const;
  private:
  bool _internal_has_vanity_url() const;
  public:
  void clear_vanity_url();
  const std::string& vanity_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vanity_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vanity_url();
  PROTOBUF_NODISCARD std::string* release_vanity_url();
  void set_allocated_vanity_url(std::string* vanity_url);
  private:
  const std::string& _internal_vanity_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vanity_url(const std::string& value);
  std::string* _internal_mutable_vanity_url();
  public:

  // optional string ip_country_code = 21;
  bool has_ip_country_code() const;
  private:
  bool _internal_has_ip_country_code() const;
  public:
  void clear_ip_country_code();
  const std::string& ip_country_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_country_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_country_code();
  PROTOBUF_NODISCARD std::string* release_ip_country_code();
  void set_allocated_ip_country_code(std::string* ip_country_code);
  private:
  const std::string& _internal_ip_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_country_code(const std::string& value);
  std::string* _internal_mutable_ip_country_code();
  public:

  // optional bytes parental_settings = 22;
  bool has_parental_settings() const;
  private:
  bool _internal_has_parental_settings() const;
  public:
  void clear_parental_settings();
  const std::string& parental_settings() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parental_settings(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parental_settings();
  PROTOBUF_NODISCARD std::string* release_parental_settings();
  void set_allocated_parental_settings(std::string* parental_settings);
  private:
  const std::string& _internal_parental_settings() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parental_settings(const std::string& value);
  std::string* _internal_mutable_parental_settings();
  public:

  // optional bytes parental_setting_signature = 23;
  bool has_parental_setting_signature() const;
  private:
  bool _internal_has_parental_setting_signature() const;
  public:
  void clear_parental_setting_signature();
  const std::string& parental_setting_signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parental_setting_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parental_setting_signature();
  PROTOBUF_NODISCARD std::string* release_parental_setting_signature();
  void set_allocated_parental_setting_signature(std::string* parental_setting_signature);
  private:
  const std::string& _internal_parental_setting_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parental_setting_signature(const std::string& value);
  std::string* _internal_mutable_parental_setting_signature();
  public:

  // optional .CMsgIPAddress public_ip = 15;
  bool has_public_ip() const;
  private:
  bool _internal_has_public_ip() const;
  public:
  void clear_public_ip();
  const ::CMsgIPAddress& public_ip() const;
  PROTOBUF_NODISCARD ::CMsgIPAddress* release_public_ip();
  ::CMsgIPAddress* mutable_public_ip();
  void set_allocated_public_ip(::CMsgIPAddress* public_ip);
  private:
  const ::CMsgIPAddress& _internal_public_ip() const;
  ::CMsgIPAddress* _internal_mutable_public_ip();
  public:
  void unsafe_arena_set_allocated_public_ip(
      ::CMsgIPAddress* public_ip);
  ::CMsgIPAddress* unsafe_arena_release_public_ip();

  // optional int32 out_of_game_heartbeat_seconds = 2;
  bool has_out_of_game_heartbeat_seconds() const;
  private:
  bool _internal_has_out_of_game_heartbeat_seconds() const;
  public:
  void clear_out_of_game_heartbeat_seconds();
  int32_t out_of_game_heartbeat_seconds() const;
  void set_out_of_game_heartbeat_seconds(int32_t value);
  private:
  int32_t _internal_out_of_game_heartbeat_seconds() const;
  void _internal_set_out_of_game_heartbeat_seconds(int32_t value);
  public:

  // optional int32 in_game_heartbeat_seconds = 3;
  bool has_in_game_heartbeat_seconds() const;
  private:
  bool _internal_has_in_game_heartbeat_seconds() const;
  public:
  void clear_in_game_heartbeat_seconds();
  int32_t in_game_heartbeat_seconds() const;
  void set_in_game_heartbeat_seconds(int32_t value);
  private:
  int32_t _internal_in_game_heartbeat_seconds() const;
  void _internal_set_in_game_heartbeat_seconds(int32_t value);
  public:

  // optional uint32 deprecated_public_ip = 4;
  bool has_deprecated_public_ip() const;
  private:
  bool _internal_has_deprecated_public_ip() const;
  public:
  void clear_deprecated_public_ip();
  uint32_t deprecated_public_ip() const;
  void set_deprecated_public_ip(uint32_t value);
  private:
  uint32_t _internal_deprecated_public_ip() const;
  void _internal_set_deprecated_public_ip(uint32_t value);
  public:

  // optional fixed32 rtime32_server_time = 5;
  bool has_rtime32_server_time() const;
  private:
  bool _internal_has_rtime32_server_time() const;
  public:
  void clear_rtime32_server_time();
  uint32_t rtime32_server_time() const;
  void set_rtime32_server_time(uint32_t value);
  private:
  uint32_t _internal_rtime32_server_time() const;
  void _internal_set_rtime32_server_time(uint32_t value);
  public:

  // optional uint32 account_flags = 6;
  bool has_account_flags() const;
  private:
  bool _internal_has_account_flags() const;
  public:
  void clear_account_flags();
  uint32_t account_flags() const;
  void set_account_flags(uint32_t value);
  private:
  uint32_t _internal_account_flags() const;
  void _internal_set_account_flags(uint32_t value);
  public:

  // optional uint32 cell_id = 7;
  bool has_cell_id() const;
  private:
  bool _internal_has_cell_id() const;
  public:
  void clear_cell_id();
  uint32_t cell_id() const;
  void set_cell_id(uint32_t value);
  private:
  uint32_t _internal_cell_id() const;
  void _internal_set_cell_id(uint32_t value);
  public:

  // optional int32 eresult_extended = 10;
  bool has_eresult_extended() const;
  private:
  bool _internal_has_eresult_extended() const;
  public:
  void clear_eresult_extended();
  int32_t eresult_extended() const;
  void set_eresult_extended(int32_t value);
  private:
  int32_t _internal_eresult_extended() const;
  void _internal_set_eresult_extended(int32_t value);
  public:

  // optional uint32 cell_id_ping_threshold = 12;
  bool has_cell_id_ping_threshold() const;
  private:
  bool _internal_has_cell_id_ping_threshold() const;
  public:
  void clear_cell_id_ping_threshold();
  uint32_t cell_id_ping_threshold() const;
  void set_cell_id_ping_threshold(uint32_t value);
  private:
  uint32_t _internal_cell_id_ping_threshold() const;
  void _internal_set_cell_id_ping_threshold(uint32_t value);
  public:

  // optional fixed64 client_supplied_steamid = 20;
  bool has_client_supplied_steamid() const;
  private:
  bool _internal_has_client_supplied_steamid() const;
  public:
  void clear_client_supplied_steamid();
  uint64_t client_supplied_steamid() const;
  void set_client_supplied_steamid(uint64_t value);
  private:
  uint64_t _internal_client_supplied_steamid() const;
  void _internal_set_client_supplied_steamid(uint64_t value);
  public:

  // optional bool use_pics = 13;
  bool has_use_pics() const;
  private:
  bool _internal_has_use_pics() const;
  public:
  void clear_use_pics();
  bool use_pics() const;
  void set_use_pics(bool value);
  private:
  bool _internal_use_pics() const;
  void _internal_set_use_pics(bool value);
  public:

  // optional bool force_client_update_check = 28;
  bool has_force_client_update_check() const;
  private:
  bool _internal_has_force_client_update_check() const;
  public:
  void clear_force_client_update_check();
  bool force_client_update_check() const;
  void set_force_client_update_check(bool value);
  private:
  bool _internal_force_client_update_check() const;
  void _internal_set_force_client_update_check(bool value);
  public:

  // optional int32 count_loginfailures_to_migrate = 24;
  bool has_count_loginfailures_to_migrate() const;
  private:
  bool _internal_has_count_loginfailures_to_migrate() const;
  public:
  void clear_count_loginfailures_to_migrate();
  int32_t count_loginfailures_to_migrate() const;
  void set_count_loginfailures_to_migrate(int32_t value);
  private:
  int32_t _internal_count_loginfailures_to_migrate() const;
  void _internal_set_count_loginfailures_to_migrate(int32_t value);
  public:

  // optional int32 count_disconnects_to_migrate = 25;
  bool has_count_disconnects_to_migrate() const;
  private:
  bool _internal_has_count_disconnects_to_migrate() const;
  public:
  void clear_count_disconnects_to_migrate();
  int32_t count_disconnects_to_migrate() const;
  void set_count_disconnects_to_migrate(int32_t value);
  private:
  int32_t _internal_count_disconnects_to_migrate() const;
  void _internal_set_count_disconnects_to_migrate(int32_t value);
  public:

  // optional int32 ogs_data_report_time_window = 26;
  bool has_ogs_data_report_time_window() const;
  private:
  bool _internal_has_ogs_data_report_time_window() const;
  public:
  void clear_ogs_data_report_time_window();
  int32_t ogs_data_report_time_window() const;
  void set_ogs_data_report_time_window(int32_t value);
  private:
  int32_t _internal_ogs_data_report_time_window() const;
  void _internal_set_ogs_data_report_time_window(int32_t value);
  public:

  // optional uint64 client_instance_id = 27;
  bool has_client_instance_id() const;
  private:
  bool _internal_has_client_instance_id() const;
  public:
  void clear_client_instance_id();
  uint64_t client_instance_id() const;
  void set_client_instance_id(uint64_t value);
  private:
  uint64_t _internal_client_instance_id() const;
  void _internal_set_client_instance_id(uint64_t value);
  public:

  // optional int32 eresult = 1 [default = 2];
  bool has_eresult() const;
  private:
  bool _internal_has_eresult() const;
  public:
  void clear_eresult();
  int32_t eresult() const;
  void set_eresult(int32_t value);
  private:
  int32_t _internal_eresult() const;
  void _internal_set_eresult(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientLogonResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_domain_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr steam2_ticket_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr webapi_authenticate_user_nonce_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vanity_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_country_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parental_settings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parental_setting_signature_;
    ::CMsgIPAddress* public_ip_;
    int32_t out_of_game_heartbeat_seconds_;
    int32_t in_game_heartbeat_seconds_;
    uint32_t deprecated_public_ip_;
    uint32_t rtime32_server_time_;
    uint32_t account_flags_;
    uint32_t cell_id_;
    int32_t eresult_extended_;
    uint32_t cell_id_ping_threshold_;
    uint64_t client_supplied_steamid_;
    bool use_pics_;
    bool force_client_update_check_;
    int32_t count_loginfailures_to_migrate_;
    int32_t count_disconnects_to_migrate_;
    int32_t ogs_data_report_time_window_;
    uint64_t client_instance_id_;
    int32_t eresult_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientRequestWebAPIAuthenticateUserNonce final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientRequestWebAPIAuthenticateUserNonce) */ {
 public:
  inline CMsgClientRequestWebAPIAuthenticateUserNonce() : CMsgClientRequestWebAPIAuthenticateUserNonce(nullptr) {}
  ~CMsgClientRequestWebAPIAuthenticateUserNonce() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientRequestWebAPIAuthenticateUserNonce(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientRequestWebAPIAuthenticateUserNonce(const CMsgClientRequestWebAPIAuthenticateUserNonce& from);
  CMsgClientRequestWebAPIAuthenticateUserNonce(CMsgClientRequestWebAPIAuthenticateUserNonce&& from) noexcept
    : CMsgClientRequestWebAPIAuthenticateUserNonce() {
    *this = ::std::move(from);
  }

  inline CMsgClientRequestWebAPIAuthenticateUserNonce& operator=(const CMsgClientRequestWebAPIAuthenticateUserNonce& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientRequestWebAPIAuthenticateUserNonce& operator=(CMsgClientRequestWebAPIAuthenticateUserNonce&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientRequestWebAPIAuthenticateUserNonce& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientRequestWebAPIAuthenticateUserNonce* internal_default_instance() {
    return reinterpret_cast<const CMsgClientRequestWebAPIAuthenticateUserNonce*>(
               &_CMsgClientRequestWebAPIAuthenticateUserNonce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CMsgClientRequestWebAPIAuthenticateUserNonce& a, CMsgClientRequestWebAPIAuthenticateUserNonce& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientRequestWebAPIAuthenticateUserNonce* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientRequestWebAPIAuthenticateUserNonce* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientRequestWebAPIAuthenticateUserNonce* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientRequestWebAPIAuthenticateUserNonce>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientRequestWebAPIAuthenticateUserNonce& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientRequestWebAPIAuthenticateUserNonce& from) {
    CMsgClientRequestWebAPIAuthenticateUserNonce::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientRequestWebAPIAuthenticateUserNonce* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientRequestWebAPIAuthenticateUserNonce";
  }
  protected:
  explicit CMsgClientRequestWebAPIAuthenticateUserNonce(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenTypeFieldNumber = 1,
  };
  // optional int32 token_type = 1 [default = -1];
  bool has_token_type() const;
  private:
  bool _internal_has_token_type() const;
  public:
  void clear_token_type();
  int32_t token_type() const;
  void set_token_type(int32_t value);
  private:
  int32_t _internal_token_type() const;
  void _internal_set_token_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientRequestWebAPIAuthenticateUserNonce)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t token_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientRequestWebAPIAuthenticateUserNonceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientRequestWebAPIAuthenticateUserNonceResponse) */ {
 public:
  inline CMsgClientRequestWebAPIAuthenticateUserNonceResponse() : CMsgClientRequestWebAPIAuthenticateUserNonceResponse(nullptr) {}
  ~CMsgClientRequestWebAPIAuthenticateUserNonceResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientRequestWebAPIAuthenticateUserNonceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientRequestWebAPIAuthenticateUserNonceResponse(const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& from);
  CMsgClientRequestWebAPIAuthenticateUserNonceResponse(CMsgClientRequestWebAPIAuthenticateUserNonceResponse&& from) noexcept
    : CMsgClientRequestWebAPIAuthenticateUserNonceResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientRequestWebAPIAuthenticateUserNonceResponse& operator=(const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientRequestWebAPIAuthenticateUserNonceResponse& operator=(CMsgClientRequestWebAPIAuthenticateUserNonceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientRequestWebAPIAuthenticateUserNonceResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientRequestWebAPIAuthenticateUserNonceResponse*>(
               &_CMsgClientRequestWebAPIAuthenticateUserNonceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CMsgClientRequestWebAPIAuthenticateUserNonceResponse& a, CMsgClientRequestWebAPIAuthenticateUserNonceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientRequestWebAPIAuthenticateUserNonceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientRequestWebAPIAuthenticateUserNonceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientRequestWebAPIAuthenticateUserNonceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientRequestWebAPIAuthenticateUserNonceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& from) {
    CMsgClientRequestWebAPIAuthenticateUserNonceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientRequestWebAPIAuthenticateUserNonceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientRequestWebAPIAuthenticateUserNonceResponse";
  }
  protected:
  explicit CMsgClientRequestWebAPIAuthenticateUserNonceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWebapiAuthenticateUserNonceFieldNumber = 11,
    kEresultFieldNumber = 1,
    kTokenTypeFieldNumber = 3,
  };
  // optional string webapi_authenticate_user_nonce = 11;
  bool has_webapi_authenticate_user_nonce() const;
  private:
  bool _internal_has_webapi_authenticate_user_nonce() const;
  public:
  void clear_webapi_authenticate_user_nonce();
  const std::string& webapi_authenticate_user_nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_webapi_authenticate_user_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_webapi_authenticate_user_nonce();
  PROTOBUF_NODISCARD std::string* release_webapi_authenticate_user_nonce();
  void set_allocated_webapi_authenticate_user_nonce(std::string* webapi_authenticate_user_nonce);
  private:
  const std::string& _internal_webapi_authenticate_user_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_webapi_authenticate_user_nonce(const std::string& value);
  std::string* _internal_mutable_webapi_authenticate_user_nonce();
  public:

  // optional int32 eresult = 1 [default = 2];
  bool has_eresult() const;
  private:
  bool _internal_has_eresult() const;
  public:
  void clear_eresult();
  int32_t eresult() const;
  void set_eresult(int32_t value);
  private:
  int32_t _internal_eresult() const;
  void _internal_set_eresult(int32_t value);
  public:

  // optional int32 token_type = 3 [default = -1];
  bool has_token_type() const;
  private:
  bool _internal_has_token_type() const;
  public:
  void clear_token_type();
  int32_t token_type() const;
  void set_token_type(int32_t value);
  private:
  int32_t _internal_token_type() const;
  void _internal_set_token_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientRequestWebAPIAuthenticateUserNonceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr webapi_authenticate_user_nonce_;
    int32_t eresult_;
    int32_t token_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientLogOff final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CMsgClientLogOff) */ {
 public:
  inline CMsgClientLogOff() : CMsgClientLogOff(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CMsgClientLogOff(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientLogOff(const CMsgClientLogOff& from);
  CMsgClientLogOff(CMsgClientLogOff&& from) noexcept
    : CMsgClientLogOff() {
    *this = ::std::move(from);
  }

  inline CMsgClientLogOff& operator=(const CMsgClientLogOff& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientLogOff& operator=(CMsgClientLogOff&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientLogOff& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientLogOff* internal_default_instance() {
    return reinterpret_cast<const CMsgClientLogOff*>(
               &_CMsgClientLogOff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CMsgClientLogOff& a, CMsgClientLogOff& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientLogOff* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientLogOff* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientLogOff* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientLogOff>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CMsgClientLogOff& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CMsgClientLogOff& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientLogOff";
  }
  protected:
  explicit CMsgClientLogOff(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CMsgClientLogOff)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientLoggedOff final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientLoggedOff) */ {
 public:
  inline CMsgClientLoggedOff() : CMsgClientLoggedOff(nullptr) {}
  ~CMsgClientLoggedOff() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientLoggedOff(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientLoggedOff(const CMsgClientLoggedOff& from);
  CMsgClientLoggedOff(CMsgClientLoggedOff&& from) noexcept
    : CMsgClientLoggedOff() {
    *this = ::std::move(from);
  }

  inline CMsgClientLoggedOff& operator=(const CMsgClientLoggedOff& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientLoggedOff& operator=(CMsgClientLoggedOff&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientLoggedOff& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientLoggedOff* internal_default_instance() {
    return reinterpret_cast<const CMsgClientLoggedOff*>(
               &_CMsgClientLoggedOff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CMsgClientLoggedOff& a, CMsgClientLoggedOff& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientLoggedOff* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientLoggedOff* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientLoggedOff* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientLoggedOff>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientLoggedOff& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientLoggedOff& from) {
    CMsgClientLoggedOff::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientLoggedOff* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientLoggedOff";
  }
  protected:
  explicit CMsgClientLoggedOff(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEresultFieldNumber = 1,
  };
  // optional int32 eresult = 1 [default = 2];
  bool has_eresult() const;
  private:
  bool _internal_has_eresult() const;
  public:
  void clear_eresult();
  int32_t eresult() const;
  void set_eresult(int32_t value);
  private:
  int32_t _internal_eresult() const;
  void _internal_set_eresult(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientLoggedOff)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t eresult_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientNewLoginKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientNewLoginKey) */ {
 public:
  inline CMsgClientNewLoginKey() : CMsgClientNewLoginKey(nullptr) {}
  ~CMsgClientNewLoginKey() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientNewLoginKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientNewLoginKey(const CMsgClientNewLoginKey& from);
  CMsgClientNewLoginKey(CMsgClientNewLoginKey&& from) noexcept
    : CMsgClientNewLoginKey() {
    *this = ::std::move(from);
  }

  inline CMsgClientNewLoginKey& operator=(const CMsgClientNewLoginKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientNewLoginKey& operator=(CMsgClientNewLoginKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientNewLoginKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientNewLoginKey* internal_default_instance() {
    return reinterpret_cast<const CMsgClientNewLoginKey*>(
               &_CMsgClientNewLoginKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CMsgClientNewLoginKey& a, CMsgClientNewLoginKey& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientNewLoginKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientNewLoginKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientNewLoginKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientNewLoginKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientNewLoginKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientNewLoginKey& from) {
    CMsgClientNewLoginKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientNewLoginKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientNewLoginKey";
  }
  protected:
  explicit CMsgClientNewLoginKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginKeyFieldNumber = 2,
    kUniqueIdFieldNumber = 1,
  };
  // optional string login_key = 2;
  bool has_login_key() const;
  private:
  bool _internal_has_login_key() const;
  public:
  void clear_login_key();
  const std::string& login_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_key();
  PROTOBUF_NODISCARD std::string* release_login_key();
  void set_allocated_login_key(std::string* login_key);
  private:
  const std::string& _internal_login_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_key(const std::string& value);
  std::string* _internal_mutable_login_key();
  public:

  // optional uint32 unique_id = 1;
  bool has_unique_id() const;
  private:
  bool _internal_has_unique_id() const;
  public:
  void clear_unique_id();
  uint32_t unique_id() const;
  void set_unique_id(uint32_t value);
  private:
  uint32_t _internal_unique_id() const;
  void _internal_set_unique_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientNewLoginKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_key_;
    uint32_t unique_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientNewLoginKeyAccepted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientNewLoginKeyAccepted) */ {
 public:
  inline CMsgClientNewLoginKeyAccepted() : CMsgClientNewLoginKeyAccepted(nullptr) {}
  ~CMsgClientNewLoginKeyAccepted() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientNewLoginKeyAccepted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientNewLoginKeyAccepted(const CMsgClientNewLoginKeyAccepted& from);
  CMsgClientNewLoginKeyAccepted(CMsgClientNewLoginKeyAccepted&& from) noexcept
    : CMsgClientNewLoginKeyAccepted() {
    *this = ::std::move(from);
  }

  inline CMsgClientNewLoginKeyAccepted& operator=(const CMsgClientNewLoginKeyAccepted& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientNewLoginKeyAccepted& operator=(CMsgClientNewLoginKeyAccepted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientNewLoginKeyAccepted& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientNewLoginKeyAccepted* internal_default_instance() {
    return reinterpret_cast<const CMsgClientNewLoginKeyAccepted*>(
               &_CMsgClientNewLoginKeyAccepted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CMsgClientNewLoginKeyAccepted& a, CMsgClientNewLoginKeyAccepted& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientNewLoginKeyAccepted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientNewLoginKeyAccepted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientNewLoginKeyAccepted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientNewLoginKeyAccepted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientNewLoginKeyAccepted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientNewLoginKeyAccepted& from) {
    CMsgClientNewLoginKeyAccepted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientNewLoginKeyAccepted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientNewLoginKeyAccepted";
  }
  protected:
  explicit CMsgClientNewLoginKeyAccepted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueIdFieldNumber = 1,
  };
  // optional uint32 unique_id = 1;
  bool has_unique_id() const;
  private:
  bool _internal_has_unique_id() const;
  public:
  void clear_unique_id();
  uint32_t unique_id() const;
  void set_unique_id(uint32_t value);
  private:
  uint32_t _internal_unique_id() const;
  void _internal_set_unique_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientNewLoginKeyAccepted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t unique_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientAccountInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientAccountInfo) */ {
 public:
  inline CMsgClientAccountInfo() : CMsgClientAccountInfo(nullptr) {}
  ~CMsgClientAccountInfo() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientAccountInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientAccountInfo(const CMsgClientAccountInfo& from);
  CMsgClientAccountInfo(CMsgClientAccountInfo&& from) noexcept
    : CMsgClientAccountInfo() {
    *this = ::std::move(from);
  }

  inline CMsgClientAccountInfo& operator=(const CMsgClientAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientAccountInfo& operator=(CMsgClientAccountInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientAccountInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientAccountInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgClientAccountInfo*>(
               &_CMsgClientAccountInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CMsgClientAccountInfo& a, CMsgClientAccountInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientAccountInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientAccountInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientAccountInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientAccountInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientAccountInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientAccountInfo& from) {
    CMsgClientAccountInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientAccountInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientAccountInfo";
  }
  protected:
  explicit CMsgClientAccountInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPersonaNameFieldNumber = 1,
    kIpCountryFieldNumber = 2,
    kFacebookNameFieldNumber = 9,
    kSteamguardMachineNameUserChosenFieldNumber = 15,
    kCountAuthedComputersFieldNumber = 5,
    kAccountFlagsFieldNumber = 7,
    kFacebookIdFieldNumber = 8,
    kSteamguardNotifyNewmachinesFieldNumber = 14,
    kIsPhoneVerifiedFieldNumber = 16,
    kIsPhoneIdentifyingFieldNumber = 18,
    kIsPhoneNeedingReverifyFieldNumber = 19,
    kTwoFactorStateFieldNumber = 17,
  };
  // optional string persona_name = 1;
  bool has_persona_name() const;
  private:
  bool _internal_has_persona_name() const;
  public:
  void clear_persona_name();
  const std::string& persona_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_persona_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_persona_name();
  PROTOBUF_NODISCARD std::string* release_persona_name();
  void set_allocated_persona_name(std::string* persona_name);
  private:
  const std::string& _internal_persona_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_persona_name(const std::string& value);
  std::string* _internal_mutable_persona_name();
  public:

  // optional string ip_country = 2;
  bool has_ip_country() const;
  private:
  bool _internal_has_ip_country() const;
  public:
  void clear_ip_country();
  const std::string& ip_country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_country();
  PROTOBUF_NODISCARD std::string* release_ip_country();
  void set_allocated_ip_country(std::string* ip_country);
  private:
  const std::string& _internal_ip_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_country(const std::string& value);
  std::string* _internal_mutable_ip_country();
  public:

  // optional string facebook_name = 9;
  bool has_facebook_name() const;
  private:
  bool _internal_has_facebook_name() const;
  public:
  void clear_facebook_name();
  const std::string& facebook_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_facebook_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_facebook_name();
  PROTOBUF_NODISCARD std::string* release_facebook_name();
  void set_allocated_facebook_name(std::string* facebook_name);
  private:
  const std::string& _internal_facebook_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_facebook_name(const std::string& value);
  std::string* _internal_mutable_facebook_name();
  public:

  // optional string steamguard_machine_name_user_chosen = 15;
  bool has_steamguard_machine_name_user_chosen() const;
  private:
  bool _internal_has_steamguard_machine_name_user_chosen() const;
  public:
  void clear_steamguard_machine_name_user_chosen();
  const std::string& steamguard_machine_name_user_chosen() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_steamguard_machine_name_user_chosen(ArgT0&& arg0, ArgT... args);
  std::string* mutable_steamguard_machine_name_user_chosen();
  PROTOBUF_NODISCARD std::string* release_steamguard_machine_name_user_chosen();
  void set_allocated_steamguard_machine_name_user_chosen(std::string* steamguard_machine_name_user_chosen);
  private:
  const std::string& _internal_steamguard_machine_name_user_chosen() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_steamguard_machine_name_user_chosen(const std::string& value);
  std::string* _internal_mutable_steamguard_machine_name_user_chosen();
  public:

  // optional int32 count_authed_computers = 5;
  bool has_count_authed_computers() const;
  private:
  bool _internal_has_count_authed_computers() const;
  public:
  void clear_count_authed_computers();
  int32_t count_authed_computers() const;
  void set_count_authed_computers(int32_t value);
  private:
  int32_t _internal_count_authed_computers() const;
  void _internal_set_count_authed_computers(int32_t value);
  public:

  // optional uint32 account_flags = 7;
  bool has_account_flags() const;
  private:
  bool _internal_has_account_flags() const;
  public:
  void clear_account_flags();
  uint32_t account_flags() const;
  void set_account_flags(uint32_t value);
  private:
  uint32_t _internal_account_flags() const;
  void _internal_set_account_flags(uint32_t value);
  public:

  // optional uint64 facebook_id = 8;
  bool has_facebook_id() const;
  private:
  bool _internal_has_facebook_id() const;
  public:
  void clear_facebook_id();
  uint64_t facebook_id() const;
  void set_facebook_id(uint64_t value);
  private:
  uint64_t _internal_facebook_id() const;
  void _internal_set_facebook_id(uint64_t value);
  public:

  // optional bool steamguard_notify_newmachines = 14;
  bool has_steamguard_notify_newmachines() const;
  private:
  bool _internal_has_steamguard_notify_newmachines() const;
  public:
  void clear_steamguard_notify_newmachines();
  bool steamguard_notify_newmachines() const;
  void set_steamguard_notify_newmachines(bool value);
  private:
  bool _internal_steamguard_notify_newmachines() const;
  void _internal_set_steamguard_notify_newmachines(bool value);
  public:

  // optional bool is_phone_verified = 16;
  bool has_is_phone_verified() const;
  private:
  bool _internal_has_is_phone_verified() const;
  public:
  void clear_is_phone_verified();
  bool is_phone_verified() const;
  void set_is_phone_verified(bool value);
  private:
  bool _internal_is_phone_verified() const;
  void _internal_set_is_phone_verified(bool value);
  public:

  // optional bool is_phone_identifying = 18;
  bool has_is_phone_identifying() const;
  private:
  bool _internal_has_is_phone_identifying() const;
  public:
  void clear_is_phone_identifying();
  bool is_phone_identifying() const;
  void set_is_phone_identifying(bool value);
  private:
  bool _internal_is_phone_identifying() const;
  void _internal_set_is_phone_identifying(bool value);
  public:

  // optional bool is_phone_needing_reverify = 19;
  bool has_is_phone_needing_reverify() const;
  private:
  bool _internal_has_is_phone_needing_reverify() const;
  public:
  void clear_is_phone_needing_reverify();
  bool is_phone_needing_reverify() const;
  void set_is_phone_needing_reverify(bool value);
  private:
  bool _internal_is_phone_needing_reverify() const;
  void _internal_set_is_phone_needing_reverify(bool value);
  public:

  // optional uint32 two_factor_state = 17;
  bool has_two_factor_state() const;
  private:
  bool _internal_has_two_factor_state() const;
  public:
  void clear_two_factor_state();
  uint32_t two_factor_state() const;
  void set_two_factor_state(uint32_t value);
  private:
  uint32_t _internal_two_factor_state() const;
  void _internal_set_two_factor_state(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientAccountInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr persona_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_country_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr facebook_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr steamguard_machine_name_user_chosen_;
    int32_t count_authed_computers_;
    uint32_t account_flags_;
    uint64_t facebook_id_;
    bool steamguard_notify_newmachines_;
    bool is_phone_verified_;
    bool is_phone_identifying_;
    bool is_phone_needing_reverify_;
    uint32_t two_factor_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientChallengeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientChallengeRequest) */ {
 public:
  inline CMsgClientChallengeRequest() : CMsgClientChallengeRequest(nullptr) {}
  ~CMsgClientChallengeRequest() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientChallengeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientChallengeRequest(const CMsgClientChallengeRequest& from);
  CMsgClientChallengeRequest(CMsgClientChallengeRequest&& from) noexcept
    : CMsgClientChallengeRequest() {
    *this = ::std::move(from);
  }

  inline CMsgClientChallengeRequest& operator=(const CMsgClientChallengeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientChallengeRequest& operator=(CMsgClientChallengeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientChallengeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientChallengeRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgClientChallengeRequest*>(
               &_CMsgClientChallengeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CMsgClientChallengeRequest& a, CMsgClientChallengeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientChallengeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientChallengeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientChallengeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientChallengeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientChallengeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientChallengeRequest& from) {
    CMsgClientChallengeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientChallengeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientChallengeRequest";
  }
  protected:
  explicit CMsgClientChallengeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamidFieldNumber = 1,
  };
  // optional fixed64 steamid = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientChallengeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t steamid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientChallengeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientChallengeResponse) */ {
 public:
  inline CMsgClientChallengeResponse() : CMsgClientChallengeResponse(nullptr) {}
  ~CMsgClientChallengeResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientChallengeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientChallengeResponse(const CMsgClientChallengeResponse& from);
  CMsgClientChallengeResponse(CMsgClientChallengeResponse&& from) noexcept
    : CMsgClientChallengeResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientChallengeResponse& operator=(const CMsgClientChallengeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientChallengeResponse& operator=(CMsgClientChallengeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientChallengeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientChallengeResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientChallengeResponse*>(
               &_CMsgClientChallengeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CMsgClientChallengeResponse& a, CMsgClientChallengeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientChallengeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientChallengeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientChallengeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientChallengeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientChallengeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientChallengeResponse& from) {
    CMsgClientChallengeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientChallengeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientChallengeResponse";
  }
  protected:
  explicit CMsgClientChallengeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChallengeFieldNumber = 1,
  };
  // optional fixed64 challenge = 1;
  bool has_challenge() const;
  private:
  bool _internal_has_challenge() const;
  public:
  void clear_challenge();
  uint64_t challenge() const;
  void set_challenge(uint64_t value);
  private:
  uint64_t _internal_challenge() const;
  void _internal_set_challenge(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientChallengeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t challenge_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fclientserver_5flogin_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgClientHeartBeat

// -------------------------------------------------------------------

// CMsgClientServerTimestampRequest

// optional uint64 client_request_timestamp = 1;
inline bool CMsgClientServerTimestampRequest::_internal_has_client_request_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientServerTimestampRequest::has_client_request_timestamp() const {
  return _internal_has_client_request_timestamp();
}
inline void CMsgClientServerTimestampRequest::clear_client_request_timestamp() {
  _impl_.client_request_timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgClientServerTimestampRequest::_internal_client_request_timestamp() const {
  return _impl_.client_request_timestamp_;
}
inline uint64_t CMsgClientServerTimestampRequest::client_request_timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgClientServerTimestampRequest.client_request_timestamp)
  return _internal_client_request_timestamp();
}
inline void CMsgClientServerTimestampRequest::_internal_set_client_request_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_request_timestamp_ = value;
}
inline void CMsgClientServerTimestampRequest::set_client_request_timestamp(uint64_t value) {
  _internal_set_client_request_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgClientServerTimestampRequest.client_request_timestamp)
}

// -------------------------------------------------------------------

// CMsgClientServerTimestampResponse

// optional uint64 client_request_timestamp = 1;
inline bool CMsgClientServerTimestampResponse::_internal_has_client_request_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientServerTimestampResponse::has_client_request_timestamp() const {
  return _internal_has_client_request_timestamp();
}
inline void CMsgClientServerTimestampResponse::clear_client_request_timestamp() {
  _impl_.client_request_timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgClientServerTimestampResponse::_internal_client_request_timestamp() const {
  return _impl_.client_request_timestamp_;
}
inline uint64_t CMsgClientServerTimestampResponse::client_request_timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgClientServerTimestampResponse.client_request_timestamp)
  return _internal_client_request_timestamp();
}
inline void CMsgClientServerTimestampResponse::_internal_set_client_request_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_request_timestamp_ = value;
}
inline void CMsgClientServerTimestampResponse::set_client_request_timestamp(uint64_t value) {
  _internal_set_client_request_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgClientServerTimestampResponse.client_request_timestamp)
}

// optional uint64 server_timestamp_ms = 2;
inline bool CMsgClientServerTimestampResponse::_internal_has_server_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientServerTimestampResponse::has_server_timestamp_ms() const {
  return _internal_has_server_timestamp_ms();
}
inline void CMsgClientServerTimestampResponse::clear_server_timestamp_ms() {
  _impl_.server_timestamp_ms_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CMsgClientServerTimestampResponse::_internal_server_timestamp_ms() const {
  return _impl_.server_timestamp_ms_;
}
inline uint64_t CMsgClientServerTimestampResponse::server_timestamp_ms() const {
  // @@protoc_insertion_point(field_get:CMsgClientServerTimestampResponse.server_timestamp_ms)
  return _internal_server_timestamp_ms();
}
inline void CMsgClientServerTimestampResponse::_internal_set_server_timestamp_ms(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.server_timestamp_ms_ = value;
}
inline void CMsgClientServerTimestampResponse::set_server_timestamp_ms(uint64_t value) {
  _internal_set_server_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:CMsgClientServerTimestampResponse.server_timestamp_ms)
}

// -------------------------------------------------------------------

// CMsgClientSecret

// optional uint32 version = 1;
inline bool CMsgClientSecret::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientSecret::has_version() const {
  return _internal_has_version();
}
inline void CMsgClientSecret::clear_version() {
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientSecret::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t CMsgClientSecret::version() const {
  // @@protoc_insertion_point(field_get:CMsgClientSecret.version)
  return _internal_version();
}
inline void CMsgClientSecret::_internal_set_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_ = value;
}
inline void CMsgClientSecret::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:CMsgClientSecret.version)
}

// optional uint32 appid = 2;
inline bool CMsgClientSecret::_internal_has_appid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientSecret::has_appid() const {
  return _internal_has_appid();
}
inline void CMsgClientSecret::clear_appid() {
  _impl_.appid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgClientSecret::_internal_appid() const {
  return _impl_.appid_;
}
inline uint32_t CMsgClientSecret::appid() const {
  // @@protoc_insertion_point(field_get:CMsgClientSecret.appid)
  return _internal_appid();
}
inline void CMsgClientSecret::_internal_set_appid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.appid_ = value;
}
inline void CMsgClientSecret::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CMsgClientSecret.appid)
}

// optional uint32 deviceid = 3;
inline bool CMsgClientSecret::_internal_has_deviceid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgClientSecret::has_deviceid() const {
  return _internal_has_deviceid();
}
inline void CMsgClientSecret::clear_deviceid() {
  _impl_.deviceid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgClientSecret::_internal_deviceid() const {
  return _impl_.deviceid_;
}
inline uint32_t CMsgClientSecret::deviceid() const {
  // @@protoc_insertion_point(field_get:CMsgClientSecret.deviceid)
  return _internal_deviceid();
}
inline void CMsgClientSecret::_internal_set_deviceid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.deviceid_ = value;
}
inline void CMsgClientSecret::set_deviceid(uint32_t value) {
  _internal_set_deviceid(value);
  // @@protoc_insertion_point(field_set:CMsgClientSecret.deviceid)
}

// optional fixed64 nonce = 4;
inline bool CMsgClientSecret::_internal_has_nonce() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgClientSecret::has_nonce() const {
  return _internal_has_nonce();
}
inline void CMsgClientSecret::clear_nonce() {
  _impl_.nonce_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CMsgClientSecret::_internal_nonce() const {
  return _impl_.nonce_;
}
inline uint64_t CMsgClientSecret::nonce() const {
  // @@protoc_insertion_point(field_get:CMsgClientSecret.nonce)
  return _internal_nonce();
}
inline void CMsgClientSecret::_internal_set_nonce(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.nonce_ = value;
}
inline void CMsgClientSecret::set_nonce(uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:CMsgClientSecret.nonce)
}

// optional bytes hmac = 5;
inline bool CMsgClientSecret::_internal_has_hmac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientSecret::has_hmac() const {
  return _internal_has_hmac();
}
inline void CMsgClientSecret::clear_hmac() {
  _impl_.hmac_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgClientSecret::hmac() const {
  // @@protoc_insertion_point(field_get:CMsgClientSecret.hmac)
  return _internal_hmac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientSecret::set_hmac(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.hmac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientSecret.hmac)
}
inline std::string* CMsgClientSecret::mutable_hmac() {
  std::string* _s = _internal_mutable_hmac();
  // @@protoc_insertion_point(field_mutable:CMsgClientSecret.hmac)
  return _s;
}
inline const std::string& CMsgClientSecret::_internal_hmac() const {
  return _impl_.hmac_.Get();
}
inline void CMsgClientSecret::_internal_set_hmac(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hmac_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientSecret::_internal_mutable_hmac() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hmac_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientSecret::release_hmac() {
  // @@protoc_insertion_point(field_release:CMsgClientSecret.hmac)
  if (!_internal_has_hmac()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.hmac_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hmac_.IsDefault()) {
    _impl_.hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientSecret::set_allocated_hmac(std::string* hmac) {
  if (hmac != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hmac_.SetAllocated(hmac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hmac_.IsDefault()) {
    _impl_.hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientSecret.hmac)
}

// -------------------------------------------------------------------

// CMsgClientLogon

// optional uint32 protocol_version = 1;
inline bool CMsgClientLogon::_internal_has_protocol_version() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_protocol_version() const {
  return _internal_has_protocol_version();
}
inline void CMsgClientLogon::clear_protocol_version() {
  _impl_.protocol_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline uint32_t CMsgClientLogon::_internal_protocol_version() const {
  return _impl_.protocol_version_;
}
inline uint32_t CMsgClientLogon::protocol_version() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.protocol_version)
  return _internal_protocol_version();
}
inline void CMsgClientLogon::_internal_set_protocol_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.protocol_version_ = value;
}
inline void CMsgClientLogon::set_protocol_version(uint32_t value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.protocol_version)
}

// optional uint32 deprecated_obfustucated_private_ip = 2;
inline bool CMsgClientLogon::_internal_has_deprecated_obfustucated_private_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_deprecated_obfustucated_private_ip() const {
  return _internal_has_deprecated_obfustucated_private_ip();
}
inline void CMsgClientLogon::clear_deprecated_obfustucated_private_ip() {
  _impl_.deprecated_obfustucated_private_ip_ = 0u;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline uint32_t CMsgClientLogon::_internal_deprecated_obfustucated_private_ip() const {
  return _impl_.deprecated_obfustucated_private_ip_;
}
inline uint32_t CMsgClientLogon::deprecated_obfustucated_private_ip() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.deprecated_obfustucated_private_ip)
  return _internal_deprecated_obfustucated_private_ip();
}
inline void CMsgClientLogon::_internal_set_deprecated_obfustucated_private_ip(uint32_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.deprecated_obfustucated_private_ip_ = value;
}
inline void CMsgClientLogon::set_deprecated_obfustucated_private_ip(uint32_t value) {
  _internal_set_deprecated_obfustucated_private_ip(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.deprecated_obfustucated_private_ip)
}

// optional uint32 cell_id = 3;
inline bool CMsgClientLogon::_internal_has_cell_id() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_cell_id() const {
  return _internal_has_cell_id();
}
inline void CMsgClientLogon::clear_cell_id() {
  _impl_.cell_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline uint32_t CMsgClientLogon::_internal_cell_id() const {
  return _impl_.cell_id_;
}
inline uint32_t CMsgClientLogon::cell_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.cell_id)
  return _internal_cell_id();
}
inline void CMsgClientLogon::_internal_set_cell_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.cell_id_ = value;
}
inline void CMsgClientLogon::set_cell_id(uint32_t value) {
  _internal_set_cell_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.cell_id)
}

// optional uint32 last_session_id = 4;
inline bool CMsgClientLogon::_internal_has_last_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_last_session_id() const {
  return _internal_has_last_session_id();
}
inline void CMsgClientLogon::clear_last_session_id() {
  _impl_.last_session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline uint32_t CMsgClientLogon::_internal_last_session_id() const {
  return _impl_.last_session_id_;
}
inline uint32_t CMsgClientLogon::last_session_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.last_session_id)
  return _internal_last_session_id();
}
inline void CMsgClientLogon::_internal_set_last_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.last_session_id_ = value;
}
inline void CMsgClientLogon::set_last_session_id(uint32_t value) {
  _internal_set_last_session_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.last_session_id)
}

// optional uint32 client_package_version = 5;
inline bool CMsgClientLogon::_internal_has_client_package_version() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_client_package_version() const {
  return _internal_has_client_package_version();
}
inline void CMsgClientLogon::clear_client_package_version() {
  _impl_.client_package_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline uint32_t CMsgClientLogon::_internal_client_package_version() const {
  return _impl_.client_package_version_;
}
inline uint32_t CMsgClientLogon::client_package_version() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.client_package_version)
  return _internal_client_package_version();
}
inline void CMsgClientLogon::_internal_set_client_package_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.client_package_version_ = value;
}
inline void CMsgClientLogon::set_client_package_version(uint32_t value) {
  _internal_set_client_package_version(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.client_package_version)
}

// optional string client_language = 6;
inline bool CMsgClientLogon::_internal_has_client_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_client_language() const {
  return _internal_has_client_language();
}
inline void CMsgClientLogon::clear_client_language() {
  _impl_.client_language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgClientLogon::client_language() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.client_language)
  return _internal_client_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_client_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.client_language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.client_language)
}
inline std::string* CMsgClientLogon::mutable_client_language() {
  std::string* _s = _internal_mutable_client_language();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.client_language)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_client_language() const {
  return _impl_.client_language_.Get();
}
inline void CMsgClientLogon::_internal_set_client_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_language_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_client_language() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.client_language_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_client_language() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.client_language)
  if (!_internal_has_client_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.client_language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_language_.IsDefault()) {
    _impl_.client_language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_client_language(std::string* client_language) {
  if (client_language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.client_language_.SetAllocated(client_language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_language_.IsDefault()) {
    _impl_.client_language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.client_language)
}

// optional uint32 client_os_type = 7;
inline bool CMsgClientLogon::_internal_has_client_os_type() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_client_os_type() const {
  return _internal_has_client_os_type();
}
inline void CMsgClientLogon::clear_client_os_type() {
  _impl_.client_os_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline uint32_t CMsgClientLogon::_internal_client_os_type() const {
  return _impl_.client_os_type_;
}
inline uint32_t CMsgClientLogon::client_os_type() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.client_os_type)
  return _internal_client_os_type();
}
inline void CMsgClientLogon::_internal_set_client_os_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.client_os_type_ = value;
}
inline void CMsgClientLogon::set_client_os_type(uint32_t value) {
  _internal_set_client_os_type(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.client_os_type)
}

// optional bool should_remember_password = 8 [default = false];
inline bool CMsgClientLogon::_internal_has_should_remember_password() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_should_remember_password() const {
  return _internal_has_should_remember_password();
}
inline void CMsgClientLogon::clear_should_remember_password() {
  _impl_.should_remember_password_ = false;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline bool CMsgClientLogon::_internal_should_remember_password() const {
  return _impl_.should_remember_password_;
}
inline bool CMsgClientLogon::should_remember_password() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.should_remember_password)
  return _internal_should_remember_password();
}
inline void CMsgClientLogon::_internal_set_should_remember_password(bool value) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.should_remember_password_ = value;
}
inline void CMsgClientLogon::set_should_remember_password(bool value) {
  _internal_set_should_remember_password(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.should_remember_password)
}

// optional string wine_version = 9;
inline bool CMsgClientLogon::_internal_has_wine_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_wine_version() const {
  return _internal_has_wine_version();
}
inline void CMsgClientLogon::clear_wine_version() {
  _impl_.wine_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgClientLogon::wine_version() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.wine_version)
  return _internal_wine_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_wine_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.wine_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.wine_version)
}
inline std::string* CMsgClientLogon::mutable_wine_version() {
  std::string* _s = _internal_mutable_wine_version();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.wine_version)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_wine_version() const {
  return _impl_.wine_version_.Get();
}
inline void CMsgClientLogon::_internal_set_wine_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wine_version_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_wine_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.wine_version_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_wine_version() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.wine_version)
  if (!_internal_has_wine_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.wine_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wine_version_.IsDefault()) {
    _impl_.wine_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_wine_version(std::string* wine_version) {
  if (wine_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.wine_version_.SetAllocated(wine_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wine_version_.IsDefault()) {
    _impl_.wine_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.wine_version)
}

// optional uint32 deprecated_10 = 10;
inline bool CMsgClientLogon::_internal_has_deprecated_10() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_deprecated_10() const {
  return _internal_has_deprecated_10();
}
inline void CMsgClientLogon::clear_deprecated_10() {
  _impl_.deprecated_10_ = 0u;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline uint32_t CMsgClientLogon::_internal_deprecated_10() const {
  return _impl_.deprecated_10_;
}
inline uint32_t CMsgClientLogon::deprecated_10() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.deprecated_10)
  return _internal_deprecated_10();
}
inline void CMsgClientLogon::_internal_set_deprecated_10(uint32_t value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.deprecated_10_ = value;
}
inline void CMsgClientLogon::set_deprecated_10(uint32_t value) {
  _internal_set_deprecated_10(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.deprecated_10)
}

// optional .CMsgIPAddress obfuscated_private_ip = 11;
inline bool CMsgClientLogon::_internal_has_obfuscated_private_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.obfuscated_private_ip_ != nullptr);
  return value;
}
inline bool CMsgClientLogon::has_obfuscated_private_ip() const {
  return _internal_has_obfuscated_private_ip();
}
inline const ::CMsgIPAddress& CMsgClientLogon::_internal_obfuscated_private_ip() const {
  const ::CMsgIPAddress* p = _impl_.obfuscated_private_ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgIPAddress&>(
      ::_CMsgIPAddress_default_instance_);
}
inline const ::CMsgIPAddress& CMsgClientLogon::obfuscated_private_ip() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.obfuscated_private_ip)
  return _internal_obfuscated_private_ip();
}
inline void CMsgClientLogon::unsafe_arena_set_allocated_obfuscated_private_ip(
    ::CMsgIPAddress* obfuscated_private_ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obfuscated_private_ip_);
  }
  _impl_.obfuscated_private_ip_ = obfuscated_private_ip;
  if (obfuscated_private_ip) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientLogon.obfuscated_private_ip)
}
inline ::CMsgIPAddress* CMsgClientLogon::release_obfuscated_private_ip() {
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::CMsgIPAddress* temp = _impl_.obfuscated_private_ip_;
  _impl_.obfuscated_private_ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgIPAddress* CMsgClientLogon::unsafe_arena_release_obfuscated_private_ip() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.obfuscated_private_ip)
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::CMsgIPAddress* temp = _impl_.obfuscated_private_ip_;
  _impl_.obfuscated_private_ip_ = nullptr;
  return temp;
}
inline ::CMsgIPAddress* CMsgClientLogon::_internal_mutable_obfuscated_private_ip() {
  _impl_._has_bits_[0] |= 0x00200000u;
  if (_impl_.obfuscated_private_ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgIPAddress>(GetArenaForAllocation());
    _impl_.obfuscated_private_ip_ = p;
  }
  return _impl_.obfuscated_private_ip_;
}
inline ::CMsgIPAddress* CMsgClientLogon::mutable_obfuscated_private_ip() {
  ::CMsgIPAddress* _msg = _internal_mutable_obfuscated_private_ip();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.obfuscated_private_ip)
  return _msg;
}
inline void CMsgClientLogon::set_allocated_obfuscated_private_ip(::CMsgIPAddress* obfuscated_private_ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obfuscated_private_ip_);
  }
  if (obfuscated_private_ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(obfuscated_private_ip));
    if (message_arena != submessage_arena) {
      obfuscated_private_ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obfuscated_private_ip, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.obfuscated_private_ip_ = obfuscated_private_ip;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.obfuscated_private_ip)
}

// optional uint32 deprecated_public_ip = 20;
inline bool CMsgClientLogon::_internal_has_deprecated_public_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_deprecated_public_ip() const {
  return _internal_has_deprecated_public_ip();
}
inline void CMsgClientLogon::clear_deprecated_public_ip() {
  _impl_.deprecated_public_ip_ = 0u;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline uint32_t CMsgClientLogon::_internal_deprecated_public_ip() const {
  return _impl_.deprecated_public_ip_;
}
inline uint32_t CMsgClientLogon::deprecated_public_ip() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.deprecated_public_ip)
  return _internal_deprecated_public_ip();
}
inline void CMsgClientLogon::_internal_set_deprecated_public_ip(uint32_t value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.deprecated_public_ip_ = value;
}
inline void CMsgClientLogon::set_deprecated_public_ip(uint32_t value) {
  _internal_set_deprecated_public_ip(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.deprecated_public_ip)
}

// optional uint32 qos_level = 21;
inline bool CMsgClientLogon::_internal_has_qos_level() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_qos_level() const {
  return _internal_has_qos_level();
}
inline void CMsgClientLogon::clear_qos_level() {
  _impl_.qos_level_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline uint32_t CMsgClientLogon::_internal_qos_level() const {
  return _impl_.qos_level_;
}
inline uint32_t CMsgClientLogon::qos_level() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.qos_level)
  return _internal_qos_level();
}
inline void CMsgClientLogon::_internal_set_qos_level(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.qos_level_ = value;
}
inline void CMsgClientLogon::set_qos_level(uint32_t value) {
  _internal_set_qos_level(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.qos_level)
}

// optional fixed64 client_supplied_steam_id = 22;
inline bool CMsgClientLogon::_internal_has_client_supplied_steam_id() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_client_supplied_steam_id() const {
  return _internal_has_client_supplied_steam_id();
}
inline void CMsgClientLogon::clear_client_supplied_steam_id() {
  _impl_.client_supplied_steam_id_ = uint64_t{0u};
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline uint64_t CMsgClientLogon::_internal_client_supplied_steam_id() const {
  return _impl_.client_supplied_steam_id_;
}
inline uint64_t CMsgClientLogon::client_supplied_steam_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.client_supplied_steam_id)
  return _internal_client_supplied_steam_id();
}
inline void CMsgClientLogon::_internal_set_client_supplied_steam_id(uint64_t value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.client_supplied_steam_id_ = value;
}
inline void CMsgClientLogon::set_client_supplied_steam_id(uint64_t value) {
  _internal_set_client_supplied_steam_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.client_supplied_steam_id)
}

// optional .CMsgIPAddress public_ip = 23;
inline bool CMsgClientLogon::_internal_has_public_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.public_ip_ != nullptr);
  return value;
}
inline bool CMsgClientLogon::has_public_ip() const {
  return _internal_has_public_ip();
}
inline const ::CMsgIPAddress& CMsgClientLogon::_internal_public_ip() const {
  const ::CMsgIPAddress* p = _impl_.public_ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgIPAddress&>(
      ::_CMsgIPAddress_default_instance_);
}
inline const ::CMsgIPAddress& CMsgClientLogon::public_ip() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.public_ip)
  return _internal_public_ip();
}
inline void CMsgClientLogon::unsafe_arena_set_allocated_public_ip(
    ::CMsgIPAddress* public_ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_ip_);
  }
  _impl_.public_ip_ = public_ip;
  if (public_ip) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientLogon.public_ip)
}
inline ::CMsgIPAddress* CMsgClientLogon::release_public_ip() {
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::CMsgIPAddress* temp = _impl_.public_ip_;
  _impl_.public_ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgIPAddress* CMsgClientLogon::unsafe_arena_release_public_ip() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.public_ip)
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::CMsgIPAddress* temp = _impl_.public_ip_;
  _impl_.public_ip_ = nullptr;
  return temp;
}
inline ::CMsgIPAddress* CMsgClientLogon::_internal_mutable_public_ip() {
  _impl_._has_bits_[0] |= 0x00400000u;
  if (_impl_.public_ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgIPAddress>(GetArenaForAllocation());
    _impl_.public_ip_ = p;
  }
  return _impl_.public_ip_;
}
inline ::CMsgIPAddress* CMsgClientLogon::mutable_public_ip() {
  ::CMsgIPAddress* _msg = _internal_mutable_public_ip();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.public_ip)
  return _msg;
}
inline void CMsgClientLogon::set_allocated_public_ip(::CMsgIPAddress* public_ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_ip_);
  }
  if (public_ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_ip));
    if (message_arena != submessage_arena) {
      public_ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_ip, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.public_ip_ = public_ip;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.public_ip)
}

// optional bytes machine_id = 30;
inline bool CMsgClientLogon::_internal_has_machine_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_machine_id() const {
  return _internal_has_machine_id();
}
inline void CMsgClientLogon::clear_machine_id() {
  _impl_.machine_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgClientLogon::machine_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.machine_id)
  return _internal_machine_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_machine_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.machine_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.machine_id)
}
inline std::string* CMsgClientLogon::mutable_machine_id() {
  std::string* _s = _internal_mutable_machine_id();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.machine_id)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_machine_id() const {
  return _impl_.machine_id_.Get();
}
inline void CMsgClientLogon::_internal_set_machine_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.machine_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_machine_id() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.machine_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_machine_id() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.machine_id)
  if (!_internal_has_machine_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.machine_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_id_.IsDefault()) {
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_machine_id(std::string* machine_id) {
  if (machine_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.machine_id_.SetAllocated(machine_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_id_.IsDefault()) {
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.machine_id)
}

// optional uint32 launcher_type = 31 [default = 0];
inline bool CMsgClientLogon::_internal_has_launcher_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_launcher_type() const {
  return _internal_has_launcher_type();
}
inline void CMsgClientLogon::clear_launcher_type() {
  _impl_.launcher_type_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline uint32_t CMsgClientLogon::_internal_launcher_type() const {
  return _impl_.launcher_type_;
}
inline uint32_t CMsgClientLogon::launcher_type() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.launcher_type)
  return _internal_launcher_type();
}
inline void CMsgClientLogon::_internal_set_launcher_type(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.launcher_type_ = value;
}
inline void CMsgClientLogon::set_launcher_type(uint32_t value) {
  _internal_set_launcher_type(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.launcher_type)
}

// optional uint32 ui_mode = 32 [default = 0];
inline bool CMsgClientLogon::_internal_has_ui_mode() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_ui_mode() const {
  return _internal_has_ui_mode();
}
inline void CMsgClientLogon::clear_ui_mode() {
  _impl_.ui_mode_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline uint32_t CMsgClientLogon::_internal_ui_mode() const {
  return _impl_.ui_mode_;
}
inline uint32_t CMsgClientLogon::ui_mode() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.ui_mode)
  return _internal_ui_mode();
}
inline void CMsgClientLogon::_internal_set_ui_mode(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.ui_mode_ = value;
}
inline void CMsgClientLogon::set_ui_mode(uint32_t value) {
  _internal_set_ui_mode(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.ui_mode)
}

// optional uint32 chat_mode = 33 [default = 0];
inline bool CMsgClientLogon::_internal_has_chat_mode() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_chat_mode() const {
  return _internal_has_chat_mode();
}
inline void CMsgClientLogon::clear_chat_mode() {
  _impl_.chat_mode_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline uint32_t CMsgClientLogon::_internal_chat_mode() const {
  return _impl_.chat_mode_;
}
inline uint32_t CMsgClientLogon::chat_mode() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.chat_mode)
  return _internal_chat_mode();
}
inline void CMsgClientLogon::_internal_set_chat_mode(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.chat_mode_ = value;
}
inline void CMsgClientLogon::set_chat_mode(uint32_t value) {
  _internal_set_chat_mode(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.chat_mode)
}

// optional bytes steam2_auth_ticket = 41;
inline bool CMsgClientLogon::_internal_has_steam2_auth_ticket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_steam2_auth_ticket() const {
  return _internal_has_steam2_auth_ticket();
}
inline void CMsgClientLogon::clear_steam2_auth_ticket() {
  _impl_.steam2_auth_ticket_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CMsgClientLogon::steam2_auth_ticket() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.steam2_auth_ticket)
  return _internal_steam2_auth_ticket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_steam2_auth_ticket(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.steam2_auth_ticket_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.steam2_auth_ticket)
}
inline std::string* CMsgClientLogon::mutable_steam2_auth_ticket() {
  std::string* _s = _internal_mutable_steam2_auth_ticket();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.steam2_auth_ticket)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_steam2_auth_ticket() const {
  return _impl_.steam2_auth_ticket_.Get();
}
inline void CMsgClientLogon::_internal_set_steam2_auth_ticket(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.steam2_auth_ticket_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_steam2_auth_ticket() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.steam2_auth_ticket_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_steam2_auth_ticket() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.steam2_auth_ticket)
  if (!_internal_has_steam2_auth_ticket()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.steam2_auth_ticket_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.steam2_auth_ticket_.IsDefault()) {
    _impl_.steam2_auth_ticket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_steam2_auth_ticket(std::string* steam2_auth_ticket) {
  if (steam2_auth_ticket != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.steam2_auth_ticket_.SetAllocated(steam2_auth_ticket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.steam2_auth_ticket_.IsDefault()) {
    _impl_.steam2_auth_ticket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.steam2_auth_ticket)
}

// optional string email_address = 42;
inline bool CMsgClientLogon::_internal_has_email_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_email_address() const {
  return _internal_has_email_address();
}
inline void CMsgClientLogon::clear_email_address() {
  _impl_.email_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CMsgClientLogon::email_address() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.email_address)
  return _internal_email_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_email_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.email_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.email_address)
}
inline std::string* CMsgClientLogon::mutable_email_address() {
  std::string* _s = _internal_mutable_email_address();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.email_address)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_email_address() const {
  return _impl_.email_address_.Get();
}
inline void CMsgClientLogon::_internal_set_email_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.email_address_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_email_address() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.email_address_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_email_address() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.email_address)
  if (!_internal_has_email_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.email_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_address_.IsDefault()) {
    _impl_.email_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_email_address(std::string* email_address) {
  if (email_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.email_address_.SetAllocated(email_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_address_.IsDefault()) {
    _impl_.email_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.email_address)
}

// optional fixed32 rtime32_account_creation = 43;
inline bool CMsgClientLogon::_internal_has_rtime32_account_creation() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_rtime32_account_creation() const {
  return _internal_has_rtime32_account_creation();
}
inline void CMsgClientLogon::clear_rtime32_account_creation() {
  _impl_.rtime32_account_creation_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline uint32_t CMsgClientLogon::_internal_rtime32_account_creation() const {
  return _impl_.rtime32_account_creation_;
}
inline uint32_t CMsgClientLogon::rtime32_account_creation() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.rtime32_account_creation)
  return _internal_rtime32_account_creation();
}
inline void CMsgClientLogon::_internal_set_rtime32_account_creation(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.rtime32_account_creation_ = value;
}
inline void CMsgClientLogon::set_rtime32_account_creation(uint32_t value) {
  _internal_set_rtime32_account_creation(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.rtime32_account_creation)
}

// optional string account_name = 50;
inline bool CMsgClientLogon::_internal_has_account_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_account_name() const {
  return _internal_has_account_name();
}
inline void CMsgClientLogon::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CMsgClientLogon::account_name() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_account_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.account_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.account_name)
}
inline std::string* CMsgClientLogon::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.account_name)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_account_name() const {
  return _impl_.account_name_.Get();
}
inline void CMsgClientLogon::_internal_set_account_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_account_name() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.account_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_account_name() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.account_name)
  if (!_internal_has_account_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.account_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.account_name_.SetAllocated(account_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.account_name)
}

// optional string password = 51;
inline bool CMsgClientLogon::_internal_has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_password() const {
  return _internal_has_password();
}
inline void CMsgClientLogon::clear_password() {
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CMsgClientLogon::password() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_password(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.password)
}
inline std::string* CMsgClientLogon::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.password)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_password() const {
  return _impl_.password_.Get();
}
inline void CMsgClientLogon::_internal_set_password(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_password() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_password() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.password_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.password)
}

// optional string game_server_token = 52;
inline bool CMsgClientLogon::_internal_has_game_server_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_game_server_token() const {
  return _internal_has_game_server_token();
}
inline void CMsgClientLogon::clear_game_server_token() {
  _impl_.game_server_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CMsgClientLogon::game_server_token() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.game_server_token)
  return _internal_game_server_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_game_server_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.game_server_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.game_server_token)
}
inline std::string* CMsgClientLogon::mutable_game_server_token() {
  std::string* _s = _internal_mutable_game_server_token();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.game_server_token)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_game_server_token() const {
  return _impl_.game_server_token_.Get();
}
inline void CMsgClientLogon::_internal_set_game_server_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.game_server_token_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_game_server_token() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.game_server_token_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_game_server_token() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.game_server_token)
  if (!_internal_has_game_server_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.game_server_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_server_token_.IsDefault()) {
    _impl_.game_server_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_game_server_token(std::string* game_server_token) {
  if (game_server_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.game_server_token_.SetAllocated(game_server_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_server_token_.IsDefault()) {
    _impl_.game_server_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.game_server_token)
}

// optional string login_key = 60;
inline bool CMsgClientLogon::_internal_has_login_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_login_key() const {
  return _internal_has_login_key();
}
inline void CMsgClientLogon::clear_login_key() {
  _impl_.login_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& CMsgClientLogon::login_key() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.login_key)
  return _internal_login_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_login_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.login_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.login_key)
}
inline std::string* CMsgClientLogon::mutable_login_key() {
  std::string* _s = _internal_mutable_login_key();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.login_key)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_login_key() const {
  return _impl_.login_key_.Get();
}
inline void CMsgClientLogon::_internal_set_login_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.login_key_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_login_key() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.login_key_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_login_key() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.login_key)
  if (!_internal_has_login_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.login_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_key_.IsDefault()) {
    _impl_.login_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_login_key(std::string* login_key) {
  if (login_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.login_key_.SetAllocated(login_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_key_.IsDefault()) {
    _impl_.login_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.login_key)
}

// optional bool was_converted_deprecated_msg = 70 [default = false];
inline bool CMsgClientLogon::_internal_has_was_converted_deprecated_msg() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_was_converted_deprecated_msg() const {
  return _internal_has_was_converted_deprecated_msg();
}
inline void CMsgClientLogon::clear_was_converted_deprecated_msg() {
  _impl_.was_converted_deprecated_msg_ = false;
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline bool CMsgClientLogon::_internal_was_converted_deprecated_msg() const {
  return _impl_.was_converted_deprecated_msg_;
}
inline bool CMsgClientLogon::was_converted_deprecated_msg() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.was_converted_deprecated_msg)
  return _internal_was_converted_deprecated_msg();
}
inline void CMsgClientLogon::_internal_set_was_converted_deprecated_msg(bool value) {
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.was_converted_deprecated_msg_ = value;
}
inline void CMsgClientLogon::set_was_converted_deprecated_msg(bool value) {
  _internal_set_was_converted_deprecated_msg(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.was_converted_deprecated_msg)
}

// optional string anon_user_target_account_name = 80;
inline bool CMsgClientLogon::_internal_has_anon_user_target_account_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_anon_user_target_account_name() const {
  return _internal_has_anon_user_target_account_name();
}
inline void CMsgClientLogon::clear_anon_user_target_account_name() {
  _impl_.anon_user_target_account_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& CMsgClientLogon::anon_user_target_account_name() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.anon_user_target_account_name)
  return _internal_anon_user_target_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_anon_user_target_account_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.anon_user_target_account_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.anon_user_target_account_name)
}
inline std::string* CMsgClientLogon::mutable_anon_user_target_account_name() {
  std::string* _s = _internal_mutable_anon_user_target_account_name();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.anon_user_target_account_name)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_anon_user_target_account_name() const {
  return _impl_.anon_user_target_account_name_.Get();
}
inline void CMsgClientLogon::_internal_set_anon_user_target_account_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.anon_user_target_account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_anon_user_target_account_name() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.anon_user_target_account_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_anon_user_target_account_name() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.anon_user_target_account_name)
  if (!_internal_has_anon_user_target_account_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.anon_user_target_account_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.anon_user_target_account_name_.IsDefault()) {
    _impl_.anon_user_target_account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_anon_user_target_account_name(std::string* anon_user_target_account_name) {
  if (anon_user_target_account_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.anon_user_target_account_name_.SetAllocated(anon_user_target_account_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.anon_user_target_account_name_.IsDefault()) {
    _impl_.anon_user_target_account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.anon_user_target_account_name)
}

// optional fixed64 resolved_user_steam_id = 81;
inline bool CMsgClientLogon::_internal_has_resolved_user_steam_id() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_resolved_user_steam_id() const {
  return _internal_has_resolved_user_steam_id();
}
inline void CMsgClientLogon::clear_resolved_user_steam_id() {
  _impl_.resolved_user_steam_id_ = uint64_t{0u};
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline uint64_t CMsgClientLogon::_internal_resolved_user_steam_id() const {
  return _impl_.resolved_user_steam_id_;
}
inline uint64_t CMsgClientLogon::resolved_user_steam_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.resolved_user_steam_id)
  return _internal_resolved_user_steam_id();
}
inline void CMsgClientLogon::_internal_set_resolved_user_steam_id(uint64_t value) {
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.resolved_user_steam_id_ = value;
}
inline void CMsgClientLogon::set_resolved_user_steam_id(uint64_t value) {
  _internal_set_resolved_user_steam_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.resolved_user_steam_id)
}

// optional int32 eresult_sentryfile = 82;
inline bool CMsgClientLogon::_internal_has_eresult_sentryfile() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_eresult_sentryfile() const {
  return _internal_has_eresult_sentryfile();
}
inline void CMsgClientLogon::clear_eresult_sentryfile() {
  _impl_.eresult_sentryfile_ = 0;
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline int32_t CMsgClientLogon::_internal_eresult_sentryfile() const {
  return _impl_.eresult_sentryfile_;
}
inline int32_t CMsgClientLogon::eresult_sentryfile() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.eresult_sentryfile)
  return _internal_eresult_sentryfile();
}
inline void CMsgClientLogon::_internal_set_eresult_sentryfile(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000800u;
  _impl_.eresult_sentryfile_ = value;
}
inline void CMsgClientLogon::set_eresult_sentryfile(int32_t value) {
  _internal_set_eresult_sentryfile(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.eresult_sentryfile)
}

// optional bytes sha_sentryfile = 83;
inline bool CMsgClientLogon::_internal_has_sha_sentryfile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_sha_sentryfile() const {
  return _internal_has_sha_sentryfile();
}
inline void CMsgClientLogon::clear_sha_sentryfile() {
  _impl_.sha_sentryfile_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& CMsgClientLogon::sha_sentryfile() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.sha_sentryfile)
  return _internal_sha_sentryfile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_sha_sentryfile(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.sha_sentryfile_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.sha_sentryfile)
}
inline std::string* CMsgClientLogon::mutable_sha_sentryfile() {
  std::string* _s = _internal_mutable_sha_sentryfile();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.sha_sentryfile)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_sha_sentryfile() const {
  return _impl_.sha_sentryfile_.Get();
}
inline void CMsgClientLogon::_internal_set_sha_sentryfile(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.sha_sentryfile_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_sha_sentryfile() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.sha_sentryfile_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_sha_sentryfile() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.sha_sentryfile)
  if (!_internal_has_sha_sentryfile()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.sha_sentryfile_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sha_sentryfile_.IsDefault()) {
    _impl_.sha_sentryfile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_sha_sentryfile(std::string* sha_sentryfile) {
  if (sha_sentryfile != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.sha_sentryfile_.SetAllocated(sha_sentryfile, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sha_sentryfile_.IsDefault()) {
    _impl_.sha_sentryfile_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.sha_sentryfile)
}

// optional string auth_code = 84;
inline bool CMsgClientLogon::_internal_has_auth_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_auth_code() const {
  return _internal_has_auth_code();
}
inline void CMsgClientLogon::clear_auth_code() {
  _impl_.auth_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& CMsgClientLogon::auth_code() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.auth_code)
  return _internal_auth_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_auth_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.auth_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.auth_code)
}
inline std::string* CMsgClientLogon::mutable_auth_code() {
  std::string* _s = _internal_mutable_auth_code();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.auth_code)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_auth_code() const {
  return _impl_.auth_code_.Get();
}
inline void CMsgClientLogon::_internal_set_auth_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.auth_code_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_auth_code() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.auth_code_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_auth_code() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.auth_code)
  if (!_internal_has_auth_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.auth_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_code_.IsDefault()) {
    _impl_.auth_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_auth_code(std::string* auth_code) {
  if (auth_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.auth_code_.SetAllocated(auth_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_code_.IsDefault()) {
    _impl_.auth_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.auth_code)
}

// optional int32 otp_type = 85;
inline bool CMsgClientLogon::_internal_has_otp_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_otp_type() const {
  return _internal_has_otp_type();
}
inline void CMsgClientLogon::clear_otp_type() {
  _impl_.otp_type_ = 0;
  _impl_._has_bits_[1] &= ~0x00001000u;
}
inline int32_t CMsgClientLogon::_internal_otp_type() const {
  return _impl_.otp_type_;
}
inline int32_t CMsgClientLogon::otp_type() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.otp_type)
  return _internal_otp_type();
}
inline void CMsgClientLogon::_internal_set_otp_type(int32_t value) {
  _impl_._has_bits_[1] |= 0x00001000u;
  _impl_.otp_type_ = value;
}
inline void CMsgClientLogon::set_otp_type(int32_t value) {
  _internal_set_otp_type(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.otp_type)
}

// optional uint32 otp_value = 86;
inline bool CMsgClientLogon::_internal_has_otp_value() const {
  bool value = (_impl_._has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_otp_value() const {
  return _internal_has_otp_value();
}
inline void CMsgClientLogon::clear_otp_value() {
  _impl_.otp_value_ = 0u;
  _impl_._has_bits_[1] &= ~0x00002000u;
}
inline uint32_t CMsgClientLogon::_internal_otp_value() const {
  return _impl_.otp_value_;
}
inline uint32_t CMsgClientLogon::otp_value() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.otp_value)
  return _internal_otp_value();
}
inline void CMsgClientLogon::_internal_set_otp_value(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00002000u;
  _impl_.otp_value_ = value;
}
inline void CMsgClientLogon::set_otp_value(uint32_t value) {
  _internal_set_otp_value(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.otp_value)
}

// optional string otp_identifier = 87;
inline bool CMsgClientLogon::_internal_has_otp_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_otp_identifier() const {
  return _internal_has_otp_identifier();
}
inline void CMsgClientLogon::clear_otp_identifier() {
  _impl_.otp_identifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& CMsgClientLogon::otp_identifier() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.otp_identifier)
  return _internal_otp_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_otp_identifier(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00001000u;
 _impl_.otp_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.otp_identifier)
}
inline std::string* CMsgClientLogon::mutable_otp_identifier() {
  std::string* _s = _internal_mutable_otp_identifier();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.otp_identifier)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_otp_identifier() const {
  return _impl_.otp_identifier_.Get();
}
inline void CMsgClientLogon::_internal_set_otp_identifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.otp_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_otp_identifier() {
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.otp_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_otp_identifier() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.otp_identifier)
  if (!_internal_has_otp_identifier()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* p = _impl_.otp_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.otp_identifier_.IsDefault()) {
    _impl_.otp_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_otp_identifier(std::string* otp_identifier) {
  if (otp_identifier != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.otp_identifier_.SetAllocated(otp_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.otp_identifier_.IsDefault()) {
    _impl_.otp_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.otp_identifier)
}

// optional bool steam2_ticket_request = 88;
inline bool CMsgClientLogon::_internal_has_steam2_ticket_request() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_steam2_ticket_request() const {
  return _internal_has_steam2_ticket_request();
}
inline void CMsgClientLogon::clear_steam2_ticket_request() {
  _impl_.steam2_ticket_request_ = false;
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline bool CMsgClientLogon::_internal_steam2_ticket_request() const {
  return _impl_.steam2_ticket_request_;
}
inline bool CMsgClientLogon::steam2_ticket_request() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.steam2_ticket_request)
  return _internal_steam2_ticket_request();
}
inline void CMsgClientLogon::_internal_set_steam2_ticket_request(bool value) {
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.steam2_ticket_request_ = value;
}
inline void CMsgClientLogon::set_steam2_ticket_request(bool value) {
  _internal_set_steam2_ticket_request(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.steam2_ticket_request)
}

// optional bytes sony_psn_ticket = 90;
inline bool CMsgClientLogon::_internal_has_sony_psn_ticket() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_sony_psn_ticket() const {
  return _internal_has_sony_psn_ticket();
}
inline void CMsgClientLogon::clear_sony_psn_ticket() {
  _impl_.sony_psn_ticket_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& CMsgClientLogon::sony_psn_ticket() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.sony_psn_ticket)
  return _internal_sony_psn_ticket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_sony_psn_ticket(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00002000u;
 _impl_.sony_psn_ticket_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.sony_psn_ticket)
}
inline std::string* CMsgClientLogon::mutable_sony_psn_ticket() {
  std::string* _s = _internal_mutable_sony_psn_ticket();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.sony_psn_ticket)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_sony_psn_ticket() const {
  return _impl_.sony_psn_ticket_.Get();
}
inline void CMsgClientLogon::_internal_set_sony_psn_ticket(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.sony_psn_ticket_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_sony_psn_ticket() {
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.sony_psn_ticket_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_sony_psn_ticket() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.sony_psn_ticket)
  if (!_internal_has_sony_psn_ticket()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* p = _impl_.sony_psn_ticket_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sony_psn_ticket_.IsDefault()) {
    _impl_.sony_psn_ticket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_sony_psn_ticket(std::string* sony_psn_ticket) {
  if (sony_psn_ticket != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.sony_psn_ticket_.SetAllocated(sony_psn_ticket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sony_psn_ticket_.IsDefault()) {
    _impl_.sony_psn_ticket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.sony_psn_ticket)
}

// optional string sony_psn_service_id = 91;
inline bool CMsgClientLogon::_internal_has_sony_psn_service_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_sony_psn_service_id() const {
  return _internal_has_sony_psn_service_id();
}
inline void CMsgClientLogon::clear_sony_psn_service_id() {
  _impl_.sony_psn_service_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const std::string& CMsgClientLogon::sony_psn_service_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.sony_psn_service_id)
  return _internal_sony_psn_service_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_sony_psn_service_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00004000u;
 _impl_.sony_psn_service_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.sony_psn_service_id)
}
inline std::string* CMsgClientLogon::mutable_sony_psn_service_id() {
  std::string* _s = _internal_mutable_sony_psn_service_id();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.sony_psn_service_id)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_sony_psn_service_id() const {
  return _impl_.sony_psn_service_id_.Get();
}
inline void CMsgClientLogon::_internal_set_sony_psn_service_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.sony_psn_service_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_sony_psn_service_id() {
  _impl_._has_bits_[0] |= 0x00004000u;
  return _impl_.sony_psn_service_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_sony_psn_service_id() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.sony_psn_service_id)
  if (!_internal_has_sony_psn_service_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00004000u;
  auto* p = _impl_.sony_psn_service_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sony_psn_service_id_.IsDefault()) {
    _impl_.sony_psn_service_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_sony_psn_service_id(std::string* sony_psn_service_id) {
  if (sony_psn_service_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.sony_psn_service_id_.SetAllocated(sony_psn_service_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sony_psn_service_id_.IsDefault()) {
    _impl_.sony_psn_service_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.sony_psn_service_id)
}

// optional bool create_new_psn_linked_account_if_needed = 92 [default = false];
inline bool CMsgClientLogon::_internal_has_create_new_psn_linked_account_if_needed() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_create_new_psn_linked_account_if_needed() const {
  return _internal_has_create_new_psn_linked_account_if_needed();
}
inline void CMsgClientLogon::clear_create_new_psn_linked_account_if_needed() {
  _impl_.create_new_psn_linked_account_if_needed_ = false;
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline bool CMsgClientLogon::_internal_create_new_psn_linked_account_if_needed() const {
  return _impl_.create_new_psn_linked_account_if_needed_;
}
inline bool CMsgClientLogon::create_new_psn_linked_account_if_needed() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.create_new_psn_linked_account_if_needed)
  return _internal_create_new_psn_linked_account_if_needed();
}
inline void CMsgClientLogon::_internal_set_create_new_psn_linked_account_if_needed(bool value) {
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.create_new_psn_linked_account_if_needed_ = value;
}
inline void CMsgClientLogon::set_create_new_psn_linked_account_if_needed(bool value) {
  _internal_set_create_new_psn_linked_account_if_needed(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.create_new_psn_linked_account_if_needed)
}

// optional string sony_psn_name = 93;
inline bool CMsgClientLogon::_internal_has_sony_psn_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_sony_psn_name() const {
  return _internal_has_sony_psn_name();
}
inline void CMsgClientLogon::clear_sony_psn_name() {
  _impl_.sony_psn_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const std::string& CMsgClientLogon::sony_psn_name() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.sony_psn_name)
  return _internal_sony_psn_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_sony_psn_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00008000u;
 _impl_.sony_psn_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.sony_psn_name)
}
inline std::string* CMsgClientLogon::mutable_sony_psn_name() {
  std::string* _s = _internal_mutable_sony_psn_name();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.sony_psn_name)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_sony_psn_name() const {
  return _impl_.sony_psn_name_.Get();
}
inline void CMsgClientLogon::_internal_set_sony_psn_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.sony_psn_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_sony_psn_name() {
  _impl_._has_bits_[0] |= 0x00008000u;
  return _impl_.sony_psn_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_sony_psn_name() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.sony_psn_name)
  if (!_internal_has_sony_psn_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00008000u;
  auto* p = _impl_.sony_psn_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sony_psn_name_.IsDefault()) {
    _impl_.sony_psn_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_sony_psn_name(std::string* sony_psn_name) {
  if (sony_psn_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.sony_psn_name_.SetAllocated(sony_psn_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sony_psn_name_.IsDefault()) {
    _impl_.sony_psn_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.sony_psn_name)
}

// optional int32 game_server_app_id = 94;
inline bool CMsgClientLogon::_internal_has_game_server_app_id() const {
  bool value = (_impl_._has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_game_server_app_id() const {
  return _internal_has_game_server_app_id();
}
inline void CMsgClientLogon::clear_game_server_app_id() {
  _impl_.game_server_app_id_ = 0;
  _impl_._has_bits_[1] &= ~0x00004000u;
}
inline int32_t CMsgClientLogon::_internal_game_server_app_id() const {
  return _impl_.game_server_app_id_;
}
inline int32_t CMsgClientLogon::game_server_app_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.game_server_app_id)
  return _internal_game_server_app_id();
}
inline void CMsgClientLogon::_internal_set_game_server_app_id(int32_t value) {
  _impl_._has_bits_[1] |= 0x00004000u;
  _impl_.game_server_app_id_ = value;
}
inline void CMsgClientLogon::set_game_server_app_id(int32_t value) {
  _internal_set_game_server_app_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.game_server_app_id)
}

// optional bool steamguard_dont_remember_computer = 95;
inline bool CMsgClientLogon::_internal_has_steamguard_dont_remember_computer() const {
  bool value = (_impl_._has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_steamguard_dont_remember_computer() const {
  return _internal_has_steamguard_dont_remember_computer();
}
inline void CMsgClientLogon::clear_steamguard_dont_remember_computer() {
  _impl_.steamguard_dont_remember_computer_ = false;
  _impl_._has_bits_[1] &= ~0x00010000u;
}
inline bool CMsgClientLogon::_internal_steamguard_dont_remember_computer() const {
  return _impl_.steamguard_dont_remember_computer_;
}
inline bool CMsgClientLogon::steamguard_dont_remember_computer() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.steamguard_dont_remember_computer)
  return _internal_steamguard_dont_remember_computer();
}
inline void CMsgClientLogon::_internal_set_steamguard_dont_remember_computer(bool value) {
  _impl_._has_bits_[1] |= 0x00010000u;
  _impl_.steamguard_dont_remember_computer_ = value;
}
inline void CMsgClientLogon::set_steamguard_dont_remember_computer(bool value) {
  _internal_set_steamguard_dont_remember_computer(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.steamguard_dont_remember_computer)
}

// optional string machine_name = 96;
inline bool CMsgClientLogon::_internal_has_machine_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_machine_name() const {
  return _internal_has_machine_name();
}
inline void CMsgClientLogon::clear_machine_name() {
  _impl_.machine_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const std::string& CMsgClientLogon::machine_name() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.machine_name)
  return _internal_machine_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_machine_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00010000u;
 _impl_.machine_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.machine_name)
}
inline std::string* CMsgClientLogon::mutable_machine_name() {
  std::string* _s = _internal_mutable_machine_name();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.machine_name)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_machine_name() const {
  return _impl_.machine_name_.Get();
}
inline void CMsgClientLogon::_internal_set_machine_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.machine_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_machine_name() {
  _impl_._has_bits_[0] |= 0x00010000u;
  return _impl_.machine_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_machine_name() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.machine_name)
  if (!_internal_has_machine_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00010000u;
  auto* p = _impl_.machine_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_name_.IsDefault()) {
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_machine_name(std::string* machine_name) {
  if (machine_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.machine_name_.SetAllocated(machine_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_name_.IsDefault()) {
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.machine_name)
}

// optional string machine_name_userchosen = 97;
inline bool CMsgClientLogon::_internal_has_machine_name_userchosen() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_machine_name_userchosen() const {
  return _internal_has_machine_name_userchosen();
}
inline void CMsgClientLogon::clear_machine_name_userchosen() {
  _impl_.machine_name_userchosen_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const std::string& CMsgClientLogon::machine_name_userchosen() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.machine_name_userchosen)
  return _internal_machine_name_userchosen();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_machine_name_userchosen(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00020000u;
 _impl_.machine_name_userchosen_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.machine_name_userchosen)
}
inline std::string* CMsgClientLogon::mutable_machine_name_userchosen() {
  std::string* _s = _internal_mutable_machine_name_userchosen();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.machine_name_userchosen)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_machine_name_userchosen() const {
  return _impl_.machine_name_userchosen_.Get();
}
inline void CMsgClientLogon::_internal_set_machine_name_userchosen(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.machine_name_userchosen_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_machine_name_userchosen() {
  _impl_._has_bits_[0] |= 0x00020000u;
  return _impl_.machine_name_userchosen_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_machine_name_userchosen() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.machine_name_userchosen)
  if (!_internal_has_machine_name_userchosen()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00020000u;
  auto* p = _impl_.machine_name_userchosen_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_name_userchosen_.IsDefault()) {
    _impl_.machine_name_userchosen_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_machine_name_userchosen(std::string* machine_name_userchosen) {
  if (machine_name_userchosen != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.machine_name_userchosen_.SetAllocated(machine_name_userchosen, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_name_userchosen_.IsDefault()) {
    _impl_.machine_name_userchosen_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.machine_name_userchosen)
}

// optional string country_override = 98;
inline bool CMsgClientLogon::_internal_has_country_override() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_country_override() const {
  return _internal_has_country_override();
}
inline void CMsgClientLogon::clear_country_override() {
  _impl_.country_override_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const std::string& CMsgClientLogon::country_override() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.country_override)
  return _internal_country_override();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_country_override(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00040000u;
 _impl_.country_override_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.country_override)
}
inline std::string* CMsgClientLogon::mutable_country_override() {
  std::string* _s = _internal_mutable_country_override();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.country_override)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_country_override() const {
  return _impl_.country_override_.Get();
}
inline void CMsgClientLogon::_internal_set_country_override(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.country_override_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_country_override() {
  _impl_._has_bits_[0] |= 0x00040000u;
  return _impl_.country_override_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_country_override() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.country_override)
  if (!_internal_has_country_override()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00040000u;
  auto* p = _impl_.country_override_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_override_.IsDefault()) {
    _impl_.country_override_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_country_override(std::string* country_override) {
  if (country_override != nullptr) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.country_override_.SetAllocated(country_override, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_override_.IsDefault()) {
    _impl_.country_override_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.country_override)
}

// optional bool is_steam_box = 99;
inline bool CMsgClientLogon::_internal_has_is_steam_box() const {
  bool value = (_impl_._has_bits_[1] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_is_steam_box() const {
  return _internal_has_is_steam_box();
}
inline void CMsgClientLogon::clear_is_steam_box() {
  _impl_.is_steam_box_ = false;
  _impl_._has_bits_[1] &= ~0x00020000u;
}
inline bool CMsgClientLogon::_internal_is_steam_box() const {
  return _impl_.is_steam_box_;
}
inline bool CMsgClientLogon::is_steam_box() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.is_steam_box)
  return _internal_is_steam_box();
}
inline void CMsgClientLogon::_internal_set_is_steam_box(bool value) {
  _impl_._has_bits_[1] |= 0x00020000u;
  _impl_.is_steam_box_ = value;
}
inline void CMsgClientLogon::set_is_steam_box(bool value) {
  _internal_set_is_steam_box(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.is_steam_box)
}

// optional uint64 client_instance_id = 100;
inline bool CMsgClientLogon::_internal_has_client_instance_id() const {
  bool value = (_impl_._has_bits_[1] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_client_instance_id() const {
  return _internal_has_client_instance_id();
}
inline void CMsgClientLogon::clear_client_instance_id() {
  _impl_.client_instance_id_ = uint64_t{0u};
  _impl_._has_bits_[1] &= ~0x00008000u;
}
inline uint64_t CMsgClientLogon::_internal_client_instance_id() const {
  return _impl_.client_instance_id_;
}
inline uint64_t CMsgClientLogon::client_instance_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.client_instance_id)
  return _internal_client_instance_id();
}
inline void CMsgClientLogon::_internal_set_client_instance_id(uint64_t value) {
  _impl_._has_bits_[1] |= 0x00008000u;
  _impl_.client_instance_id_ = value;
}
inline void CMsgClientLogon::set_client_instance_id(uint64_t value) {
  _internal_set_client_instance_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.client_instance_id)
}

// optional string two_factor_code = 101;
inline bool CMsgClientLogon::_internal_has_two_factor_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_two_factor_code() const {
  return _internal_has_two_factor_code();
}
inline void CMsgClientLogon::clear_two_factor_code() {
  _impl_.two_factor_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const std::string& CMsgClientLogon::two_factor_code() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.two_factor_code)
  return _internal_two_factor_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_two_factor_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00080000u;
 _impl_.two_factor_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.two_factor_code)
}
inline std::string* CMsgClientLogon::mutable_two_factor_code() {
  std::string* _s = _internal_mutable_two_factor_code();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.two_factor_code)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_two_factor_code() const {
  return _impl_.two_factor_code_.Get();
}
inline void CMsgClientLogon::_internal_set_two_factor_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.two_factor_code_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_two_factor_code() {
  _impl_._has_bits_[0] |= 0x00080000u;
  return _impl_.two_factor_code_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_two_factor_code() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.two_factor_code)
  if (!_internal_has_two_factor_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00080000u;
  auto* p = _impl_.two_factor_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.two_factor_code_.IsDefault()) {
    _impl_.two_factor_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_two_factor_code(std::string* two_factor_code) {
  if (two_factor_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.two_factor_code_.SetAllocated(two_factor_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.two_factor_code_.IsDefault()) {
    _impl_.two_factor_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.two_factor_code)
}

// optional bool supports_rate_limit_response = 102;
inline bool CMsgClientLogon::_internal_has_supports_rate_limit_response() const {
  bool value = (_impl_._has_bits_[1] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_supports_rate_limit_response() const {
  return _internal_has_supports_rate_limit_response();
}
inline void CMsgClientLogon::clear_supports_rate_limit_response() {
  _impl_.supports_rate_limit_response_ = false;
  _impl_._has_bits_[1] &= ~0x00040000u;
}
inline bool CMsgClientLogon::_internal_supports_rate_limit_response() const {
  return _impl_.supports_rate_limit_response_;
}
inline bool CMsgClientLogon::supports_rate_limit_response() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.supports_rate_limit_response)
  return _internal_supports_rate_limit_response();
}
inline void CMsgClientLogon::_internal_set_supports_rate_limit_response(bool value) {
  _impl_._has_bits_[1] |= 0x00040000u;
  _impl_.supports_rate_limit_response_ = value;
}
inline void CMsgClientLogon::set_supports_rate_limit_response(bool value) {
  _internal_set_supports_rate_limit_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.supports_rate_limit_response)
}

// optional string web_logon_nonce = 103;
inline bool CMsgClientLogon::_internal_has_web_logon_nonce() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_web_logon_nonce() const {
  return _internal_has_web_logon_nonce();
}
inline void CMsgClientLogon::clear_web_logon_nonce() {
  _impl_.web_logon_nonce_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const std::string& CMsgClientLogon::web_logon_nonce() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.web_logon_nonce)
  return _internal_web_logon_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogon::set_web_logon_nonce(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00100000u;
 _impl_.web_logon_nonce_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogon.web_logon_nonce)
}
inline std::string* CMsgClientLogon::mutable_web_logon_nonce() {
  std::string* _s = _internal_mutable_web_logon_nonce();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.web_logon_nonce)
  return _s;
}
inline const std::string& CMsgClientLogon::_internal_web_logon_nonce() const {
  return _impl_.web_logon_nonce_.Get();
}
inline void CMsgClientLogon::_internal_set_web_logon_nonce(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.web_logon_nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::_internal_mutable_web_logon_nonce() {
  _impl_._has_bits_[0] |= 0x00100000u;
  return _impl_.web_logon_nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogon::release_web_logon_nonce() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.web_logon_nonce)
  if (!_internal_has_web_logon_nonce()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00100000u;
  auto* p = _impl_.web_logon_nonce_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.web_logon_nonce_.IsDefault()) {
    _impl_.web_logon_nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogon::set_allocated_web_logon_nonce(std::string* web_logon_nonce) {
  if (web_logon_nonce != nullptr) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.web_logon_nonce_.SetAllocated(web_logon_nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.web_logon_nonce_.IsDefault()) {
    _impl_.web_logon_nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.web_logon_nonce)
}

// optional int32 priority_reason = 104;
inline bool CMsgClientLogon::_internal_has_priority_reason() const {
  bool value = (_impl_._has_bits_[1] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgClientLogon::has_priority_reason() const {
  return _internal_has_priority_reason();
}
inline void CMsgClientLogon::clear_priority_reason() {
  _impl_.priority_reason_ = 0;
  _impl_._has_bits_[1] &= ~0x00080000u;
}
inline int32_t CMsgClientLogon::_internal_priority_reason() const {
  return _impl_.priority_reason_;
}
inline int32_t CMsgClientLogon::priority_reason() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.priority_reason)
  return _internal_priority_reason();
}
inline void CMsgClientLogon::_internal_set_priority_reason(int32_t value) {
  _impl_._has_bits_[1] |= 0x00080000u;
  _impl_.priority_reason_ = value;
}
inline void CMsgClientLogon::set_priority_reason(int32_t value) {
  _internal_set_priority_reason(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogon.priority_reason)
}

// optional .CMsgClientSecret embedded_client_secret = 105;
inline bool CMsgClientLogon::_internal_has_embedded_client_secret() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.embedded_client_secret_ != nullptr);
  return value;
}
inline bool CMsgClientLogon::has_embedded_client_secret() const {
  return _internal_has_embedded_client_secret();
}
inline void CMsgClientLogon::clear_embedded_client_secret() {
  if (_impl_.embedded_client_secret_ != nullptr) _impl_.embedded_client_secret_->Clear();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const ::CMsgClientSecret& CMsgClientLogon::_internal_embedded_client_secret() const {
  const ::CMsgClientSecret* p = _impl_.embedded_client_secret_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgClientSecret&>(
      ::_CMsgClientSecret_default_instance_);
}
inline const ::CMsgClientSecret& CMsgClientLogon::embedded_client_secret() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogon.embedded_client_secret)
  return _internal_embedded_client_secret();
}
inline void CMsgClientLogon::unsafe_arena_set_allocated_embedded_client_secret(
    ::CMsgClientSecret* embedded_client_secret) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.embedded_client_secret_);
  }
  _impl_.embedded_client_secret_ = embedded_client_secret;
  if (embedded_client_secret) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientLogon.embedded_client_secret)
}
inline ::CMsgClientSecret* CMsgClientLogon::release_embedded_client_secret() {
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::CMsgClientSecret* temp = _impl_.embedded_client_secret_;
  _impl_.embedded_client_secret_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgClientSecret* CMsgClientLogon::unsafe_arena_release_embedded_client_secret() {
  // @@protoc_insertion_point(field_release:CMsgClientLogon.embedded_client_secret)
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::CMsgClientSecret* temp = _impl_.embedded_client_secret_;
  _impl_.embedded_client_secret_ = nullptr;
  return temp;
}
inline ::CMsgClientSecret* CMsgClientLogon::_internal_mutable_embedded_client_secret() {
  _impl_._has_bits_[0] |= 0x00800000u;
  if (_impl_.embedded_client_secret_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgClientSecret>(GetArenaForAllocation());
    _impl_.embedded_client_secret_ = p;
  }
  return _impl_.embedded_client_secret_;
}
inline ::CMsgClientSecret* CMsgClientLogon::mutable_embedded_client_secret() {
  ::CMsgClientSecret* _msg = _internal_mutable_embedded_client_secret();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogon.embedded_client_secret)
  return _msg;
}
inline void CMsgClientLogon::set_allocated_embedded_client_secret(::CMsgClientSecret* embedded_client_secret) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.embedded_client_secret_;
  }
  if (embedded_client_secret) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(embedded_client_secret);
    if (message_arena != submessage_arena) {
      embedded_client_secret = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, embedded_client_secret, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.embedded_client_secret_ = embedded_client_secret;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogon.embedded_client_secret)
}

// -------------------------------------------------------------------

// CMsgClientLogonResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientLogonResponse::_internal_has_eresult() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_eresult() const {
  return _internal_has_eresult();
}
inline void CMsgClientLogonResponse::clear_eresult() {
  _impl_.eresult_ = 2;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline int32_t CMsgClientLogonResponse::_internal_eresult() const {
  return _impl_.eresult_;
}
inline int32_t CMsgClientLogonResponse::eresult() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.eresult)
  return _internal_eresult();
}
inline void CMsgClientLogonResponse::_internal_set_eresult(int32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.eresult_ = value;
}
inline void CMsgClientLogonResponse::set_eresult(int32_t value) {
  _internal_set_eresult(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.eresult)
}

// optional int32 out_of_game_heartbeat_seconds = 2;
inline bool CMsgClientLogonResponse::_internal_has_out_of_game_heartbeat_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_out_of_game_heartbeat_seconds() const {
  return _internal_has_out_of_game_heartbeat_seconds();
}
inline void CMsgClientLogonResponse::clear_out_of_game_heartbeat_seconds() {
  _impl_.out_of_game_heartbeat_seconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t CMsgClientLogonResponse::_internal_out_of_game_heartbeat_seconds() const {
  return _impl_.out_of_game_heartbeat_seconds_;
}
inline int32_t CMsgClientLogonResponse::out_of_game_heartbeat_seconds() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.out_of_game_heartbeat_seconds)
  return _internal_out_of_game_heartbeat_seconds();
}
inline void CMsgClientLogonResponse::_internal_set_out_of_game_heartbeat_seconds(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.out_of_game_heartbeat_seconds_ = value;
}
inline void CMsgClientLogonResponse::set_out_of_game_heartbeat_seconds(int32_t value) {
  _internal_set_out_of_game_heartbeat_seconds(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.out_of_game_heartbeat_seconds)
}

// optional int32 in_game_heartbeat_seconds = 3;
inline bool CMsgClientLogonResponse::_internal_has_in_game_heartbeat_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_in_game_heartbeat_seconds() const {
  return _internal_has_in_game_heartbeat_seconds();
}
inline void CMsgClientLogonResponse::clear_in_game_heartbeat_seconds() {
  _impl_.in_game_heartbeat_seconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t CMsgClientLogonResponse::_internal_in_game_heartbeat_seconds() const {
  return _impl_.in_game_heartbeat_seconds_;
}
inline int32_t CMsgClientLogonResponse::in_game_heartbeat_seconds() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.in_game_heartbeat_seconds)
  return _internal_in_game_heartbeat_seconds();
}
inline void CMsgClientLogonResponse::_internal_set_in_game_heartbeat_seconds(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.in_game_heartbeat_seconds_ = value;
}
inline void CMsgClientLogonResponse::set_in_game_heartbeat_seconds(int32_t value) {
  _internal_set_in_game_heartbeat_seconds(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.in_game_heartbeat_seconds)
}

// optional uint32 deprecated_public_ip = 4;
inline bool CMsgClientLogonResponse::_internal_has_deprecated_public_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_deprecated_public_ip() const {
  return _internal_has_deprecated_public_ip();
}
inline void CMsgClientLogonResponse::clear_deprecated_public_ip() {
  _impl_.deprecated_public_ip_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t CMsgClientLogonResponse::_internal_deprecated_public_ip() const {
  return _impl_.deprecated_public_ip_;
}
inline uint32_t CMsgClientLogonResponse::deprecated_public_ip() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.deprecated_public_ip)
  return _internal_deprecated_public_ip();
}
inline void CMsgClientLogonResponse::_internal_set_deprecated_public_ip(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.deprecated_public_ip_ = value;
}
inline void CMsgClientLogonResponse::set_deprecated_public_ip(uint32_t value) {
  _internal_set_deprecated_public_ip(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.deprecated_public_ip)
}

// optional fixed32 rtime32_server_time = 5;
inline bool CMsgClientLogonResponse::_internal_has_rtime32_server_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_rtime32_server_time() const {
  return _internal_has_rtime32_server_time();
}
inline void CMsgClientLogonResponse::clear_rtime32_server_time() {
  _impl_.rtime32_server_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t CMsgClientLogonResponse::_internal_rtime32_server_time() const {
  return _impl_.rtime32_server_time_;
}
inline uint32_t CMsgClientLogonResponse::rtime32_server_time() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.rtime32_server_time)
  return _internal_rtime32_server_time();
}
inline void CMsgClientLogonResponse::_internal_set_rtime32_server_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.rtime32_server_time_ = value;
}
inline void CMsgClientLogonResponse::set_rtime32_server_time(uint32_t value) {
  _internal_set_rtime32_server_time(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.rtime32_server_time)
}

// optional uint32 account_flags = 6;
inline bool CMsgClientLogonResponse::_internal_has_account_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_account_flags() const {
  return _internal_has_account_flags();
}
inline void CMsgClientLogonResponse::clear_account_flags() {
  _impl_.account_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint32_t CMsgClientLogonResponse::_internal_account_flags() const {
  return _impl_.account_flags_;
}
inline uint32_t CMsgClientLogonResponse::account_flags() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.account_flags)
  return _internal_account_flags();
}
inline void CMsgClientLogonResponse::_internal_set_account_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.account_flags_ = value;
}
inline void CMsgClientLogonResponse::set_account_flags(uint32_t value) {
  _internal_set_account_flags(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.account_flags)
}

// optional uint32 cell_id = 7;
inline bool CMsgClientLogonResponse::_internal_has_cell_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_cell_id() const {
  return _internal_has_cell_id();
}
inline void CMsgClientLogonResponse::clear_cell_id() {
  _impl_.cell_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t CMsgClientLogonResponse::_internal_cell_id() const {
  return _impl_.cell_id_;
}
inline uint32_t CMsgClientLogonResponse::cell_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.cell_id)
  return _internal_cell_id();
}
inline void CMsgClientLogonResponse::_internal_set_cell_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.cell_id_ = value;
}
inline void CMsgClientLogonResponse::set_cell_id(uint32_t value) {
  _internal_set_cell_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.cell_id)
}

// optional string email_domain = 8;
inline bool CMsgClientLogonResponse::_internal_has_email_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_email_domain() const {
  return _internal_has_email_domain();
}
inline void CMsgClientLogonResponse::clear_email_domain() {
  _impl_.email_domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgClientLogonResponse::email_domain() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.email_domain)
  return _internal_email_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogonResponse::set_email_domain(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.email_domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.email_domain)
}
inline std::string* CMsgClientLogonResponse::mutable_email_domain() {
  std::string* _s = _internal_mutable_email_domain();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogonResponse.email_domain)
  return _s;
}
inline const std::string& CMsgClientLogonResponse::_internal_email_domain() const {
  return _impl_.email_domain_.Get();
}
inline void CMsgClientLogonResponse::_internal_set_email_domain(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.email_domain_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::_internal_mutable_email_domain() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.email_domain_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::release_email_domain() {
  // @@protoc_insertion_point(field_release:CMsgClientLogonResponse.email_domain)
  if (!_internal_has_email_domain()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.email_domain_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_domain_.IsDefault()) {
    _impl_.email_domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogonResponse::set_allocated_email_domain(std::string* email_domain) {
  if (email_domain != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.email_domain_.SetAllocated(email_domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_domain_.IsDefault()) {
    _impl_.email_domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogonResponse.email_domain)
}

// optional bytes steam2_ticket = 9;
inline bool CMsgClientLogonResponse::_internal_has_steam2_ticket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_steam2_ticket() const {
  return _internal_has_steam2_ticket();
}
inline void CMsgClientLogonResponse::clear_steam2_ticket() {
  _impl_.steam2_ticket_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgClientLogonResponse::steam2_ticket() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.steam2_ticket)
  return _internal_steam2_ticket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogonResponse::set_steam2_ticket(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.steam2_ticket_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.steam2_ticket)
}
inline std::string* CMsgClientLogonResponse::mutable_steam2_ticket() {
  std::string* _s = _internal_mutable_steam2_ticket();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogonResponse.steam2_ticket)
  return _s;
}
inline const std::string& CMsgClientLogonResponse::_internal_steam2_ticket() const {
  return _impl_.steam2_ticket_.Get();
}
inline void CMsgClientLogonResponse::_internal_set_steam2_ticket(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.steam2_ticket_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::_internal_mutable_steam2_ticket() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.steam2_ticket_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::release_steam2_ticket() {
  // @@protoc_insertion_point(field_release:CMsgClientLogonResponse.steam2_ticket)
  if (!_internal_has_steam2_ticket()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.steam2_ticket_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.steam2_ticket_.IsDefault()) {
    _impl_.steam2_ticket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogonResponse::set_allocated_steam2_ticket(std::string* steam2_ticket) {
  if (steam2_ticket != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.steam2_ticket_.SetAllocated(steam2_ticket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.steam2_ticket_.IsDefault()) {
    _impl_.steam2_ticket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogonResponse.steam2_ticket)
}

// optional int32 eresult_extended = 10;
inline bool CMsgClientLogonResponse::_internal_has_eresult_extended() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_eresult_extended() const {
  return _internal_has_eresult_extended();
}
inline void CMsgClientLogonResponse::clear_eresult_extended() {
  _impl_.eresult_extended_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t CMsgClientLogonResponse::_internal_eresult_extended() const {
  return _impl_.eresult_extended_;
}
inline int32_t CMsgClientLogonResponse::eresult_extended() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.eresult_extended)
  return _internal_eresult_extended();
}
inline void CMsgClientLogonResponse::_internal_set_eresult_extended(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.eresult_extended_ = value;
}
inline void CMsgClientLogonResponse::set_eresult_extended(int32_t value) {
  _internal_set_eresult_extended(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.eresult_extended)
}

// optional string webapi_authenticate_user_nonce = 11;
inline bool CMsgClientLogonResponse::_internal_has_webapi_authenticate_user_nonce() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_webapi_authenticate_user_nonce() const {
  return _internal_has_webapi_authenticate_user_nonce();
}
inline void CMsgClientLogonResponse::clear_webapi_authenticate_user_nonce() {
  _impl_.webapi_authenticate_user_nonce_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgClientLogonResponse::webapi_authenticate_user_nonce() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.webapi_authenticate_user_nonce)
  return _internal_webapi_authenticate_user_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogonResponse::set_webapi_authenticate_user_nonce(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.webapi_authenticate_user_nonce_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.webapi_authenticate_user_nonce)
}
inline std::string* CMsgClientLogonResponse::mutable_webapi_authenticate_user_nonce() {
  std::string* _s = _internal_mutable_webapi_authenticate_user_nonce();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogonResponse.webapi_authenticate_user_nonce)
  return _s;
}
inline const std::string& CMsgClientLogonResponse::_internal_webapi_authenticate_user_nonce() const {
  return _impl_.webapi_authenticate_user_nonce_.Get();
}
inline void CMsgClientLogonResponse::_internal_set_webapi_authenticate_user_nonce(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.webapi_authenticate_user_nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::_internal_mutable_webapi_authenticate_user_nonce() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.webapi_authenticate_user_nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::release_webapi_authenticate_user_nonce() {
  // @@protoc_insertion_point(field_release:CMsgClientLogonResponse.webapi_authenticate_user_nonce)
  if (!_internal_has_webapi_authenticate_user_nonce()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.webapi_authenticate_user_nonce_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.webapi_authenticate_user_nonce_.IsDefault()) {
    _impl_.webapi_authenticate_user_nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogonResponse::set_allocated_webapi_authenticate_user_nonce(std::string* webapi_authenticate_user_nonce) {
  if (webapi_authenticate_user_nonce != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.webapi_authenticate_user_nonce_.SetAllocated(webapi_authenticate_user_nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.webapi_authenticate_user_nonce_.IsDefault()) {
    _impl_.webapi_authenticate_user_nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogonResponse.webapi_authenticate_user_nonce)
}

// optional uint32 cell_id_ping_threshold = 12;
inline bool CMsgClientLogonResponse::_internal_has_cell_id_ping_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_cell_id_ping_threshold() const {
  return _internal_has_cell_id_ping_threshold();
}
inline void CMsgClientLogonResponse::clear_cell_id_ping_threshold() {
  _impl_.cell_id_ping_threshold_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline uint32_t CMsgClientLogonResponse::_internal_cell_id_ping_threshold() const {
  return _impl_.cell_id_ping_threshold_;
}
inline uint32_t CMsgClientLogonResponse::cell_id_ping_threshold() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.cell_id_ping_threshold)
  return _internal_cell_id_ping_threshold();
}
inline void CMsgClientLogonResponse::_internal_set_cell_id_ping_threshold(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.cell_id_ping_threshold_ = value;
}
inline void CMsgClientLogonResponse::set_cell_id_ping_threshold(uint32_t value) {
  _internal_set_cell_id_ping_threshold(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.cell_id_ping_threshold)
}

// optional bool use_pics = 13;
inline bool CMsgClientLogonResponse::_internal_has_use_pics() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_use_pics() const {
  return _internal_has_use_pics();
}
inline void CMsgClientLogonResponse::clear_use_pics() {
  _impl_.use_pics_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool CMsgClientLogonResponse::_internal_use_pics() const {
  return _impl_.use_pics_;
}
inline bool CMsgClientLogonResponse::use_pics() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.use_pics)
  return _internal_use_pics();
}
inline void CMsgClientLogonResponse::_internal_set_use_pics(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.use_pics_ = value;
}
inline void CMsgClientLogonResponse::set_use_pics(bool value) {
  _internal_set_use_pics(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.use_pics)
}

// optional string vanity_url = 14;
inline bool CMsgClientLogonResponse::_internal_has_vanity_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_vanity_url() const {
  return _internal_has_vanity_url();
}
inline void CMsgClientLogonResponse::clear_vanity_url() {
  _impl_.vanity_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CMsgClientLogonResponse::vanity_url() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.vanity_url)
  return _internal_vanity_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogonResponse::set_vanity_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.vanity_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.vanity_url)
}
inline std::string* CMsgClientLogonResponse::mutable_vanity_url() {
  std::string* _s = _internal_mutable_vanity_url();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogonResponse.vanity_url)
  return _s;
}
inline const std::string& CMsgClientLogonResponse::_internal_vanity_url() const {
  return _impl_.vanity_url_.Get();
}
inline void CMsgClientLogonResponse::_internal_set_vanity_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.vanity_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::_internal_mutable_vanity_url() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.vanity_url_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::release_vanity_url() {
  // @@protoc_insertion_point(field_release:CMsgClientLogonResponse.vanity_url)
  if (!_internal_has_vanity_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.vanity_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vanity_url_.IsDefault()) {
    _impl_.vanity_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogonResponse::set_allocated_vanity_url(std::string* vanity_url) {
  if (vanity_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.vanity_url_.SetAllocated(vanity_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vanity_url_.IsDefault()) {
    _impl_.vanity_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogonResponse.vanity_url)
}

// optional .CMsgIPAddress public_ip = 15;
inline bool CMsgClientLogonResponse::_internal_has_public_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.public_ip_ != nullptr);
  return value;
}
inline bool CMsgClientLogonResponse::has_public_ip() const {
  return _internal_has_public_ip();
}
inline const ::CMsgIPAddress& CMsgClientLogonResponse::_internal_public_ip() const {
  const ::CMsgIPAddress* p = _impl_.public_ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgIPAddress&>(
      ::_CMsgIPAddress_default_instance_);
}
inline const ::CMsgIPAddress& CMsgClientLogonResponse::public_ip() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.public_ip)
  return _internal_public_ip();
}
inline void CMsgClientLogonResponse::unsafe_arena_set_allocated_public_ip(
    ::CMsgIPAddress* public_ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_ip_);
  }
  _impl_.public_ip_ = public_ip;
  if (public_ip) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientLogonResponse.public_ip)
}
inline ::CMsgIPAddress* CMsgClientLogonResponse::release_public_ip() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::CMsgIPAddress* temp = _impl_.public_ip_;
  _impl_.public_ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgIPAddress* CMsgClientLogonResponse::unsafe_arena_release_public_ip() {
  // @@protoc_insertion_point(field_release:CMsgClientLogonResponse.public_ip)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::CMsgIPAddress* temp = _impl_.public_ip_;
  _impl_.public_ip_ = nullptr;
  return temp;
}
inline ::CMsgIPAddress* CMsgClientLogonResponse::_internal_mutable_public_ip() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.public_ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgIPAddress>(GetArenaForAllocation());
    _impl_.public_ip_ = p;
  }
  return _impl_.public_ip_;
}
inline ::CMsgIPAddress* CMsgClientLogonResponse::mutable_public_ip() {
  ::CMsgIPAddress* _msg = _internal_mutable_public_ip();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogonResponse.public_ip)
  return _msg;
}
inline void CMsgClientLogonResponse::set_allocated_public_ip(::CMsgIPAddress* public_ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_ip_);
  }
  if (public_ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_ip));
    if (message_arena != submessage_arena) {
      public_ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_ip, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.public_ip_ = public_ip;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogonResponse.public_ip)
}

// optional fixed64 client_supplied_steamid = 20;
inline bool CMsgClientLogonResponse::_internal_has_client_supplied_steamid() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_client_supplied_steamid() const {
  return _internal_has_client_supplied_steamid();
}
inline void CMsgClientLogonResponse::clear_client_supplied_steamid() {
  _impl_.client_supplied_steamid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline uint64_t CMsgClientLogonResponse::_internal_client_supplied_steamid() const {
  return _impl_.client_supplied_steamid_;
}
inline uint64_t CMsgClientLogonResponse::client_supplied_steamid() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.client_supplied_steamid)
  return _internal_client_supplied_steamid();
}
inline void CMsgClientLogonResponse::_internal_set_client_supplied_steamid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.client_supplied_steamid_ = value;
}
inline void CMsgClientLogonResponse::set_client_supplied_steamid(uint64_t value) {
  _internal_set_client_supplied_steamid(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.client_supplied_steamid)
}

// optional string ip_country_code = 21;
inline bool CMsgClientLogonResponse::_internal_has_ip_country_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_ip_country_code() const {
  return _internal_has_ip_country_code();
}
inline void CMsgClientLogonResponse::clear_ip_country_code() {
  _impl_.ip_country_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CMsgClientLogonResponse::ip_country_code() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.ip_country_code)
  return _internal_ip_country_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogonResponse::set_ip_country_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.ip_country_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.ip_country_code)
}
inline std::string* CMsgClientLogonResponse::mutable_ip_country_code() {
  std::string* _s = _internal_mutable_ip_country_code();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogonResponse.ip_country_code)
  return _s;
}
inline const std::string& CMsgClientLogonResponse::_internal_ip_country_code() const {
  return _impl_.ip_country_code_.Get();
}
inline void CMsgClientLogonResponse::_internal_set_ip_country_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ip_country_code_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::_internal_mutable_ip_country_code() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.ip_country_code_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::release_ip_country_code() {
  // @@protoc_insertion_point(field_release:CMsgClientLogonResponse.ip_country_code)
  if (!_internal_has_ip_country_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.ip_country_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_country_code_.IsDefault()) {
    _impl_.ip_country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogonResponse::set_allocated_ip_country_code(std::string* ip_country_code) {
  if (ip_country_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.ip_country_code_.SetAllocated(ip_country_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_country_code_.IsDefault()) {
    _impl_.ip_country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogonResponse.ip_country_code)
}

// optional bytes parental_settings = 22;
inline bool CMsgClientLogonResponse::_internal_has_parental_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_parental_settings() const {
  return _internal_has_parental_settings();
}
inline void CMsgClientLogonResponse::clear_parental_settings() {
  _impl_.parental_settings_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CMsgClientLogonResponse::parental_settings() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.parental_settings)
  return _internal_parental_settings();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogonResponse::set_parental_settings(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.parental_settings_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.parental_settings)
}
inline std::string* CMsgClientLogonResponse::mutable_parental_settings() {
  std::string* _s = _internal_mutable_parental_settings();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogonResponse.parental_settings)
  return _s;
}
inline const std::string& CMsgClientLogonResponse::_internal_parental_settings() const {
  return _impl_.parental_settings_.Get();
}
inline void CMsgClientLogonResponse::_internal_set_parental_settings(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.parental_settings_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::_internal_mutable_parental_settings() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.parental_settings_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::release_parental_settings() {
  // @@protoc_insertion_point(field_release:CMsgClientLogonResponse.parental_settings)
  if (!_internal_has_parental_settings()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.parental_settings_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parental_settings_.IsDefault()) {
    _impl_.parental_settings_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogonResponse::set_allocated_parental_settings(std::string* parental_settings) {
  if (parental_settings != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.parental_settings_.SetAllocated(parental_settings, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parental_settings_.IsDefault()) {
    _impl_.parental_settings_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogonResponse.parental_settings)
}

// optional bytes parental_setting_signature = 23;
inline bool CMsgClientLogonResponse::_internal_has_parental_setting_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_parental_setting_signature() const {
  return _internal_has_parental_setting_signature();
}
inline void CMsgClientLogonResponse::clear_parental_setting_signature() {
  _impl_.parental_setting_signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CMsgClientLogonResponse::parental_setting_signature() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.parental_setting_signature)
  return _internal_parental_setting_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientLogonResponse::set_parental_setting_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.parental_setting_signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.parental_setting_signature)
}
inline std::string* CMsgClientLogonResponse::mutable_parental_setting_signature() {
  std::string* _s = _internal_mutable_parental_setting_signature();
  // @@protoc_insertion_point(field_mutable:CMsgClientLogonResponse.parental_setting_signature)
  return _s;
}
inline const std::string& CMsgClientLogonResponse::_internal_parental_setting_signature() const {
  return _impl_.parental_setting_signature_.Get();
}
inline void CMsgClientLogonResponse::_internal_set_parental_setting_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.parental_setting_signature_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::_internal_mutable_parental_setting_signature() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.parental_setting_signature_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientLogonResponse::release_parental_setting_signature() {
  // @@protoc_insertion_point(field_release:CMsgClientLogonResponse.parental_setting_signature)
  if (!_internal_has_parental_setting_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.parental_setting_signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parental_setting_signature_.IsDefault()) {
    _impl_.parental_setting_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientLogonResponse::set_allocated_parental_setting_signature(std::string* parental_setting_signature) {
  if (parental_setting_signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.parental_setting_signature_.SetAllocated(parental_setting_signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parental_setting_signature_.IsDefault()) {
    _impl_.parental_setting_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientLogonResponse.parental_setting_signature)
}

// optional int32 count_loginfailures_to_migrate = 24;
inline bool CMsgClientLogonResponse::_internal_has_count_loginfailures_to_migrate() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_count_loginfailures_to_migrate() const {
  return _internal_has_count_loginfailures_to_migrate();
}
inline void CMsgClientLogonResponse::clear_count_loginfailures_to_migrate() {
  _impl_.count_loginfailures_to_migrate_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline int32_t CMsgClientLogonResponse::_internal_count_loginfailures_to_migrate() const {
  return _impl_.count_loginfailures_to_migrate_;
}
inline int32_t CMsgClientLogonResponse::count_loginfailures_to_migrate() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.count_loginfailures_to_migrate)
  return _internal_count_loginfailures_to_migrate();
}
inline void CMsgClientLogonResponse::_internal_set_count_loginfailures_to_migrate(int32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.count_loginfailures_to_migrate_ = value;
}
inline void CMsgClientLogonResponse::set_count_loginfailures_to_migrate(int32_t value) {
  _internal_set_count_loginfailures_to_migrate(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.count_loginfailures_to_migrate)
}

// optional int32 count_disconnects_to_migrate = 25;
inline bool CMsgClientLogonResponse::_internal_has_count_disconnects_to_migrate() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_count_disconnects_to_migrate() const {
  return _internal_has_count_disconnects_to_migrate();
}
inline void CMsgClientLogonResponse::clear_count_disconnects_to_migrate() {
  _impl_.count_disconnects_to_migrate_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline int32_t CMsgClientLogonResponse::_internal_count_disconnects_to_migrate() const {
  return _impl_.count_disconnects_to_migrate_;
}
inline int32_t CMsgClientLogonResponse::count_disconnects_to_migrate() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.count_disconnects_to_migrate)
  return _internal_count_disconnects_to_migrate();
}
inline void CMsgClientLogonResponse::_internal_set_count_disconnects_to_migrate(int32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.count_disconnects_to_migrate_ = value;
}
inline void CMsgClientLogonResponse::set_count_disconnects_to_migrate(int32_t value) {
  _internal_set_count_disconnects_to_migrate(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.count_disconnects_to_migrate)
}

// optional int32 ogs_data_report_time_window = 26;
inline bool CMsgClientLogonResponse::_internal_has_ogs_data_report_time_window() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_ogs_data_report_time_window() const {
  return _internal_has_ogs_data_report_time_window();
}
inline void CMsgClientLogonResponse::clear_ogs_data_report_time_window() {
  _impl_.ogs_data_report_time_window_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline int32_t CMsgClientLogonResponse::_internal_ogs_data_report_time_window() const {
  return _impl_.ogs_data_report_time_window_;
}
inline int32_t CMsgClientLogonResponse::ogs_data_report_time_window() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.ogs_data_report_time_window)
  return _internal_ogs_data_report_time_window();
}
inline void CMsgClientLogonResponse::_internal_set_ogs_data_report_time_window(int32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.ogs_data_report_time_window_ = value;
}
inline void CMsgClientLogonResponse::set_ogs_data_report_time_window(int32_t value) {
  _internal_set_ogs_data_report_time_window(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.ogs_data_report_time_window)
}

// optional uint64 client_instance_id = 27;
inline bool CMsgClientLogonResponse::_internal_has_client_instance_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_client_instance_id() const {
  return _internal_has_client_instance_id();
}
inline void CMsgClientLogonResponse::clear_client_instance_id() {
  _impl_.client_instance_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline uint64_t CMsgClientLogonResponse::_internal_client_instance_id() const {
  return _impl_.client_instance_id_;
}
inline uint64_t CMsgClientLogonResponse::client_instance_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.client_instance_id)
  return _internal_client_instance_id();
}
inline void CMsgClientLogonResponse::_internal_set_client_instance_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.client_instance_id_ = value;
}
inline void CMsgClientLogonResponse::set_client_instance_id(uint64_t value) {
  _internal_set_client_instance_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.client_instance_id)
}

// optional bool force_client_update_check = 28;
inline bool CMsgClientLogonResponse::_internal_has_force_client_update_check() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgClientLogonResponse::has_force_client_update_check() const {
  return _internal_has_force_client_update_check();
}
inline void CMsgClientLogonResponse::clear_force_client_update_check() {
  _impl_.force_client_update_check_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool CMsgClientLogonResponse::_internal_force_client_update_check() const {
  return _impl_.force_client_update_check_;
}
inline bool CMsgClientLogonResponse::force_client_update_check() const {
  // @@protoc_insertion_point(field_get:CMsgClientLogonResponse.force_client_update_check)
  return _internal_force_client_update_check();
}
inline void CMsgClientLogonResponse::_internal_set_force_client_update_check(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.force_client_update_check_ = value;
}
inline void CMsgClientLogonResponse::set_force_client_update_check(bool value) {
  _internal_set_force_client_update_check(value);
  // @@protoc_insertion_point(field_set:CMsgClientLogonResponse.force_client_update_check)
}

// -------------------------------------------------------------------

// CMsgClientRequestWebAPIAuthenticateUserNonce

// optional int32 token_type = 1 [default = -1];
inline bool CMsgClientRequestWebAPIAuthenticateUserNonce::_internal_has_token_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientRequestWebAPIAuthenticateUserNonce::has_token_type() const {
  return _internal_has_token_type();
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonce::clear_token_type() {
  _impl_.token_type_ = -1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CMsgClientRequestWebAPIAuthenticateUserNonce::_internal_token_type() const {
  return _impl_.token_type_;
}
inline int32_t CMsgClientRequestWebAPIAuthenticateUserNonce::token_type() const {
  // @@protoc_insertion_point(field_get:CMsgClientRequestWebAPIAuthenticateUserNonce.token_type)
  return _internal_token_type();
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonce::_internal_set_token_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_type_ = value;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonce::set_token_type(int32_t value) {
  _internal_set_token_type(value);
  // @@protoc_insertion_point(field_set:CMsgClientRequestWebAPIAuthenticateUserNonce.token_type)
}

// -------------------------------------------------------------------

// CMsgClientRequestWebAPIAuthenticateUserNonceResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientRequestWebAPIAuthenticateUserNonceResponse::_internal_has_eresult() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientRequestWebAPIAuthenticateUserNonceResponse::has_eresult() const {
  return _internal_has_eresult();
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_eresult() {
  _impl_.eresult_ = 2;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CMsgClientRequestWebAPIAuthenticateUserNonceResponse::_internal_eresult() const {
  return _impl_.eresult_;
}
inline int32_t CMsgClientRequestWebAPIAuthenticateUserNonceResponse::eresult() const {
  // @@protoc_insertion_point(field_get:CMsgClientRequestWebAPIAuthenticateUserNonceResponse.eresult)
  return _internal_eresult();
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::_internal_set_eresult(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.eresult_ = value;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_eresult(int32_t value) {
  _internal_set_eresult(value);
  // @@protoc_insertion_point(field_set:CMsgClientRequestWebAPIAuthenticateUserNonceResponse.eresult)
}

// optional string webapi_authenticate_user_nonce = 11;
inline bool CMsgClientRequestWebAPIAuthenticateUserNonceResponse::_internal_has_webapi_authenticate_user_nonce() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientRequestWebAPIAuthenticateUserNonceResponse::has_webapi_authenticate_user_nonce() const {
  return _internal_has_webapi_authenticate_user_nonce();
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_webapi_authenticate_user_nonce() {
  _impl_.webapi_authenticate_user_nonce_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgClientRequestWebAPIAuthenticateUserNonceResponse::webapi_authenticate_user_nonce() const {
  // @@protoc_insertion_point(field_get:CMsgClientRequestWebAPIAuthenticateUserNonceResponse.webapi_authenticate_user_nonce)
  return _internal_webapi_authenticate_user_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_webapi_authenticate_user_nonce(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.webapi_authenticate_user_nonce_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientRequestWebAPIAuthenticateUserNonceResponse.webapi_authenticate_user_nonce)
}
inline std::string* CMsgClientRequestWebAPIAuthenticateUserNonceResponse::mutable_webapi_authenticate_user_nonce() {
  std::string* _s = _internal_mutable_webapi_authenticate_user_nonce();
  // @@protoc_insertion_point(field_mutable:CMsgClientRequestWebAPIAuthenticateUserNonceResponse.webapi_authenticate_user_nonce)
  return _s;
}
inline const std::string& CMsgClientRequestWebAPIAuthenticateUserNonceResponse::_internal_webapi_authenticate_user_nonce() const {
  return _impl_.webapi_authenticate_user_nonce_.Get();
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::_internal_set_webapi_authenticate_user_nonce(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.webapi_authenticate_user_nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientRequestWebAPIAuthenticateUserNonceResponse::_internal_mutable_webapi_authenticate_user_nonce() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.webapi_authenticate_user_nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientRequestWebAPIAuthenticateUserNonceResponse::release_webapi_authenticate_user_nonce() {
  // @@protoc_insertion_point(field_release:CMsgClientRequestWebAPIAuthenticateUserNonceResponse.webapi_authenticate_user_nonce)
  if (!_internal_has_webapi_authenticate_user_nonce()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.webapi_authenticate_user_nonce_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.webapi_authenticate_user_nonce_.IsDefault()) {
    _impl_.webapi_authenticate_user_nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_allocated_webapi_authenticate_user_nonce(std::string* webapi_authenticate_user_nonce) {
  if (webapi_authenticate_user_nonce != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.webapi_authenticate_user_nonce_.SetAllocated(webapi_authenticate_user_nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.webapi_authenticate_user_nonce_.IsDefault()) {
    _impl_.webapi_authenticate_user_nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientRequestWebAPIAuthenticateUserNonceResponse.webapi_authenticate_user_nonce)
}

// optional int32 token_type = 3 [default = -1];
inline bool CMsgClientRequestWebAPIAuthenticateUserNonceResponse::_internal_has_token_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientRequestWebAPIAuthenticateUserNonceResponse::has_token_type() const {
  return _internal_has_token_type();
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_token_type() {
  _impl_.token_type_ = -1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t CMsgClientRequestWebAPIAuthenticateUserNonceResponse::_internal_token_type() const {
  return _impl_.token_type_;
}
inline int32_t CMsgClientRequestWebAPIAuthenticateUserNonceResponse::token_type() const {
  // @@protoc_insertion_point(field_get:CMsgClientRequestWebAPIAuthenticateUserNonceResponse.token_type)
  return _internal_token_type();
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::_internal_set_token_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.token_type_ = value;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_token_type(int32_t value) {
  _internal_set_token_type(value);
  // @@protoc_insertion_point(field_set:CMsgClientRequestWebAPIAuthenticateUserNonceResponse.token_type)
}

// -------------------------------------------------------------------

// CMsgClientLogOff

// -------------------------------------------------------------------

// CMsgClientLoggedOff

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientLoggedOff::_internal_has_eresult() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientLoggedOff::has_eresult() const {
  return _internal_has_eresult();
}
inline void CMsgClientLoggedOff::clear_eresult() {
  _impl_.eresult_ = 2;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CMsgClientLoggedOff::_internal_eresult() const {
  return _impl_.eresult_;
}
inline int32_t CMsgClientLoggedOff::eresult() const {
  // @@protoc_insertion_point(field_get:CMsgClientLoggedOff.eresult)
  return _internal_eresult();
}
inline void CMsgClientLoggedOff::_internal_set_eresult(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.eresult_ = value;
}
inline void CMsgClientLoggedOff::set_eresult(int32_t value) {
  _internal_set_eresult(value);
  // @@protoc_insertion_point(field_set:CMsgClientLoggedOff.eresult)
}

// -------------------------------------------------------------------

// CMsgClientNewLoginKey

// optional uint32 unique_id = 1;
inline bool CMsgClientNewLoginKey::_internal_has_unique_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientNewLoginKey::has_unique_id() const {
  return _internal_has_unique_id();
}
inline void CMsgClientNewLoginKey::clear_unique_id() {
  _impl_.unique_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientNewLoginKey::_internal_unique_id() const {
  return _impl_.unique_id_;
}
inline uint32_t CMsgClientNewLoginKey::unique_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientNewLoginKey.unique_id)
  return _internal_unique_id();
}
inline void CMsgClientNewLoginKey::_internal_set_unique_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.unique_id_ = value;
}
inline void CMsgClientNewLoginKey::set_unique_id(uint32_t value) {
  _internal_set_unique_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientNewLoginKey.unique_id)
}

// optional string login_key = 2;
inline bool CMsgClientNewLoginKey::_internal_has_login_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientNewLoginKey::has_login_key() const {
  return _internal_has_login_key();
}
inline void CMsgClientNewLoginKey::clear_login_key() {
  _impl_.login_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgClientNewLoginKey::login_key() const {
  // @@protoc_insertion_point(field_get:CMsgClientNewLoginKey.login_key)
  return _internal_login_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientNewLoginKey::set_login_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.login_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientNewLoginKey.login_key)
}
inline std::string* CMsgClientNewLoginKey::mutable_login_key() {
  std::string* _s = _internal_mutable_login_key();
  // @@protoc_insertion_point(field_mutable:CMsgClientNewLoginKey.login_key)
  return _s;
}
inline const std::string& CMsgClientNewLoginKey::_internal_login_key() const {
  return _impl_.login_key_.Get();
}
inline void CMsgClientNewLoginKey::_internal_set_login_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.login_key_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientNewLoginKey::_internal_mutable_login_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.login_key_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientNewLoginKey::release_login_key() {
  // @@protoc_insertion_point(field_release:CMsgClientNewLoginKey.login_key)
  if (!_internal_has_login_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.login_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_key_.IsDefault()) {
    _impl_.login_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientNewLoginKey::set_allocated_login_key(std::string* login_key) {
  if (login_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.login_key_.SetAllocated(login_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_key_.IsDefault()) {
    _impl_.login_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientNewLoginKey.login_key)
}

// -------------------------------------------------------------------

// CMsgClientNewLoginKeyAccepted

// optional uint32 unique_id = 1;
inline bool CMsgClientNewLoginKeyAccepted::_internal_has_unique_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientNewLoginKeyAccepted::has_unique_id() const {
  return _internal_has_unique_id();
}
inline void CMsgClientNewLoginKeyAccepted::clear_unique_id() {
  _impl_.unique_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgClientNewLoginKeyAccepted::_internal_unique_id() const {
  return _impl_.unique_id_;
}
inline uint32_t CMsgClientNewLoginKeyAccepted::unique_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientNewLoginKeyAccepted.unique_id)
  return _internal_unique_id();
}
inline void CMsgClientNewLoginKeyAccepted::_internal_set_unique_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.unique_id_ = value;
}
inline void CMsgClientNewLoginKeyAccepted::set_unique_id(uint32_t value) {
  _internal_set_unique_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientNewLoginKeyAccepted.unique_id)
}

// -------------------------------------------------------------------

// CMsgClientAccountInfo

// optional string persona_name = 1;
inline bool CMsgClientAccountInfo::_internal_has_persona_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientAccountInfo::has_persona_name() const {
  return _internal_has_persona_name();
}
inline void CMsgClientAccountInfo::clear_persona_name() {
  _impl_.persona_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgClientAccountInfo::persona_name() const {
  // @@protoc_insertion_point(field_get:CMsgClientAccountInfo.persona_name)
  return _internal_persona_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientAccountInfo::set_persona_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.persona_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientAccountInfo.persona_name)
}
inline std::string* CMsgClientAccountInfo::mutable_persona_name() {
  std::string* _s = _internal_mutable_persona_name();
  // @@protoc_insertion_point(field_mutable:CMsgClientAccountInfo.persona_name)
  return _s;
}
inline const std::string& CMsgClientAccountInfo::_internal_persona_name() const {
  return _impl_.persona_name_.Get();
}
inline void CMsgClientAccountInfo::_internal_set_persona_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.persona_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientAccountInfo::_internal_mutable_persona_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.persona_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientAccountInfo::release_persona_name() {
  // @@protoc_insertion_point(field_release:CMsgClientAccountInfo.persona_name)
  if (!_internal_has_persona_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.persona_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.persona_name_.IsDefault()) {
    _impl_.persona_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientAccountInfo::set_allocated_persona_name(std::string* persona_name) {
  if (persona_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.persona_name_.SetAllocated(persona_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.persona_name_.IsDefault()) {
    _impl_.persona_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientAccountInfo.persona_name)
}

// optional string ip_country = 2;
inline bool CMsgClientAccountInfo::_internal_has_ip_country() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientAccountInfo::has_ip_country() const {
  return _internal_has_ip_country();
}
inline void CMsgClientAccountInfo::clear_ip_country() {
  _impl_.ip_country_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgClientAccountInfo::ip_country() const {
  // @@protoc_insertion_point(field_get:CMsgClientAccountInfo.ip_country)
  return _internal_ip_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientAccountInfo::set_ip_country(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ip_country_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientAccountInfo.ip_country)
}
inline std::string* CMsgClientAccountInfo::mutable_ip_country() {
  std::string* _s = _internal_mutable_ip_country();
  // @@protoc_insertion_point(field_mutable:CMsgClientAccountInfo.ip_country)
  return _s;
}
inline const std::string& CMsgClientAccountInfo::_internal_ip_country() const {
  return _impl_.ip_country_.Get();
}
inline void CMsgClientAccountInfo::_internal_set_ip_country(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ip_country_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientAccountInfo::_internal_mutable_ip_country() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ip_country_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientAccountInfo::release_ip_country() {
  // @@protoc_insertion_point(field_release:CMsgClientAccountInfo.ip_country)
  if (!_internal_has_ip_country()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ip_country_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_country_.IsDefault()) {
    _impl_.ip_country_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientAccountInfo::set_allocated_ip_country(std::string* ip_country) {
  if (ip_country != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ip_country_.SetAllocated(ip_country, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_country_.IsDefault()) {
    _impl_.ip_country_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientAccountInfo.ip_country)
}

// optional int32 count_authed_computers = 5;
inline bool CMsgClientAccountInfo::_internal_has_count_authed_computers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgClientAccountInfo::has_count_authed_computers() const {
  return _internal_has_count_authed_computers();
}
inline void CMsgClientAccountInfo::clear_count_authed_computers() {
  _impl_.count_authed_computers_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t CMsgClientAccountInfo::_internal_count_authed_computers() const {
  return _impl_.count_authed_computers_;
}
inline int32_t CMsgClientAccountInfo::count_authed_computers() const {
  // @@protoc_insertion_point(field_get:CMsgClientAccountInfo.count_authed_computers)
  return _internal_count_authed_computers();
}
inline void CMsgClientAccountInfo::_internal_set_count_authed_computers(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.count_authed_computers_ = value;
}
inline void CMsgClientAccountInfo::set_count_authed_computers(int32_t value) {
  _internal_set_count_authed_computers(value);
  // @@protoc_insertion_point(field_set:CMsgClientAccountInfo.count_authed_computers)
}

// optional uint32 account_flags = 7;
inline bool CMsgClientAccountInfo::_internal_has_account_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgClientAccountInfo::has_account_flags() const {
  return _internal_has_account_flags();
}
inline void CMsgClientAccountInfo::clear_account_flags() {
  _impl_.account_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgClientAccountInfo::_internal_account_flags() const {
  return _impl_.account_flags_;
}
inline uint32_t CMsgClientAccountInfo::account_flags() const {
  // @@protoc_insertion_point(field_get:CMsgClientAccountInfo.account_flags)
  return _internal_account_flags();
}
inline void CMsgClientAccountInfo::_internal_set_account_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.account_flags_ = value;
}
inline void CMsgClientAccountInfo::set_account_flags(uint32_t value) {
  _internal_set_account_flags(value);
  // @@protoc_insertion_point(field_set:CMsgClientAccountInfo.account_flags)
}

// optional uint64 facebook_id = 8;
inline bool CMsgClientAccountInfo::_internal_has_facebook_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgClientAccountInfo::has_facebook_id() const {
  return _internal_has_facebook_id();
}
inline void CMsgClientAccountInfo::clear_facebook_id() {
  _impl_.facebook_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t CMsgClientAccountInfo::_internal_facebook_id() const {
  return _impl_.facebook_id_;
}
inline uint64_t CMsgClientAccountInfo::facebook_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientAccountInfo.facebook_id)
  return _internal_facebook_id();
}
inline void CMsgClientAccountInfo::_internal_set_facebook_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.facebook_id_ = value;
}
inline void CMsgClientAccountInfo::set_facebook_id(uint64_t value) {
  _internal_set_facebook_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientAccountInfo.facebook_id)
}

// optional string facebook_name = 9;
inline bool CMsgClientAccountInfo::_internal_has_facebook_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientAccountInfo::has_facebook_name() const {
  return _internal_has_facebook_name();
}
inline void CMsgClientAccountInfo::clear_facebook_name() {
  _impl_.facebook_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgClientAccountInfo::facebook_name() const {
  // @@protoc_insertion_point(field_get:CMsgClientAccountInfo.facebook_name)
  return _internal_facebook_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientAccountInfo::set_facebook_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.facebook_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientAccountInfo.facebook_name)
}
inline std::string* CMsgClientAccountInfo::mutable_facebook_name() {
  std::string* _s = _internal_mutable_facebook_name();
  // @@protoc_insertion_point(field_mutable:CMsgClientAccountInfo.facebook_name)
  return _s;
}
inline const std::string& CMsgClientAccountInfo::_internal_facebook_name() const {
  return _impl_.facebook_name_.Get();
}
inline void CMsgClientAccountInfo::_internal_set_facebook_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.facebook_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientAccountInfo::_internal_mutable_facebook_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.facebook_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientAccountInfo::release_facebook_name() {
  // @@protoc_insertion_point(field_release:CMsgClientAccountInfo.facebook_name)
  if (!_internal_has_facebook_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.facebook_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.facebook_name_.IsDefault()) {
    _impl_.facebook_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientAccountInfo::set_allocated_facebook_name(std::string* facebook_name) {
  if (facebook_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.facebook_name_.SetAllocated(facebook_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.facebook_name_.IsDefault()) {
    _impl_.facebook_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientAccountInfo.facebook_name)
}

// optional bool steamguard_notify_newmachines = 14;
inline bool CMsgClientAccountInfo::_internal_has_steamguard_notify_newmachines() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgClientAccountInfo::has_steamguard_notify_newmachines() const {
  return _internal_has_steamguard_notify_newmachines();
}
inline void CMsgClientAccountInfo::clear_steamguard_notify_newmachines() {
  _impl_.steamguard_notify_newmachines_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool CMsgClientAccountInfo::_internal_steamguard_notify_newmachines() const {
  return _impl_.steamguard_notify_newmachines_;
}
inline bool CMsgClientAccountInfo::steamguard_notify_newmachines() const {
  // @@protoc_insertion_point(field_get:CMsgClientAccountInfo.steamguard_notify_newmachines)
  return _internal_steamguard_notify_newmachines();
}
inline void CMsgClientAccountInfo::_internal_set_steamguard_notify_newmachines(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.steamguard_notify_newmachines_ = value;
}
inline void CMsgClientAccountInfo::set_steamguard_notify_newmachines(bool value) {
  _internal_set_steamguard_notify_newmachines(value);
  // @@protoc_insertion_point(field_set:CMsgClientAccountInfo.steamguard_notify_newmachines)
}

// optional string steamguard_machine_name_user_chosen = 15;
inline bool CMsgClientAccountInfo::_internal_has_steamguard_machine_name_user_chosen() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgClientAccountInfo::has_steamguard_machine_name_user_chosen() const {
  return _internal_has_steamguard_machine_name_user_chosen();
}
inline void CMsgClientAccountInfo::clear_steamguard_machine_name_user_chosen() {
  _impl_.steamguard_machine_name_user_chosen_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CMsgClientAccountInfo::steamguard_machine_name_user_chosen() const {
  // @@protoc_insertion_point(field_get:CMsgClientAccountInfo.steamguard_machine_name_user_chosen)
  return _internal_steamguard_machine_name_user_chosen();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientAccountInfo::set_steamguard_machine_name_user_chosen(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.steamguard_machine_name_user_chosen_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientAccountInfo.steamguard_machine_name_user_chosen)
}
inline std::string* CMsgClientAccountInfo::mutable_steamguard_machine_name_user_chosen() {
  std::string* _s = _internal_mutable_steamguard_machine_name_user_chosen();
  // @@protoc_insertion_point(field_mutable:CMsgClientAccountInfo.steamguard_machine_name_user_chosen)
  return _s;
}
inline const std::string& CMsgClientAccountInfo::_internal_steamguard_machine_name_user_chosen() const {
  return _impl_.steamguard_machine_name_user_chosen_.Get();
}
inline void CMsgClientAccountInfo::_internal_set_steamguard_machine_name_user_chosen(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.steamguard_machine_name_user_chosen_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientAccountInfo::_internal_mutable_steamguard_machine_name_user_chosen() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.steamguard_machine_name_user_chosen_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientAccountInfo::release_steamguard_machine_name_user_chosen() {
  // @@protoc_insertion_point(field_release:CMsgClientAccountInfo.steamguard_machine_name_user_chosen)
  if (!_internal_has_steamguard_machine_name_user_chosen()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.steamguard_machine_name_user_chosen_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.steamguard_machine_name_user_chosen_.IsDefault()) {
    _impl_.steamguard_machine_name_user_chosen_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientAccountInfo::set_allocated_steamguard_machine_name_user_chosen(std::string* steamguard_machine_name_user_chosen) {
  if (steamguard_machine_name_user_chosen != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.steamguard_machine_name_user_chosen_.SetAllocated(steamguard_machine_name_user_chosen, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.steamguard_machine_name_user_chosen_.IsDefault()) {
    _impl_.steamguard_machine_name_user_chosen_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientAccountInfo.steamguard_machine_name_user_chosen)
}

// optional bool is_phone_verified = 16;
inline bool CMsgClientAccountInfo::_internal_has_is_phone_verified() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgClientAccountInfo::has_is_phone_verified() const {
  return _internal_has_is_phone_verified();
}
inline void CMsgClientAccountInfo::clear_is_phone_verified() {
  _impl_.is_phone_verified_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool CMsgClientAccountInfo::_internal_is_phone_verified() const {
  return _impl_.is_phone_verified_;
}
inline bool CMsgClientAccountInfo::is_phone_verified() const {
  // @@protoc_insertion_point(field_get:CMsgClientAccountInfo.is_phone_verified)
  return _internal_is_phone_verified();
}
inline void CMsgClientAccountInfo::_internal_set_is_phone_verified(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.is_phone_verified_ = value;
}
inline void CMsgClientAccountInfo::set_is_phone_verified(bool value) {
  _internal_set_is_phone_verified(value);
  // @@protoc_insertion_point(field_set:CMsgClientAccountInfo.is_phone_verified)
}

// optional uint32 two_factor_state = 17;
inline bool CMsgClientAccountInfo::_internal_has_two_factor_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgClientAccountInfo::has_two_factor_state() const {
  return _internal_has_two_factor_state();
}
inline void CMsgClientAccountInfo::clear_two_factor_state() {
  _impl_.two_factor_state_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t CMsgClientAccountInfo::_internal_two_factor_state() const {
  return _impl_.two_factor_state_;
}
inline uint32_t CMsgClientAccountInfo::two_factor_state() const {
  // @@protoc_insertion_point(field_get:CMsgClientAccountInfo.two_factor_state)
  return _internal_two_factor_state();
}
inline void CMsgClientAccountInfo::_internal_set_two_factor_state(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.two_factor_state_ = value;
}
inline void CMsgClientAccountInfo::set_two_factor_state(uint32_t value) {
  _internal_set_two_factor_state(value);
  // @@protoc_insertion_point(field_set:CMsgClientAccountInfo.two_factor_state)
}

// optional bool is_phone_identifying = 18;
inline bool CMsgClientAccountInfo::_internal_has_is_phone_identifying() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgClientAccountInfo::has_is_phone_identifying() const {
  return _internal_has_is_phone_identifying();
}
inline void CMsgClientAccountInfo::clear_is_phone_identifying() {
  _impl_.is_phone_identifying_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool CMsgClientAccountInfo::_internal_is_phone_identifying() const {
  return _impl_.is_phone_identifying_;
}
inline bool CMsgClientAccountInfo::is_phone_identifying() const {
  // @@protoc_insertion_point(field_get:CMsgClientAccountInfo.is_phone_identifying)
  return _internal_is_phone_identifying();
}
inline void CMsgClientAccountInfo::_internal_set_is_phone_identifying(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.is_phone_identifying_ = value;
}
inline void CMsgClientAccountInfo::set_is_phone_identifying(bool value) {
  _internal_set_is_phone_identifying(value);
  // @@protoc_insertion_point(field_set:CMsgClientAccountInfo.is_phone_identifying)
}

// optional bool is_phone_needing_reverify = 19;
inline bool CMsgClientAccountInfo::_internal_has_is_phone_needing_reverify() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgClientAccountInfo::has_is_phone_needing_reverify() const {
  return _internal_has_is_phone_needing_reverify();
}
inline void CMsgClientAccountInfo::clear_is_phone_needing_reverify() {
  _impl_.is_phone_needing_reverify_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool CMsgClientAccountInfo::_internal_is_phone_needing_reverify() const {
  return _impl_.is_phone_needing_reverify_;
}
inline bool CMsgClientAccountInfo::is_phone_needing_reverify() const {
  // @@protoc_insertion_point(field_get:CMsgClientAccountInfo.is_phone_needing_reverify)
  return _internal_is_phone_needing_reverify();
}
inline void CMsgClientAccountInfo::_internal_set_is_phone_needing_reverify(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.is_phone_needing_reverify_ = value;
}
inline void CMsgClientAccountInfo::set_is_phone_needing_reverify(bool value) {
  _internal_set_is_phone_needing_reverify(value);
  // @@protoc_insertion_point(field_set:CMsgClientAccountInfo.is_phone_needing_reverify)
}

// -------------------------------------------------------------------

// CMsgClientChallengeRequest

// optional fixed64 steamid = 1;
inline bool CMsgClientChallengeRequest::_internal_has_steamid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientChallengeRequest::has_steamid() const {
  return _internal_has_steamid();
}
inline void CMsgClientChallengeRequest::clear_steamid() {
  _impl_.steamid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgClientChallengeRequest::_internal_steamid() const {
  return _impl_.steamid_;
}
inline uint64_t CMsgClientChallengeRequest::steamid() const {
  // @@protoc_insertion_point(field_get:CMsgClientChallengeRequest.steamid)
  return _internal_steamid();
}
inline void CMsgClientChallengeRequest::_internal_set_steamid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.steamid_ = value;
}
inline void CMsgClientChallengeRequest::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CMsgClientChallengeRequest.steamid)
}

// -------------------------------------------------------------------

// CMsgClientChallengeResponse

// optional fixed64 challenge = 1;
inline bool CMsgClientChallengeResponse::_internal_has_challenge() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientChallengeResponse::has_challenge() const {
  return _internal_has_challenge();
}
inline void CMsgClientChallengeResponse::clear_challenge() {
  _impl_.challenge_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgClientChallengeResponse::_internal_challenge() const {
  return _impl_.challenge_;
}
inline uint64_t CMsgClientChallengeResponse::challenge() const {
  // @@protoc_insertion_point(field_get:CMsgClientChallengeResponse.challenge)
  return _internal_challenge();
}
inline void CMsgClientChallengeResponse::_internal_set_challenge(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.challenge_ = value;
}
inline void CMsgClientChallengeResponse::set_challenge(uint64_t value) {
  _internal_set_challenge(value);
  // @@protoc_insertion_point(field_set:CMsgClientChallengeResponse.challenge)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_steammessages_5fclientserver_5flogin_2eproto
