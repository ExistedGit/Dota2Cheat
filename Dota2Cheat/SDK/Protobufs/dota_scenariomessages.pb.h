// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_scenariomessages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dota_5fscenariomessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dota_5fscenariomessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "dota_shared_enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dota_5fscenariomessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dota_5fscenariomessages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dota_5fscenariomessages_2eproto;
class CMsgDotaScenario;
struct CMsgDotaScenarioDefaultTypeInternal;
extern CMsgDotaScenarioDefaultTypeInternal _CMsgDotaScenario_default_instance_;
class CMsgDotaScenario_Building;
struct CMsgDotaScenario_BuildingDefaultTypeInternal;
extern CMsgDotaScenario_BuildingDefaultTypeInternal _CMsgDotaScenario_Building_default_instance_;
class CMsgDotaScenario_DamageStatsByType;
struct CMsgDotaScenario_DamageStatsByTypeDefaultTypeInternal;
extern CMsgDotaScenario_DamageStatsByTypeDefaultTypeInternal _CMsgDotaScenario_DamageStatsByType_default_instance_;
class CMsgDotaScenario_Entity;
struct CMsgDotaScenario_EntityDefaultTypeInternal;
extern CMsgDotaScenario_EntityDefaultTypeInternal _CMsgDotaScenario_Entity_default_instance_;
class CMsgDotaScenario_EntityRef;
struct CMsgDotaScenario_EntityRefDefaultTypeInternal;
extern CMsgDotaScenario_EntityRefDefaultTypeInternal _CMsgDotaScenario_EntityRef_default_instance_;
class CMsgDotaScenario_Game;
struct CMsgDotaScenario_GameDefaultTypeInternal;
extern CMsgDotaScenario_GameDefaultTypeInternal _CMsgDotaScenario_Game_default_instance_;
class CMsgDotaScenario_Hero;
struct CMsgDotaScenario_HeroDefaultTypeInternal;
extern CMsgDotaScenario_HeroDefaultTypeInternal _CMsgDotaScenario_Hero_default_instance_;
class CMsgDotaScenario_HeroAbility;
struct CMsgDotaScenario_HeroAbilityDefaultTypeInternal;
extern CMsgDotaScenario_HeroAbilityDefaultTypeInternal _CMsgDotaScenario_HeroAbility_default_instance_;
class CMsgDotaScenario_HeroHeroFloat;
struct CMsgDotaScenario_HeroHeroFloatDefaultTypeInternal;
extern CMsgDotaScenario_HeroHeroFloatDefaultTypeInternal _CMsgDotaScenario_HeroHeroFloat_default_instance_;
class CMsgDotaScenario_HeroHeroInt;
struct CMsgDotaScenario_HeroHeroIntDefaultTypeInternal;
extern CMsgDotaScenario_HeroHeroIntDefaultTypeInternal _CMsgDotaScenario_HeroHeroInt_default_instance_;
class CMsgDotaScenario_Item;
struct CMsgDotaScenario_ItemDefaultTypeInternal;
extern CMsgDotaScenario_ItemDefaultTypeInternal _CMsgDotaScenario_Item_default_instance_;
class CMsgDotaScenario_Modifier;
struct CMsgDotaScenario_ModifierDefaultTypeInternal;
extern CMsgDotaScenario_ModifierDefaultTypeInternal _CMsgDotaScenario_Modifier_default_instance_;
class CMsgDotaScenario_Stock;
struct CMsgDotaScenario_StockDefaultTypeInternal;
extern CMsgDotaScenario_StockDefaultTypeInternal _CMsgDotaScenario_Stock_default_instance_;
class CMsgDotaScenario_Team;
struct CMsgDotaScenario_TeamDefaultTypeInternal;
extern CMsgDotaScenario_TeamDefaultTypeInternal _CMsgDotaScenario_Team_default_instance_;
class CMsgDotaScenario_TeamNeutralItem;
struct CMsgDotaScenario_TeamNeutralItemDefaultTypeInternal;
extern CMsgDotaScenario_TeamNeutralItemDefaultTypeInternal _CMsgDotaScenario_TeamNeutralItem_default_instance_;
class CScenarioEnt_Courier;
struct CScenarioEnt_CourierDefaultTypeInternal;
extern CScenarioEnt_CourierDefaultTypeInternal _CScenarioEnt_Courier_default_instance_;
class CScenarioEnt_DroppedItem;
struct CScenarioEnt_DroppedItemDefaultTypeInternal;
extern CScenarioEnt_DroppedItemDefaultTypeInternal _CScenarioEnt_DroppedItem_default_instance_;
class CScenarioEnt_NPC;
struct CScenarioEnt_NPCDefaultTypeInternal;
extern CScenarioEnt_NPCDefaultTypeInternal _CScenarioEnt_NPC_default_instance_;
class CScenarioEnt_SpiritBear;
struct CScenarioEnt_SpiritBearDefaultTypeInternal;
extern CScenarioEnt_SpiritBearDefaultTypeInternal _CScenarioEnt_SpiritBear_default_instance_;
class CScenarioGame_RoshanSpawner;
struct CScenarioGame_RoshanSpawnerDefaultTypeInternal;
extern CScenarioGame_RoshanSpawnerDefaultTypeInternal _CScenarioGame_RoshanSpawner_default_instance_;
class CScenario_Position;
struct CScenario_PositionDefaultTypeInternal;
extern CScenario_PositionDefaultTypeInternal _CScenario_Position_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CMsgDotaScenario* Arena::CreateMaybeMessage<::CMsgDotaScenario>(Arena*);
template<> ::CMsgDotaScenario_Building* Arena::CreateMaybeMessage<::CMsgDotaScenario_Building>(Arena*);
template<> ::CMsgDotaScenario_DamageStatsByType* Arena::CreateMaybeMessage<::CMsgDotaScenario_DamageStatsByType>(Arena*);
template<> ::CMsgDotaScenario_Entity* Arena::CreateMaybeMessage<::CMsgDotaScenario_Entity>(Arena*);
template<> ::CMsgDotaScenario_EntityRef* Arena::CreateMaybeMessage<::CMsgDotaScenario_EntityRef>(Arena*);
template<> ::CMsgDotaScenario_Game* Arena::CreateMaybeMessage<::CMsgDotaScenario_Game>(Arena*);
template<> ::CMsgDotaScenario_Hero* Arena::CreateMaybeMessage<::CMsgDotaScenario_Hero>(Arena*);
template<> ::CMsgDotaScenario_HeroAbility* Arena::CreateMaybeMessage<::CMsgDotaScenario_HeroAbility>(Arena*);
template<> ::CMsgDotaScenario_HeroHeroFloat* Arena::CreateMaybeMessage<::CMsgDotaScenario_HeroHeroFloat>(Arena*);
template<> ::CMsgDotaScenario_HeroHeroInt* Arena::CreateMaybeMessage<::CMsgDotaScenario_HeroHeroInt>(Arena*);
template<> ::CMsgDotaScenario_Item* Arena::CreateMaybeMessage<::CMsgDotaScenario_Item>(Arena*);
template<> ::CMsgDotaScenario_Modifier* Arena::CreateMaybeMessage<::CMsgDotaScenario_Modifier>(Arena*);
template<> ::CMsgDotaScenario_Stock* Arena::CreateMaybeMessage<::CMsgDotaScenario_Stock>(Arena*);
template<> ::CMsgDotaScenario_Team* Arena::CreateMaybeMessage<::CMsgDotaScenario_Team>(Arena*);
template<> ::CMsgDotaScenario_TeamNeutralItem* Arena::CreateMaybeMessage<::CMsgDotaScenario_TeamNeutralItem>(Arena*);
template<> ::CScenarioEnt_Courier* Arena::CreateMaybeMessage<::CScenarioEnt_Courier>(Arena*);
template<> ::CScenarioEnt_DroppedItem* Arena::CreateMaybeMessage<::CScenarioEnt_DroppedItem>(Arena*);
template<> ::CScenarioEnt_NPC* Arena::CreateMaybeMessage<::CScenarioEnt_NPC>(Arena*);
template<> ::CScenarioEnt_SpiritBear* Arena::CreateMaybeMessage<::CScenarioEnt_SpiritBear>(Arena*);
template<> ::CScenarioGame_RoshanSpawner* Arena::CreateMaybeMessage<::CScenarioGame_RoshanSpawner>(Arena*);
template<> ::CScenario_Position* Arena::CreateMaybeMessage<::CScenario_Position>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class CScenario_Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CScenario_Position) */ {
 public:
  inline CScenario_Position() : CScenario_Position(nullptr) {}
  ~CScenario_Position() override;
  explicit PROTOBUF_CONSTEXPR CScenario_Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CScenario_Position(const CScenario_Position& from);
  CScenario_Position(CScenario_Position&& from) noexcept
    : CScenario_Position() {
    *this = ::std::move(from);
  }

  inline CScenario_Position& operator=(const CScenario_Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline CScenario_Position& operator=(CScenario_Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CScenario_Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const CScenario_Position* internal_default_instance() {
    return reinterpret_cast<const CScenario_Position*>(
               &_CScenario_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CScenario_Position& a, CScenario_Position& b) {
    a.Swap(&b);
  }
  inline void Swap(CScenario_Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CScenario_Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CScenario_Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CScenario_Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CScenario_Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CScenario_Position& from) {
    CScenario_Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CScenario_Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CScenario_Position";
  }
  protected:
  explicit CScenario_Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:CScenario_Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CScenarioGame_RoshanSpawner final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CScenarioGame_RoshanSpawner) */ {
 public:
  inline CScenarioGame_RoshanSpawner() : CScenarioGame_RoshanSpawner(nullptr) {}
  ~CScenarioGame_RoshanSpawner() override;
  explicit PROTOBUF_CONSTEXPR CScenarioGame_RoshanSpawner(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CScenarioGame_RoshanSpawner(const CScenarioGame_RoshanSpawner& from);
  CScenarioGame_RoshanSpawner(CScenarioGame_RoshanSpawner&& from) noexcept
    : CScenarioGame_RoshanSpawner() {
    *this = ::std::move(from);
  }

  inline CScenarioGame_RoshanSpawner& operator=(const CScenarioGame_RoshanSpawner& from) {
    CopyFrom(from);
    return *this;
  }
  inline CScenarioGame_RoshanSpawner& operator=(CScenarioGame_RoshanSpawner&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CScenarioGame_RoshanSpawner& default_instance() {
    return *internal_default_instance();
  }
  static inline const CScenarioGame_RoshanSpawner* internal_default_instance() {
    return reinterpret_cast<const CScenarioGame_RoshanSpawner*>(
               &_CScenarioGame_RoshanSpawner_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CScenarioGame_RoshanSpawner& a, CScenarioGame_RoshanSpawner& b) {
    a.Swap(&b);
  }
  inline void Swap(CScenarioGame_RoshanSpawner* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CScenarioGame_RoshanSpawner* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CScenarioGame_RoshanSpawner* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CScenarioGame_RoshanSpawner>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CScenarioGame_RoshanSpawner& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CScenarioGame_RoshanSpawner& from) {
    CScenarioGame_RoshanSpawner::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CScenarioGame_RoshanSpawner* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CScenarioGame_RoshanSpawner";
  }
  protected:
  explicit CScenarioGame_RoshanSpawner(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKillCountFieldNumber = 1,
    kStateFieldNumber = 2,
    kCooldownFieldNumber = 3,
  };
  // optional int32 kill_count = 1;
  bool has_kill_count() const;
  private:
  bool _internal_has_kill_count() const;
  public:
  void clear_kill_count();
  int32_t kill_count() const;
  void set_kill_count(int32_t value);
  private:
  int32_t _internal_kill_count() const;
  void _internal_set_kill_count(int32_t value);
  public:

  // optional int32 state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // optional float cooldown = 3;
  bool has_cooldown() const;
  private:
  bool _internal_has_cooldown() const;
  public:
  void clear_cooldown();
  float cooldown() const;
  void set_cooldown(float value);
  private:
  float _internal_cooldown() const;
  void _internal_set_cooldown(float value);
  public:

  // @@protoc_insertion_point(class_scope:CScenarioGame_RoshanSpawner)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t kill_count_;
    int32_t state_;
    float cooldown_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CScenarioEnt_Courier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CScenarioEnt_Courier) */ {
 public:
  inline CScenarioEnt_Courier() : CScenarioEnt_Courier(nullptr) {}
  ~CScenarioEnt_Courier() override;
  explicit PROTOBUF_CONSTEXPR CScenarioEnt_Courier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CScenarioEnt_Courier(const CScenarioEnt_Courier& from);
  CScenarioEnt_Courier(CScenarioEnt_Courier&& from) noexcept
    : CScenarioEnt_Courier() {
    *this = ::std::move(from);
  }

  inline CScenarioEnt_Courier& operator=(const CScenarioEnt_Courier& from) {
    CopyFrom(from);
    return *this;
  }
  inline CScenarioEnt_Courier& operator=(CScenarioEnt_Courier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CScenarioEnt_Courier& default_instance() {
    return *internal_default_instance();
  }
  static inline const CScenarioEnt_Courier* internal_default_instance() {
    return reinterpret_cast<const CScenarioEnt_Courier*>(
               &_CScenarioEnt_Courier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CScenarioEnt_Courier& a, CScenarioEnt_Courier& b) {
    a.Swap(&b);
  }
  inline void Swap(CScenarioEnt_Courier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CScenarioEnt_Courier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CScenarioEnt_Courier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CScenarioEnt_Courier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CScenarioEnt_Courier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CScenarioEnt_Courier& from) {
    CScenarioEnt_Courier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CScenarioEnt_Courier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CScenarioEnt_Courier";
  }
  protected:
  explicit CScenarioEnt_Courier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamNumberFieldNumber = 1,
    kOwnerPlayerIdFieldNumber = 2,
    kCooldownFieldNumber = 3,
  };
  // optional int32 team_number = 1;
  bool has_team_number() const;
  private:
  bool _internal_has_team_number() const;
  public:
  void clear_team_number();
  int32_t team_number() const;
  void set_team_number(int32_t value);
  private:
  int32_t _internal_team_number() const;
  void _internal_set_team_number(int32_t value);
  public:

  // optional int32 owner_player_id = 2 [default = -1];
  bool has_owner_player_id() const;
  private:
  bool _internal_has_owner_player_id() const;
  public:
  void clear_owner_player_id();
  int32_t owner_player_id() const;
  void set_owner_player_id(int32_t value);
  private:
  int32_t _internal_owner_player_id() const;
  void _internal_set_owner_player_id(int32_t value);
  public:

  // optional float cooldown = 3 [default = -1];
  bool has_cooldown() const;
  private:
  bool _internal_has_cooldown() const;
  public:
  void clear_cooldown();
  float cooldown() const;
  void set_cooldown(float value);
  private:
  float _internal_cooldown() const;
  void _internal_set_cooldown(float value);
  public:

  // @@protoc_insertion_point(class_scope:CScenarioEnt_Courier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t team_number_;
    int32_t owner_player_id_;
    float cooldown_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CScenarioEnt_NPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CScenarioEnt_NPC) */ {
 public:
  inline CScenarioEnt_NPC() : CScenarioEnt_NPC(nullptr) {}
  ~CScenarioEnt_NPC() override;
  explicit PROTOBUF_CONSTEXPR CScenarioEnt_NPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CScenarioEnt_NPC(const CScenarioEnt_NPC& from);
  CScenarioEnt_NPC(CScenarioEnt_NPC&& from) noexcept
    : CScenarioEnt_NPC() {
    *this = ::std::move(from);
  }

  inline CScenarioEnt_NPC& operator=(const CScenarioEnt_NPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline CScenarioEnt_NPC& operator=(CScenarioEnt_NPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CScenarioEnt_NPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const CScenarioEnt_NPC* internal_default_instance() {
    return reinterpret_cast<const CScenarioEnt_NPC*>(
               &_CScenarioEnt_NPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CScenarioEnt_NPC& a, CScenarioEnt_NPC& b) {
    a.Swap(&b);
  }
  inline void Swap(CScenarioEnt_NPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CScenarioEnt_NPC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CScenarioEnt_NPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CScenarioEnt_NPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CScenarioEnt_NPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CScenarioEnt_NPC& from) {
    CScenarioEnt_NPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CScenarioEnt_NPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CScenarioEnt_NPC";
  }
  protected:
  explicit CScenarioEnt_NPC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitNameFieldNumber = 2,
    kOwningCampFieldNumber = 10,
    kInvadeGoalFieldNumber = 20,
    kPositionFieldNumber = 1,
    kOwningCampPositionFieldNumber = 11,
    kTeamNumberFieldNumber = 3,
    kHealthFracFieldNumber = 4,
  };
  // optional string unit_name = 2;
  bool has_unit_name() const;
  private:
  bool _internal_has_unit_name() const;
  public:
  void clear_unit_name();
  const std::string& unit_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit_name();
  PROTOBUF_NODISCARD std::string* release_unit_name();
  void set_allocated_unit_name(std::string* unit_name);
  private:
  const std::string& _internal_unit_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit_name(const std::string& value);
  std::string* _internal_mutable_unit_name();
  public:

  // optional string owning_camp = 10;
  bool has_owning_camp() const;
  private:
  bool _internal_has_owning_camp() const;
  public:
  void clear_owning_camp();
  const std::string& owning_camp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owning_camp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owning_camp();
  PROTOBUF_NODISCARD std::string* release_owning_camp();
  void set_allocated_owning_camp(std::string* owning_camp);
  private:
  const std::string& _internal_owning_camp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owning_camp(const std::string& value);
  std::string* _internal_mutable_owning_camp();
  public:

  // optional string invade_goal = 20;
  bool has_invade_goal() const;
  private:
  bool _internal_has_invade_goal() const;
  public:
  void clear_invade_goal();
  const std::string& invade_goal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invade_goal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invade_goal();
  PROTOBUF_NODISCARD std::string* release_invade_goal();
  void set_allocated_invade_goal(std::string* invade_goal);
  private:
  const std::string& _internal_invade_goal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invade_goal(const std::string& value);
  std::string* _internal_mutable_invade_goal();
  public:

  // optional .CScenario_Position position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::CScenario_Position& position() const;
  PROTOBUF_NODISCARD ::CScenario_Position* release_position();
  ::CScenario_Position* mutable_position();
  void set_allocated_position(::CScenario_Position* position);
  private:
  const ::CScenario_Position& _internal_position() const;
  ::CScenario_Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::CScenario_Position* position);
  ::CScenario_Position* unsafe_arena_release_position();

  // optional .CScenario_Position owning_camp_position = 11;
  bool has_owning_camp_position() const;
  private:
  bool _internal_has_owning_camp_position() const;
  public:
  void clear_owning_camp_position();
  const ::CScenario_Position& owning_camp_position() const;
  PROTOBUF_NODISCARD ::CScenario_Position* release_owning_camp_position();
  ::CScenario_Position* mutable_owning_camp_position();
  void set_allocated_owning_camp_position(::CScenario_Position* owning_camp_position);
  private:
  const ::CScenario_Position& _internal_owning_camp_position() const;
  ::CScenario_Position* _internal_mutable_owning_camp_position();
  public:
  void unsafe_arena_set_allocated_owning_camp_position(
      ::CScenario_Position* owning_camp_position);
  ::CScenario_Position* unsafe_arena_release_owning_camp_position();

  // optional int32 team_number = 3;
  bool has_team_number() const;
  private:
  bool _internal_has_team_number() const;
  public:
  void clear_team_number();
  int32_t team_number() const;
  void set_team_number(int32_t value);
  private:
  int32_t _internal_team_number() const;
  void _internal_set_team_number(int32_t value);
  public:

  // optional float health_frac = 4 [default = 1];
  bool has_health_frac() const;
  private:
  bool _internal_has_health_frac() const;
  public:
  void clear_health_frac();
  float health_frac() const;
  void set_health_frac(float value);
  private:
  float _internal_health_frac() const;
  void _internal_set_health_frac(float value);
  public:

  // @@protoc_insertion_point(class_scope:CScenarioEnt_NPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owning_camp_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invade_goal_;
    ::CScenario_Position* position_;
    ::CScenario_Position* owning_camp_position_;
    int32_t team_number_;
    float health_frac_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CScenarioEnt_SpiritBear final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CScenarioEnt_SpiritBear) */ {
 public:
  inline CScenarioEnt_SpiritBear() : CScenarioEnt_SpiritBear(nullptr) {}
  ~CScenarioEnt_SpiritBear() override;
  explicit PROTOBUF_CONSTEXPR CScenarioEnt_SpiritBear(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CScenarioEnt_SpiritBear(const CScenarioEnt_SpiritBear& from);
  CScenarioEnt_SpiritBear(CScenarioEnt_SpiritBear&& from) noexcept
    : CScenarioEnt_SpiritBear() {
    *this = ::std::move(from);
  }

  inline CScenarioEnt_SpiritBear& operator=(const CScenarioEnt_SpiritBear& from) {
    CopyFrom(from);
    return *this;
  }
  inline CScenarioEnt_SpiritBear& operator=(CScenarioEnt_SpiritBear&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CScenarioEnt_SpiritBear& default_instance() {
    return *internal_default_instance();
  }
  static inline const CScenarioEnt_SpiritBear* internal_default_instance() {
    return reinterpret_cast<const CScenarioEnt_SpiritBear*>(
               &_CScenarioEnt_SpiritBear_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CScenarioEnt_SpiritBear& a, CScenarioEnt_SpiritBear& b) {
    a.Swap(&b);
  }
  inline void Swap(CScenarioEnt_SpiritBear* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CScenarioEnt_SpiritBear* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CScenarioEnt_SpiritBear* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CScenarioEnt_SpiritBear>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CScenarioEnt_SpiritBear& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CScenarioEnt_SpiritBear& from) {
    CScenarioEnt_SpiritBear::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CScenarioEnt_SpiritBear* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CScenarioEnt_SpiritBear";
  }
  protected:
  explicit CScenarioEnt_SpiritBear(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamIdFieldNumber = 2,
    kOwnerIdFieldNumber = 1,
  };
  // optional int32 team_id = 2;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  int32_t team_id() const;
  void set_team_id(int32_t value);
  private:
  int32_t _internal_team_id() const;
  void _internal_set_team_id(int32_t value);
  public:

  // optional int32 owner_id = 1 [default = -1];
  bool has_owner_id() const;
  private:
  bool _internal_has_owner_id() const;
  public:
  void clear_owner_id();
  int32_t owner_id() const;
  void set_owner_id(int32_t value);
  private:
  int32_t _internal_owner_id() const;
  void _internal_set_owner_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CScenarioEnt_SpiritBear)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t team_id_;
    int32_t owner_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CScenarioEnt_DroppedItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CScenarioEnt_DroppedItem) */ {
 public:
  inline CScenarioEnt_DroppedItem() : CScenarioEnt_DroppedItem(nullptr) {}
  ~CScenarioEnt_DroppedItem() override;
  explicit PROTOBUF_CONSTEXPR CScenarioEnt_DroppedItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CScenarioEnt_DroppedItem(const CScenarioEnt_DroppedItem& from);
  CScenarioEnt_DroppedItem(CScenarioEnt_DroppedItem&& from) noexcept
    : CScenarioEnt_DroppedItem() {
    *this = ::std::move(from);
  }

  inline CScenarioEnt_DroppedItem& operator=(const CScenarioEnt_DroppedItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline CScenarioEnt_DroppedItem& operator=(CScenarioEnt_DroppedItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CScenarioEnt_DroppedItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const CScenarioEnt_DroppedItem* internal_default_instance() {
    return reinterpret_cast<const CScenarioEnt_DroppedItem*>(
               &_CScenarioEnt_DroppedItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CScenarioEnt_DroppedItem& a, CScenarioEnt_DroppedItem& b) {
    a.Swap(&b);
  }
  inline void Swap(CScenarioEnt_DroppedItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CScenarioEnt_DroppedItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CScenarioEnt_DroppedItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CScenarioEnt_DroppedItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CScenarioEnt_DroppedItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CScenarioEnt_DroppedItem& from) {
    CScenarioEnt_DroppedItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CScenarioEnt_DroppedItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CScenarioEnt_DroppedItem";
  }
  protected:
  explicit CScenarioEnt_DroppedItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
  };
  // optional .CScenario_Position position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::CScenario_Position& position() const;
  PROTOBUF_NODISCARD ::CScenario_Position* release_position();
  ::CScenario_Position* mutable_position();
  void set_allocated_position(::CScenario_Position* position);
  private:
  const ::CScenario_Position& _internal_position() const;
  ::CScenario_Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::CScenario_Position* position);
  ::CScenario_Position* unsafe_arena_release_position();

  // @@protoc_insertion_point(class_scope:CScenarioEnt_DroppedItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CScenario_Position* position_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_EntityRef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.EntityRef) */ {
 public:
  inline CMsgDotaScenario_EntityRef() : CMsgDotaScenario_EntityRef(nullptr) {}
  ~CMsgDotaScenario_EntityRef() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_EntityRef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_EntityRef(const CMsgDotaScenario_EntityRef& from);
  CMsgDotaScenario_EntityRef(CMsgDotaScenario_EntityRef&& from) noexcept
    : CMsgDotaScenario_EntityRef() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_EntityRef& operator=(const CMsgDotaScenario_EntityRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_EntityRef& operator=(CMsgDotaScenario_EntityRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_EntityRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_EntityRef* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_EntityRef*>(
               &_CMsgDotaScenario_EntityRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CMsgDotaScenario_EntityRef& a, CMsgDotaScenario_EntityRef& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_EntityRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_EntityRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_EntityRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_EntityRef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_EntityRef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_EntityRef& from) {
    CMsgDotaScenario_EntityRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_EntityRef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.EntityRef";
  }
  protected:
  explicit CMsgDotaScenario_EntityRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAbilityNameFieldNumber = 10,
    kRoshanFieldNumber = 4,
    kEntityIdxFieldNumber = 3,
    kPlayerIdFieldNumber = 1,
    kNeutralStashIdFieldNumber = 2,
  };
  // optional string ability_name = 10;
  bool has_ability_name() const;
  private:
  bool _internal_has_ability_name() const;
  public:
  void clear_ability_name();
  const std::string& ability_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ability_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ability_name();
  PROTOBUF_NODISCARD std::string* release_ability_name();
  void set_allocated_ability_name(std::string* ability_name);
  private:
  const std::string& _internal_ability_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ability_name(const std::string& value);
  std::string* _internal_mutable_ability_name();
  public:

  // optional bool roshan = 4 [default = false];
  bool has_roshan() const;
  private:
  bool _internal_has_roshan() const;
  public:
  void clear_roshan();
  bool roshan() const;
  void set_roshan(bool value);
  private:
  bool _internal_roshan() const;
  void _internal_set_roshan(bool value);
  public:

  // optional int32 entity_idx = 3 [default = -1];
  bool has_entity_idx() const;
  private:
  bool _internal_has_entity_idx() const;
  public:
  void clear_entity_idx();
  int32_t entity_idx() const;
  void set_entity_idx(int32_t value);
  private:
  int32_t _internal_entity_idx() const;
  void _internal_set_entity_idx(int32_t value);
  public:

  // optional int32 player_id = 1 [default = -1];
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // optional int32 neutral_stash_id = 2 [default = -1];
  bool has_neutral_stash_id() const;
  private:
  bool _internal_has_neutral_stash_id() const;
  public:
  void clear_neutral_stash_id();
  int32_t neutral_stash_id() const;
  void set_neutral_stash_id(int32_t value);
  private:
  int32_t _internal_neutral_stash_id() const;
  void _internal_set_neutral_stash_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.EntityRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ability_name_;
    bool roshan_;
    int32_t entity_idx_;
    int32_t player_id_;
    int32_t neutral_stash_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_Game final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.Game) */ {
 public:
  inline CMsgDotaScenario_Game() : CMsgDotaScenario_Game(nullptr) {}
  ~CMsgDotaScenario_Game() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_Game(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_Game(const CMsgDotaScenario_Game& from);
  CMsgDotaScenario_Game(CMsgDotaScenario_Game&& from) noexcept
    : CMsgDotaScenario_Game() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_Game& operator=(const CMsgDotaScenario_Game& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_Game& operator=(CMsgDotaScenario_Game&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_Game& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_Game* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_Game*>(
               &_CMsgDotaScenario_Game_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CMsgDotaScenario_Game& a, CMsgDotaScenario_Game& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_Game* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_Game* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_Game* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_Game>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_Game& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_Game& from) {
    CMsgDotaScenario_Game::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_Game* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.Game";
  }
  protected:
  explicit CMsgDotaScenario_Game(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoshanFieldNumber = 5,
    kMatchIdFieldNumber = 1,
    kGameModeFieldNumber = 2,
    kClockTimeFieldNumber = 3,
    kInternalTimeFieldNumber = 4,
  };
  // optional .CScenarioGame_RoshanSpawner roshan = 5;
  bool has_roshan() const;
  private:
  bool _internal_has_roshan() const;
  public:
  void clear_roshan();
  const ::CScenarioGame_RoshanSpawner& roshan() const;
  PROTOBUF_NODISCARD ::CScenarioGame_RoshanSpawner* release_roshan();
  ::CScenarioGame_RoshanSpawner* mutable_roshan();
  void set_allocated_roshan(::CScenarioGame_RoshanSpawner* roshan);
  private:
  const ::CScenarioGame_RoshanSpawner& _internal_roshan() const;
  ::CScenarioGame_RoshanSpawner* _internal_mutable_roshan();
  public:
  void unsafe_arena_set_allocated_roshan(
      ::CScenarioGame_RoshanSpawner* roshan);
  ::CScenarioGame_RoshanSpawner* unsafe_arena_release_roshan();

  // optional uint64 match_id = 1;
  bool has_match_id() const;
  private:
  bool _internal_has_match_id() const;
  public:
  void clear_match_id();
  uint64_t match_id() const;
  void set_match_id(uint64_t value);
  private:
  uint64_t _internal_match_id() const;
  void _internal_set_match_id(uint64_t value);
  public:

  // optional int32 game_mode = 2;
  bool has_game_mode() const;
  private:
  bool _internal_has_game_mode() const;
  public:
  void clear_game_mode();
  int32_t game_mode() const;
  void set_game_mode(int32_t value);
  private:
  int32_t _internal_game_mode() const;
  void _internal_set_game_mode(int32_t value);
  public:

  // optional float clock_time = 3;
  bool has_clock_time() const;
  private:
  bool _internal_has_clock_time() const;
  public:
  void clear_clock_time();
  float clock_time() const;
  void set_clock_time(float value);
  private:
  float _internal_clock_time() const;
  void _internal_set_clock_time(float value);
  public:

  // optional float internal_time = 4;
  bool has_internal_time() const;
  private:
  bool _internal_has_internal_time() const;
  public:
  void clear_internal_time();
  float internal_time() const;
  void set_internal_time(float value);
  private:
  float _internal_internal_time() const;
  void _internal_set_internal_time(float value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.Game)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CScenarioGame_RoshanSpawner* roshan_;
    uint64_t match_id_;
    int32_t game_mode_;
    float clock_time_;
    float internal_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_TeamNeutralItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.TeamNeutralItem) */ {
 public:
  inline CMsgDotaScenario_TeamNeutralItem() : CMsgDotaScenario_TeamNeutralItem(nullptr) {}
  ~CMsgDotaScenario_TeamNeutralItem() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_TeamNeutralItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_TeamNeutralItem(const CMsgDotaScenario_TeamNeutralItem& from);
  CMsgDotaScenario_TeamNeutralItem(CMsgDotaScenario_TeamNeutralItem&& from) noexcept
    : CMsgDotaScenario_TeamNeutralItem() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_TeamNeutralItem& operator=(const CMsgDotaScenario_TeamNeutralItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_TeamNeutralItem& operator=(CMsgDotaScenario_TeamNeutralItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_TeamNeutralItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_TeamNeutralItem* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_TeamNeutralItem*>(
               &_CMsgDotaScenario_TeamNeutralItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CMsgDotaScenario_TeamNeutralItem& a, CMsgDotaScenario_TeamNeutralItem& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_TeamNeutralItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_TeamNeutralItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_TeamNeutralItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_TeamNeutralItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_TeamNeutralItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_TeamNeutralItem& from) {
    CMsgDotaScenario_TeamNeutralItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_TeamNeutralItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.TeamNeutralItem";
  }
  protected:
  explicit CMsgDotaScenario_TeamNeutralItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kConsumedFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool consumed = 2;
  bool has_consumed() const;
  private:
  bool _internal_has_consumed() const;
  public:
  void clear_consumed();
  bool consumed() const;
  void set_consumed(bool value);
  private:
  bool _internal_consumed() const;
  void _internal_set_consumed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.TeamNeutralItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool consumed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_Team final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.Team) */ {
 public:
  inline CMsgDotaScenario_Team() : CMsgDotaScenario_Team(nullptr) {}
  ~CMsgDotaScenario_Team() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_Team(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_Team(const CMsgDotaScenario_Team& from);
  CMsgDotaScenario_Team(CMsgDotaScenario_Team&& from) noexcept
    : CMsgDotaScenario_Team() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_Team& operator=(const CMsgDotaScenario_Team& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_Team& operator=(CMsgDotaScenario_Team&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_Team& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_Team* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_Team*>(
               &_CMsgDotaScenario_Team_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CMsgDotaScenario_Team& a, CMsgDotaScenario_Team& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_Team* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_Team* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_Team* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_Team>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_Team& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_Team& from) {
    CMsgDotaScenario_Team::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_Team* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.Team";
  }
  protected:
  explicit CMsgDotaScenario_Team(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNeutralItemsFieldNumber = 2,
    kTeamNumberFieldNumber = 1,
    kHeroKillsFieldNumber = 3,
    kTowerKillsFieldNumber = 4,
    kBarracksKillsFieldNumber = 5,
    kGlyphCooldownFieldNumber = 6,
    kRadarCooldownFieldNumber = 7,
  };
  // repeated .CMsgDotaScenario.TeamNeutralItem neutral_items = 2;
  int neutral_items_size() const;
  private:
  int _internal_neutral_items_size() const;
  public:
  void clear_neutral_items();
  ::CMsgDotaScenario_TeamNeutralItem* mutable_neutral_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_TeamNeutralItem >*
      mutable_neutral_items();
  private:
  const ::CMsgDotaScenario_TeamNeutralItem& _internal_neutral_items(int index) const;
  ::CMsgDotaScenario_TeamNeutralItem* _internal_add_neutral_items();
  public:
  const ::CMsgDotaScenario_TeamNeutralItem& neutral_items(int index) const;
  ::CMsgDotaScenario_TeamNeutralItem* add_neutral_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_TeamNeutralItem >&
      neutral_items() const;

  // optional int32 team_number = 1;
  bool has_team_number() const;
  private:
  bool _internal_has_team_number() const;
  public:
  void clear_team_number();
  int32_t team_number() const;
  void set_team_number(int32_t value);
  private:
  int32_t _internal_team_number() const;
  void _internal_set_team_number(int32_t value);
  public:

  // optional int32 hero_kills = 3;
  bool has_hero_kills() const;
  private:
  bool _internal_has_hero_kills() const;
  public:
  void clear_hero_kills();
  int32_t hero_kills() const;
  void set_hero_kills(int32_t value);
  private:
  int32_t _internal_hero_kills() const;
  void _internal_set_hero_kills(int32_t value);
  public:

  // optional int32 tower_kills = 4;
  bool has_tower_kills() const;
  private:
  bool _internal_has_tower_kills() const;
  public:
  void clear_tower_kills();
  int32_t tower_kills() const;
  void set_tower_kills(int32_t value);
  private:
  int32_t _internal_tower_kills() const;
  void _internal_set_tower_kills(int32_t value);
  public:

  // optional int32 barracks_kills = 5;
  bool has_barracks_kills() const;
  private:
  bool _internal_has_barracks_kills() const;
  public:
  void clear_barracks_kills();
  int32_t barracks_kills() const;
  void set_barracks_kills(int32_t value);
  private:
  int32_t _internal_barracks_kills() const;
  void _internal_set_barracks_kills(int32_t value);
  public:

  // optional float glyph_cooldown = 6;
  bool has_glyph_cooldown() const;
  private:
  bool _internal_has_glyph_cooldown() const;
  public:
  void clear_glyph_cooldown();
  float glyph_cooldown() const;
  void set_glyph_cooldown(float value);
  private:
  float _internal_glyph_cooldown() const;
  void _internal_set_glyph_cooldown(float value);
  public:

  // optional float radar_cooldown = 7;
  bool has_radar_cooldown() const;
  private:
  bool _internal_has_radar_cooldown() const;
  public:
  void clear_radar_cooldown();
  float radar_cooldown() const;
  void set_radar_cooldown(float value);
  private:
  float _internal_radar_cooldown() const;
  void _internal_set_radar_cooldown(float value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.Team)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_TeamNeutralItem > neutral_items_;
    int32_t team_number_;
    int32_t hero_kills_;
    int32_t tower_kills_;
    int32_t barracks_kills_;
    float glyph_cooldown_;
    float radar_cooldown_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_HeroHeroInt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.HeroHeroInt) */ {
 public:
  inline CMsgDotaScenario_HeroHeroInt() : CMsgDotaScenario_HeroHeroInt(nullptr) {}
  ~CMsgDotaScenario_HeroHeroInt() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_HeroHeroInt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_HeroHeroInt(const CMsgDotaScenario_HeroHeroInt& from);
  CMsgDotaScenario_HeroHeroInt(CMsgDotaScenario_HeroHeroInt&& from) noexcept
    : CMsgDotaScenario_HeroHeroInt() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_HeroHeroInt& operator=(const CMsgDotaScenario_HeroHeroInt& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_HeroHeroInt& operator=(CMsgDotaScenario_HeroHeroInt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_HeroHeroInt& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_HeroHeroInt* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_HeroHeroInt*>(
               &_CMsgDotaScenario_HeroHeroInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CMsgDotaScenario_HeroHeroInt& a, CMsgDotaScenario_HeroHeroInt& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_HeroHeroInt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_HeroHeroInt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_HeroHeroInt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_HeroHeroInt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_HeroHeroInt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_HeroHeroInt& from) {
    CMsgDotaScenario_HeroHeroInt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_HeroHeroInt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.HeroHeroInt";
  }
  protected:
  explicit CMsgDotaScenario_HeroHeroInt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // optional int32 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // optional int32 player_id = 1 [default = -1];
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.HeroHeroInt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t value_;
    int32_t player_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_HeroHeroFloat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.HeroHeroFloat) */ {
 public:
  inline CMsgDotaScenario_HeroHeroFloat() : CMsgDotaScenario_HeroHeroFloat(nullptr) {}
  ~CMsgDotaScenario_HeroHeroFloat() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_HeroHeroFloat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_HeroHeroFloat(const CMsgDotaScenario_HeroHeroFloat& from);
  CMsgDotaScenario_HeroHeroFloat(CMsgDotaScenario_HeroHeroFloat&& from) noexcept
    : CMsgDotaScenario_HeroHeroFloat() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_HeroHeroFloat& operator=(const CMsgDotaScenario_HeroHeroFloat& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_HeroHeroFloat& operator=(CMsgDotaScenario_HeroHeroFloat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_HeroHeroFloat& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_HeroHeroFloat* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_HeroHeroFloat*>(
               &_CMsgDotaScenario_HeroHeroFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CMsgDotaScenario_HeroHeroFloat& a, CMsgDotaScenario_HeroHeroFloat& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_HeroHeroFloat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_HeroHeroFloat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_HeroHeroFloat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_HeroHeroFloat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_HeroHeroFloat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_HeroHeroFloat& from) {
    CMsgDotaScenario_HeroHeroFloat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_HeroHeroFloat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.HeroHeroFloat";
  }
  protected:
  explicit CMsgDotaScenario_HeroHeroFloat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // optional float value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // optional int32 player_id = 1 [default = -1];
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.HeroHeroFloat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float value_;
    int32_t player_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_DamageStatsByType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.DamageStatsByType) */ {
 public:
  inline CMsgDotaScenario_DamageStatsByType() : CMsgDotaScenario_DamageStatsByType(nullptr) {}
  ~CMsgDotaScenario_DamageStatsByType() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_DamageStatsByType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_DamageStatsByType(const CMsgDotaScenario_DamageStatsByType& from);
  CMsgDotaScenario_DamageStatsByType(CMsgDotaScenario_DamageStatsByType&& from) noexcept
    : CMsgDotaScenario_DamageStatsByType() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_DamageStatsByType& operator=(const CMsgDotaScenario_DamageStatsByType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_DamageStatsByType& operator=(CMsgDotaScenario_DamageStatsByType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_DamageStatsByType& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_DamageStatsByType* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_DamageStatsByType*>(
               &_CMsgDotaScenario_DamageStatsByType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CMsgDotaScenario_DamageStatsByType& a, CMsgDotaScenario_DamageStatsByType& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_DamageStatsByType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_DamageStatsByType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_DamageStatsByType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_DamageStatsByType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_DamageStatsByType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_DamageStatsByType& from) {
    CMsgDotaScenario_DamageStatsByType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_DamageStatsByType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.DamageStatsByType";
  }
  protected:
  explicit CMsgDotaScenario_DamageStatsByType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDamageTypeFieldNumber = 1,
    kReceivedPreReductionFieldNumber = 2,
    kReceivedPostReductionFieldNumber = 3,
    kOutgoingPreReductionFieldNumber = 4,
    kOutgoingPostReductionFieldNumber = 5,
  };
  // optional int32 damage_type = 1;
  bool has_damage_type() const;
  private:
  bool _internal_has_damage_type() const;
  public:
  void clear_damage_type();
  int32_t damage_type() const;
  void set_damage_type(int32_t value);
  private:
  int32_t _internal_damage_type() const;
  void _internal_set_damage_type(int32_t value);
  public:

  // optional int32 received_pre_reduction = 2;
  bool has_received_pre_reduction() const;
  private:
  bool _internal_has_received_pre_reduction() const;
  public:
  void clear_received_pre_reduction();
  int32_t received_pre_reduction() const;
  void set_received_pre_reduction(int32_t value);
  private:
  int32_t _internal_received_pre_reduction() const;
  void _internal_set_received_pre_reduction(int32_t value);
  public:

  // optional int32 received_post_reduction = 3;
  bool has_received_post_reduction() const;
  private:
  bool _internal_has_received_post_reduction() const;
  public:
  void clear_received_post_reduction();
  int32_t received_post_reduction() const;
  void set_received_post_reduction(int32_t value);
  private:
  int32_t _internal_received_post_reduction() const;
  void _internal_set_received_post_reduction(int32_t value);
  public:

  // optional int32 outgoing_pre_reduction = 4;
  bool has_outgoing_pre_reduction() const;
  private:
  bool _internal_has_outgoing_pre_reduction() const;
  public:
  void clear_outgoing_pre_reduction();
  int32_t outgoing_pre_reduction() const;
  void set_outgoing_pre_reduction(int32_t value);
  private:
  int32_t _internal_outgoing_pre_reduction() const;
  void _internal_set_outgoing_pre_reduction(int32_t value);
  public:

  // optional int32 outgoing_post_reduction = 5;
  bool has_outgoing_post_reduction() const;
  private:
  bool _internal_has_outgoing_post_reduction() const;
  public:
  void clear_outgoing_post_reduction();
  int32_t outgoing_post_reduction() const;
  void set_outgoing_post_reduction(int32_t value);
  private:
  int32_t _internal_outgoing_post_reduction() const;
  void _internal_set_outgoing_post_reduction(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.DamageStatsByType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t damage_type_;
    int32_t received_pre_reduction_;
    int32_t received_post_reduction_;
    int32_t outgoing_pre_reduction_;
    int32_t outgoing_post_reduction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_HeroAbility final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.HeroAbility) */ {
 public:
  inline CMsgDotaScenario_HeroAbility() : CMsgDotaScenario_HeroAbility(nullptr) {}
  ~CMsgDotaScenario_HeroAbility() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_HeroAbility(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_HeroAbility(const CMsgDotaScenario_HeroAbility& from);
  CMsgDotaScenario_HeroAbility(CMsgDotaScenario_HeroAbility&& from) noexcept
    : CMsgDotaScenario_HeroAbility() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_HeroAbility& operator=(const CMsgDotaScenario_HeroAbility& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_HeroAbility& operator=(CMsgDotaScenario_HeroAbility&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_HeroAbility& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_HeroAbility* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_HeroAbility*>(
               &_CMsgDotaScenario_HeroAbility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CMsgDotaScenario_HeroAbility& a, CMsgDotaScenario_HeroAbility& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_HeroAbility* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_HeroAbility* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_HeroAbility* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_HeroAbility>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_HeroAbility& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_HeroAbility& from) {
    CMsgDotaScenario_HeroAbility::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_HeroAbility* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.HeroAbility";
  }
  protected:
  explicit CMsgDotaScenario_HeroAbility(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int32 level = 2;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.HeroAbility)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t level_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_Hero final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.Hero) */ {
 public:
  inline CMsgDotaScenario_Hero() : CMsgDotaScenario_Hero(nullptr) {}
  ~CMsgDotaScenario_Hero() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_Hero(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_Hero(const CMsgDotaScenario_Hero& from);
  CMsgDotaScenario_Hero(CMsgDotaScenario_Hero&& from) noexcept
    : CMsgDotaScenario_Hero() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_Hero& operator=(const CMsgDotaScenario_Hero& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_Hero& operator=(CMsgDotaScenario_Hero&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_Hero& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_Hero* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_Hero*>(
               &_CMsgDotaScenario_Hero_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CMsgDotaScenario_Hero& a, CMsgDotaScenario_Hero& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_Hero* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_Hero* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_Hero* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_Hero>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_Hero& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_Hero& from) {
    CMsgDotaScenario_Hero::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_Hero* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.Hero";
  }
  protected:
  explicit CMsgDotaScenario_Hero(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnemyKillsFieldNumber = 150,
    kDamageStatsFieldNumber = 151,
    kAbilitiesFieldNumber = 152,
    kHeroFieldNumber = 4,
    kPositionFieldNumber = 75,
    kSteamIdFieldNumber = 1,
    kTeamIdFieldNumber = 3,
    kTotalXpFieldNumber = 5,
    kBkbChargesUsedFieldNumber = 6,
    kAeonChargesUsedFieldNumber = 7,
    kReliableGoldFieldNumber = 8,
    kUnreliableGoldFieldNumber = 9,
    kTotalEarnedGoldFieldNumber = 10,
    kSharedGoldFieldNumber = 11,
    kHeroKillGoldFieldNumber = 12,
    kCreepKillGoldFieldNumber = 13,
    kNeutralKillGoldFieldNumber = 14,
    kCourierGoldFieldNumber = 15,
    kBountyGoldFieldNumber = 16,
    kRoshanGoldFieldNumber = 17,
    kBuildingGoldFieldNumber = 18,
    kOtherGoldFieldNumber = 19,
    kIncomeGoldFieldNumber = 26,
    kWardKillGoldFieldNumber = 27,
    kAbilityGoldFieldNumber = 28,
    kDeniesFieldNumber = 29,
    kLastHitsFieldNumber = 30,
    kLastHitStreakFieldNumber = 31,
    kLastHitMultikillFieldNumber = 32,
    kNearbyCreepDeathCountFieldNumber = 33,
    kClaimedDenyCountFieldNumber = 34,
    kClaimedMissCountFieldNumber = 35,
    kMissCountFieldNumber = 36,
    kBuybackCooldownTimeFieldNumber = 40,
    kBuybackGoldLimitTimeFieldNumber = 41,
    kStunDurationFieldNumber = 44,
    kHealingFieldNumber = 45,
    kTowerKillsFieldNumber = 46,
    kRoshanKillsFieldNumber = 47,
    kObserverWardsPlacedFieldNumber = 48,
    kSentryWardsPlacedFieldNumber = 49,
    kCreepsStackedFieldNumber = 50,
    kCampsStackedFieldNumber = 51,
    kRunePickupsFieldNumber = 52,
    kGoldSpentOnSupportFieldNumber = 53,
    kHeroDamageFieldNumber = 54,
    kWardsPurchasedFieldNumber = 55,
    kWardsDestroyedFieldNumber = 56,
    kGoldSpentOnConsumablesFieldNumber = 58,
    kGoldSpentOnItemsFieldNumber = 59,
    kGoldSpentOnBuybacksFieldNumber = 60,
    kGoldLostToDeathFieldNumber = 61,
    kKillsFieldNumber = 62,
    kAssistsFieldNumber = 63,
    kDeathsFieldNumber = 64,
    kKillStreakFieldNumber = 65,
    kLastBuybackTimeFieldNumber = 69,
    kFirstBloodClaimedFieldNumber = 71,
    kFirstBloodGivenFieldNumber = 72,
    kBountyRunesFieldNumber = 73,
    kOutpostsCapturedFieldNumber = 74,
    kPlayerIdFieldNumber = 2,
    kRespawnSecondsFieldNumber = 68,
  };
  // repeated .CMsgDotaScenario.HeroHeroInt enemy_kills = 150;
  int enemy_kills_size() const;
  private:
  int _internal_enemy_kills_size() const;
  public:
  void clear_enemy_kills();
  ::CMsgDotaScenario_HeroHeroInt* mutable_enemy_kills(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_HeroHeroInt >*
      mutable_enemy_kills();
  private:
  const ::CMsgDotaScenario_HeroHeroInt& _internal_enemy_kills(int index) const;
  ::CMsgDotaScenario_HeroHeroInt* _internal_add_enemy_kills();
  public:
  const ::CMsgDotaScenario_HeroHeroInt& enemy_kills(int index) const;
  ::CMsgDotaScenario_HeroHeroInt* add_enemy_kills();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_HeroHeroInt >&
      enemy_kills() const;

  // repeated .CMsgDotaScenario.DamageStatsByType damage_stats = 151;
  int damage_stats_size() const;
  private:
  int _internal_damage_stats_size() const;
  public:
  void clear_damage_stats();
  ::CMsgDotaScenario_DamageStatsByType* mutable_damage_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_DamageStatsByType >*
      mutable_damage_stats();
  private:
  const ::CMsgDotaScenario_DamageStatsByType& _internal_damage_stats(int index) const;
  ::CMsgDotaScenario_DamageStatsByType* _internal_add_damage_stats();
  public:
  const ::CMsgDotaScenario_DamageStatsByType& damage_stats(int index) const;
  ::CMsgDotaScenario_DamageStatsByType* add_damage_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_DamageStatsByType >&
      damage_stats() const;

  // repeated .CMsgDotaScenario.HeroAbility abilities = 152;
  int abilities_size() const;
  private:
  int _internal_abilities_size() const;
  public:
  void clear_abilities();
  ::CMsgDotaScenario_HeroAbility* mutable_abilities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_HeroAbility >*
      mutable_abilities();
  private:
  const ::CMsgDotaScenario_HeroAbility& _internal_abilities(int index) const;
  ::CMsgDotaScenario_HeroAbility* _internal_add_abilities();
  public:
  const ::CMsgDotaScenario_HeroAbility& abilities(int index) const;
  ::CMsgDotaScenario_HeroAbility* add_abilities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_HeroAbility >&
      abilities() const;

  // optional string hero = 4;
  bool has_hero() const;
  private:
  bool _internal_has_hero() const;
  public:
  void clear_hero();
  const std::string& hero() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hero(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hero();
  PROTOBUF_NODISCARD std::string* release_hero();
  void set_allocated_hero(std::string* hero);
  private:
  const std::string& _internal_hero() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hero(const std::string& value);
  std::string* _internal_mutable_hero();
  public:

  // optional .CScenario_Position position = 75;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::CScenario_Position& position() const;
  PROTOBUF_NODISCARD ::CScenario_Position* release_position();
  ::CScenario_Position* mutable_position();
  void set_allocated_position(::CScenario_Position* position);
  private:
  const ::CScenario_Position& _internal_position() const;
  ::CScenario_Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::CScenario_Position* position);
  ::CScenario_Position* unsafe_arena_release_position();

  // optional fixed64 steam_id = 1;
  bool has_steam_id() const;
  private:
  bool _internal_has_steam_id() const;
  public:
  void clear_steam_id();
  uint64_t steam_id() const;
  void set_steam_id(uint64_t value);
  private:
  uint64_t _internal_steam_id() const;
  void _internal_set_steam_id(uint64_t value);
  public:

  // optional int32 team_id = 3;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  int32_t team_id() const;
  void set_team_id(int32_t value);
  private:
  int32_t _internal_team_id() const;
  void _internal_set_team_id(int32_t value);
  public:

  // optional int32 total_xp = 5;
  bool has_total_xp() const;
  private:
  bool _internal_has_total_xp() const;
  public:
  void clear_total_xp();
  int32_t total_xp() const;
  void set_total_xp(int32_t value);
  private:
  int32_t _internal_total_xp() const;
  void _internal_set_total_xp(int32_t value);
  public:

  // optional int32 bkb_charges_used = 6;
  bool has_bkb_charges_used() const;
  private:
  bool _internal_has_bkb_charges_used() const;
  public:
  void clear_bkb_charges_used();
  int32_t bkb_charges_used() const;
  void set_bkb_charges_used(int32_t value);
  private:
  int32_t _internal_bkb_charges_used() const;
  void _internal_set_bkb_charges_used(int32_t value);
  public:

  // optional int32 aeon_charges_used = 7;
  bool has_aeon_charges_used() const;
  private:
  bool _internal_has_aeon_charges_used() const;
  public:
  void clear_aeon_charges_used();
  int32_t aeon_charges_used() const;
  void set_aeon_charges_used(int32_t value);
  private:
  int32_t _internal_aeon_charges_used() const;
  void _internal_set_aeon_charges_used(int32_t value);
  public:

  // optional int32 reliable_gold = 8;
  bool has_reliable_gold() const;
  private:
  bool _internal_has_reliable_gold() const;
  public:
  void clear_reliable_gold();
  int32_t reliable_gold() const;
  void set_reliable_gold(int32_t value);
  private:
  int32_t _internal_reliable_gold() const;
  void _internal_set_reliable_gold(int32_t value);
  public:

  // optional int32 unreliable_gold = 9;
  bool has_unreliable_gold() const;
  private:
  bool _internal_has_unreliable_gold() const;
  public:
  void clear_unreliable_gold();
  int32_t unreliable_gold() const;
  void set_unreliable_gold(int32_t value);
  private:
  int32_t _internal_unreliable_gold() const;
  void _internal_set_unreliable_gold(int32_t value);
  public:

  // optional int32 total_earned_gold = 10;
  bool has_total_earned_gold() const;
  private:
  bool _internal_has_total_earned_gold() const;
  public:
  void clear_total_earned_gold();
  int32_t total_earned_gold() const;
  void set_total_earned_gold(int32_t value);
  private:
  int32_t _internal_total_earned_gold() const;
  void _internal_set_total_earned_gold(int32_t value);
  public:

  // optional int32 shared_gold = 11;
  bool has_shared_gold() const;
  private:
  bool _internal_has_shared_gold() const;
  public:
  void clear_shared_gold();
  int32_t shared_gold() const;
  void set_shared_gold(int32_t value);
  private:
  int32_t _internal_shared_gold() const;
  void _internal_set_shared_gold(int32_t value);
  public:

  // optional int32 hero_kill_gold = 12;
  bool has_hero_kill_gold() const;
  private:
  bool _internal_has_hero_kill_gold() const;
  public:
  void clear_hero_kill_gold();
  int32_t hero_kill_gold() const;
  void set_hero_kill_gold(int32_t value);
  private:
  int32_t _internal_hero_kill_gold() const;
  void _internal_set_hero_kill_gold(int32_t value);
  public:

  // optional int32 creep_kill_gold = 13;
  bool has_creep_kill_gold() const;
  private:
  bool _internal_has_creep_kill_gold() const;
  public:
  void clear_creep_kill_gold();
  int32_t creep_kill_gold() const;
  void set_creep_kill_gold(int32_t value);
  private:
  int32_t _internal_creep_kill_gold() const;
  void _internal_set_creep_kill_gold(int32_t value);
  public:

  // optional int32 neutral_kill_gold = 14;
  bool has_neutral_kill_gold() const;
  private:
  bool _internal_has_neutral_kill_gold() const;
  public:
  void clear_neutral_kill_gold();
  int32_t neutral_kill_gold() const;
  void set_neutral_kill_gold(int32_t value);
  private:
  int32_t _internal_neutral_kill_gold() const;
  void _internal_set_neutral_kill_gold(int32_t value);
  public:

  // optional int32 courier_gold = 15;
  bool has_courier_gold() const;
  private:
  bool _internal_has_courier_gold() const;
  public:
  void clear_courier_gold();
  int32_t courier_gold() const;
  void set_courier_gold(int32_t value);
  private:
  int32_t _internal_courier_gold() const;
  void _internal_set_courier_gold(int32_t value);
  public:

  // optional int32 bounty_gold = 16;
  bool has_bounty_gold() const;
  private:
  bool _internal_has_bounty_gold() const;
  public:
  void clear_bounty_gold();
  int32_t bounty_gold() const;
  void set_bounty_gold(int32_t value);
  private:
  int32_t _internal_bounty_gold() const;
  void _internal_set_bounty_gold(int32_t value);
  public:

  // optional int32 roshan_gold = 17;
  bool has_roshan_gold() const;
  private:
  bool _internal_has_roshan_gold() const;
  public:
  void clear_roshan_gold();
  int32_t roshan_gold() const;
  void set_roshan_gold(int32_t value);
  private:
  int32_t _internal_roshan_gold() const;
  void _internal_set_roshan_gold(int32_t value);
  public:

  // optional int32 building_gold = 18;
  bool has_building_gold() const;
  private:
  bool _internal_has_building_gold() const;
  public:
  void clear_building_gold();
  int32_t building_gold() const;
  void set_building_gold(int32_t value);
  private:
  int32_t _internal_building_gold() const;
  void _internal_set_building_gold(int32_t value);
  public:

  // optional int32 other_gold = 19;
  bool has_other_gold() const;
  private:
  bool _internal_has_other_gold() const;
  public:
  void clear_other_gold();
  int32_t other_gold() const;
  void set_other_gold(int32_t value);
  private:
  int32_t _internal_other_gold() const;
  void _internal_set_other_gold(int32_t value);
  public:

  // optional int32 income_gold = 26;
  bool has_income_gold() const;
  private:
  bool _internal_has_income_gold() const;
  public:
  void clear_income_gold();
  int32_t income_gold() const;
  void set_income_gold(int32_t value);
  private:
  int32_t _internal_income_gold() const;
  void _internal_set_income_gold(int32_t value);
  public:

  // optional int32 ward_kill_gold = 27;
  bool has_ward_kill_gold() const;
  private:
  bool _internal_has_ward_kill_gold() const;
  public:
  void clear_ward_kill_gold();
  int32_t ward_kill_gold() const;
  void set_ward_kill_gold(int32_t value);
  private:
  int32_t _internal_ward_kill_gold() const;
  void _internal_set_ward_kill_gold(int32_t value);
  public:

  // optional int32 ability_gold = 28;
  bool has_ability_gold() const;
  private:
  bool _internal_has_ability_gold() const;
  public:
  void clear_ability_gold();
  int32_t ability_gold() const;
  void set_ability_gold(int32_t value);
  private:
  int32_t _internal_ability_gold() const;
  void _internal_set_ability_gold(int32_t value);
  public:

  // optional int32 denies = 29;
  bool has_denies() const;
  private:
  bool _internal_has_denies() const;
  public:
  void clear_denies();
  int32_t denies() const;
  void set_denies(int32_t value);
  private:
  int32_t _internal_denies() const;
  void _internal_set_denies(int32_t value);
  public:

  // optional int32 last_hits = 30;
  bool has_last_hits() const;
  private:
  bool _internal_has_last_hits() const;
  public:
  void clear_last_hits();
  int32_t last_hits() const;
  void set_last_hits(int32_t value);
  private:
  int32_t _internal_last_hits() const;
  void _internal_set_last_hits(int32_t value);
  public:

  // optional int32 last_hit_streak = 31;
  bool has_last_hit_streak() const;
  private:
  bool _internal_has_last_hit_streak() const;
  public:
  void clear_last_hit_streak();
  int32_t last_hit_streak() const;
  void set_last_hit_streak(int32_t value);
  private:
  int32_t _internal_last_hit_streak() const;
  void _internal_set_last_hit_streak(int32_t value);
  public:

  // optional int32 last_hit_multikill = 32;
  bool has_last_hit_multikill() const;
  private:
  bool _internal_has_last_hit_multikill() const;
  public:
  void clear_last_hit_multikill();
  int32_t last_hit_multikill() const;
  void set_last_hit_multikill(int32_t value);
  private:
  int32_t _internal_last_hit_multikill() const;
  void _internal_set_last_hit_multikill(int32_t value);
  public:

  // optional int32 nearby_creep_death_count = 33;
  bool has_nearby_creep_death_count() const;
  private:
  bool _internal_has_nearby_creep_death_count() const;
  public:
  void clear_nearby_creep_death_count();
  int32_t nearby_creep_death_count() const;
  void set_nearby_creep_death_count(int32_t value);
  private:
  int32_t _internal_nearby_creep_death_count() const;
  void _internal_set_nearby_creep_death_count(int32_t value);
  public:

  // optional int32 claimed_deny_count = 34;
  bool has_claimed_deny_count() const;
  private:
  bool _internal_has_claimed_deny_count() const;
  public:
  void clear_claimed_deny_count();
  int32_t claimed_deny_count() const;
  void set_claimed_deny_count(int32_t value);
  private:
  int32_t _internal_claimed_deny_count() const;
  void _internal_set_claimed_deny_count(int32_t value);
  public:

  // optional int32 claimed_miss_count = 35;
  bool has_claimed_miss_count() const;
  private:
  bool _internal_has_claimed_miss_count() const;
  public:
  void clear_claimed_miss_count();
  int32_t claimed_miss_count() const;
  void set_claimed_miss_count(int32_t value);
  private:
  int32_t _internal_claimed_miss_count() const;
  void _internal_set_claimed_miss_count(int32_t value);
  public:

  // optional int32 miss_count = 36;
  bool has_miss_count() const;
  private:
  bool _internal_has_miss_count() const;
  public:
  void clear_miss_count();
  int32_t miss_count() const;
  void set_miss_count(int32_t value);
  private:
  int32_t _internal_miss_count() const;
  void _internal_set_miss_count(int32_t value);
  public:

  // optional float buyback_cooldown_time = 40;
  bool has_buyback_cooldown_time() const;
  private:
  bool _internal_has_buyback_cooldown_time() const;
  public:
  void clear_buyback_cooldown_time();
  float buyback_cooldown_time() const;
  void set_buyback_cooldown_time(float value);
  private:
  float _internal_buyback_cooldown_time() const;
  void _internal_set_buyback_cooldown_time(float value);
  public:

  // optional float buyback_gold_limit_time = 41;
  bool has_buyback_gold_limit_time() const;
  private:
  bool _internal_has_buyback_gold_limit_time() const;
  public:
  void clear_buyback_gold_limit_time();
  float buyback_gold_limit_time() const;
  void set_buyback_gold_limit_time(float value);
  private:
  float _internal_buyback_gold_limit_time() const;
  void _internal_set_buyback_gold_limit_time(float value);
  public:

  // optional float stun_duration = 44;
  bool has_stun_duration() const;
  private:
  bool _internal_has_stun_duration() const;
  public:
  void clear_stun_duration();
  float stun_duration() const;
  void set_stun_duration(float value);
  private:
  float _internal_stun_duration() const;
  void _internal_set_stun_duration(float value);
  public:

  // optional float healing = 45;
  bool has_healing() const;
  private:
  bool _internal_has_healing() const;
  public:
  void clear_healing();
  float healing() const;
  void set_healing(float value);
  private:
  float _internal_healing() const;
  void _internal_set_healing(float value);
  public:

  // optional int32 tower_kills = 46;
  bool has_tower_kills() const;
  private:
  bool _internal_has_tower_kills() const;
  public:
  void clear_tower_kills();
  int32_t tower_kills() const;
  void set_tower_kills(int32_t value);
  private:
  int32_t _internal_tower_kills() const;
  void _internal_set_tower_kills(int32_t value);
  public:

  // optional int32 roshan_kills = 47;
  bool has_roshan_kills() const;
  private:
  bool _internal_has_roshan_kills() const;
  public:
  void clear_roshan_kills();
  int32_t roshan_kills() const;
  void set_roshan_kills(int32_t value);
  private:
  int32_t _internal_roshan_kills() const;
  void _internal_set_roshan_kills(int32_t value);
  public:

  // optional int32 observer_wards_placed = 48;
  bool has_observer_wards_placed() const;
  private:
  bool _internal_has_observer_wards_placed() const;
  public:
  void clear_observer_wards_placed();
  int32_t observer_wards_placed() const;
  void set_observer_wards_placed(int32_t value);
  private:
  int32_t _internal_observer_wards_placed() const;
  void _internal_set_observer_wards_placed(int32_t value);
  public:

  // optional int32 sentry_wards_placed = 49;
  bool has_sentry_wards_placed() const;
  private:
  bool _internal_has_sentry_wards_placed() const;
  public:
  void clear_sentry_wards_placed();
  int32_t sentry_wards_placed() const;
  void set_sentry_wards_placed(int32_t value);
  private:
  int32_t _internal_sentry_wards_placed() const;
  void _internal_set_sentry_wards_placed(int32_t value);
  public:

  // optional int32 creeps_stacked = 50;
  bool has_creeps_stacked() const;
  private:
  bool _internal_has_creeps_stacked() const;
  public:
  void clear_creeps_stacked();
  int32_t creeps_stacked() const;
  void set_creeps_stacked(int32_t value);
  private:
  int32_t _internal_creeps_stacked() const;
  void _internal_set_creeps_stacked(int32_t value);
  public:

  // optional int32 camps_stacked = 51;
  bool has_camps_stacked() const;
  private:
  bool _internal_has_camps_stacked() const;
  public:
  void clear_camps_stacked();
  int32_t camps_stacked() const;
  void set_camps_stacked(int32_t value);
  private:
  int32_t _internal_camps_stacked() const;
  void _internal_set_camps_stacked(int32_t value);
  public:

  // optional int32 rune_pickups = 52;
  bool has_rune_pickups() const;
  private:
  bool _internal_has_rune_pickups() const;
  public:
  void clear_rune_pickups();
  int32_t rune_pickups() const;
  void set_rune_pickups(int32_t value);
  private:
  int32_t _internal_rune_pickups() const;
  void _internal_set_rune_pickups(int32_t value);
  public:

  // optional int32 gold_spent_on_support = 53;
  bool has_gold_spent_on_support() const;
  private:
  bool _internal_has_gold_spent_on_support() const;
  public:
  void clear_gold_spent_on_support();
  int32_t gold_spent_on_support() const;
  void set_gold_spent_on_support(int32_t value);
  private:
  int32_t _internal_gold_spent_on_support() const;
  void _internal_set_gold_spent_on_support(int32_t value);
  public:

  // optional int32 hero_damage = 54;
  bool has_hero_damage() const;
  private:
  bool _internal_has_hero_damage() const;
  public:
  void clear_hero_damage();
  int32_t hero_damage() const;
  void set_hero_damage(int32_t value);
  private:
  int32_t _internal_hero_damage() const;
  void _internal_set_hero_damage(int32_t value);
  public:

  // optional int32 wards_purchased = 55;
  bool has_wards_purchased() const;
  private:
  bool _internal_has_wards_purchased() const;
  public:
  void clear_wards_purchased();
  int32_t wards_purchased() const;
  void set_wards_purchased(int32_t value);
  private:
  int32_t _internal_wards_purchased() const;
  void _internal_set_wards_purchased(int32_t value);
  public:

  // optional int32 wards_destroyed = 56;
  bool has_wards_destroyed() const;
  private:
  bool _internal_has_wards_destroyed() const;
  public:
  void clear_wards_destroyed();
  int32_t wards_destroyed() const;
  void set_wards_destroyed(int32_t value);
  private:
  int32_t _internal_wards_destroyed() const;
  void _internal_set_wards_destroyed(int32_t value);
  public:

  // optional int32 gold_spent_on_consumables = 58;
  bool has_gold_spent_on_consumables() const;
  private:
  bool _internal_has_gold_spent_on_consumables() const;
  public:
  void clear_gold_spent_on_consumables();
  int32_t gold_spent_on_consumables() const;
  void set_gold_spent_on_consumables(int32_t value);
  private:
  int32_t _internal_gold_spent_on_consumables() const;
  void _internal_set_gold_spent_on_consumables(int32_t value);
  public:

  // optional int32 gold_spent_on_items = 59;
  bool has_gold_spent_on_items() const;
  private:
  bool _internal_has_gold_spent_on_items() const;
  public:
  void clear_gold_spent_on_items();
  int32_t gold_spent_on_items() const;
  void set_gold_spent_on_items(int32_t value);
  private:
  int32_t _internal_gold_spent_on_items() const;
  void _internal_set_gold_spent_on_items(int32_t value);
  public:

  // optional int32 gold_spent_on_buybacks = 60;
  bool has_gold_spent_on_buybacks() const;
  private:
  bool _internal_has_gold_spent_on_buybacks() const;
  public:
  void clear_gold_spent_on_buybacks();
  int32_t gold_spent_on_buybacks() const;
  void set_gold_spent_on_buybacks(int32_t value);
  private:
  int32_t _internal_gold_spent_on_buybacks() const;
  void _internal_set_gold_spent_on_buybacks(int32_t value);
  public:

  // optional int32 gold_lost_to_death = 61;
  bool has_gold_lost_to_death() const;
  private:
  bool _internal_has_gold_lost_to_death() const;
  public:
  void clear_gold_lost_to_death();
  int32_t gold_lost_to_death() const;
  void set_gold_lost_to_death(int32_t value);
  private:
  int32_t _internal_gold_lost_to_death() const;
  void _internal_set_gold_lost_to_death(int32_t value);
  public:

  // optional int32 kills = 62;
  bool has_kills() const;
  private:
  bool _internal_has_kills() const;
  public:
  void clear_kills();
  int32_t kills() const;
  void set_kills(int32_t value);
  private:
  int32_t _internal_kills() const;
  void _internal_set_kills(int32_t value);
  public:

  // optional int32 assists = 63;
  bool has_assists() const;
  private:
  bool _internal_has_assists() const;
  public:
  void clear_assists();
  int32_t assists() const;
  void set_assists(int32_t value);
  private:
  int32_t _internal_assists() const;
  void _internal_set_assists(int32_t value);
  public:

  // optional int32 deaths = 64;
  bool has_deaths() const;
  private:
  bool _internal_has_deaths() const;
  public:
  void clear_deaths();
  int32_t deaths() const;
  void set_deaths(int32_t value);
  private:
  int32_t _internal_deaths() const;
  void _internal_set_deaths(int32_t value);
  public:

  // optional int32 kill_streak = 65;
  bool has_kill_streak() const;
  private:
  bool _internal_has_kill_streak() const;
  public:
  void clear_kill_streak();
  int32_t kill_streak() const;
  void set_kill_streak(int32_t value);
  private:
  int32_t _internal_kill_streak() const;
  void _internal_set_kill_streak(int32_t value);
  public:

  // optional int32 last_buyback_time = 69;
  bool has_last_buyback_time() const;
  private:
  bool _internal_has_last_buyback_time() const;
  public:
  void clear_last_buyback_time();
  int32_t last_buyback_time() const;
  void set_last_buyback_time(int32_t value);
  private:
  int32_t _internal_last_buyback_time() const;
  void _internal_set_last_buyback_time(int32_t value);
  public:

  // optional bool first_blood_claimed = 71;
  bool has_first_blood_claimed() const;
  private:
  bool _internal_has_first_blood_claimed() const;
  public:
  void clear_first_blood_claimed();
  bool first_blood_claimed() const;
  void set_first_blood_claimed(bool value);
  private:
  bool _internal_first_blood_claimed() const;
  void _internal_set_first_blood_claimed(bool value);
  public:

  // optional bool first_blood_given = 72;
  bool has_first_blood_given() const;
  private:
  bool _internal_has_first_blood_given() const;
  public:
  void clear_first_blood_given();
  bool first_blood_given() const;
  void set_first_blood_given(bool value);
  private:
  bool _internal_first_blood_given() const;
  void _internal_set_first_blood_given(bool value);
  public:

  // optional int32 bounty_runes = 73;
  bool has_bounty_runes() const;
  private:
  bool _internal_has_bounty_runes() const;
  public:
  void clear_bounty_runes();
  int32_t bounty_runes() const;
  void set_bounty_runes(int32_t value);
  private:
  int32_t _internal_bounty_runes() const;
  void _internal_set_bounty_runes(int32_t value);
  public:

  // optional int32 outposts_captured = 74;
  bool has_outposts_captured() const;
  private:
  bool _internal_has_outposts_captured() const;
  public:
  void clear_outposts_captured();
  int32_t outposts_captured() const;
  void set_outposts_captured(int32_t value);
  private:
  int32_t _internal_outposts_captured() const;
  void _internal_set_outposts_captured(int32_t value);
  public:

  // optional int32 player_id = 2 [default = -1];
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // optional int32 respawn_seconds = 68 [default = -1];
  bool has_respawn_seconds() const;
  private:
  bool _internal_has_respawn_seconds() const;
  public:
  void clear_respawn_seconds();
  int32_t respawn_seconds() const;
  void set_respawn_seconds(int32_t value);
  private:
  int32_t _internal_respawn_seconds() const;
  void _internal_set_respawn_seconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.Hero)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_HeroHeroInt > enemy_kills_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_DamageStatsByType > damage_stats_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_HeroAbility > abilities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hero_;
    ::CScenario_Position* position_;
    uint64_t steam_id_;
    int32_t team_id_;
    int32_t total_xp_;
    int32_t bkb_charges_used_;
    int32_t aeon_charges_used_;
    int32_t reliable_gold_;
    int32_t unreliable_gold_;
    int32_t total_earned_gold_;
    int32_t shared_gold_;
    int32_t hero_kill_gold_;
    int32_t creep_kill_gold_;
    int32_t neutral_kill_gold_;
    int32_t courier_gold_;
    int32_t bounty_gold_;
    int32_t roshan_gold_;
    int32_t building_gold_;
    int32_t other_gold_;
    int32_t income_gold_;
    int32_t ward_kill_gold_;
    int32_t ability_gold_;
    int32_t denies_;
    int32_t last_hits_;
    int32_t last_hit_streak_;
    int32_t last_hit_multikill_;
    int32_t nearby_creep_death_count_;
    int32_t claimed_deny_count_;
    int32_t claimed_miss_count_;
    int32_t miss_count_;
    float buyback_cooldown_time_;
    float buyback_gold_limit_time_;
    float stun_duration_;
    float healing_;
    int32_t tower_kills_;
    int32_t roshan_kills_;
    int32_t observer_wards_placed_;
    int32_t sentry_wards_placed_;
    int32_t creeps_stacked_;
    int32_t camps_stacked_;
    int32_t rune_pickups_;
    int32_t gold_spent_on_support_;
    int32_t hero_damage_;
    int32_t wards_purchased_;
    int32_t wards_destroyed_;
    int32_t gold_spent_on_consumables_;
    int32_t gold_spent_on_items_;
    int32_t gold_spent_on_buybacks_;
    int32_t gold_lost_to_death_;
    int32_t kills_;
    int32_t assists_;
    int32_t deaths_;
    int32_t kill_streak_;
    int32_t last_buyback_time_;
    bool first_blood_claimed_;
    bool first_blood_given_;
    int32_t bounty_runes_;
    int32_t outposts_captured_;
    int32_t player_id_;
    int32_t respawn_seconds_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_Stock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.Stock) */ {
 public:
  inline CMsgDotaScenario_Stock() : CMsgDotaScenario_Stock(nullptr) {}
  ~CMsgDotaScenario_Stock() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_Stock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_Stock(const CMsgDotaScenario_Stock& from);
  CMsgDotaScenario_Stock(CMsgDotaScenario_Stock&& from) noexcept
    : CMsgDotaScenario_Stock() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_Stock& operator=(const CMsgDotaScenario_Stock& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_Stock& operator=(CMsgDotaScenario_Stock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_Stock& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_Stock* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_Stock*>(
               &_CMsgDotaScenario_Stock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CMsgDotaScenario_Stock& a, CMsgDotaScenario_Stock& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_Stock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_Stock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_Stock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_Stock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_Stock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_Stock& from) {
    CMsgDotaScenario_Stock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_Stock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.Stock";
  }
  protected:
  explicit CMsgDotaScenario_Stock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCurrentStockFieldNumber = 4,
    kCooldownFieldNumber = 5,
    kBonusStockFieldNumber = 6,
    kTeamNumberFieldNumber = 2,
    kPlayerIdFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int32 current_stock = 4;
  bool has_current_stock() const;
  private:
  bool _internal_has_current_stock() const;
  public:
  void clear_current_stock();
  int32_t current_stock() const;
  void set_current_stock(int32_t value);
  private:
  int32_t _internal_current_stock() const;
  void _internal_set_current_stock(int32_t value);
  public:

  // optional float cooldown = 5;
  bool has_cooldown() const;
  private:
  bool _internal_has_cooldown() const;
  public:
  void clear_cooldown();
  float cooldown() const;
  void set_cooldown(float value);
  private:
  float _internal_cooldown() const;
  void _internal_set_cooldown(float value);
  public:

  // optional int32 bonus_stock = 6;
  bool has_bonus_stock() const;
  private:
  bool _internal_has_bonus_stock() const;
  public:
  void clear_bonus_stock();
  int32_t bonus_stock() const;
  void set_bonus_stock(int32_t value);
  private:
  int32_t _internal_bonus_stock() const;
  void _internal_set_bonus_stock(int32_t value);
  public:

  // optional int32 team_number = 2 [default = -1];
  bool has_team_number() const;
  private:
  bool _internal_has_team_number() const;
  public:
  void clear_team_number();
  int32_t team_number() const;
  void set_team_number(int32_t value);
  private:
  int32_t _internal_team_number() const;
  void _internal_set_team_number(int32_t value);
  public:

  // optional int32 player_id = 3 [default = -1];
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.Stock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t current_stock_;
    float cooldown_;
    int32_t bonus_stock_;
    int32_t team_number_;
    int32_t player_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_Building final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.Building) */ {
 public:
  inline CMsgDotaScenario_Building() : CMsgDotaScenario_Building(nullptr) {}
  ~CMsgDotaScenario_Building() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_Building(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_Building(const CMsgDotaScenario_Building& from);
  CMsgDotaScenario_Building(CMsgDotaScenario_Building&& from) noexcept
    : CMsgDotaScenario_Building() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_Building& operator=(const CMsgDotaScenario_Building& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_Building& operator=(CMsgDotaScenario_Building&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_Building& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_Building* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_Building*>(
               &_CMsgDotaScenario_Building_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CMsgDotaScenario_Building& a, CMsgDotaScenario_Building& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_Building* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_Building* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_Building* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_Building>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_Building& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_Building& from) {
    CMsgDotaScenario_Building::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_Building* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.Building";
  }
  protected:
  explicit CMsgDotaScenario_Building(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityNameFieldNumber = 1,
    kEntityClassFieldNumber = 2,
    kTeamIdFieldNumber = 3,
    kIsDestroyedFieldNumber = 4,
    kHealthFracFieldNumber = 5,
  };
  // optional string entity_name = 1;
  bool has_entity_name() const;
  private:
  bool _internal_has_entity_name() const;
  public:
  void clear_entity_name();
  const std::string& entity_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entity_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entity_name();
  PROTOBUF_NODISCARD std::string* release_entity_name();
  void set_allocated_entity_name(std::string* entity_name);
  private:
  const std::string& _internal_entity_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_name(const std::string& value);
  std::string* _internal_mutable_entity_name();
  public:

  // optional string entity_class = 2;
  bool has_entity_class() const;
  private:
  bool _internal_has_entity_class() const;
  public:
  void clear_entity_class();
  const std::string& entity_class() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entity_class(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entity_class();
  PROTOBUF_NODISCARD std::string* release_entity_class();
  void set_allocated_entity_class(std::string* entity_class);
  private:
  const std::string& _internal_entity_class() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_class(const std::string& value);
  std::string* _internal_mutable_entity_class();
  public:

  // optional int32 team_id = 3;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  int32_t team_id() const;
  void set_team_id(int32_t value);
  private:
  int32_t _internal_team_id() const;
  void _internal_set_team_id(int32_t value);
  public:

  // optional bool is_destroyed = 4;
  bool has_is_destroyed() const;
  private:
  bool _internal_has_is_destroyed() const;
  public:
  void clear_is_destroyed();
  bool is_destroyed() const;
  void set_is_destroyed(bool value);
  private:
  bool _internal_is_destroyed() const;
  void _internal_set_is_destroyed(bool value);
  public:

  // optional float health_frac = 5 [default = 1];
  bool has_health_frac() const;
  private:
  bool _internal_has_health_frac() const;
  public:
  void clear_health_frac();
  float health_frac() const;
  void set_health_frac(float value);
  private:
  float _internal_health_frac() const;
  void _internal_set_health_frac(float value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.Building)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_class_;
    int32_t team_id_;
    bool is_destroyed_;
    float health_frac_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_Entity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.Entity) */ {
 public:
  inline CMsgDotaScenario_Entity() : CMsgDotaScenario_Entity(nullptr) {}
  ~CMsgDotaScenario_Entity() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_Entity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_Entity(const CMsgDotaScenario_Entity& from);
  CMsgDotaScenario_Entity(CMsgDotaScenario_Entity&& from) noexcept
    : CMsgDotaScenario_Entity() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_Entity& operator=(const CMsgDotaScenario_Entity& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_Entity& operator=(CMsgDotaScenario_Entity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_Entity& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_Entity* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_Entity*>(
               &_CMsgDotaScenario_Entity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CMsgDotaScenario_Entity& a, CMsgDotaScenario_Entity& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_Entity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_Entity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_Entity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_Entity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_Entity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_Entity& from) {
    CMsgDotaScenario_Entity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_Entity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.Entity";
  }
  protected:
  explicit CMsgDotaScenario_Entity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCourierFieldNumber = 1,
    kNpcFieldNumber = 2,
    kSpiritBearFieldNumber = 3,
    kDroppedItemFieldNumber = 4,
  };
  // optional .CScenarioEnt_Courier courier = 1;
  bool has_courier() const;
  private:
  bool _internal_has_courier() const;
  public:
  void clear_courier();
  const ::CScenarioEnt_Courier& courier() const;
  PROTOBUF_NODISCARD ::CScenarioEnt_Courier* release_courier();
  ::CScenarioEnt_Courier* mutable_courier();
  void set_allocated_courier(::CScenarioEnt_Courier* courier);
  private:
  const ::CScenarioEnt_Courier& _internal_courier() const;
  ::CScenarioEnt_Courier* _internal_mutable_courier();
  public:
  void unsafe_arena_set_allocated_courier(
      ::CScenarioEnt_Courier* courier);
  ::CScenarioEnt_Courier* unsafe_arena_release_courier();

  // optional .CScenarioEnt_NPC npc = 2;
  bool has_npc() const;
  private:
  bool _internal_has_npc() const;
  public:
  void clear_npc();
  const ::CScenarioEnt_NPC& npc() const;
  PROTOBUF_NODISCARD ::CScenarioEnt_NPC* release_npc();
  ::CScenarioEnt_NPC* mutable_npc();
  void set_allocated_npc(::CScenarioEnt_NPC* npc);
  private:
  const ::CScenarioEnt_NPC& _internal_npc() const;
  ::CScenarioEnt_NPC* _internal_mutable_npc();
  public:
  void unsafe_arena_set_allocated_npc(
      ::CScenarioEnt_NPC* npc);
  ::CScenarioEnt_NPC* unsafe_arena_release_npc();

  // optional .CScenarioEnt_SpiritBear spirit_bear = 3;
  bool has_spirit_bear() const;
  private:
  bool _internal_has_spirit_bear() const;
  public:
  void clear_spirit_bear();
  const ::CScenarioEnt_SpiritBear& spirit_bear() const;
  PROTOBUF_NODISCARD ::CScenarioEnt_SpiritBear* release_spirit_bear();
  ::CScenarioEnt_SpiritBear* mutable_spirit_bear();
  void set_allocated_spirit_bear(::CScenarioEnt_SpiritBear* spirit_bear);
  private:
  const ::CScenarioEnt_SpiritBear& _internal_spirit_bear() const;
  ::CScenarioEnt_SpiritBear* _internal_mutable_spirit_bear();
  public:
  void unsafe_arena_set_allocated_spirit_bear(
      ::CScenarioEnt_SpiritBear* spirit_bear);
  ::CScenarioEnt_SpiritBear* unsafe_arena_release_spirit_bear();

  // optional .CScenarioEnt_DroppedItem dropped_item = 4;
  bool has_dropped_item() const;
  private:
  bool _internal_has_dropped_item() const;
  public:
  void clear_dropped_item();
  const ::CScenarioEnt_DroppedItem& dropped_item() const;
  PROTOBUF_NODISCARD ::CScenarioEnt_DroppedItem* release_dropped_item();
  ::CScenarioEnt_DroppedItem* mutable_dropped_item();
  void set_allocated_dropped_item(::CScenarioEnt_DroppedItem* dropped_item);
  private:
  const ::CScenarioEnt_DroppedItem& _internal_dropped_item() const;
  ::CScenarioEnt_DroppedItem* _internal_mutable_dropped_item();
  public:
  void unsafe_arena_set_allocated_dropped_item(
      ::CScenarioEnt_DroppedItem* dropped_item);
  ::CScenarioEnt_DroppedItem* unsafe_arena_release_dropped_item();

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.Entity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CScenarioEnt_Courier* courier_;
    ::CScenarioEnt_NPC* npc_;
    ::CScenarioEnt_SpiritBear* spirit_bear_;
    ::CScenarioEnt_DroppedItem* dropped_item_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.Item) */ {
 public:
  inline CMsgDotaScenario_Item() : CMsgDotaScenario_Item(nullptr) {}
  ~CMsgDotaScenario_Item() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_Item(const CMsgDotaScenario_Item& from);
  CMsgDotaScenario_Item(CMsgDotaScenario_Item&& from) noexcept
    : CMsgDotaScenario_Item() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_Item& operator=(const CMsgDotaScenario_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_Item& operator=(CMsgDotaScenario_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_Item* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_Item*>(
               &_CMsgDotaScenario_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CMsgDotaScenario_Item& a, CMsgDotaScenario_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_Item& from) {
    CMsgDotaScenario_Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.Item";
  }
  protected:
  explicit CMsgDotaScenario_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLocationFieldNumber = 2,
    kItemSlotFieldNumber = 4,
    kNeutralDropTeamFieldNumber = 5,
    kChargesFieldNumber = 6,
    kSecondaryChargesFieldNumber = 7,
    kStoredRuneTypeFieldNumber = 9,
    kOwnerIdFieldNumber = 3,
    kLifetimeFieldNumber = 8,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .CMsgDotaScenario.EntityRef location = 2;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::CMsgDotaScenario_EntityRef& location() const;
  PROTOBUF_NODISCARD ::CMsgDotaScenario_EntityRef* release_location();
  ::CMsgDotaScenario_EntityRef* mutable_location();
  void set_allocated_location(::CMsgDotaScenario_EntityRef* location);
  private:
  const ::CMsgDotaScenario_EntityRef& _internal_location() const;
  ::CMsgDotaScenario_EntityRef* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::CMsgDotaScenario_EntityRef* location);
  ::CMsgDotaScenario_EntityRef* unsafe_arena_release_location();

  // optional int32 item_slot = 4;
  bool has_item_slot() const;
  private:
  bool _internal_has_item_slot() const;
  public:
  void clear_item_slot();
  int32_t item_slot() const;
  void set_item_slot(int32_t value);
  private:
  int32_t _internal_item_slot() const;
  void _internal_set_item_slot(int32_t value);
  public:

  // optional int32 neutral_drop_team = 5;
  bool has_neutral_drop_team() const;
  private:
  bool _internal_has_neutral_drop_team() const;
  public:
  void clear_neutral_drop_team();
  int32_t neutral_drop_team() const;
  void set_neutral_drop_team(int32_t value);
  private:
  int32_t _internal_neutral_drop_team() const;
  void _internal_set_neutral_drop_team(int32_t value);
  public:

  // optional int32 charges = 6;
  bool has_charges() const;
  private:
  bool _internal_has_charges() const;
  public:
  void clear_charges();
  int32_t charges() const;
  void set_charges(int32_t value);
  private:
  int32_t _internal_charges() const;
  void _internal_set_charges(int32_t value);
  public:

  // optional int32 secondary_charges = 7;
  bool has_secondary_charges() const;
  private:
  bool _internal_has_secondary_charges() const;
  public:
  void clear_secondary_charges();
  int32_t secondary_charges() const;
  void set_secondary_charges(int32_t value);
  private:
  int32_t _internal_secondary_charges() const;
  void _internal_set_secondary_charges(int32_t value);
  public:

  // optional int32 stored_rune_type = 9 [default = -1];
  bool has_stored_rune_type() const;
  private:
  bool _internal_has_stored_rune_type() const;
  public:
  void clear_stored_rune_type();
  int32_t stored_rune_type() const;
  void set_stored_rune_type(int32_t value);
  private:
  int32_t _internal_stored_rune_type() const;
  void _internal_set_stored_rune_type(int32_t value);
  public:

  // optional int32 owner_id = 3 [default = -1];
  bool has_owner_id() const;
  private:
  bool _internal_has_owner_id() const;
  public:
  void clear_owner_id();
  int32_t owner_id() const;
  void set_owner_id(int32_t value);
  private:
  int32_t _internal_owner_id() const;
  void _internal_set_owner_id(int32_t value);
  public:

  // optional float lifetime = 8 [default = -1];
  bool has_lifetime() const;
  private:
  bool _internal_has_lifetime() const;
  public:
  void clear_lifetime();
  float lifetime() const;
  void set_lifetime(float value);
  private:
  float _internal_lifetime() const;
  void _internal_set_lifetime(float value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::CMsgDotaScenario_EntityRef* location_;
    int32_t item_slot_;
    int32_t neutral_drop_team_;
    int32_t charges_;
    int32_t secondary_charges_;
    int32_t stored_rune_type_;
    int32_t owner_id_;
    float lifetime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario_Modifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario.Modifier) */ {
 public:
  inline CMsgDotaScenario_Modifier() : CMsgDotaScenario_Modifier(nullptr) {}
  ~CMsgDotaScenario_Modifier() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario_Modifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario_Modifier(const CMsgDotaScenario_Modifier& from);
  CMsgDotaScenario_Modifier(CMsgDotaScenario_Modifier&& from) noexcept
    : CMsgDotaScenario_Modifier() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario_Modifier& operator=(const CMsgDotaScenario_Modifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario_Modifier& operator=(CMsgDotaScenario_Modifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario_Modifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario_Modifier* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario_Modifier*>(
               &_CMsgDotaScenario_Modifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CMsgDotaScenario_Modifier& a, CMsgDotaScenario_Modifier& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario_Modifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario_Modifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario_Modifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario_Modifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario_Modifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario_Modifier& from) {
    CMsgDotaScenario_Modifier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario_Modifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario.Modifier";
  }
  protected:
  explicit CMsgDotaScenario_Modifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kCasterFieldNumber = 3,
    kAbilityFieldNumber = 4,
    kLifetimeRemainingFieldNumber = 6,
    kStackCountFieldNumber = 7,
    kCreateEvenIfExistingFieldNumber = 8,
    kCreateWithoutCasterFieldNumber = 9,
    kCreateWithoutAbilityFieldNumber = 10,
    kMoonshardConsumedBonusFieldNumber = 100,
    kMoonshardConsumedBonusNightVisionFieldNumber = 101,
    kWardtruesightRangeFieldNumber = 110,
    kUltimateScepterConsumedAlchemistBonusAllStatsFieldNumber = 120,
    kUltimateScepterConsumedAlchemistBonusHealthFieldNumber = 121,
    kUltimateScepterConsumedAlchemistBonusManaFieldNumber = 122,
    kDurationFieldNumber = 5,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .CMsgDotaScenario.EntityRef parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::CMsgDotaScenario_EntityRef& parent() const;
  PROTOBUF_NODISCARD ::CMsgDotaScenario_EntityRef* release_parent();
  ::CMsgDotaScenario_EntityRef* mutable_parent();
  void set_allocated_parent(::CMsgDotaScenario_EntityRef* parent);
  private:
  const ::CMsgDotaScenario_EntityRef& _internal_parent() const;
  ::CMsgDotaScenario_EntityRef* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::CMsgDotaScenario_EntityRef* parent);
  ::CMsgDotaScenario_EntityRef* unsafe_arena_release_parent();

  // optional .CMsgDotaScenario.EntityRef caster = 3;
  bool has_caster() const;
  private:
  bool _internal_has_caster() const;
  public:
  void clear_caster();
  const ::CMsgDotaScenario_EntityRef& caster() const;
  PROTOBUF_NODISCARD ::CMsgDotaScenario_EntityRef* release_caster();
  ::CMsgDotaScenario_EntityRef* mutable_caster();
  void set_allocated_caster(::CMsgDotaScenario_EntityRef* caster);
  private:
  const ::CMsgDotaScenario_EntityRef& _internal_caster() const;
  ::CMsgDotaScenario_EntityRef* _internal_mutable_caster();
  public:
  void unsafe_arena_set_allocated_caster(
      ::CMsgDotaScenario_EntityRef* caster);
  ::CMsgDotaScenario_EntityRef* unsafe_arena_release_caster();

  // optional .CMsgDotaScenario.EntityRef ability = 4;
  bool has_ability() const;
  private:
  bool _internal_has_ability() const;
  public:
  void clear_ability();
  const ::CMsgDotaScenario_EntityRef& ability() const;
  PROTOBUF_NODISCARD ::CMsgDotaScenario_EntityRef* release_ability();
  ::CMsgDotaScenario_EntityRef* mutable_ability();
  void set_allocated_ability(::CMsgDotaScenario_EntityRef* ability);
  private:
  const ::CMsgDotaScenario_EntityRef& _internal_ability() const;
  ::CMsgDotaScenario_EntityRef* _internal_mutable_ability();
  public:
  void unsafe_arena_set_allocated_ability(
      ::CMsgDotaScenario_EntityRef* ability);
  ::CMsgDotaScenario_EntityRef* unsafe_arena_release_ability();

  // optional float lifetime_remaining = 6 [default = 0];
  bool has_lifetime_remaining() const;
  private:
  bool _internal_has_lifetime_remaining() const;
  public:
  void clear_lifetime_remaining();
  float lifetime_remaining() const;
  void set_lifetime_remaining(float value);
  private:
  float _internal_lifetime_remaining() const;
  void _internal_set_lifetime_remaining(float value);
  public:

  // optional int32 stack_count = 7;
  bool has_stack_count() const;
  private:
  bool _internal_has_stack_count() const;
  public:
  void clear_stack_count();
  int32_t stack_count() const;
  void set_stack_count(int32_t value);
  private:
  int32_t _internal_stack_count() const;
  void _internal_set_stack_count(int32_t value);
  public:

  // optional bool create_even_if_existing = 8;
  bool has_create_even_if_existing() const;
  private:
  bool _internal_has_create_even_if_existing() const;
  public:
  void clear_create_even_if_existing();
  bool create_even_if_existing() const;
  void set_create_even_if_existing(bool value);
  private:
  bool _internal_create_even_if_existing() const;
  void _internal_set_create_even_if_existing(bool value);
  public:

  // optional bool create_without_caster = 9;
  bool has_create_without_caster() const;
  private:
  bool _internal_has_create_without_caster() const;
  public:
  void clear_create_without_caster();
  bool create_without_caster() const;
  void set_create_without_caster(bool value);
  private:
  bool _internal_create_without_caster() const;
  void _internal_set_create_without_caster(bool value);
  public:

  // optional bool create_without_ability = 10;
  bool has_create_without_ability() const;
  private:
  bool _internal_has_create_without_ability() const;
  public:
  void clear_create_without_ability();
  bool create_without_ability() const;
  void set_create_without_ability(bool value);
  private:
  bool _internal_create_without_ability() const;
  void _internal_set_create_without_ability(bool value);
  public:

  // optional int32 moonshard_consumed_bonus = 100;
  bool has_moonshard_consumed_bonus() const;
  private:
  bool _internal_has_moonshard_consumed_bonus() const;
  public:
  void clear_moonshard_consumed_bonus();
  int32_t moonshard_consumed_bonus() const;
  void set_moonshard_consumed_bonus(int32_t value);
  private:
  int32_t _internal_moonshard_consumed_bonus() const;
  void _internal_set_moonshard_consumed_bonus(int32_t value);
  public:

  // optional int32 moonshard_consumed_bonus_night_vision = 101;
  bool has_moonshard_consumed_bonus_night_vision() const;
  private:
  bool _internal_has_moonshard_consumed_bonus_night_vision() const;
  public:
  void clear_moonshard_consumed_bonus_night_vision();
  int32_t moonshard_consumed_bonus_night_vision() const;
  void set_moonshard_consumed_bonus_night_vision(int32_t value);
  private:
  int32_t _internal_moonshard_consumed_bonus_night_vision() const;
  void _internal_set_moonshard_consumed_bonus_night_vision(int32_t value);
  public:

  // optional int32 wardtruesight_range = 110;
  bool has_wardtruesight_range() const;
  private:
  bool _internal_has_wardtruesight_range() const;
  public:
  void clear_wardtruesight_range();
  int32_t wardtruesight_range() const;
  void set_wardtruesight_range(int32_t value);
  private:
  int32_t _internal_wardtruesight_range() const;
  void _internal_set_wardtruesight_range(int32_t value);
  public:

  // optional int32 ultimate_scepter_consumed_alchemist_bonus_all_stats = 120;
  bool has_ultimate_scepter_consumed_alchemist_bonus_all_stats() const;
  private:
  bool _internal_has_ultimate_scepter_consumed_alchemist_bonus_all_stats() const;
  public:
  void clear_ultimate_scepter_consumed_alchemist_bonus_all_stats();
  int32_t ultimate_scepter_consumed_alchemist_bonus_all_stats() const;
  void set_ultimate_scepter_consumed_alchemist_bonus_all_stats(int32_t value);
  private:
  int32_t _internal_ultimate_scepter_consumed_alchemist_bonus_all_stats() const;
  void _internal_set_ultimate_scepter_consumed_alchemist_bonus_all_stats(int32_t value);
  public:

  // optional int32 ultimate_scepter_consumed_alchemist_bonus_health = 121;
  bool has_ultimate_scepter_consumed_alchemist_bonus_health() const;
  private:
  bool _internal_has_ultimate_scepter_consumed_alchemist_bonus_health() const;
  public:
  void clear_ultimate_scepter_consumed_alchemist_bonus_health();
  int32_t ultimate_scepter_consumed_alchemist_bonus_health() const;
  void set_ultimate_scepter_consumed_alchemist_bonus_health(int32_t value);
  private:
  int32_t _internal_ultimate_scepter_consumed_alchemist_bonus_health() const;
  void _internal_set_ultimate_scepter_consumed_alchemist_bonus_health(int32_t value);
  public:

  // optional int32 ultimate_scepter_consumed_alchemist_bonus_mana = 122;
  bool has_ultimate_scepter_consumed_alchemist_bonus_mana() const;
  private:
  bool _internal_has_ultimate_scepter_consumed_alchemist_bonus_mana() const;
  public:
  void clear_ultimate_scepter_consumed_alchemist_bonus_mana();
  int32_t ultimate_scepter_consumed_alchemist_bonus_mana() const;
  void set_ultimate_scepter_consumed_alchemist_bonus_mana(int32_t value);
  private:
  int32_t _internal_ultimate_scepter_consumed_alchemist_bonus_mana() const;
  void _internal_set_ultimate_scepter_consumed_alchemist_bonus_mana(int32_t value);
  public:

  // optional float duration = 5 [default = -1];
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  float duration() const;
  void set_duration(float value);
  private:
  float _internal_duration() const;
  void _internal_set_duration(float value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario.Modifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::CMsgDotaScenario_EntityRef* parent_;
    ::CMsgDotaScenario_EntityRef* caster_;
    ::CMsgDotaScenario_EntityRef* ability_;
    float lifetime_remaining_;
    int32_t stack_count_;
    bool create_even_if_existing_;
    bool create_without_caster_;
    bool create_without_ability_;
    int32_t moonshard_consumed_bonus_;
    int32_t moonshard_consumed_bonus_night_vision_;
    int32_t wardtruesight_range_;
    int32_t ultimate_scepter_consumed_alchemist_bonus_all_stats_;
    int32_t ultimate_scepter_consumed_alchemist_bonus_health_;
    int32_t ultimate_scepter_consumed_alchemist_bonus_mana_;
    float duration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// -------------------------------------------------------------------

class CMsgDotaScenario final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDotaScenario) */ {
 public:
  inline CMsgDotaScenario() : CMsgDotaScenario(nullptr) {}
  ~CMsgDotaScenario() override;
  explicit PROTOBUF_CONSTEXPR CMsgDotaScenario(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDotaScenario(const CMsgDotaScenario& from);
  CMsgDotaScenario(CMsgDotaScenario&& from) noexcept
    : CMsgDotaScenario() {
    *this = ::std::move(from);
  }

  inline CMsgDotaScenario& operator=(const CMsgDotaScenario& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDotaScenario& operator=(CMsgDotaScenario&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDotaScenario& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDotaScenario* internal_default_instance() {
    return reinterpret_cast<const CMsgDotaScenario*>(
               &_CMsgDotaScenario_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CMsgDotaScenario& a, CMsgDotaScenario& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDotaScenario* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDotaScenario* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDotaScenario* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDotaScenario>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDotaScenario& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDotaScenario& from) {
    CMsgDotaScenario::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDotaScenario* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDotaScenario";
  }
  protected:
  explicit CMsgDotaScenario(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDotaScenario_EntityRef EntityRef;
  typedef CMsgDotaScenario_Game Game;
  typedef CMsgDotaScenario_TeamNeutralItem TeamNeutralItem;
  typedef CMsgDotaScenario_Team Team;
  typedef CMsgDotaScenario_HeroHeroInt HeroHeroInt;
  typedef CMsgDotaScenario_HeroHeroFloat HeroHeroFloat;
  typedef CMsgDotaScenario_DamageStatsByType DamageStatsByType;
  typedef CMsgDotaScenario_HeroAbility HeroAbility;
  typedef CMsgDotaScenario_Hero Hero;
  typedef CMsgDotaScenario_Stock Stock;
  typedef CMsgDotaScenario_Building Building;
  typedef CMsgDotaScenario_Entity Entity;
  typedef CMsgDotaScenario_Item Item;
  typedef CMsgDotaScenario_Modifier Modifier;

  // accessors -------------------------------------------------------

  enum : int {
    kTeamsFieldNumber = 3,
    kHeroesFieldNumber = 4,
    kStockFieldNumber = 5,
    kBuildingsFieldNumber = 6,
    kEntitiesFieldNumber = 7,
    kItemsFieldNumber = 8,
    kModifiersFieldNumber = 9,
    kGameFieldNumber = 2,
    kLobbyIdFieldNumber = 1,
  };
  // repeated .CMsgDotaScenario.Team teams = 3;
  int teams_size() const;
  private:
  int _internal_teams_size() const;
  public:
  void clear_teams();
  ::CMsgDotaScenario_Team* mutable_teams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Team >*
      mutable_teams();
  private:
  const ::CMsgDotaScenario_Team& _internal_teams(int index) const;
  ::CMsgDotaScenario_Team* _internal_add_teams();
  public:
  const ::CMsgDotaScenario_Team& teams(int index) const;
  ::CMsgDotaScenario_Team* add_teams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Team >&
      teams() const;

  // repeated .CMsgDotaScenario.Hero heroes = 4;
  int heroes_size() const;
  private:
  int _internal_heroes_size() const;
  public:
  void clear_heroes();
  ::CMsgDotaScenario_Hero* mutable_heroes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Hero >*
      mutable_heroes();
  private:
  const ::CMsgDotaScenario_Hero& _internal_heroes(int index) const;
  ::CMsgDotaScenario_Hero* _internal_add_heroes();
  public:
  const ::CMsgDotaScenario_Hero& heroes(int index) const;
  ::CMsgDotaScenario_Hero* add_heroes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Hero >&
      heroes() const;

  // repeated .CMsgDotaScenario.Stock stock = 5;
  int stock_size() const;
  private:
  int _internal_stock_size() const;
  public:
  void clear_stock();
  ::CMsgDotaScenario_Stock* mutable_stock(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Stock >*
      mutable_stock();
  private:
  const ::CMsgDotaScenario_Stock& _internal_stock(int index) const;
  ::CMsgDotaScenario_Stock* _internal_add_stock();
  public:
  const ::CMsgDotaScenario_Stock& stock(int index) const;
  ::CMsgDotaScenario_Stock* add_stock();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Stock >&
      stock() const;

  // repeated .CMsgDotaScenario.Building buildings = 6;
  int buildings_size() const;
  private:
  int _internal_buildings_size() const;
  public:
  void clear_buildings();
  ::CMsgDotaScenario_Building* mutable_buildings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Building >*
      mutable_buildings();
  private:
  const ::CMsgDotaScenario_Building& _internal_buildings(int index) const;
  ::CMsgDotaScenario_Building* _internal_add_buildings();
  public:
  const ::CMsgDotaScenario_Building& buildings(int index) const;
  ::CMsgDotaScenario_Building* add_buildings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Building >&
      buildings() const;

  // repeated .CMsgDotaScenario.Entity entities = 7;
  int entities_size() const;
  private:
  int _internal_entities_size() const;
  public:
  void clear_entities();
  ::CMsgDotaScenario_Entity* mutable_entities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Entity >*
      mutable_entities();
  private:
  const ::CMsgDotaScenario_Entity& _internal_entities(int index) const;
  ::CMsgDotaScenario_Entity* _internal_add_entities();
  public:
  const ::CMsgDotaScenario_Entity& entities(int index) const;
  ::CMsgDotaScenario_Entity* add_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Entity >&
      entities() const;

  // repeated .CMsgDotaScenario.Item items = 8;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::CMsgDotaScenario_Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Item >*
      mutable_items();
  private:
  const ::CMsgDotaScenario_Item& _internal_items(int index) const;
  ::CMsgDotaScenario_Item* _internal_add_items();
  public:
  const ::CMsgDotaScenario_Item& items(int index) const;
  ::CMsgDotaScenario_Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Item >&
      items() const;

  // repeated .CMsgDotaScenario.Modifier modifiers = 9;
  int modifiers_size() const;
  private:
  int _internal_modifiers_size() const;
  public:
  void clear_modifiers();
  ::CMsgDotaScenario_Modifier* mutable_modifiers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Modifier >*
      mutable_modifiers();
  private:
  const ::CMsgDotaScenario_Modifier& _internal_modifiers(int index) const;
  ::CMsgDotaScenario_Modifier* _internal_add_modifiers();
  public:
  const ::CMsgDotaScenario_Modifier& modifiers(int index) const;
  ::CMsgDotaScenario_Modifier* add_modifiers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Modifier >&
      modifiers() const;

  // optional .CMsgDotaScenario.Game game = 2;
  bool has_game() const;
  private:
  bool _internal_has_game() const;
  public:
  void clear_game();
  const ::CMsgDotaScenario_Game& game() const;
  PROTOBUF_NODISCARD ::CMsgDotaScenario_Game* release_game();
  ::CMsgDotaScenario_Game* mutable_game();
  void set_allocated_game(::CMsgDotaScenario_Game* game);
  private:
  const ::CMsgDotaScenario_Game& _internal_game() const;
  ::CMsgDotaScenario_Game* _internal_mutable_game();
  public:
  void unsafe_arena_set_allocated_game(
      ::CMsgDotaScenario_Game* game);
  ::CMsgDotaScenario_Game* unsafe_arena_release_game();

  // optional uint64 lobby_id = 1;
  bool has_lobby_id() const;
  private:
  bool _internal_has_lobby_id() const;
  public:
  void clear_lobby_id();
  uint64_t lobby_id() const;
  void set_lobby_id(uint64_t value);
  private:
  uint64_t _internal_lobby_id() const;
  void _internal_set_lobby_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDotaScenario)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Team > teams_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Hero > heroes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Stock > stock_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Building > buildings_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Entity > entities_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Item > items_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Modifier > modifiers_;
    ::CMsgDotaScenario_Game* game_;
    uint64_t lobby_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fscenariomessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CScenario_Position

// optional float x = 1;
inline bool CScenario_Position::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CScenario_Position::has_x() const {
  return _internal_has_x();
}
inline void CScenario_Position::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float CScenario_Position::_internal_x() const {
  return _impl_.x_;
}
inline float CScenario_Position::x() const {
  // @@protoc_insertion_point(field_get:CScenario_Position.x)
  return _internal_x();
}
inline void CScenario_Position::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void CScenario_Position::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:CScenario_Position.x)
}

// optional float y = 2;
inline bool CScenario_Position::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CScenario_Position::has_y() const {
  return _internal_has_y();
}
inline void CScenario_Position::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float CScenario_Position::_internal_y() const {
  return _impl_.y_;
}
inline float CScenario_Position::y() const {
  // @@protoc_insertion_point(field_get:CScenario_Position.y)
  return _internal_y();
}
inline void CScenario_Position::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void CScenario_Position::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:CScenario_Position.y)
}

// -------------------------------------------------------------------

// CScenarioGame_RoshanSpawner

// optional int32 kill_count = 1;
inline bool CScenarioGame_RoshanSpawner::_internal_has_kill_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CScenarioGame_RoshanSpawner::has_kill_count() const {
  return _internal_has_kill_count();
}
inline void CScenarioGame_RoshanSpawner::clear_kill_count() {
  _impl_.kill_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CScenarioGame_RoshanSpawner::_internal_kill_count() const {
  return _impl_.kill_count_;
}
inline int32_t CScenarioGame_RoshanSpawner::kill_count() const {
  // @@protoc_insertion_point(field_get:CScenarioGame_RoshanSpawner.kill_count)
  return _internal_kill_count();
}
inline void CScenarioGame_RoshanSpawner::_internal_set_kill_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.kill_count_ = value;
}
inline void CScenarioGame_RoshanSpawner::set_kill_count(int32_t value) {
  _internal_set_kill_count(value);
  // @@protoc_insertion_point(field_set:CScenarioGame_RoshanSpawner.kill_count)
}

// optional int32 state = 2;
inline bool CScenarioGame_RoshanSpawner::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CScenarioGame_RoshanSpawner::has_state() const {
  return _internal_has_state();
}
inline void CScenarioGame_RoshanSpawner::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CScenarioGame_RoshanSpawner::_internal_state() const {
  return _impl_.state_;
}
inline int32_t CScenarioGame_RoshanSpawner::state() const {
  // @@protoc_insertion_point(field_get:CScenarioGame_RoshanSpawner.state)
  return _internal_state();
}
inline void CScenarioGame_RoshanSpawner::_internal_set_state(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_ = value;
}
inline void CScenarioGame_RoshanSpawner::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:CScenarioGame_RoshanSpawner.state)
}

// optional float cooldown = 3;
inline bool CScenarioGame_RoshanSpawner::_internal_has_cooldown() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CScenarioGame_RoshanSpawner::has_cooldown() const {
  return _internal_has_cooldown();
}
inline void CScenarioGame_RoshanSpawner::clear_cooldown() {
  _impl_.cooldown_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float CScenarioGame_RoshanSpawner::_internal_cooldown() const {
  return _impl_.cooldown_;
}
inline float CScenarioGame_RoshanSpawner::cooldown() const {
  // @@protoc_insertion_point(field_get:CScenarioGame_RoshanSpawner.cooldown)
  return _internal_cooldown();
}
inline void CScenarioGame_RoshanSpawner::_internal_set_cooldown(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cooldown_ = value;
}
inline void CScenarioGame_RoshanSpawner::set_cooldown(float value) {
  _internal_set_cooldown(value);
  // @@protoc_insertion_point(field_set:CScenarioGame_RoshanSpawner.cooldown)
}

// -------------------------------------------------------------------

// CScenarioEnt_Courier

// optional int32 team_number = 1;
inline bool CScenarioEnt_Courier::_internal_has_team_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CScenarioEnt_Courier::has_team_number() const {
  return _internal_has_team_number();
}
inline void CScenarioEnt_Courier::clear_team_number() {
  _impl_.team_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CScenarioEnt_Courier::_internal_team_number() const {
  return _impl_.team_number_;
}
inline int32_t CScenarioEnt_Courier::team_number() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_Courier.team_number)
  return _internal_team_number();
}
inline void CScenarioEnt_Courier::_internal_set_team_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.team_number_ = value;
}
inline void CScenarioEnt_Courier::set_team_number(int32_t value) {
  _internal_set_team_number(value);
  // @@protoc_insertion_point(field_set:CScenarioEnt_Courier.team_number)
}

// optional int32 owner_player_id = 2 [default = -1];
inline bool CScenarioEnt_Courier::_internal_has_owner_player_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CScenarioEnt_Courier::has_owner_player_id() const {
  return _internal_has_owner_player_id();
}
inline void CScenarioEnt_Courier::clear_owner_player_id() {
  _impl_.owner_player_id_ = -1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CScenarioEnt_Courier::_internal_owner_player_id() const {
  return _impl_.owner_player_id_;
}
inline int32_t CScenarioEnt_Courier::owner_player_id() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_Courier.owner_player_id)
  return _internal_owner_player_id();
}
inline void CScenarioEnt_Courier::_internal_set_owner_player_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.owner_player_id_ = value;
}
inline void CScenarioEnt_Courier::set_owner_player_id(int32_t value) {
  _internal_set_owner_player_id(value);
  // @@protoc_insertion_point(field_set:CScenarioEnt_Courier.owner_player_id)
}

// optional float cooldown = 3 [default = -1];
inline bool CScenarioEnt_Courier::_internal_has_cooldown() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CScenarioEnt_Courier::has_cooldown() const {
  return _internal_has_cooldown();
}
inline void CScenarioEnt_Courier::clear_cooldown() {
  _impl_.cooldown_ = -1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float CScenarioEnt_Courier::_internal_cooldown() const {
  return _impl_.cooldown_;
}
inline float CScenarioEnt_Courier::cooldown() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_Courier.cooldown)
  return _internal_cooldown();
}
inline void CScenarioEnt_Courier::_internal_set_cooldown(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cooldown_ = value;
}
inline void CScenarioEnt_Courier::set_cooldown(float value) {
  _internal_set_cooldown(value);
  // @@protoc_insertion_point(field_set:CScenarioEnt_Courier.cooldown)
}

// -------------------------------------------------------------------

// CScenarioEnt_NPC

// optional .CScenario_Position position = 1;
inline bool CScenarioEnt_NPC::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool CScenarioEnt_NPC::has_position() const {
  return _internal_has_position();
}
inline void CScenarioEnt_NPC::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::CScenario_Position& CScenarioEnt_NPC::_internal_position() const {
  const ::CScenario_Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::CScenario_Position&>(
      ::_CScenario_Position_default_instance_);
}
inline const ::CScenario_Position& CScenarioEnt_NPC::position() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_NPC.position)
  return _internal_position();
}
inline void CScenarioEnt_NPC::unsafe_arena_set_allocated_position(
    ::CScenario_Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CScenarioEnt_NPC.position)
}
inline ::CScenario_Position* CScenarioEnt_NPC::release_position() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CScenario_Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CScenario_Position* CScenarioEnt_NPC::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:CScenarioEnt_NPC.position)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CScenario_Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::CScenario_Position* CScenarioEnt_NPC::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::CScenario_Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::CScenario_Position* CScenarioEnt_NPC::mutable_position() {
  ::CScenario_Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:CScenarioEnt_NPC.position)
  return _msg;
}
inline void CScenarioEnt_NPC::set_allocated_position(::CScenario_Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:CScenarioEnt_NPC.position)
}

// optional string unit_name = 2;
inline bool CScenarioEnt_NPC::_internal_has_unit_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CScenarioEnt_NPC::has_unit_name() const {
  return _internal_has_unit_name();
}
inline void CScenarioEnt_NPC::clear_unit_name() {
  _impl_.unit_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CScenarioEnt_NPC::unit_name() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_NPC.unit_name)
  return _internal_unit_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CScenarioEnt_NPC::set_unit_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.unit_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CScenarioEnt_NPC.unit_name)
}
inline std::string* CScenarioEnt_NPC::mutable_unit_name() {
  std::string* _s = _internal_mutable_unit_name();
  // @@protoc_insertion_point(field_mutable:CScenarioEnt_NPC.unit_name)
  return _s;
}
inline const std::string& CScenarioEnt_NPC::_internal_unit_name() const {
  return _impl_.unit_name_.Get();
}
inline void CScenarioEnt_NPC::_internal_set_unit_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.unit_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CScenarioEnt_NPC::_internal_mutable_unit_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.unit_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CScenarioEnt_NPC::release_unit_name() {
  // @@protoc_insertion_point(field_release:CScenarioEnt_NPC.unit_name)
  if (!_internal_has_unit_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.unit_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_name_.IsDefault()) {
    _impl_.unit_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CScenarioEnt_NPC::set_allocated_unit_name(std::string* unit_name) {
  if (unit_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.unit_name_.SetAllocated(unit_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_name_.IsDefault()) {
    _impl_.unit_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CScenarioEnt_NPC.unit_name)
}

// optional int32 team_number = 3;
inline bool CScenarioEnt_NPC::_internal_has_team_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CScenarioEnt_NPC::has_team_number() const {
  return _internal_has_team_number();
}
inline void CScenarioEnt_NPC::clear_team_number() {
  _impl_.team_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t CScenarioEnt_NPC::_internal_team_number() const {
  return _impl_.team_number_;
}
inline int32_t CScenarioEnt_NPC::team_number() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_NPC.team_number)
  return _internal_team_number();
}
inline void CScenarioEnt_NPC::_internal_set_team_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.team_number_ = value;
}
inline void CScenarioEnt_NPC::set_team_number(int32_t value) {
  _internal_set_team_number(value);
  // @@protoc_insertion_point(field_set:CScenarioEnt_NPC.team_number)
}

// optional float health_frac = 4 [default = 1];
inline bool CScenarioEnt_NPC::_internal_has_health_frac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CScenarioEnt_NPC::has_health_frac() const {
  return _internal_has_health_frac();
}
inline void CScenarioEnt_NPC::clear_health_frac() {
  _impl_.health_frac_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float CScenarioEnt_NPC::_internal_health_frac() const {
  return _impl_.health_frac_;
}
inline float CScenarioEnt_NPC::health_frac() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_NPC.health_frac)
  return _internal_health_frac();
}
inline void CScenarioEnt_NPC::_internal_set_health_frac(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.health_frac_ = value;
}
inline void CScenarioEnt_NPC::set_health_frac(float value) {
  _internal_set_health_frac(value);
  // @@protoc_insertion_point(field_set:CScenarioEnt_NPC.health_frac)
}

// optional string owning_camp = 10;
inline bool CScenarioEnt_NPC::_internal_has_owning_camp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CScenarioEnt_NPC::has_owning_camp() const {
  return _internal_has_owning_camp();
}
inline void CScenarioEnt_NPC::clear_owning_camp() {
  _impl_.owning_camp_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CScenarioEnt_NPC::owning_camp() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_NPC.owning_camp)
  return _internal_owning_camp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CScenarioEnt_NPC::set_owning_camp(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.owning_camp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CScenarioEnt_NPC.owning_camp)
}
inline std::string* CScenarioEnt_NPC::mutable_owning_camp() {
  std::string* _s = _internal_mutable_owning_camp();
  // @@protoc_insertion_point(field_mutable:CScenarioEnt_NPC.owning_camp)
  return _s;
}
inline const std::string& CScenarioEnt_NPC::_internal_owning_camp() const {
  return _impl_.owning_camp_.Get();
}
inline void CScenarioEnt_NPC::_internal_set_owning_camp(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.owning_camp_.Set(value, GetArenaForAllocation());
}
inline std::string* CScenarioEnt_NPC::_internal_mutable_owning_camp() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.owning_camp_.Mutable(GetArenaForAllocation());
}
inline std::string* CScenarioEnt_NPC::release_owning_camp() {
  // @@protoc_insertion_point(field_release:CScenarioEnt_NPC.owning_camp)
  if (!_internal_has_owning_camp()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.owning_camp_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owning_camp_.IsDefault()) {
    _impl_.owning_camp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CScenarioEnt_NPC::set_allocated_owning_camp(std::string* owning_camp) {
  if (owning_camp != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.owning_camp_.SetAllocated(owning_camp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owning_camp_.IsDefault()) {
    _impl_.owning_camp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CScenarioEnt_NPC.owning_camp)
}

// optional .CScenario_Position owning_camp_position = 11;
inline bool CScenarioEnt_NPC::_internal_has_owning_camp_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.owning_camp_position_ != nullptr);
  return value;
}
inline bool CScenarioEnt_NPC::has_owning_camp_position() const {
  return _internal_has_owning_camp_position();
}
inline void CScenarioEnt_NPC::clear_owning_camp_position() {
  if (_impl_.owning_camp_position_ != nullptr) _impl_.owning_camp_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::CScenario_Position& CScenarioEnt_NPC::_internal_owning_camp_position() const {
  const ::CScenario_Position* p = _impl_.owning_camp_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::CScenario_Position&>(
      ::_CScenario_Position_default_instance_);
}
inline const ::CScenario_Position& CScenarioEnt_NPC::owning_camp_position() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_NPC.owning_camp_position)
  return _internal_owning_camp_position();
}
inline void CScenarioEnt_NPC::unsafe_arena_set_allocated_owning_camp_position(
    ::CScenario_Position* owning_camp_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.owning_camp_position_);
  }
  _impl_.owning_camp_position_ = owning_camp_position;
  if (owning_camp_position) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CScenarioEnt_NPC.owning_camp_position)
}
inline ::CScenario_Position* CScenarioEnt_NPC::release_owning_camp_position() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::CScenario_Position* temp = _impl_.owning_camp_position_;
  _impl_.owning_camp_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CScenario_Position* CScenarioEnt_NPC::unsafe_arena_release_owning_camp_position() {
  // @@protoc_insertion_point(field_release:CScenarioEnt_NPC.owning_camp_position)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::CScenario_Position* temp = _impl_.owning_camp_position_;
  _impl_.owning_camp_position_ = nullptr;
  return temp;
}
inline ::CScenario_Position* CScenarioEnt_NPC::_internal_mutable_owning_camp_position() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.owning_camp_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::CScenario_Position>(GetArenaForAllocation());
    _impl_.owning_camp_position_ = p;
  }
  return _impl_.owning_camp_position_;
}
inline ::CScenario_Position* CScenarioEnt_NPC::mutable_owning_camp_position() {
  ::CScenario_Position* _msg = _internal_mutable_owning_camp_position();
  // @@protoc_insertion_point(field_mutable:CScenarioEnt_NPC.owning_camp_position)
  return _msg;
}
inline void CScenarioEnt_NPC::set_allocated_owning_camp_position(::CScenario_Position* owning_camp_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.owning_camp_position_;
  }
  if (owning_camp_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(owning_camp_position);
    if (message_arena != submessage_arena) {
      owning_camp_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owning_camp_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.owning_camp_position_ = owning_camp_position;
  // @@protoc_insertion_point(field_set_allocated:CScenarioEnt_NPC.owning_camp_position)
}

// optional string invade_goal = 20;
inline bool CScenarioEnt_NPC::_internal_has_invade_goal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CScenarioEnt_NPC::has_invade_goal() const {
  return _internal_has_invade_goal();
}
inline void CScenarioEnt_NPC::clear_invade_goal() {
  _impl_.invade_goal_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CScenarioEnt_NPC::invade_goal() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_NPC.invade_goal)
  return _internal_invade_goal();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CScenarioEnt_NPC::set_invade_goal(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.invade_goal_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CScenarioEnt_NPC.invade_goal)
}
inline std::string* CScenarioEnt_NPC::mutable_invade_goal() {
  std::string* _s = _internal_mutable_invade_goal();
  // @@protoc_insertion_point(field_mutable:CScenarioEnt_NPC.invade_goal)
  return _s;
}
inline const std::string& CScenarioEnt_NPC::_internal_invade_goal() const {
  return _impl_.invade_goal_.Get();
}
inline void CScenarioEnt_NPC::_internal_set_invade_goal(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.invade_goal_.Set(value, GetArenaForAllocation());
}
inline std::string* CScenarioEnt_NPC::_internal_mutable_invade_goal() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.invade_goal_.Mutable(GetArenaForAllocation());
}
inline std::string* CScenarioEnt_NPC::release_invade_goal() {
  // @@protoc_insertion_point(field_release:CScenarioEnt_NPC.invade_goal)
  if (!_internal_has_invade_goal()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.invade_goal_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invade_goal_.IsDefault()) {
    _impl_.invade_goal_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CScenarioEnt_NPC::set_allocated_invade_goal(std::string* invade_goal) {
  if (invade_goal != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.invade_goal_.SetAllocated(invade_goal, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invade_goal_.IsDefault()) {
    _impl_.invade_goal_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CScenarioEnt_NPC.invade_goal)
}

// -------------------------------------------------------------------

// CScenarioEnt_SpiritBear

// optional int32 owner_id = 1 [default = -1];
inline bool CScenarioEnt_SpiritBear::_internal_has_owner_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CScenarioEnt_SpiritBear::has_owner_id() const {
  return _internal_has_owner_id();
}
inline void CScenarioEnt_SpiritBear::clear_owner_id() {
  _impl_.owner_id_ = -1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CScenarioEnt_SpiritBear::_internal_owner_id() const {
  return _impl_.owner_id_;
}
inline int32_t CScenarioEnt_SpiritBear::owner_id() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_SpiritBear.owner_id)
  return _internal_owner_id();
}
inline void CScenarioEnt_SpiritBear::_internal_set_owner_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.owner_id_ = value;
}
inline void CScenarioEnt_SpiritBear::set_owner_id(int32_t value) {
  _internal_set_owner_id(value);
  // @@protoc_insertion_point(field_set:CScenarioEnt_SpiritBear.owner_id)
}

// optional int32 team_id = 2;
inline bool CScenarioEnt_SpiritBear::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CScenarioEnt_SpiritBear::has_team_id() const {
  return _internal_has_team_id();
}
inline void CScenarioEnt_SpiritBear::clear_team_id() {
  _impl_.team_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CScenarioEnt_SpiritBear::_internal_team_id() const {
  return _impl_.team_id_;
}
inline int32_t CScenarioEnt_SpiritBear::team_id() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_SpiritBear.team_id)
  return _internal_team_id();
}
inline void CScenarioEnt_SpiritBear::_internal_set_team_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.team_id_ = value;
}
inline void CScenarioEnt_SpiritBear::set_team_id(int32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CScenarioEnt_SpiritBear.team_id)
}

// -------------------------------------------------------------------

// CScenarioEnt_DroppedItem

// optional .CScenario_Position position = 1;
inline bool CScenarioEnt_DroppedItem::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool CScenarioEnt_DroppedItem::has_position() const {
  return _internal_has_position();
}
inline void CScenarioEnt_DroppedItem::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CScenario_Position& CScenarioEnt_DroppedItem::_internal_position() const {
  const ::CScenario_Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::CScenario_Position&>(
      ::_CScenario_Position_default_instance_);
}
inline const ::CScenario_Position& CScenarioEnt_DroppedItem::position() const {
  // @@protoc_insertion_point(field_get:CScenarioEnt_DroppedItem.position)
  return _internal_position();
}
inline void CScenarioEnt_DroppedItem::unsafe_arena_set_allocated_position(
    ::CScenario_Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CScenarioEnt_DroppedItem.position)
}
inline ::CScenario_Position* CScenarioEnt_DroppedItem::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CScenario_Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CScenario_Position* CScenarioEnt_DroppedItem::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:CScenarioEnt_DroppedItem.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CScenario_Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::CScenario_Position* CScenarioEnt_DroppedItem::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::CScenario_Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::CScenario_Position* CScenarioEnt_DroppedItem::mutable_position() {
  ::CScenario_Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:CScenarioEnt_DroppedItem.position)
  return _msg;
}
inline void CScenarioEnt_DroppedItem::set_allocated_position(::CScenario_Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:CScenarioEnt_DroppedItem.position)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_EntityRef

// optional int32 player_id = 1 [default = -1];
inline bool CMsgDotaScenario_EntityRef::_internal_has_player_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDotaScenario_EntityRef::has_player_id() const {
  return _internal_has_player_id();
}
inline void CMsgDotaScenario_EntityRef::clear_player_id() {
  _impl_.player_id_ = -1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t CMsgDotaScenario_EntityRef::_internal_player_id() const {
  return _impl_.player_id_;
}
inline int32_t CMsgDotaScenario_EntityRef::player_id() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.EntityRef.player_id)
  return _internal_player_id();
}
inline void CMsgDotaScenario_EntityRef::_internal_set_player_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.player_id_ = value;
}
inline void CMsgDotaScenario_EntityRef::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.EntityRef.player_id)
}

// optional int32 neutral_stash_id = 2 [default = -1];
inline bool CMsgDotaScenario_EntityRef::_internal_has_neutral_stash_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDotaScenario_EntityRef::has_neutral_stash_id() const {
  return _internal_has_neutral_stash_id();
}
inline void CMsgDotaScenario_EntityRef::clear_neutral_stash_id() {
  _impl_.neutral_stash_id_ = -1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t CMsgDotaScenario_EntityRef::_internal_neutral_stash_id() const {
  return _impl_.neutral_stash_id_;
}
inline int32_t CMsgDotaScenario_EntityRef::neutral_stash_id() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.EntityRef.neutral_stash_id)
  return _internal_neutral_stash_id();
}
inline void CMsgDotaScenario_EntityRef::_internal_set_neutral_stash_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.neutral_stash_id_ = value;
}
inline void CMsgDotaScenario_EntityRef::set_neutral_stash_id(int32_t value) {
  _internal_set_neutral_stash_id(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.EntityRef.neutral_stash_id)
}

// optional int32 entity_idx = 3 [default = -1];
inline bool CMsgDotaScenario_EntityRef::_internal_has_entity_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDotaScenario_EntityRef::has_entity_idx() const {
  return _internal_has_entity_idx();
}
inline void CMsgDotaScenario_EntityRef::clear_entity_idx() {
  _impl_.entity_idx_ = -1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t CMsgDotaScenario_EntityRef::_internal_entity_idx() const {
  return _impl_.entity_idx_;
}
inline int32_t CMsgDotaScenario_EntityRef::entity_idx() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.EntityRef.entity_idx)
  return _internal_entity_idx();
}
inline void CMsgDotaScenario_EntityRef::_internal_set_entity_idx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.entity_idx_ = value;
}
inline void CMsgDotaScenario_EntityRef::set_entity_idx(int32_t value) {
  _internal_set_entity_idx(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.EntityRef.entity_idx)
}

// optional bool roshan = 4 [default = false];
inline bool CMsgDotaScenario_EntityRef::_internal_has_roshan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDotaScenario_EntityRef::has_roshan() const {
  return _internal_has_roshan();
}
inline void CMsgDotaScenario_EntityRef::clear_roshan() {
  _impl_.roshan_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CMsgDotaScenario_EntityRef::_internal_roshan() const {
  return _impl_.roshan_;
}
inline bool CMsgDotaScenario_EntityRef::roshan() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.EntityRef.roshan)
  return _internal_roshan();
}
inline void CMsgDotaScenario_EntityRef::_internal_set_roshan(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.roshan_ = value;
}
inline void CMsgDotaScenario_EntityRef::set_roshan(bool value) {
  _internal_set_roshan(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.EntityRef.roshan)
}

// optional string ability_name = 10;
inline bool CMsgDotaScenario_EntityRef::_internal_has_ability_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_EntityRef::has_ability_name() const {
  return _internal_has_ability_name();
}
inline void CMsgDotaScenario_EntityRef::clear_ability_name() {
  _impl_.ability_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDotaScenario_EntityRef::ability_name() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.EntityRef.ability_name)
  return _internal_ability_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDotaScenario_EntityRef::set_ability_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ability_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.EntityRef.ability_name)
}
inline std::string* CMsgDotaScenario_EntityRef::mutable_ability_name() {
  std::string* _s = _internal_mutable_ability_name();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.EntityRef.ability_name)
  return _s;
}
inline const std::string& CMsgDotaScenario_EntityRef::_internal_ability_name() const {
  return _impl_.ability_name_.Get();
}
inline void CMsgDotaScenario_EntityRef::_internal_set_ability_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ability_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_EntityRef::_internal_mutable_ability_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ability_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_EntityRef::release_ability_name() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.EntityRef.ability_name)
  if (!_internal_has_ability_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ability_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ability_name_.IsDefault()) {
    _impl_.ability_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDotaScenario_EntityRef::set_allocated_ability_name(std::string* ability_name) {
  if (ability_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ability_name_.SetAllocated(ability_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ability_name_.IsDefault()) {
    _impl_.ability_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.EntityRef.ability_name)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_Game

// optional uint64 match_id = 1;
inline bool CMsgDotaScenario_Game::_internal_has_match_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Game::has_match_id() const {
  return _internal_has_match_id();
}
inline void CMsgDotaScenario_Game::clear_match_id() {
  _impl_.match_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CMsgDotaScenario_Game::_internal_match_id() const {
  return _impl_.match_id_;
}
inline uint64_t CMsgDotaScenario_Game::match_id() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Game.match_id)
  return _internal_match_id();
}
inline void CMsgDotaScenario_Game::_internal_set_match_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.match_id_ = value;
}
inline void CMsgDotaScenario_Game::set_match_id(uint64_t value) {
  _internal_set_match_id(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Game.match_id)
}

// optional int32 game_mode = 2;
inline bool CMsgDotaScenario_Game::_internal_has_game_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Game::has_game_mode() const {
  return _internal_has_game_mode();
}
inline void CMsgDotaScenario_Game::clear_game_mode() {
  _impl_.game_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t CMsgDotaScenario_Game::_internal_game_mode() const {
  return _impl_.game_mode_;
}
inline int32_t CMsgDotaScenario_Game::game_mode() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Game.game_mode)
  return _internal_game_mode();
}
inline void CMsgDotaScenario_Game::_internal_set_game_mode(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.game_mode_ = value;
}
inline void CMsgDotaScenario_Game::set_game_mode(int32_t value) {
  _internal_set_game_mode(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Game.game_mode)
}

// optional float clock_time = 3;
inline bool CMsgDotaScenario_Game::_internal_has_clock_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Game::has_clock_time() const {
  return _internal_has_clock_time();
}
inline void CMsgDotaScenario_Game::clear_clock_time() {
  _impl_.clock_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float CMsgDotaScenario_Game::_internal_clock_time() const {
  return _impl_.clock_time_;
}
inline float CMsgDotaScenario_Game::clock_time() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Game.clock_time)
  return _internal_clock_time();
}
inline void CMsgDotaScenario_Game::_internal_set_clock_time(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.clock_time_ = value;
}
inline void CMsgDotaScenario_Game::set_clock_time(float value) {
  _internal_set_clock_time(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Game.clock_time)
}

// optional float internal_time = 4;
inline bool CMsgDotaScenario_Game::_internal_has_internal_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Game::has_internal_time() const {
  return _internal_has_internal_time();
}
inline void CMsgDotaScenario_Game::clear_internal_time() {
  _impl_.internal_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float CMsgDotaScenario_Game::_internal_internal_time() const {
  return _impl_.internal_time_;
}
inline float CMsgDotaScenario_Game::internal_time() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Game.internal_time)
  return _internal_internal_time();
}
inline void CMsgDotaScenario_Game::_internal_set_internal_time(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.internal_time_ = value;
}
inline void CMsgDotaScenario_Game::set_internal_time(float value) {
  _internal_set_internal_time(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Game.internal_time)
}

// optional .CScenarioGame_RoshanSpawner roshan = 5;
inline bool CMsgDotaScenario_Game::_internal_has_roshan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.roshan_ != nullptr);
  return value;
}
inline bool CMsgDotaScenario_Game::has_roshan() const {
  return _internal_has_roshan();
}
inline void CMsgDotaScenario_Game::clear_roshan() {
  if (_impl_.roshan_ != nullptr) _impl_.roshan_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CScenarioGame_RoshanSpawner& CMsgDotaScenario_Game::_internal_roshan() const {
  const ::CScenarioGame_RoshanSpawner* p = _impl_.roshan_;
  return p != nullptr ? *p : reinterpret_cast<const ::CScenarioGame_RoshanSpawner&>(
      ::_CScenarioGame_RoshanSpawner_default_instance_);
}
inline const ::CScenarioGame_RoshanSpawner& CMsgDotaScenario_Game::roshan() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Game.roshan)
  return _internal_roshan();
}
inline void CMsgDotaScenario_Game::unsafe_arena_set_allocated_roshan(
    ::CScenarioGame_RoshanSpawner* roshan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.roshan_);
  }
  _impl_.roshan_ = roshan;
  if (roshan) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDotaScenario.Game.roshan)
}
inline ::CScenarioGame_RoshanSpawner* CMsgDotaScenario_Game::release_roshan() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CScenarioGame_RoshanSpawner* temp = _impl_.roshan_;
  _impl_.roshan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CScenarioGame_RoshanSpawner* CMsgDotaScenario_Game::unsafe_arena_release_roshan() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Game.roshan)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CScenarioGame_RoshanSpawner* temp = _impl_.roshan_;
  _impl_.roshan_ = nullptr;
  return temp;
}
inline ::CScenarioGame_RoshanSpawner* CMsgDotaScenario_Game::_internal_mutable_roshan() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.roshan_ == nullptr) {
    auto* p = CreateMaybeMessage<::CScenarioGame_RoshanSpawner>(GetArenaForAllocation());
    _impl_.roshan_ = p;
  }
  return _impl_.roshan_;
}
inline ::CScenarioGame_RoshanSpawner* CMsgDotaScenario_Game::mutable_roshan() {
  ::CScenarioGame_RoshanSpawner* _msg = _internal_mutable_roshan();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Game.roshan)
  return _msg;
}
inline void CMsgDotaScenario_Game::set_allocated_roshan(::CScenarioGame_RoshanSpawner* roshan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.roshan_;
  }
  if (roshan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(roshan);
    if (message_arena != submessage_arena) {
      roshan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roshan, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.roshan_ = roshan;
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Game.roshan)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_TeamNeutralItem

// optional string name = 1;
inline bool CMsgDotaScenario_TeamNeutralItem::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_TeamNeutralItem::has_name() const {
  return _internal_has_name();
}
inline void CMsgDotaScenario_TeamNeutralItem::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDotaScenario_TeamNeutralItem::name() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.TeamNeutralItem.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDotaScenario_TeamNeutralItem::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.TeamNeutralItem.name)
}
inline std::string* CMsgDotaScenario_TeamNeutralItem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.TeamNeutralItem.name)
  return _s;
}
inline const std::string& CMsgDotaScenario_TeamNeutralItem::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDotaScenario_TeamNeutralItem::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_TeamNeutralItem::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_TeamNeutralItem::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.TeamNeutralItem.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDotaScenario_TeamNeutralItem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.TeamNeutralItem.name)
}

// optional bool consumed = 2;
inline bool CMsgDotaScenario_TeamNeutralItem::_internal_has_consumed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDotaScenario_TeamNeutralItem::has_consumed() const {
  return _internal_has_consumed();
}
inline void CMsgDotaScenario_TeamNeutralItem::clear_consumed() {
  _impl_.consumed_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CMsgDotaScenario_TeamNeutralItem::_internal_consumed() const {
  return _impl_.consumed_;
}
inline bool CMsgDotaScenario_TeamNeutralItem::consumed() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.TeamNeutralItem.consumed)
  return _internal_consumed();
}
inline void CMsgDotaScenario_TeamNeutralItem::_internal_set_consumed(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.consumed_ = value;
}
inline void CMsgDotaScenario_TeamNeutralItem::set_consumed(bool value) {
  _internal_set_consumed(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.TeamNeutralItem.consumed)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_Team

// optional int32 team_number = 1;
inline bool CMsgDotaScenario_Team::_internal_has_team_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Team::has_team_number() const {
  return _internal_has_team_number();
}
inline void CMsgDotaScenario_Team::clear_team_number() {
  _impl_.team_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CMsgDotaScenario_Team::_internal_team_number() const {
  return _impl_.team_number_;
}
inline int32_t CMsgDotaScenario_Team::team_number() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Team.team_number)
  return _internal_team_number();
}
inline void CMsgDotaScenario_Team::_internal_set_team_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.team_number_ = value;
}
inline void CMsgDotaScenario_Team::set_team_number(int32_t value) {
  _internal_set_team_number(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Team.team_number)
}

// repeated .CMsgDotaScenario.TeamNeutralItem neutral_items = 2;
inline int CMsgDotaScenario_Team::_internal_neutral_items_size() const {
  return _impl_.neutral_items_.size();
}
inline int CMsgDotaScenario_Team::neutral_items_size() const {
  return _internal_neutral_items_size();
}
inline void CMsgDotaScenario_Team::clear_neutral_items() {
  _impl_.neutral_items_.Clear();
}
inline ::CMsgDotaScenario_TeamNeutralItem* CMsgDotaScenario_Team::mutable_neutral_items(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Team.neutral_items)
  return _impl_.neutral_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_TeamNeutralItem >*
CMsgDotaScenario_Team::mutable_neutral_items() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDotaScenario.Team.neutral_items)
  return &_impl_.neutral_items_;
}
inline const ::CMsgDotaScenario_TeamNeutralItem& CMsgDotaScenario_Team::_internal_neutral_items(int index) const {
  return _impl_.neutral_items_.Get(index);
}
inline const ::CMsgDotaScenario_TeamNeutralItem& CMsgDotaScenario_Team::neutral_items(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Team.neutral_items)
  return _internal_neutral_items(index);
}
inline ::CMsgDotaScenario_TeamNeutralItem* CMsgDotaScenario_Team::_internal_add_neutral_items() {
  return _impl_.neutral_items_.Add();
}
inline ::CMsgDotaScenario_TeamNeutralItem* CMsgDotaScenario_Team::add_neutral_items() {
  ::CMsgDotaScenario_TeamNeutralItem* _add = _internal_add_neutral_items();
  // @@protoc_insertion_point(field_add:CMsgDotaScenario.Team.neutral_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_TeamNeutralItem >&
CMsgDotaScenario_Team::neutral_items() const {
  // @@protoc_insertion_point(field_list:CMsgDotaScenario.Team.neutral_items)
  return _impl_.neutral_items_;
}

// optional int32 hero_kills = 3;
inline bool CMsgDotaScenario_Team::_internal_has_hero_kills() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Team::has_hero_kills() const {
  return _internal_has_hero_kills();
}
inline void CMsgDotaScenario_Team::clear_hero_kills() {
  _impl_.hero_kills_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CMsgDotaScenario_Team::_internal_hero_kills() const {
  return _impl_.hero_kills_;
}
inline int32_t CMsgDotaScenario_Team::hero_kills() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Team.hero_kills)
  return _internal_hero_kills();
}
inline void CMsgDotaScenario_Team::_internal_set_hero_kills(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.hero_kills_ = value;
}
inline void CMsgDotaScenario_Team::set_hero_kills(int32_t value) {
  _internal_set_hero_kills(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Team.hero_kills)
}

// optional int32 tower_kills = 4;
inline bool CMsgDotaScenario_Team::_internal_has_tower_kills() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Team::has_tower_kills() const {
  return _internal_has_tower_kills();
}
inline void CMsgDotaScenario_Team::clear_tower_kills() {
  _impl_.tower_kills_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t CMsgDotaScenario_Team::_internal_tower_kills() const {
  return _impl_.tower_kills_;
}
inline int32_t CMsgDotaScenario_Team::tower_kills() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Team.tower_kills)
  return _internal_tower_kills();
}
inline void CMsgDotaScenario_Team::_internal_set_tower_kills(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tower_kills_ = value;
}
inline void CMsgDotaScenario_Team::set_tower_kills(int32_t value) {
  _internal_set_tower_kills(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Team.tower_kills)
}

// optional int32 barracks_kills = 5;
inline bool CMsgDotaScenario_Team::_internal_has_barracks_kills() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Team::has_barracks_kills() const {
  return _internal_has_barracks_kills();
}
inline void CMsgDotaScenario_Team::clear_barracks_kills() {
  _impl_.barracks_kills_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t CMsgDotaScenario_Team::_internal_barracks_kills() const {
  return _impl_.barracks_kills_;
}
inline int32_t CMsgDotaScenario_Team::barracks_kills() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Team.barracks_kills)
  return _internal_barracks_kills();
}
inline void CMsgDotaScenario_Team::_internal_set_barracks_kills(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.barracks_kills_ = value;
}
inline void CMsgDotaScenario_Team::set_barracks_kills(int32_t value) {
  _internal_set_barracks_kills(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Team.barracks_kills)
}

// optional float glyph_cooldown = 6;
inline bool CMsgDotaScenario_Team::_internal_has_glyph_cooldown() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Team::has_glyph_cooldown() const {
  return _internal_has_glyph_cooldown();
}
inline void CMsgDotaScenario_Team::clear_glyph_cooldown() {
  _impl_.glyph_cooldown_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float CMsgDotaScenario_Team::_internal_glyph_cooldown() const {
  return _impl_.glyph_cooldown_;
}
inline float CMsgDotaScenario_Team::glyph_cooldown() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Team.glyph_cooldown)
  return _internal_glyph_cooldown();
}
inline void CMsgDotaScenario_Team::_internal_set_glyph_cooldown(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.glyph_cooldown_ = value;
}
inline void CMsgDotaScenario_Team::set_glyph_cooldown(float value) {
  _internal_set_glyph_cooldown(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Team.glyph_cooldown)
}

// optional float radar_cooldown = 7;
inline bool CMsgDotaScenario_Team::_internal_has_radar_cooldown() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Team::has_radar_cooldown() const {
  return _internal_has_radar_cooldown();
}
inline void CMsgDotaScenario_Team::clear_radar_cooldown() {
  _impl_.radar_cooldown_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float CMsgDotaScenario_Team::_internal_radar_cooldown() const {
  return _impl_.radar_cooldown_;
}
inline float CMsgDotaScenario_Team::radar_cooldown() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Team.radar_cooldown)
  return _internal_radar_cooldown();
}
inline void CMsgDotaScenario_Team::_internal_set_radar_cooldown(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.radar_cooldown_ = value;
}
inline void CMsgDotaScenario_Team::set_radar_cooldown(float value) {
  _internal_set_radar_cooldown(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Team.radar_cooldown)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_HeroHeroInt

// optional int32 player_id = 1 [default = -1];
inline bool CMsgDotaScenario_HeroHeroInt::_internal_has_player_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDotaScenario_HeroHeroInt::has_player_id() const {
  return _internal_has_player_id();
}
inline void CMsgDotaScenario_HeroHeroInt::clear_player_id() {
  _impl_.player_id_ = -1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CMsgDotaScenario_HeroHeroInt::_internal_player_id() const {
  return _impl_.player_id_;
}
inline int32_t CMsgDotaScenario_HeroHeroInt::player_id() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.HeroHeroInt.player_id)
  return _internal_player_id();
}
inline void CMsgDotaScenario_HeroHeroInt::_internal_set_player_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.player_id_ = value;
}
inline void CMsgDotaScenario_HeroHeroInt::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.HeroHeroInt.player_id)
}

// optional int32 value = 2;
inline bool CMsgDotaScenario_HeroHeroInt::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_HeroHeroInt::has_value() const {
  return _internal_has_value();
}
inline void CMsgDotaScenario_HeroHeroInt::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CMsgDotaScenario_HeroHeroInt::_internal_value() const {
  return _impl_.value_;
}
inline int32_t CMsgDotaScenario_HeroHeroInt::value() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.HeroHeroInt.value)
  return _internal_value();
}
inline void CMsgDotaScenario_HeroHeroInt::_internal_set_value(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_ = value;
}
inline void CMsgDotaScenario_HeroHeroInt::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.HeroHeroInt.value)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_HeroHeroFloat

// optional int32 player_id = 1 [default = -1];
inline bool CMsgDotaScenario_HeroHeroFloat::_internal_has_player_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDotaScenario_HeroHeroFloat::has_player_id() const {
  return _internal_has_player_id();
}
inline void CMsgDotaScenario_HeroHeroFloat::clear_player_id() {
  _impl_.player_id_ = -1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CMsgDotaScenario_HeroHeroFloat::_internal_player_id() const {
  return _impl_.player_id_;
}
inline int32_t CMsgDotaScenario_HeroHeroFloat::player_id() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.HeroHeroFloat.player_id)
  return _internal_player_id();
}
inline void CMsgDotaScenario_HeroHeroFloat::_internal_set_player_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.player_id_ = value;
}
inline void CMsgDotaScenario_HeroHeroFloat::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.HeroHeroFloat.player_id)
}

// optional float value = 2;
inline bool CMsgDotaScenario_HeroHeroFloat::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_HeroHeroFloat::has_value() const {
  return _internal_has_value();
}
inline void CMsgDotaScenario_HeroHeroFloat::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float CMsgDotaScenario_HeroHeroFloat::_internal_value() const {
  return _impl_.value_;
}
inline float CMsgDotaScenario_HeroHeroFloat::value() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.HeroHeroFloat.value)
  return _internal_value();
}
inline void CMsgDotaScenario_HeroHeroFloat::_internal_set_value(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_ = value;
}
inline void CMsgDotaScenario_HeroHeroFloat::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.HeroHeroFloat.value)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_DamageStatsByType

// optional int32 damage_type = 1;
inline bool CMsgDotaScenario_DamageStatsByType::_internal_has_damage_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_DamageStatsByType::has_damage_type() const {
  return _internal_has_damage_type();
}
inline void CMsgDotaScenario_DamageStatsByType::clear_damage_type() {
  _impl_.damage_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CMsgDotaScenario_DamageStatsByType::_internal_damage_type() const {
  return _impl_.damage_type_;
}
inline int32_t CMsgDotaScenario_DamageStatsByType::damage_type() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.DamageStatsByType.damage_type)
  return _internal_damage_type();
}
inline void CMsgDotaScenario_DamageStatsByType::_internal_set_damage_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.damage_type_ = value;
}
inline void CMsgDotaScenario_DamageStatsByType::set_damage_type(int32_t value) {
  _internal_set_damage_type(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.DamageStatsByType.damage_type)
}

// optional int32 received_pre_reduction = 2;
inline bool CMsgDotaScenario_DamageStatsByType::_internal_has_received_pre_reduction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDotaScenario_DamageStatsByType::has_received_pre_reduction() const {
  return _internal_has_received_pre_reduction();
}
inline void CMsgDotaScenario_DamageStatsByType::clear_received_pre_reduction() {
  _impl_.received_pre_reduction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CMsgDotaScenario_DamageStatsByType::_internal_received_pre_reduction() const {
  return _impl_.received_pre_reduction_;
}
inline int32_t CMsgDotaScenario_DamageStatsByType::received_pre_reduction() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.DamageStatsByType.received_pre_reduction)
  return _internal_received_pre_reduction();
}
inline void CMsgDotaScenario_DamageStatsByType::_internal_set_received_pre_reduction(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.received_pre_reduction_ = value;
}
inline void CMsgDotaScenario_DamageStatsByType::set_received_pre_reduction(int32_t value) {
  _internal_set_received_pre_reduction(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.DamageStatsByType.received_pre_reduction)
}

// optional int32 received_post_reduction = 3;
inline bool CMsgDotaScenario_DamageStatsByType::_internal_has_received_post_reduction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDotaScenario_DamageStatsByType::has_received_post_reduction() const {
  return _internal_has_received_post_reduction();
}
inline void CMsgDotaScenario_DamageStatsByType::clear_received_post_reduction() {
  _impl_.received_post_reduction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t CMsgDotaScenario_DamageStatsByType::_internal_received_post_reduction() const {
  return _impl_.received_post_reduction_;
}
inline int32_t CMsgDotaScenario_DamageStatsByType::received_post_reduction() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.DamageStatsByType.received_post_reduction)
  return _internal_received_post_reduction();
}
inline void CMsgDotaScenario_DamageStatsByType::_internal_set_received_post_reduction(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.received_post_reduction_ = value;
}
inline void CMsgDotaScenario_DamageStatsByType::set_received_post_reduction(int32_t value) {
  _internal_set_received_post_reduction(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.DamageStatsByType.received_post_reduction)
}

// optional int32 outgoing_pre_reduction = 4;
inline bool CMsgDotaScenario_DamageStatsByType::_internal_has_outgoing_pre_reduction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDotaScenario_DamageStatsByType::has_outgoing_pre_reduction() const {
  return _internal_has_outgoing_pre_reduction();
}
inline void CMsgDotaScenario_DamageStatsByType::clear_outgoing_pre_reduction() {
  _impl_.outgoing_pre_reduction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t CMsgDotaScenario_DamageStatsByType::_internal_outgoing_pre_reduction() const {
  return _impl_.outgoing_pre_reduction_;
}
inline int32_t CMsgDotaScenario_DamageStatsByType::outgoing_pre_reduction() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.DamageStatsByType.outgoing_pre_reduction)
  return _internal_outgoing_pre_reduction();
}
inline void CMsgDotaScenario_DamageStatsByType::_internal_set_outgoing_pre_reduction(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.outgoing_pre_reduction_ = value;
}
inline void CMsgDotaScenario_DamageStatsByType::set_outgoing_pre_reduction(int32_t value) {
  _internal_set_outgoing_pre_reduction(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.DamageStatsByType.outgoing_pre_reduction)
}

// optional int32 outgoing_post_reduction = 5;
inline bool CMsgDotaScenario_DamageStatsByType::_internal_has_outgoing_post_reduction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDotaScenario_DamageStatsByType::has_outgoing_post_reduction() const {
  return _internal_has_outgoing_post_reduction();
}
inline void CMsgDotaScenario_DamageStatsByType::clear_outgoing_post_reduction() {
  _impl_.outgoing_post_reduction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t CMsgDotaScenario_DamageStatsByType::_internal_outgoing_post_reduction() const {
  return _impl_.outgoing_post_reduction_;
}
inline int32_t CMsgDotaScenario_DamageStatsByType::outgoing_post_reduction() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.DamageStatsByType.outgoing_post_reduction)
  return _internal_outgoing_post_reduction();
}
inline void CMsgDotaScenario_DamageStatsByType::_internal_set_outgoing_post_reduction(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.outgoing_post_reduction_ = value;
}
inline void CMsgDotaScenario_DamageStatsByType::set_outgoing_post_reduction(int32_t value) {
  _internal_set_outgoing_post_reduction(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.DamageStatsByType.outgoing_post_reduction)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_HeroAbility

// optional string name = 1;
inline bool CMsgDotaScenario_HeroAbility::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_HeroAbility::has_name() const {
  return _internal_has_name();
}
inline void CMsgDotaScenario_HeroAbility::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDotaScenario_HeroAbility::name() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.HeroAbility.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDotaScenario_HeroAbility::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.HeroAbility.name)
}
inline std::string* CMsgDotaScenario_HeroAbility::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.HeroAbility.name)
  return _s;
}
inline const std::string& CMsgDotaScenario_HeroAbility::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDotaScenario_HeroAbility::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_HeroAbility::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_HeroAbility::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.HeroAbility.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDotaScenario_HeroAbility::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.HeroAbility.name)
}

// optional int32 level = 2;
inline bool CMsgDotaScenario_HeroAbility::_internal_has_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDotaScenario_HeroAbility::has_level() const {
  return _internal_has_level();
}
inline void CMsgDotaScenario_HeroAbility::clear_level() {
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CMsgDotaScenario_HeroAbility::_internal_level() const {
  return _impl_.level_;
}
inline int32_t CMsgDotaScenario_HeroAbility::level() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.HeroAbility.level)
  return _internal_level();
}
inline void CMsgDotaScenario_HeroAbility::_internal_set_level(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.level_ = value;
}
inline void CMsgDotaScenario_HeroAbility::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.HeroAbility.level)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_Hero

// optional fixed64 steam_id = 1;
inline bool CMsgDotaScenario_Hero::_internal_has_steam_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_steam_id() const {
  return _internal_has_steam_id();
}
inline void CMsgDotaScenario_Hero::clear_steam_id() {
  _impl_.steam_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CMsgDotaScenario_Hero::_internal_steam_id() const {
  return _impl_.steam_id_;
}
inline uint64_t CMsgDotaScenario_Hero::steam_id() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.steam_id)
  return _internal_steam_id();
}
inline void CMsgDotaScenario_Hero::_internal_set_steam_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.steam_id_ = value;
}
inline void CMsgDotaScenario_Hero::set_steam_id(uint64_t value) {
  _internal_set_steam_id(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.steam_id)
}

// optional int32 player_id = 2 [default = -1];
inline bool CMsgDotaScenario_Hero::_internal_has_player_id() const {
  bool value = (_impl_._has_bits_[1] & 0x04000000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_player_id() const {
  return _internal_has_player_id();
}
inline void CMsgDotaScenario_Hero::clear_player_id() {
  _impl_.player_id_ = -1;
  _impl_._has_bits_[1] &= ~0x04000000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_player_id() const {
  return _impl_.player_id_;
}
inline int32_t CMsgDotaScenario_Hero::player_id() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.player_id)
  return _internal_player_id();
}
inline void CMsgDotaScenario_Hero::_internal_set_player_id(int32_t value) {
  _impl_._has_bits_[1] |= 0x04000000u;
  _impl_.player_id_ = value;
}
inline void CMsgDotaScenario_Hero::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.player_id)
}

// optional int32 team_id = 3;
inline bool CMsgDotaScenario_Hero::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDotaScenario_Hero::clear_team_id() {
  _impl_.team_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_team_id() const {
  return _impl_.team_id_;
}
inline int32_t CMsgDotaScenario_Hero::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.team_id)
  return _internal_team_id();
}
inline void CMsgDotaScenario_Hero::_internal_set_team_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.team_id_ = value;
}
inline void CMsgDotaScenario_Hero::set_team_id(int32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.team_id)
}

// optional string hero = 4;
inline bool CMsgDotaScenario_Hero::_internal_has_hero() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_hero() const {
  return _internal_has_hero();
}
inline void CMsgDotaScenario_Hero::clear_hero() {
  _impl_.hero_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDotaScenario_Hero::hero() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.hero)
  return _internal_hero();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDotaScenario_Hero::set_hero(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.hero_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.hero)
}
inline std::string* CMsgDotaScenario_Hero::mutable_hero() {
  std::string* _s = _internal_mutable_hero();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Hero.hero)
  return _s;
}
inline const std::string& CMsgDotaScenario_Hero::_internal_hero() const {
  return _impl_.hero_.Get();
}
inline void CMsgDotaScenario_Hero::_internal_set_hero(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hero_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_Hero::_internal_mutable_hero() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hero_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_Hero::release_hero() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Hero.hero)
  if (!_internal_has_hero()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.hero_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hero_.IsDefault()) {
    _impl_.hero_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDotaScenario_Hero::set_allocated_hero(std::string* hero) {
  if (hero != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hero_.SetAllocated(hero, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hero_.IsDefault()) {
    _impl_.hero_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Hero.hero)
}

// optional int32 total_xp = 5;
inline bool CMsgDotaScenario_Hero::_internal_has_total_xp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_total_xp() const {
  return _internal_has_total_xp();
}
inline void CMsgDotaScenario_Hero::clear_total_xp() {
  _impl_.total_xp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_total_xp() const {
  return _impl_.total_xp_;
}
inline int32_t CMsgDotaScenario_Hero::total_xp() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.total_xp)
  return _internal_total_xp();
}
inline void CMsgDotaScenario_Hero::_internal_set_total_xp(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.total_xp_ = value;
}
inline void CMsgDotaScenario_Hero::set_total_xp(int32_t value) {
  _internal_set_total_xp(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.total_xp)
}

// optional int32 bkb_charges_used = 6;
inline bool CMsgDotaScenario_Hero::_internal_has_bkb_charges_used() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_bkb_charges_used() const {
  return _internal_has_bkb_charges_used();
}
inline void CMsgDotaScenario_Hero::clear_bkb_charges_used() {
  _impl_.bkb_charges_used_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_bkb_charges_used() const {
  return _impl_.bkb_charges_used_;
}
inline int32_t CMsgDotaScenario_Hero::bkb_charges_used() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.bkb_charges_used)
  return _internal_bkb_charges_used();
}
inline void CMsgDotaScenario_Hero::_internal_set_bkb_charges_used(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.bkb_charges_used_ = value;
}
inline void CMsgDotaScenario_Hero::set_bkb_charges_used(int32_t value) {
  _internal_set_bkb_charges_used(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.bkb_charges_used)
}

// optional int32 aeon_charges_used = 7;
inline bool CMsgDotaScenario_Hero::_internal_has_aeon_charges_used() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_aeon_charges_used() const {
  return _internal_has_aeon_charges_used();
}
inline void CMsgDotaScenario_Hero::clear_aeon_charges_used() {
  _impl_.aeon_charges_used_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_aeon_charges_used() const {
  return _impl_.aeon_charges_used_;
}
inline int32_t CMsgDotaScenario_Hero::aeon_charges_used() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.aeon_charges_used)
  return _internal_aeon_charges_used();
}
inline void CMsgDotaScenario_Hero::_internal_set_aeon_charges_used(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.aeon_charges_used_ = value;
}
inline void CMsgDotaScenario_Hero::set_aeon_charges_used(int32_t value) {
  _internal_set_aeon_charges_used(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.aeon_charges_used)
}

// optional int32 reliable_gold = 8;
inline bool CMsgDotaScenario_Hero::_internal_has_reliable_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_reliable_gold() const {
  return _internal_has_reliable_gold();
}
inline void CMsgDotaScenario_Hero::clear_reliable_gold() {
  _impl_.reliable_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_reliable_gold() const {
  return _impl_.reliable_gold_;
}
inline int32_t CMsgDotaScenario_Hero::reliable_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.reliable_gold)
  return _internal_reliable_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_reliable_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.reliable_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_reliable_gold(int32_t value) {
  _internal_set_reliable_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.reliable_gold)
}

// optional int32 unreliable_gold = 9;
inline bool CMsgDotaScenario_Hero::_internal_has_unreliable_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_unreliable_gold() const {
  return _internal_has_unreliable_gold();
}
inline void CMsgDotaScenario_Hero::clear_unreliable_gold() {
  _impl_.unreliable_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_unreliable_gold() const {
  return _impl_.unreliable_gold_;
}
inline int32_t CMsgDotaScenario_Hero::unreliable_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.unreliable_gold)
  return _internal_unreliable_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_unreliable_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.unreliable_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_unreliable_gold(int32_t value) {
  _internal_set_unreliable_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.unreliable_gold)
}

// optional int32 total_earned_gold = 10;
inline bool CMsgDotaScenario_Hero::_internal_has_total_earned_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_total_earned_gold() const {
  return _internal_has_total_earned_gold();
}
inline void CMsgDotaScenario_Hero::clear_total_earned_gold() {
  _impl_.total_earned_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_total_earned_gold() const {
  return _impl_.total_earned_gold_;
}
inline int32_t CMsgDotaScenario_Hero::total_earned_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.total_earned_gold)
  return _internal_total_earned_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_total_earned_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.total_earned_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_total_earned_gold(int32_t value) {
  _internal_set_total_earned_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.total_earned_gold)
}

// optional int32 shared_gold = 11;
inline bool CMsgDotaScenario_Hero::_internal_has_shared_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_shared_gold() const {
  return _internal_has_shared_gold();
}
inline void CMsgDotaScenario_Hero::clear_shared_gold() {
  _impl_.shared_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_shared_gold() const {
  return _impl_.shared_gold_;
}
inline int32_t CMsgDotaScenario_Hero::shared_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.shared_gold)
  return _internal_shared_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_shared_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.shared_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_shared_gold(int32_t value) {
  _internal_set_shared_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.shared_gold)
}

// optional int32 hero_kill_gold = 12;
inline bool CMsgDotaScenario_Hero::_internal_has_hero_kill_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_hero_kill_gold() const {
  return _internal_has_hero_kill_gold();
}
inline void CMsgDotaScenario_Hero::clear_hero_kill_gold() {
  _impl_.hero_kill_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_hero_kill_gold() const {
  return _impl_.hero_kill_gold_;
}
inline int32_t CMsgDotaScenario_Hero::hero_kill_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.hero_kill_gold)
  return _internal_hero_kill_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_hero_kill_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.hero_kill_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_hero_kill_gold(int32_t value) {
  _internal_set_hero_kill_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.hero_kill_gold)
}

// optional int32 creep_kill_gold = 13;
inline bool CMsgDotaScenario_Hero::_internal_has_creep_kill_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_creep_kill_gold() const {
  return _internal_has_creep_kill_gold();
}
inline void CMsgDotaScenario_Hero::clear_creep_kill_gold() {
  _impl_.creep_kill_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_creep_kill_gold() const {
  return _impl_.creep_kill_gold_;
}
inline int32_t CMsgDotaScenario_Hero::creep_kill_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.creep_kill_gold)
  return _internal_creep_kill_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_creep_kill_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.creep_kill_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_creep_kill_gold(int32_t value) {
  _internal_set_creep_kill_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.creep_kill_gold)
}

// optional int32 neutral_kill_gold = 14;
inline bool CMsgDotaScenario_Hero::_internal_has_neutral_kill_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_neutral_kill_gold() const {
  return _internal_has_neutral_kill_gold();
}
inline void CMsgDotaScenario_Hero::clear_neutral_kill_gold() {
  _impl_.neutral_kill_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_neutral_kill_gold() const {
  return _impl_.neutral_kill_gold_;
}
inline int32_t CMsgDotaScenario_Hero::neutral_kill_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.neutral_kill_gold)
  return _internal_neutral_kill_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_neutral_kill_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.neutral_kill_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_neutral_kill_gold(int32_t value) {
  _internal_set_neutral_kill_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.neutral_kill_gold)
}

// optional int32 courier_gold = 15;
inline bool CMsgDotaScenario_Hero::_internal_has_courier_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_courier_gold() const {
  return _internal_has_courier_gold();
}
inline void CMsgDotaScenario_Hero::clear_courier_gold() {
  _impl_.courier_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_courier_gold() const {
  return _impl_.courier_gold_;
}
inline int32_t CMsgDotaScenario_Hero::courier_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.courier_gold)
  return _internal_courier_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_courier_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.courier_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_courier_gold(int32_t value) {
  _internal_set_courier_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.courier_gold)
}

// optional int32 bounty_gold = 16;
inline bool CMsgDotaScenario_Hero::_internal_has_bounty_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_bounty_gold() const {
  return _internal_has_bounty_gold();
}
inline void CMsgDotaScenario_Hero::clear_bounty_gold() {
  _impl_.bounty_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_bounty_gold() const {
  return _impl_.bounty_gold_;
}
inline int32_t CMsgDotaScenario_Hero::bounty_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.bounty_gold)
  return _internal_bounty_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_bounty_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.bounty_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_bounty_gold(int32_t value) {
  _internal_set_bounty_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.bounty_gold)
}

// optional int32 roshan_gold = 17;
inline bool CMsgDotaScenario_Hero::_internal_has_roshan_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_roshan_gold() const {
  return _internal_has_roshan_gold();
}
inline void CMsgDotaScenario_Hero::clear_roshan_gold() {
  _impl_.roshan_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_roshan_gold() const {
  return _impl_.roshan_gold_;
}
inline int32_t CMsgDotaScenario_Hero::roshan_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.roshan_gold)
  return _internal_roshan_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_roshan_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.roshan_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_roshan_gold(int32_t value) {
  _internal_set_roshan_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.roshan_gold)
}

// optional int32 building_gold = 18;
inline bool CMsgDotaScenario_Hero::_internal_has_building_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_building_gold() const {
  return _internal_has_building_gold();
}
inline void CMsgDotaScenario_Hero::clear_building_gold() {
  _impl_.building_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_building_gold() const {
  return _impl_.building_gold_;
}
inline int32_t CMsgDotaScenario_Hero::building_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.building_gold)
  return _internal_building_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_building_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.building_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_building_gold(int32_t value) {
  _internal_set_building_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.building_gold)
}

// optional int32 other_gold = 19;
inline bool CMsgDotaScenario_Hero::_internal_has_other_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_other_gold() const {
  return _internal_has_other_gold();
}
inline void CMsgDotaScenario_Hero::clear_other_gold() {
  _impl_.other_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_other_gold() const {
  return _impl_.other_gold_;
}
inline int32_t CMsgDotaScenario_Hero::other_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.other_gold)
  return _internal_other_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_other_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.other_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_other_gold(int32_t value) {
  _internal_set_other_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.other_gold)
}

// optional int32 income_gold = 26;
inline bool CMsgDotaScenario_Hero::_internal_has_income_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_income_gold() const {
  return _internal_has_income_gold();
}
inline void CMsgDotaScenario_Hero::clear_income_gold() {
  _impl_.income_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_income_gold() const {
  return _impl_.income_gold_;
}
inline int32_t CMsgDotaScenario_Hero::income_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.income_gold)
  return _internal_income_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_income_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.income_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_income_gold(int32_t value) {
  _internal_set_income_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.income_gold)
}

// optional int32 ward_kill_gold = 27;
inline bool CMsgDotaScenario_Hero::_internal_has_ward_kill_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_ward_kill_gold() const {
  return _internal_has_ward_kill_gold();
}
inline void CMsgDotaScenario_Hero::clear_ward_kill_gold() {
  _impl_.ward_kill_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_ward_kill_gold() const {
  return _impl_.ward_kill_gold_;
}
inline int32_t CMsgDotaScenario_Hero::ward_kill_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.ward_kill_gold)
  return _internal_ward_kill_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_ward_kill_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.ward_kill_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_ward_kill_gold(int32_t value) {
  _internal_set_ward_kill_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.ward_kill_gold)
}

// optional int32 ability_gold = 28;
inline bool CMsgDotaScenario_Hero::_internal_has_ability_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_ability_gold() const {
  return _internal_has_ability_gold();
}
inline void CMsgDotaScenario_Hero::clear_ability_gold() {
  _impl_.ability_gold_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_ability_gold() const {
  return _impl_.ability_gold_;
}
inline int32_t CMsgDotaScenario_Hero::ability_gold() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.ability_gold)
  return _internal_ability_gold();
}
inline void CMsgDotaScenario_Hero::_internal_set_ability_gold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.ability_gold_ = value;
}
inline void CMsgDotaScenario_Hero::set_ability_gold(int32_t value) {
  _internal_set_ability_gold(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.ability_gold)
}

// optional int32 denies = 29;
inline bool CMsgDotaScenario_Hero::_internal_has_denies() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_denies() const {
  return _internal_has_denies();
}
inline void CMsgDotaScenario_Hero::clear_denies() {
  _impl_.denies_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_denies() const {
  return _impl_.denies_;
}
inline int32_t CMsgDotaScenario_Hero::denies() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.denies)
  return _internal_denies();
}
inline void CMsgDotaScenario_Hero::_internal_set_denies(int32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.denies_ = value;
}
inline void CMsgDotaScenario_Hero::set_denies(int32_t value) {
  _internal_set_denies(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.denies)
}

// optional int32 last_hits = 30;
inline bool CMsgDotaScenario_Hero::_internal_has_last_hits() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_last_hits() const {
  return _internal_has_last_hits();
}
inline void CMsgDotaScenario_Hero::clear_last_hits() {
  _impl_.last_hits_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_last_hits() const {
  return _impl_.last_hits_;
}
inline int32_t CMsgDotaScenario_Hero::last_hits() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.last_hits)
  return _internal_last_hits();
}
inline void CMsgDotaScenario_Hero::_internal_set_last_hits(int32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.last_hits_ = value;
}
inline void CMsgDotaScenario_Hero::set_last_hits(int32_t value) {
  _internal_set_last_hits(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.last_hits)
}

// optional int32 last_hit_streak = 31;
inline bool CMsgDotaScenario_Hero::_internal_has_last_hit_streak() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_last_hit_streak() const {
  return _internal_has_last_hit_streak();
}
inline void CMsgDotaScenario_Hero::clear_last_hit_streak() {
  _impl_.last_hit_streak_ = 0;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_last_hit_streak() const {
  return _impl_.last_hit_streak_;
}
inline int32_t CMsgDotaScenario_Hero::last_hit_streak() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.last_hit_streak)
  return _internal_last_hit_streak();
}
inline void CMsgDotaScenario_Hero::_internal_set_last_hit_streak(int32_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.last_hit_streak_ = value;
}
inline void CMsgDotaScenario_Hero::set_last_hit_streak(int32_t value) {
  _internal_set_last_hit_streak(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.last_hit_streak)
}

// optional int32 last_hit_multikill = 32;
inline bool CMsgDotaScenario_Hero::_internal_has_last_hit_multikill() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_last_hit_multikill() const {
  return _internal_has_last_hit_multikill();
}
inline void CMsgDotaScenario_Hero::clear_last_hit_multikill() {
  _impl_.last_hit_multikill_ = 0;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_last_hit_multikill() const {
  return _impl_.last_hit_multikill_;
}
inline int32_t CMsgDotaScenario_Hero::last_hit_multikill() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.last_hit_multikill)
  return _internal_last_hit_multikill();
}
inline void CMsgDotaScenario_Hero::_internal_set_last_hit_multikill(int32_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.last_hit_multikill_ = value;
}
inline void CMsgDotaScenario_Hero::set_last_hit_multikill(int32_t value) {
  _internal_set_last_hit_multikill(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.last_hit_multikill)
}

// optional int32 nearby_creep_death_count = 33;
inline bool CMsgDotaScenario_Hero::_internal_has_nearby_creep_death_count() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_nearby_creep_death_count() const {
  return _internal_has_nearby_creep_death_count();
}
inline void CMsgDotaScenario_Hero::clear_nearby_creep_death_count() {
  _impl_.nearby_creep_death_count_ = 0;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_nearby_creep_death_count() const {
  return _impl_.nearby_creep_death_count_;
}
inline int32_t CMsgDotaScenario_Hero::nearby_creep_death_count() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.nearby_creep_death_count)
  return _internal_nearby_creep_death_count();
}
inline void CMsgDotaScenario_Hero::_internal_set_nearby_creep_death_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.nearby_creep_death_count_ = value;
}
inline void CMsgDotaScenario_Hero::set_nearby_creep_death_count(int32_t value) {
  _internal_set_nearby_creep_death_count(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.nearby_creep_death_count)
}

// optional int32 claimed_deny_count = 34;
inline bool CMsgDotaScenario_Hero::_internal_has_claimed_deny_count() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_claimed_deny_count() const {
  return _internal_has_claimed_deny_count();
}
inline void CMsgDotaScenario_Hero::clear_claimed_deny_count() {
  _impl_.claimed_deny_count_ = 0;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_claimed_deny_count() const {
  return _impl_.claimed_deny_count_;
}
inline int32_t CMsgDotaScenario_Hero::claimed_deny_count() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.claimed_deny_count)
  return _internal_claimed_deny_count();
}
inline void CMsgDotaScenario_Hero::_internal_set_claimed_deny_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.claimed_deny_count_ = value;
}
inline void CMsgDotaScenario_Hero::set_claimed_deny_count(int32_t value) {
  _internal_set_claimed_deny_count(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.claimed_deny_count)
}

// optional int32 claimed_miss_count = 35;
inline bool CMsgDotaScenario_Hero::_internal_has_claimed_miss_count() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_claimed_miss_count() const {
  return _internal_has_claimed_miss_count();
}
inline void CMsgDotaScenario_Hero::clear_claimed_miss_count() {
  _impl_.claimed_miss_count_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_claimed_miss_count() const {
  return _impl_.claimed_miss_count_;
}
inline int32_t CMsgDotaScenario_Hero::claimed_miss_count() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.claimed_miss_count)
  return _internal_claimed_miss_count();
}
inline void CMsgDotaScenario_Hero::_internal_set_claimed_miss_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.claimed_miss_count_ = value;
}
inline void CMsgDotaScenario_Hero::set_claimed_miss_count(int32_t value) {
  _internal_set_claimed_miss_count(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.claimed_miss_count)
}

// optional int32 miss_count = 36;
inline bool CMsgDotaScenario_Hero::_internal_has_miss_count() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_miss_count() const {
  return _internal_has_miss_count();
}
inline void CMsgDotaScenario_Hero::clear_miss_count() {
  _impl_.miss_count_ = 0;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_miss_count() const {
  return _impl_.miss_count_;
}
inline int32_t CMsgDotaScenario_Hero::miss_count() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.miss_count)
  return _internal_miss_count();
}
inline void CMsgDotaScenario_Hero::_internal_set_miss_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.miss_count_ = value;
}
inline void CMsgDotaScenario_Hero::set_miss_count(int32_t value) {
  _internal_set_miss_count(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.miss_count)
}

// optional float buyback_cooldown_time = 40;
inline bool CMsgDotaScenario_Hero::_internal_has_buyback_cooldown_time() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_buyback_cooldown_time() const {
  return _internal_has_buyback_cooldown_time();
}
inline void CMsgDotaScenario_Hero::clear_buyback_cooldown_time() {
  _impl_.buyback_cooldown_time_ = 0;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline float CMsgDotaScenario_Hero::_internal_buyback_cooldown_time() const {
  return _impl_.buyback_cooldown_time_;
}
inline float CMsgDotaScenario_Hero::buyback_cooldown_time() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.buyback_cooldown_time)
  return _internal_buyback_cooldown_time();
}
inline void CMsgDotaScenario_Hero::_internal_set_buyback_cooldown_time(float value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.buyback_cooldown_time_ = value;
}
inline void CMsgDotaScenario_Hero::set_buyback_cooldown_time(float value) {
  _internal_set_buyback_cooldown_time(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.buyback_cooldown_time)
}

// optional float buyback_gold_limit_time = 41;
inline bool CMsgDotaScenario_Hero::_internal_has_buyback_gold_limit_time() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_buyback_gold_limit_time() const {
  return _internal_has_buyback_gold_limit_time();
}
inline void CMsgDotaScenario_Hero::clear_buyback_gold_limit_time() {
  _impl_.buyback_gold_limit_time_ = 0;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline float CMsgDotaScenario_Hero::_internal_buyback_gold_limit_time() const {
  return _impl_.buyback_gold_limit_time_;
}
inline float CMsgDotaScenario_Hero::buyback_gold_limit_time() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.buyback_gold_limit_time)
  return _internal_buyback_gold_limit_time();
}
inline void CMsgDotaScenario_Hero::_internal_set_buyback_gold_limit_time(float value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.buyback_gold_limit_time_ = value;
}
inline void CMsgDotaScenario_Hero::set_buyback_gold_limit_time(float value) {
  _internal_set_buyback_gold_limit_time(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.buyback_gold_limit_time)
}

// optional float stun_duration = 44;
inline bool CMsgDotaScenario_Hero::_internal_has_stun_duration() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_stun_duration() const {
  return _internal_has_stun_duration();
}
inline void CMsgDotaScenario_Hero::clear_stun_duration() {
  _impl_.stun_duration_ = 0;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline float CMsgDotaScenario_Hero::_internal_stun_duration() const {
  return _impl_.stun_duration_;
}
inline float CMsgDotaScenario_Hero::stun_duration() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.stun_duration)
  return _internal_stun_duration();
}
inline void CMsgDotaScenario_Hero::_internal_set_stun_duration(float value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.stun_duration_ = value;
}
inline void CMsgDotaScenario_Hero::set_stun_duration(float value) {
  _internal_set_stun_duration(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.stun_duration)
}

// optional float healing = 45;
inline bool CMsgDotaScenario_Hero::_internal_has_healing() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_healing() const {
  return _internal_has_healing();
}
inline void CMsgDotaScenario_Hero::clear_healing() {
  _impl_.healing_ = 0;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline float CMsgDotaScenario_Hero::_internal_healing() const {
  return _impl_.healing_;
}
inline float CMsgDotaScenario_Hero::healing() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.healing)
  return _internal_healing();
}
inline void CMsgDotaScenario_Hero::_internal_set_healing(float value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.healing_ = value;
}
inline void CMsgDotaScenario_Hero::set_healing(float value) {
  _internal_set_healing(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.healing)
}

// optional int32 tower_kills = 46;
inline bool CMsgDotaScenario_Hero::_internal_has_tower_kills() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_tower_kills() const {
  return _internal_has_tower_kills();
}
inline void CMsgDotaScenario_Hero::clear_tower_kills() {
  _impl_.tower_kills_ = 0;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_tower_kills() const {
  return _impl_.tower_kills_;
}
inline int32_t CMsgDotaScenario_Hero::tower_kills() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.tower_kills)
  return _internal_tower_kills();
}
inline void CMsgDotaScenario_Hero::_internal_set_tower_kills(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.tower_kills_ = value;
}
inline void CMsgDotaScenario_Hero::set_tower_kills(int32_t value) {
  _internal_set_tower_kills(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.tower_kills)
}

// optional int32 roshan_kills = 47;
inline bool CMsgDotaScenario_Hero::_internal_has_roshan_kills() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_roshan_kills() const {
  return _internal_has_roshan_kills();
}
inline void CMsgDotaScenario_Hero::clear_roshan_kills() {
  _impl_.roshan_kills_ = 0;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_roshan_kills() const {
  return _impl_.roshan_kills_;
}
inline int32_t CMsgDotaScenario_Hero::roshan_kills() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.roshan_kills)
  return _internal_roshan_kills();
}
inline void CMsgDotaScenario_Hero::_internal_set_roshan_kills(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.roshan_kills_ = value;
}
inline void CMsgDotaScenario_Hero::set_roshan_kills(int32_t value) {
  _internal_set_roshan_kills(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.roshan_kills)
}

// optional int32 observer_wards_placed = 48;
inline bool CMsgDotaScenario_Hero::_internal_has_observer_wards_placed() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_observer_wards_placed() const {
  return _internal_has_observer_wards_placed();
}
inline void CMsgDotaScenario_Hero::clear_observer_wards_placed() {
  _impl_.observer_wards_placed_ = 0;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_observer_wards_placed() const {
  return _impl_.observer_wards_placed_;
}
inline int32_t CMsgDotaScenario_Hero::observer_wards_placed() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.observer_wards_placed)
  return _internal_observer_wards_placed();
}
inline void CMsgDotaScenario_Hero::_internal_set_observer_wards_placed(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.observer_wards_placed_ = value;
}
inline void CMsgDotaScenario_Hero::set_observer_wards_placed(int32_t value) {
  _internal_set_observer_wards_placed(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.observer_wards_placed)
}

// optional int32 sentry_wards_placed = 49;
inline bool CMsgDotaScenario_Hero::_internal_has_sentry_wards_placed() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_sentry_wards_placed() const {
  return _internal_has_sentry_wards_placed();
}
inline void CMsgDotaScenario_Hero::clear_sentry_wards_placed() {
  _impl_.sentry_wards_placed_ = 0;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_sentry_wards_placed() const {
  return _impl_.sentry_wards_placed_;
}
inline int32_t CMsgDotaScenario_Hero::sentry_wards_placed() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.sentry_wards_placed)
  return _internal_sentry_wards_placed();
}
inline void CMsgDotaScenario_Hero::_internal_set_sentry_wards_placed(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.sentry_wards_placed_ = value;
}
inline void CMsgDotaScenario_Hero::set_sentry_wards_placed(int32_t value) {
  _internal_set_sentry_wards_placed(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.sentry_wards_placed)
}

// optional int32 creeps_stacked = 50;
inline bool CMsgDotaScenario_Hero::_internal_has_creeps_stacked() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_creeps_stacked() const {
  return _internal_has_creeps_stacked();
}
inline void CMsgDotaScenario_Hero::clear_creeps_stacked() {
  _impl_.creeps_stacked_ = 0;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_creeps_stacked() const {
  return _impl_.creeps_stacked_;
}
inline int32_t CMsgDotaScenario_Hero::creeps_stacked() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.creeps_stacked)
  return _internal_creeps_stacked();
}
inline void CMsgDotaScenario_Hero::_internal_set_creeps_stacked(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.creeps_stacked_ = value;
}
inline void CMsgDotaScenario_Hero::set_creeps_stacked(int32_t value) {
  _internal_set_creeps_stacked(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.creeps_stacked)
}

// optional int32 camps_stacked = 51;
inline bool CMsgDotaScenario_Hero::_internal_has_camps_stacked() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_camps_stacked() const {
  return _internal_has_camps_stacked();
}
inline void CMsgDotaScenario_Hero::clear_camps_stacked() {
  _impl_.camps_stacked_ = 0;
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_camps_stacked() const {
  return _impl_.camps_stacked_;
}
inline int32_t CMsgDotaScenario_Hero::camps_stacked() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.camps_stacked)
  return _internal_camps_stacked();
}
inline void CMsgDotaScenario_Hero::_internal_set_camps_stacked(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.camps_stacked_ = value;
}
inline void CMsgDotaScenario_Hero::set_camps_stacked(int32_t value) {
  _internal_set_camps_stacked(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.camps_stacked)
}

// optional int32 rune_pickups = 52;
inline bool CMsgDotaScenario_Hero::_internal_has_rune_pickups() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_rune_pickups() const {
  return _internal_has_rune_pickups();
}
inline void CMsgDotaScenario_Hero::clear_rune_pickups() {
  _impl_.rune_pickups_ = 0;
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_rune_pickups() const {
  return _impl_.rune_pickups_;
}
inline int32_t CMsgDotaScenario_Hero::rune_pickups() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.rune_pickups)
  return _internal_rune_pickups();
}
inline void CMsgDotaScenario_Hero::_internal_set_rune_pickups(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.rune_pickups_ = value;
}
inline void CMsgDotaScenario_Hero::set_rune_pickups(int32_t value) {
  _internal_set_rune_pickups(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.rune_pickups)
}

// optional int32 gold_spent_on_support = 53;
inline bool CMsgDotaScenario_Hero::_internal_has_gold_spent_on_support() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_gold_spent_on_support() const {
  return _internal_has_gold_spent_on_support();
}
inline void CMsgDotaScenario_Hero::clear_gold_spent_on_support() {
  _impl_.gold_spent_on_support_ = 0;
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_gold_spent_on_support() const {
  return _impl_.gold_spent_on_support_;
}
inline int32_t CMsgDotaScenario_Hero::gold_spent_on_support() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.gold_spent_on_support)
  return _internal_gold_spent_on_support();
}
inline void CMsgDotaScenario_Hero::_internal_set_gold_spent_on_support(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.gold_spent_on_support_ = value;
}
inline void CMsgDotaScenario_Hero::set_gold_spent_on_support(int32_t value) {
  _internal_set_gold_spent_on_support(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.gold_spent_on_support)
}

// optional int32 hero_damage = 54;
inline bool CMsgDotaScenario_Hero::_internal_has_hero_damage() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_hero_damage() const {
  return _internal_has_hero_damage();
}
inline void CMsgDotaScenario_Hero::clear_hero_damage() {
  _impl_.hero_damage_ = 0;
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_hero_damage() const {
  return _impl_.hero_damage_;
}
inline int32_t CMsgDotaScenario_Hero::hero_damage() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.hero_damage)
  return _internal_hero_damage();
}
inline void CMsgDotaScenario_Hero::_internal_set_hero_damage(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.hero_damage_ = value;
}
inline void CMsgDotaScenario_Hero::set_hero_damage(int32_t value) {
  _internal_set_hero_damage(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.hero_damage)
}

// optional int32 wards_purchased = 55;
inline bool CMsgDotaScenario_Hero::_internal_has_wards_purchased() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_wards_purchased() const {
  return _internal_has_wards_purchased();
}
inline void CMsgDotaScenario_Hero::clear_wards_purchased() {
  _impl_.wards_purchased_ = 0;
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_wards_purchased() const {
  return _impl_.wards_purchased_;
}
inline int32_t CMsgDotaScenario_Hero::wards_purchased() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.wards_purchased)
  return _internal_wards_purchased();
}
inline void CMsgDotaScenario_Hero::_internal_set_wards_purchased(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000800u;
  _impl_.wards_purchased_ = value;
}
inline void CMsgDotaScenario_Hero::set_wards_purchased(int32_t value) {
  _internal_set_wards_purchased(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.wards_purchased)
}

// optional int32 wards_destroyed = 56;
inline bool CMsgDotaScenario_Hero::_internal_has_wards_destroyed() const {
  bool value = (_impl_._has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_wards_destroyed() const {
  return _internal_has_wards_destroyed();
}
inline void CMsgDotaScenario_Hero::clear_wards_destroyed() {
  _impl_.wards_destroyed_ = 0;
  _impl_._has_bits_[1] &= ~0x00001000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_wards_destroyed() const {
  return _impl_.wards_destroyed_;
}
inline int32_t CMsgDotaScenario_Hero::wards_destroyed() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.wards_destroyed)
  return _internal_wards_destroyed();
}
inline void CMsgDotaScenario_Hero::_internal_set_wards_destroyed(int32_t value) {
  _impl_._has_bits_[1] |= 0x00001000u;
  _impl_.wards_destroyed_ = value;
}
inline void CMsgDotaScenario_Hero::set_wards_destroyed(int32_t value) {
  _internal_set_wards_destroyed(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.wards_destroyed)
}

// optional int32 gold_spent_on_consumables = 58;
inline bool CMsgDotaScenario_Hero::_internal_has_gold_spent_on_consumables() const {
  bool value = (_impl_._has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_gold_spent_on_consumables() const {
  return _internal_has_gold_spent_on_consumables();
}
inline void CMsgDotaScenario_Hero::clear_gold_spent_on_consumables() {
  _impl_.gold_spent_on_consumables_ = 0;
  _impl_._has_bits_[1] &= ~0x00002000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_gold_spent_on_consumables() const {
  return _impl_.gold_spent_on_consumables_;
}
inline int32_t CMsgDotaScenario_Hero::gold_spent_on_consumables() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.gold_spent_on_consumables)
  return _internal_gold_spent_on_consumables();
}
inline void CMsgDotaScenario_Hero::_internal_set_gold_spent_on_consumables(int32_t value) {
  _impl_._has_bits_[1] |= 0x00002000u;
  _impl_.gold_spent_on_consumables_ = value;
}
inline void CMsgDotaScenario_Hero::set_gold_spent_on_consumables(int32_t value) {
  _internal_set_gold_spent_on_consumables(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.gold_spent_on_consumables)
}

// optional int32 gold_spent_on_items = 59;
inline bool CMsgDotaScenario_Hero::_internal_has_gold_spent_on_items() const {
  bool value = (_impl_._has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_gold_spent_on_items() const {
  return _internal_has_gold_spent_on_items();
}
inline void CMsgDotaScenario_Hero::clear_gold_spent_on_items() {
  _impl_.gold_spent_on_items_ = 0;
  _impl_._has_bits_[1] &= ~0x00004000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_gold_spent_on_items() const {
  return _impl_.gold_spent_on_items_;
}
inline int32_t CMsgDotaScenario_Hero::gold_spent_on_items() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.gold_spent_on_items)
  return _internal_gold_spent_on_items();
}
inline void CMsgDotaScenario_Hero::_internal_set_gold_spent_on_items(int32_t value) {
  _impl_._has_bits_[1] |= 0x00004000u;
  _impl_.gold_spent_on_items_ = value;
}
inline void CMsgDotaScenario_Hero::set_gold_spent_on_items(int32_t value) {
  _internal_set_gold_spent_on_items(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.gold_spent_on_items)
}

// optional int32 gold_spent_on_buybacks = 60;
inline bool CMsgDotaScenario_Hero::_internal_has_gold_spent_on_buybacks() const {
  bool value = (_impl_._has_bits_[1] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_gold_spent_on_buybacks() const {
  return _internal_has_gold_spent_on_buybacks();
}
inline void CMsgDotaScenario_Hero::clear_gold_spent_on_buybacks() {
  _impl_.gold_spent_on_buybacks_ = 0;
  _impl_._has_bits_[1] &= ~0x00008000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_gold_spent_on_buybacks() const {
  return _impl_.gold_spent_on_buybacks_;
}
inline int32_t CMsgDotaScenario_Hero::gold_spent_on_buybacks() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.gold_spent_on_buybacks)
  return _internal_gold_spent_on_buybacks();
}
inline void CMsgDotaScenario_Hero::_internal_set_gold_spent_on_buybacks(int32_t value) {
  _impl_._has_bits_[1] |= 0x00008000u;
  _impl_.gold_spent_on_buybacks_ = value;
}
inline void CMsgDotaScenario_Hero::set_gold_spent_on_buybacks(int32_t value) {
  _internal_set_gold_spent_on_buybacks(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.gold_spent_on_buybacks)
}

// optional int32 gold_lost_to_death = 61;
inline bool CMsgDotaScenario_Hero::_internal_has_gold_lost_to_death() const {
  bool value = (_impl_._has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_gold_lost_to_death() const {
  return _internal_has_gold_lost_to_death();
}
inline void CMsgDotaScenario_Hero::clear_gold_lost_to_death() {
  _impl_.gold_lost_to_death_ = 0;
  _impl_._has_bits_[1] &= ~0x00010000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_gold_lost_to_death() const {
  return _impl_.gold_lost_to_death_;
}
inline int32_t CMsgDotaScenario_Hero::gold_lost_to_death() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.gold_lost_to_death)
  return _internal_gold_lost_to_death();
}
inline void CMsgDotaScenario_Hero::_internal_set_gold_lost_to_death(int32_t value) {
  _impl_._has_bits_[1] |= 0x00010000u;
  _impl_.gold_lost_to_death_ = value;
}
inline void CMsgDotaScenario_Hero::set_gold_lost_to_death(int32_t value) {
  _internal_set_gold_lost_to_death(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.gold_lost_to_death)
}

// optional int32 kills = 62;
inline bool CMsgDotaScenario_Hero::_internal_has_kills() const {
  bool value = (_impl_._has_bits_[1] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_kills() const {
  return _internal_has_kills();
}
inline void CMsgDotaScenario_Hero::clear_kills() {
  _impl_.kills_ = 0;
  _impl_._has_bits_[1] &= ~0x00020000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_kills() const {
  return _impl_.kills_;
}
inline int32_t CMsgDotaScenario_Hero::kills() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.kills)
  return _internal_kills();
}
inline void CMsgDotaScenario_Hero::_internal_set_kills(int32_t value) {
  _impl_._has_bits_[1] |= 0x00020000u;
  _impl_.kills_ = value;
}
inline void CMsgDotaScenario_Hero::set_kills(int32_t value) {
  _internal_set_kills(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.kills)
}

// optional int32 assists = 63;
inline bool CMsgDotaScenario_Hero::_internal_has_assists() const {
  bool value = (_impl_._has_bits_[1] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_assists() const {
  return _internal_has_assists();
}
inline void CMsgDotaScenario_Hero::clear_assists() {
  _impl_.assists_ = 0;
  _impl_._has_bits_[1] &= ~0x00040000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_assists() const {
  return _impl_.assists_;
}
inline int32_t CMsgDotaScenario_Hero::assists() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.assists)
  return _internal_assists();
}
inline void CMsgDotaScenario_Hero::_internal_set_assists(int32_t value) {
  _impl_._has_bits_[1] |= 0x00040000u;
  _impl_.assists_ = value;
}
inline void CMsgDotaScenario_Hero::set_assists(int32_t value) {
  _internal_set_assists(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.assists)
}

// optional int32 deaths = 64;
inline bool CMsgDotaScenario_Hero::_internal_has_deaths() const {
  bool value = (_impl_._has_bits_[1] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_deaths() const {
  return _internal_has_deaths();
}
inline void CMsgDotaScenario_Hero::clear_deaths() {
  _impl_.deaths_ = 0;
  _impl_._has_bits_[1] &= ~0x00080000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_deaths() const {
  return _impl_.deaths_;
}
inline int32_t CMsgDotaScenario_Hero::deaths() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.deaths)
  return _internal_deaths();
}
inline void CMsgDotaScenario_Hero::_internal_set_deaths(int32_t value) {
  _impl_._has_bits_[1] |= 0x00080000u;
  _impl_.deaths_ = value;
}
inline void CMsgDotaScenario_Hero::set_deaths(int32_t value) {
  _internal_set_deaths(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.deaths)
}

// optional int32 kill_streak = 65;
inline bool CMsgDotaScenario_Hero::_internal_has_kill_streak() const {
  bool value = (_impl_._has_bits_[1] & 0x00100000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_kill_streak() const {
  return _internal_has_kill_streak();
}
inline void CMsgDotaScenario_Hero::clear_kill_streak() {
  _impl_.kill_streak_ = 0;
  _impl_._has_bits_[1] &= ~0x00100000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_kill_streak() const {
  return _impl_.kill_streak_;
}
inline int32_t CMsgDotaScenario_Hero::kill_streak() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.kill_streak)
  return _internal_kill_streak();
}
inline void CMsgDotaScenario_Hero::_internal_set_kill_streak(int32_t value) {
  _impl_._has_bits_[1] |= 0x00100000u;
  _impl_.kill_streak_ = value;
}
inline void CMsgDotaScenario_Hero::set_kill_streak(int32_t value) {
  _internal_set_kill_streak(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.kill_streak)
}

// optional int32 respawn_seconds = 68 [default = -1];
inline bool CMsgDotaScenario_Hero::_internal_has_respawn_seconds() const {
  bool value = (_impl_._has_bits_[1] & 0x08000000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_respawn_seconds() const {
  return _internal_has_respawn_seconds();
}
inline void CMsgDotaScenario_Hero::clear_respawn_seconds() {
  _impl_.respawn_seconds_ = -1;
  _impl_._has_bits_[1] &= ~0x08000000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_respawn_seconds() const {
  return _impl_.respawn_seconds_;
}
inline int32_t CMsgDotaScenario_Hero::respawn_seconds() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.respawn_seconds)
  return _internal_respawn_seconds();
}
inline void CMsgDotaScenario_Hero::_internal_set_respawn_seconds(int32_t value) {
  _impl_._has_bits_[1] |= 0x08000000u;
  _impl_.respawn_seconds_ = value;
}
inline void CMsgDotaScenario_Hero::set_respawn_seconds(int32_t value) {
  _internal_set_respawn_seconds(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.respawn_seconds)
}

// optional int32 last_buyback_time = 69;
inline bool CMsgDotaScenario_Hero::_internal_has_last_buyback_time() const {
  bool value = (_impl_._has_bits_[1] & 0x00200000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_last_buyback_time() const {
  return _internal_has_last_buyback_time();
}
inline void CMsgDotaScenario_Hero::clear_last_buyback_time() {
  _impl_.last_buyback_time_ = 0;
  _impl_._has_bits_[1] &= ~0x00200000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_last_buyback_time() const {
  return _impl_.last_buyback_time_;
}
inline int32_t CMsgDotaScenario_Hero::last_buyback_time() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.last_buyback_time)
  return _internal_last_buyback_time();
}
inline void CMsgDotaScenario_Hero::_internal_set_last_buyback_time(int32_t value) {
  _impl_._has_bits_[1] |= 0x00200000u;
  _impl_.last_buyback_time_ = value;
}
inline void CMsgDotaScenario_Hero::set_last_buyback_time(int32_t value) {
  _internal_set_last_buyback_time(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.last_buyback_time)
}

// optional bool first_blood_claimed = 71;
inline bool CMsgDotaScenario_Hero::_internal_has_first_blood_claimed() const {
  bool value = (_impl_._has_bits_[1] & 0x00400000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_first_blood_claimed() const {
  return _internal_has_first_blood_claimed();
}
inline void CMsgDotaScenario_Hero::clear_first_blood_claimed() {
  _impl_.first_blood_claimed_ = false;
  _impl_._has_bits_[1] &= ~0x00400000u;
}
inline bool CMsgDotaScenario_Hero::_internal_first_blood_claimed() const {
  return _impl_.first_blood_claimed_;
}
inline bool CMsgDotaScenario_Hero::first_blood_claimed() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.first_blood_claimed)
  return _internal_first_blood_claimed();
}
inline void CMsgDotaScenario_Hero::_internal_set_first_blood_claimed(bool value) {
  _impl_._has_bits_[1] |= 0x00400000u;
  _impl_.first_blood_claimed_ = value;
}
inline void CMsgDotaScenario_Hero::set_first_blood_claimed(bool value) {
  _internal_set_first_blood_claimed(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.first_blood_claimed)
}

// optional bool first_blood_given = 72;
inline bool CMsgDotaScenario_Hero::_internal_has_first_blood_given() const {
  bool value = (_impl_._has_bits_[1] & 0x00800000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_first_blood_given() const {
  return _internal_has_first_blood_given();
}
inline void CMsgDotaScenario_Hero::clear_first_blood_given() {
  _impl_.first_blood_given_ = false;
  _impl_._has_bits_[1] &= ~0x00800000u;
}
inline bool CMsgDotaScenario_Hero::_internal_first_blood_given() const {
  return _impl_.first_blood_given_;
}
inline bool CMsgDotaScenario_Hero::first_blood_given() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.first_blood_given)
  return _internal_first_blood_given();
}
inline void CMsgDotaScenario_Hero::_internal_set_first_blood_given(bool value) {
  _impl_._has_bits_[1] |= 0x00800000u;
  _impl_.first_blood_given_ = value;
}
inline void CMsgDotaScenario_Hero::set_first_blood_given(bool value) {
  _internal_set_first_blood_given(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.first_blood_given)
}

// optional int32 bounty_runes = 73;
inline bool CMsgDotaScenario_Hero::_internal_has_bounty_runes() const {
  bool value = (_impl_._has_bits_[1] & 0x01000000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_bounty_runes() const {
  return _internal_has_bounty_runes();
}
inline void CMsgDotaScenario_Hero::clear_bounty_runes() {
  _impl_.bounty_runes_ = 0;
  _impl_._has_bits_[1] &= ~0x01000000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_bounty_runes() const {
  return _impl_.bounty_runes_;
}
inline int32_t CMsgDotaScenario_Hero::bounty_runes() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.bounty_runes)
  return _internal_bounty_runes();
}
inline void CMsgDotaScenario_Hero::_internal_set_bounty_runes(int32_t value) {
  _impl_._has_bits_[1] |= 0x01000000u;
  _impl_.bounty_runes_ = value;
}
inline void CMsgDotaScenario_Hero::set_bounty_runes(int32_t value) {
  _internal_set_bounty_runes(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.bounty_runes)
}

// optional int32 outposts_captured = 74;
inline bool CMsgDotaScenario_Hero::_internal_has_outposts_captured() const {
  bool value = (_impl_._has_bits_[1] & 0x02000000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Hero::has_outposts_captured() const {
  return _internal_has_outposts_captured();
}
inline void CMsgDotaScenario_Hero::clear_outposts_captured() {
  _impl_.outposts_captured_ = 0;
  _impl_._has_bits_[1] &= ~0x02000000u;
}
inline int32_t CMsgDotaScenario_Hero::_internal_outposts_captured() const {
  return _impl_.outposts_captured_;
}
inline int32_t CMsgDotaScenario_Hero::outposts_captured() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.outposts_captured)
  return _internal_outposts_captured();
}
inline void CMsgDotaScenario_Hero::_internal_set_outposts_captured(int32_t value) {
  _impl_._has_bits_[1] |= 0x02000000u;
  _impl_.outposts_captured_ = value;
}
inline void CMsgDotaScenario_Hero::set_outposts_captured(int32_t value) {
  _internal_set_outposts_captured(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Hero.outposts_captured)
}

// optional .CScenario_Position position = 75;
inline bool CMsgDotaScenario_Hero::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool CMsgDotaScenario_Hero::has_position() const {
  return _internal_has_position();
}
inline void CMsgDotaScenario_Hero::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CScenario_Position& CMsgDotaScenario_Hero::_internal_position() const {
  const ::CScenario_Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::CScenario_Position&>(
      ::_CScenario_Position_default_instance_);
}
inline const ::CScenario_Position& CMsgDotaScenario_Hero::position() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.position)
  return _internal_position();
}
inline void CMsgDotaScenario_Hero::unsafe_arena_set_allocated_position(
    ::CScenario_Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDotaScenario.Hero.position)
}
inline ::CScenario_Position* CMsgDotaScenario_Hero::release_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CScenario_Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CScenario_Position* CMsgDotaScenario_Hero::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Hero.position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CScenario_Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::CScenario_Position* CMsgDotaScenario_Hero::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::CScenario_Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::CScenario_Position* CMsgDotaScenario_Hero::mutable_position() {
  ::CScenario_Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Hero.position)
  return _msg;
}
inline void CMsgDotaScenario_Hero::set_allocated_position(::CScenario_Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Hero.position)
}

// repeated .CMsgDotaScenario.HeroHeroInt enemy_kills = 150;
inline int CMsgDotaScenario_Hero::_internal_enemy_kills_size() const {
  return _impl_.enemy_kills_.size();
}
inline int CMsgDotaScenario_Hero::enemy_kills_size() const {
  return _internal_enemy_kills_size();
}
inline void CMsgDotaScenario_Hero::clear_enemy_kills() {
  _impl_.enemy_kills_.Clear();
}
inline ::CMsgDotaScenario_HeroHeroInt* CMsgDotaScenario_Hero::mutable_enemy_kills(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Hero.enemy_kills)
  return _impl_.enemy_kills_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_HeroHeroInt >*
CMsgDotaScenario_Hero::mutable_enemy_kills() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDotaScenario.Hero.enemy_kills)
  return &_impl_.enemy_kills_;
}
inline const ::CMsgDotaScenario_HeroHeroInt& CMsgDotaScenario_Hero::_internal_enemy_kills(int index) const {
  return _impl_.enemy_kills_.Get(index);
}
inline const ::CMsgDotaScenario_HeroHeroInt& CMsgDotaScenario_Hero::enemy_kills(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.enemy_kills)
  return _internal_enemy_kills(index);
}
inline ::CMsgDotaScenario_HeroHeroInt* CMsgDotaScenario_Hero::_internal_add_enemy_kills() {
  return _impl_.enemy_kills_.Add();
}
inline ::CMsgDotaScenario_HeroHeroInt* CMsgDotaScenario_Hero::add_enemy_kills() {
  ::CMsgDotaScenario_HeroHeroInt* _add = _internal_add_enemy_kills();
  // @@protoc_insertion_point(field_add:CMsgDotaScenario.Hero.enemy_kills)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_HeroHeroInt >&
CMsgDotaScenario_Hero::enemy_kills() const {
  // @@protoc_insertion_point(field_list:CMsgDotaScenario.Hero.enemy_kills)
  return _impl_.enemy_kills_;
}

// repeated .CMsgDotaScenario.DamageStatsByType damage_stats = 151;
inline int CMsgDotaScenario_Hero::_internal_damage_stats_size() const {
  return _impl_.damage_stats_.size();
}
inline int CMsgDotaScenario_Hero::damage_stats_size() const {
  return _internal_damage_stats_size();
}
inline void CMsgDotaScenario_Hero::clear_damage_stats() {
  _impl_.damage_stats_.Clear();
}
inline ::CMsgDotaScenario_DamageStatsByType* CMsgDotaScenario_Hero::mutable_damage_stats(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Hero.damage_stats)
  return _impl_.damage_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_DamageStatsByType >*
CMsgDotaScenario_Hero::mutable_damage_stats() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDotaScenario.Hero.damage_stats)
  return &_impl_.damage_stats_;
}
inline const ::CMsgDotaScenario_DamageStatsByType& CMsgDotaScenario_Hero::_internal_damage_stats(int index) const {
  return _impl_.damage_stats_.Get(index);
}
inline const ::CMsgDotaScenario_DamageStatsByType& CMsgDotaScenario_Hero::damage_stats(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.damage_stats)
  return _internal_damage_stats(index);
}
inline ::CMsgDotaScenario_DamageStatsByType* CMsgDotaScenario_Hero::_internal_add_damage_stats() {
  return _impl_.damage_stats_.Add();
}
inline ::CMsgDotaScenario_DamageStatsByType* CMsgDotaScenario_Hero::add_damage_stats() {
  ::CMsgDotaScenario_DamageStatsByType* _add = _internal_add_damage_stats();
  // @@protoc_insertion_point(field_add:CMsgDotaScenario.Hero.damage_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_DamageStatsByType >&
CMsgDotaScenario_Hero::damage_stats() const {
  // @@protoc_insertion_point(field_list:CMsgDotaScenario.Hero.damage_stats)
  return _impl_.damage_stats_;
}

// repeated .CMsgDotaScenario.HeroAbility abilities = 152;
inline int CMsgDotaScenario_Hero::_internal_abilities_size() const {
  return _impl_.abilities_.size();
}
inline int CMsgDotaScenario_Hero::abilities_size() const {
  return _internal_abilities_size();
}
inline void CMsgDotaScenario_Hero::clear_abilities() {
  _impl_.abilities_.Clear();
}
inline ::CMsgDotaScenario_HeroAbility* CMsgDotaScenario_Hero::mutable_abilities(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Hero.abilities)
  return _impl_.abilities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_HeroAbility >*
CMsgDotaScenario_Hero::mutable_abilities() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDotaScenario.Hero.abilities)
  return &_impl_.abilities_;
}
inline const ::CMsgDotaScenario_HeroAbility& CMsgDotaScenario_Hero::_internal_abilities(int index) const {
  return _impl_.abilities_.Get(index);
}
inline const ::CMsgDotaScenario_HeroAbility& CMsgDotaScenario_Hero::abilities(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Hero.abilities)
  return _internal_abilities(index);
}
inline ::CMsgDotaScenario_HeroAbility* CMsgDotaScenario_Hero::_internal_add_abilities() {
  return _impl_.abilities_.Add();
}
inline ::CMsgDotaScenario_HeroAbility* CMsgDotaScenario_Hero::add_abilities() {
  ::CMsgDotaScenario_HeroAbility* _add = _internal_add_abilities();
  // @@protoc_insertion_point(field_add:CMsgDotaScenario.Hero.abilities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_HeroAbility >&
CMsgDotaScenario_Hero::abilities() const {
  // @@protoc_insertion_point(field_list:CMsgDotaScenario.Hero.abilities)
  return _impl_.abilities_;
}

// -------------------------------------------------------------------

// CMsgDotaScenario_Stock

// optional string name = 1;
inline bool CMsgDotaScenario_Stock::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Stock::has_name() const {
  return _internal_has_name();
}
inline void CMsgDotaScenario_Stock::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDotaScenario_Stock::name() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Stock.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDotaScenario_Stock::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Stock.name)
}
inline std::string* CMsgDotaScenario_Stock::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Stock.name)
  return _s;
}
inline const std::string& CMsgDotaScenario_Stock::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDotaScenario_Stock::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_Stock::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_Stock::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Stock.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDotaScenario_Stock::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Stock.name)
}

// optional int32 team_number = 2 [default = -1];
inline bool CMsgDotaScenario_Stock::_internal_has_team_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Stock::has_team_number() const {
  return _internal_has_team_number();
}
inline void CMsgDotaScenario_Stock::clear_team_number() {
  _impl_.team_number_ = -1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t CMsgDotaScenario_Stock::_internal_team_number() const {
  return _impl_.team_number_;
}
inline int32_t CMsgDotaScenario_Stock::team_number() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Stock.team_number)
  return _internal_team_number();
}
inline void CMsgDotaScenario_Stock::_internal_set_team_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.team_number_ = value;
}
inline void CMsgDotaScenario_Stock::set_team_number(int32_t value) {
  _internal_set_team_number(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Stock.team_number)
}

// optional int32 player_id = 3 [default = -1];
inline bool CMsgDotaScenario_Stock::_internal_has_player_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Stock::has_player_id() const {
  return _internal_has_player_id();
}
inline void CMsgDotaScenario_Stock::clear_player_id() {
  _impl_.player_id_ = -1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t CMsgDotaScenario_Stock::_internal_player_id() const {
  return _impl_.player_id_;
}
inline int32_t CMsgDotaScenario_Stock::player_id() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Stock.player_id)
  return _internal_player_id();
}
inline void CMsgDotaScenario_Stock::_internal_set_player_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.player_id_ = value;
}
inline void CMsgDotaScenario_Stock::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Stock.player_id)
}

// optional int32 current_stock = 4;
inline bool CMsgDotaScenario_Stock::_internal_has_current_stock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Stock::has_current_stock() const {
  return _internal_has_current_stock();
}
inline void CMsgDotaScenario_Stock::clear_current_stock() {
  _impl_.current_stock_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CMsgDotaScenario_Stock::_internal_current_stock() const {
  return _impl_.current_stock_;
}
inline int32_t CMsgDotaScenario_Stock::current_stock() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Stock.current_stock)
  return _internal_current_stock();
}
inline void CMsgDotaScenario_Stock::_internal_set_current_stock(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.current_stock_ = value;
}
inline void CMsgDotaScenario_Stock::set_current_stock(int32_t value) {
  _internal_set_current_stock(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Stock.current_stock)
}

// optional float cooldown = 5;
inline bool CMsgDotaScenario_Stock::_internal_has_cooldown() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Stock::has_cooldown() const {
  return _internal_has_cooldown();
}
inline void CMsgDotaScenario_Stock::clear_cooldown() {
  _impl_.cooldown_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float CMsgDotaScenario_Stock::_internal_cooldown() const {
  return _impl_.cooldown_;
}
inline float CMsgDotaScenario_Stock::cooldown() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Stock.cooldown)
  return _internal_cooldown();
}
inline void CMsgDotaScenario_Stock::_internal_set_cooldown(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cooldown_ = value;
}
inline void CMsgDotaScenario_Stock::set_cooldown(float value) {
  _internal_set_cooldown(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Stock.cooldown)
}

// optional int32 bonus_stock = 6;
inline bool CMsgDotaScenario_Stock::_internal_has_bonus_stock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Stock::has_bonus_stock() const {
  return _internal_has_bonus_stock();
}
inline void CMsgDotaScenario_Stock::clear_bonus_stock() {
  _impl_.bonus_stock_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t CMsgDotaScenario_Stock::_internal_bonus_stock() const {
  return _impl_.bonus_stock_;
}
inline int32_t CMsgDotaScenario_Stock::bonus_stock() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Stock.bonus_stock)
  return _internal_bonus_stock();
}
inline void CMsgDotaScenario_Stock::_internal_set_bonus_stock(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bonus_stock_ = value;
}
inline void CMsgDotaScenario_Stock::set_bonus_stock(int32_t value) {
  _internal_set_bonus_stock(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Stock.bonus_stock)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_Building

// optional string entity_name = 1;
inline bool CMsgDotaScenario_Building::_internal_has_entity_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Building::has_entity_name() const {
  return _internal_has_entity_name();
}
inline void CMsgDotaScenario_Building::clear_entity_name() {
  _impl_.entity_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDotaScenario_Building::entity_name() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Building.entity_name)
  return _internal_entity_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDotaScenario_Building::set_entity_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.entity_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Building.entity_name)
}
inline std::string* CMsgDotaScenario_Building::mutable_entity_name() {
  std::string* _s = _internal_mutable_entity_name();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Building.entity_name)
  return _s;
}
inline const std::string& CMsgDotaScenario_Building::_internal_entity_name() const {
  return _impl_.entity_name_.Get();
}
inline void CMsgDotaScenario_Building::_internal_set_entity_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.entity_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_Building::_internal_mutable_entity_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.entity_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_Building::release_entity_name() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Building.entity_name)
  if (!_internal_has_entity_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.entity_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entity_name_.IsDefault()) {
    _impl_.entity_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDotaScenario_Building::set_allocated_entity_name(std::string* entity_name) {
  if (entity_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.entity_name_.SetAllocated(entity_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entity_name_.IsDefault()) {
    _impl_.entity_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Building.entity_name)
}

// optional string entity_class = 2;
inline bool CMsgDotaScenario_Building::_internal_has_entity_class() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Building::has_entity_class() const {
  return _internal_has_entity_class();
}
inline void CMsgDotaScenario_Building::clear_entity_class() {
  _impl_.entity_class_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDotaScenario_Building::entity_class() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Building.entity_class)
  return _internal_entity_class();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDotaScenario_Building::set_entity_class(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.entity_class_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Building.entity_class)
}
inline std::string* CMsgDotaScenario_Building::mutable_entity_class() {
  std::string* _s = _internal_mutable_entity_class();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Building.entity_class)
  return _s;
}
inline const std::string& CMsgDotaScenario_Building::_internal_entity_class() const {
  return _impl_.entity_class_.Get();
}
inline void CMsgDotaScenario_Building::_internal_set_entity_class(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.entity_class_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_Building::_internal_mutable_entity_class() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.entity_class_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_Building::release_entity_class() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Building.entity_class)
  if (!_internal_has_entity_class()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.entity_class_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entity_class_.IsDefault()) {
    _impl_.entity_class_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDotaScenario_Building::set_allocated_entity_class(std::string* entity_class) {
  if (entity_class != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.entity_class_.SetAllocated(entity_class, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entity_class_.IsDefault()) {
    _impl_.entity_class_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Building.entity_class)
}

// optional int32 team_id = 3;
inline bool CMsgDotaScenario_Building::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Building::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDotaScenario_Building::clear_team_id() {
  _impl_.team_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t CMsgDotaScenario_Building::_internal_team_id() const {
  return _impl_.team_id_;
}
inline int32_t CMsgDotaScenario_Building::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Building.team_id)
  return _internal_team_id();
}
inline void CMsgDotaScenario_Building::_internal_set_team_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.team_id_ = value;
}
inline void CMsgDotaScenario_Building::set_team_id(int32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Building.team_id)
}

// optional bool is_destroyed = 4;
inline bool CMsgDotaScenario_Building::_internal_has_is_destroyed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Building::has_is_destroyed() const {
  return _internal_has_is_destroyed();
}
inline void CMsgDotaScenario_Building::clear_is_destroyed() {
  _impl_.is_destroyed_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool CMsgDotaScenario_Building::_internal_is_destroyed() const {
  return _impl_.is_destroyed_;
}
inline bool CMsgDotaScenario_Building::is_destroyed() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Building.is_destroyed)
  return _internal_is_destroyed();
}
inline void CMsgDotaScenario_Building::_internal_set_is_destroyed(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.is_destroyed_ = value;
}
inline void CMsgDotaScenario_Building::set_is_destroyed(bool value) {
  _internal_set_is_destroyed(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Building.is_destroyed)
}

// optional float health_frac = 5 [default = 1];
inline bool CMsgDotaScenario_Building::_internal_has_health_frac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Building::has_health_frac() const {
  return _internal_has_health_frac();
}
inline void CMsgDotaScenario_Building::clear_health_frac() {
  _impl_.health_frac_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float CMsgDotaScenario_Building::_internal_health_frac() const {
  return _impl_.health_frac_;
}
inline float CMsgDotaScenario_Building::health_frac() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Building.health_frac)
  return _internal_health_frac();
}
inline void CMsgDotaScenario_Building::_internal_set_health_frac(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.health_frac_ = value;
}
inline void CMsgDotaScenario_Building::set_health_frac(float value) {
  _internal_set_health_frac(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Building.health_frac)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_Entity

// optional .CScenarioEnt_Courier courier = 1;
inline bool CMsgDotaScenario_Entity::_internal_has_courier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.courier_ != nullptr);
  return value;
}
inline bool CMsgDotaScenario_Entity::has_courier() const {
  return _internal_has_courier();
}
inline void CMsgDotaScenario_Entity::clear_courier() {
  if (_impl_.courier_ != nullptr) _impl_.courier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CScenarioEnt_Courier& CMsgDotaScenario_Entity::_internal_courier() const {
  const ::CScenarioEnt_Courier* p = _impl_.courier_;
  return p != nullptr ? *p : reinterpret_cast<const ::CScenarioEnt_Courier&>(
      ::_CScenarioEnt_Courier_default_instance_);
}
inline const ::CScenarioEnt_Courier& CMsgDotaScenario_Entity::courier() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Entity.courier)
  return _internal_courier();
}
inline void CMsgDotaScenario_Entity::unsafe_arena_set_allocated_courier(
    ::CScenarioEnt_Courier* courier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.courier_);
  }
  _impl_.courier_ = courier;
  if (courier) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDotaScenario.Entity.courier)
}
inline ::CScenarioEnt_Courier* CMsgDotaScenario_Entity::release_courier() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CScenarioEnt_Courier* temp = _impl_.courier_;
  _impl_.courier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CScenarioEnt_Courier* CMsgDotaScenario_Entity::unsafe_arena_release_courier() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Entity.courier)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CScenarioEnt_Courier* temp = _impl_.courier_;
  _impl_.courier_ = nullptr;
  return temp;
}
inline ::CScenarioEnt_Courier* CMsgDotaScenario_Entity::_internal_mutable_courier() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.courier_ == nullptr) {
    auto* p = CreateMaybeMessage<::CScenarioEnt_Courier>(GetArenaForAllocation());
    _impl_.courier_ = p;
  }
  return _impl_.courier_;
}
inline ::CScenarioEnt_Courier* CMsgDotaScenario_Entity::mutable_courier() {
  ::CScenarioEnt_Courier* _msg = _internal_mutable_courier();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Entity.courier)
  return _msg;
}
inline void CMsgDotaScenario_Entity::set_allocated_courier(::CScenarioEnt_Courier* courier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.courier_;
  }
  if (courier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(courier);
    if (message_arena != submessage_arena) {
      courier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, courier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.courier_ = courier;
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Entity.courier)
}

// optional .CScenarioEnt_NPC npc = 2;
inline bool CMsgDotaScenario_Entity::_internal_has_npc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.npc_ != nullptr);
  return value;
}
inline bool CMsgDotaScenario_Entity::has_npc() const {
  return _internal_has_npc();
}
inline void CMsgDotaScenario_Entity::clear_npc() {
  if (_impl_.npc_ != nullptr) _impl_.npc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CScenarioEnt_NPC& CMsgDotaScenario_Entity::_internal_npc() const {
  const ::CScenarioEnt_NPC* p = _impl_.npc_;
  return p != nullptr ? *p : reinterpret_cast<const ::CScenarioEnt_NPC&>(
      ::_CScenarioEnt_NPC_default_instance_);
}
inline const ::CScenarioEnt_NPC& CMsgDotaScenario_Entity::npc() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Entity.npc)
  return _internal_npc();
}
inline void CMsgDotaScenario_Entity::unsafe_arena_set_allocated_npc(
    ::CScenarioEnt_NPC* npc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.npc_);
  }
  _impl_.npc_ = npc;
  if (npc) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDotaScenario.Entity.npc)
}
inline ::CScenarioEnt_NPC* CMsgDotaScenario_Entity::release_npc() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CScenarioEnt_NPC* temp = _impl_.npc_;
  _impl_.npc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CScenarioEnt_NPC* CMsgDotaScenario_Entity::unsafe_arena_release_npc() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Entity.npc)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CScenarioEnt_NPC* temp = _impl_.npc_;
  _impl_.npc_ = nullptr;
  return temp;
}
inline ::CScenarioEnt_NPC* CMsgDotaScenario_Entity::_internal_mutable_npc() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.npc_ == nullptr) {
    auto* p = CreateMaybeMessage<::CScenarioEnt_NPC>(GetArenaForAllocation());
    _impl_.npc_ = p;
  }
  return _impl_.npc_;
}
inline ::CScenarioEnt_NPC* CMsgDotaScenario_Entity::mutable_npc() {
  ::CScenarioEnt_NPC* _msg = _internal_mutable_npc();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Entity.npc)
  return _msg;
}
inline void CMsgDotaScenario_Entity::set_allocated_npc(::CScenarioEnt_NPC* npc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.npc_;
  }
  if (npc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(npc);
    if (message_arena != submessage_arena) {
      npc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, npc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.npc_ = npc;
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Entity.npc)
}

// optional .CScenarioEnt_SpiritBear spirit_bear = 3;
inline bool CMsgDotaScenario_Entity::_internal_has_spirit_bear() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spirit_bear_ != nullptr);
  return value;
}
inline bool CMsgDotaScenario_Entity::has_spirit_bear() const {
  return _internal_has_spirit_bear();
}
inline void CMsgDotaScenario_Entity::clear_spirit_bear() {
  if (_impl_.spirit_bear_ != nullptr) _impl_.spirit_bear_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::CScenarioEnt_SpiritBear& CMsgDotaScenario_Entity::_internal_spirit_bear() const {
  const ::CScenarioEnt_SpiritBear* p = _impl_.spirit_bear_;
  return p != nullptr ? *p : reinterpret_cast<const ::CScenarioEnt_SpiritBear&>(
      ::_CScenarioEnt_SpiritBear_default_instance_);
}
inline const ::CScenarioEnt_SpiritBear& CMsgDotaScenario_Entity::spirit_bear() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Entity.spirit_bear)
  return _internal_spirit_bear();
}
inline void CMsgDotaScenario_Entity::unsafe_arena_set_allocated_spirit_bear(
    ::CScenarioEnt_SpiritBear* spirit_bear) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spirit_bear_);
  }
  _impl_.spirit_bear_ = spirit_bear;
  if (spirit_bear) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDotaScenario.Entity.spirit_bear)
}
inline ::CScenarioEnt_SpiritBear* CMsgDotaScenario_Entity::release_spirit_bear() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CScenarioEnt_SpiritBear* temp = _impl_.spirit_bear_;
  _impl_.spirit_bear_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CScenarioEnt_SpiritBear* CMsgDotaScenario_Entity::unsafe_arena_release_spirit_bear() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Entity.spirit_bear)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CScenarioEnt_SpiritBear* temp = _impl_.spirit_bear_;
  _impl_.spirit_bear_ = nullptr;
  return temp;
}
inline ::CScenarioEnt_SpiritBear* CMsgDotaScenario_Entity::_internal_mutable_spirit_bear() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.spirit_bear_ == nullptr) {
    auto* p = CreateMaybeMessage<::CScenarioEnt_SpiritBear>(GetArenaForAllocation());
    _impl_.spirit_bear_ = p;
  }
  return _impl_.spirit_bear_;
}
inline ::CScenarioEnt_SpiritBear* CMsgDotaScenario_Entity::mutable_spirit_bear() {
  ::CScenarioEnt_SpiritBear* _msg = _internal_mutable_spirit_bear();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Entity.spirit_bear)
  return _msg;
}
inline void CMsgDotaScenario_Entity::set_allocated_spirit_bear(::CScenarioEnt_SpiritBear* spirit_bear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spirit_bear_;
  }
  if (spirit_bear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spirit_bear);
    if (message_arena != submessage_arena) {
      spirit_bear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spirit_bear, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.spirit_bear_ = spirit_bear;
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Entity.spirit_bear)
}

// optional .CScenarioEnt_DroppedItem dropped_item = 4;
inline bool CMsgDotaScenario_Entity::_internal_has_dropped_item() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dropped_item_ != nullptr);
  return value;
}
inline bool CMsgDotaScenario_Entity::has_dropped_item() const {
  return _internal_has_dropped_item();
}
inline void CMsgDotaScenario_Entity::clear_dropped_item() {
  if (_impl_.dropped_item_ != nullptr) _impl_.dropped_item_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::CScenarioEnt_DroppedItem& CMsgDotaScenario_Entity::_internal_dropped_item() const {
  const ::CScenarioEnt_DroppedItem* p = _impl_.dropped_item_;
  return p != nullptr ? *p : reinterpret_cast<const ::CScenarioEnt_DroppedItem&>(
      ::_CScenarioEnt_DroppedItem_default_instance_);
}
inline const ::CScenarioEnt_DroppedItem& CMsgDotaScenario_Entity::dropped_item() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Entity.dropped_item)
  return _internal_dropped_item();
}
inline void CMsgDotaScenario_Entity::unsafe_arena_set_allocated_dropped_item(
    ::CScenarioEnt_DroppedItem* dropped_item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dropped_item_);
  }
  _impl_.dropped_item_ = dropped_item;
  if (dropped_item) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDotaScenario.Entity.dropped_item)
}
inline ::CScenarioEnt_DroppedItem* CMsgDotaScenario_Entity::release_dropped_item() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CScenarioEnt_DroppedItem* temp = _impl_.dropped_item_;
  _impl_.dropped_item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CScenarioEnt_DroppedItem* CMsgDotaScenario_Entity::unsafe_arena_release_dropped_item() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Entity.dropped_item)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CScenarioEnt_DroppedItem* temp = _impl_.dropped_item_;
  _impl_.dropped_item_ = nullptr;
  return temp;
}
inline ::CScenarioEnt_DroppedItem* CMsgDotaScenario_Entity::_internal_mutable_dropped_item() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.dropped_item_ == nullptr) {
    auto* p = CreateMaybeMessage<::CScenarioEnt_DroppedItem>(GetArenaForAllocation());
    _impl_.dropped_item_ = p;
  }
  return _impl_.dropped_item_;
}
inline ::CScenarioEnt_DroppedItem* CMsgDotaScenario_Entity::mutable_dropped_item() {
  ::CScenarioEnt_DroppedItem* _msg = _internal_mutable_dropped_item();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Entity.dropped_item)
  return _msg;
}
inline void CMsgDotaScenario_Entity::set_allocated_dropped_item(::CScenarioEnt_DroppedItem* dropped_item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dropped_item_;
  }
  if (dropped_item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dropped_item);
    if (message_arena != submessage_arena) {
      dropped_item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dropped_item, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.dropped_item_ = dropped_item;
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Entity.dropped_item)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_Item

// optional string name = 1;
inline bool CMsgDotaScenario_Item::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Item::has_name() const {
  return _internal_has_name();
}
inline void CMsgDotaScenario_Item::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDotaScenario_Item::name() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Item.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDotaScenario_Item::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Item.name)
}
inline std::string* CMsgDotaScenario_Item::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Item.name)
  return _s;
}
inline const std::string& CMsgDotaScenario_Item::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDotaScenario_Item::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_Item::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_Item::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Item.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDotaScenario_Item::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Item.name)
}

// optional .CMsgDotaScenario.EntityRef location = 2;
inline bool CMsgDotaScenario_Item::_internal_has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline bool CMsgDotaScenario_Item::has_location() const {
  return _internal_has_location();
}
inline void CMsgDotaScenario_Item::clear_location() {
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CMsgDotaScenario_EntityRef& CMsgDotaScenario_Item::_internal_location() const {
  const ::CMsgDotaScenario_EntityRef* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgDotaScenario_EntityRef&>(
      ::_CMsgDotaScenario_EntityRef_default_instance_);
}
inline const ::CMsgDotaScenario_EntityRef& CMsgDotaScenario_Item::location() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Item.location)
  return _internal_location();
}
inline void CMsgDotaScenario_Item::unsafe_arena_set_allocated_location(
    ::CMsgDotaScenario_EntityRef* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDotaScenario.Item.location)
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Item::release_location() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgDotaScenario_EntityRef* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Item::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Item.location)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgDotaScenario_EntityRef* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Item::_internal_mutable_location() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgDotaScenario_EntityRef>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Item::mutable_location() {
  ::CMsgDotaScenario_EntityRef* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Item.location)
  return _msg;
}
inline void CMsgDotaScenario_Item::set_allocated_location(::CMsgDotaScenario_EntityRef* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Item.location)
}

// optional int32 owner_id = 3 [default = -1];
inline bool CMsgDotaScenario_Item::_internal_has_owner_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Item::has_owner_id() const {
  return _internal_has_owner_id();
}
inline void CMsgDotaScenario_Item::clear_owner_id() {
  _impl_.owner_id_ = -1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t CMsgDotaScenario_Item::_internal_owner_id() const {
  return _impl_.owner_id_;
}
inline int32_t CMsgDotaScenario_Item::owner_id() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Item.owner_id)
  return _internal_owner_id();
}
inline void CMsgDotaScenario_Item::_internal_set_owner_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.owner_id_ = value;
}
inline void CMsgDotaScenario_Item::set_owner_id(int32_t value) {
  _internal_set_owner_id(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Item.owner_id)
}

// optional int32 item_slot = 4;
inline bool CMsgDotaScenario_Item::_internal_has_item_slot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Item::has_item_slot() const {
  return _internal_has_item_slot();
}
inline void CMsgDotaScenario_Item::clear_item_slot() {
  _impl_.item_slot_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t CMsgDotaScenario_Item::_internal_item_slot() const {
  return _impl_.item_slot_;
}
inline int32_t CMsgDotaScenario_Item::item_slot() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Item.item_slot)
  return _internal_item_slot();
}
inline void CMsgDotaScenario_Item::_internal_set_item_slot(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.item_slot_ = value;
}
inline void CMsgDotaScenario_Item::set_item_slot(int32_t value) {
  _internal_set_item_slot(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Item.item_slot)
}

// optional int32 neutral_drop_team = 5;
inline bool CMsgDotaScenario_Item::_internal_has_neutral_drop_team() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Item::has_neutral_drop_team() const {
  return _internal_has_neutral_drop_team();
}
inline void CMsgDotaScenario_Item::clear_neutral_drop_team() {
  _impl_.neutral_drop_team_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t CMsgDotaScenario_Item::_internal_neutral_drop_team() const {
  return _impl_.neutral_drop_team_;
}
inline int32_t CMsgDotaScenario_Item::neutral_drop_team() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Item.neutral_drop_team)
  return _internal_neutral_drop_team();
}
inline void CMsgDotaScenario_Item::_internal_set_neutral_drop_team(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.neutral_drop_team_ = value;
}
inline void CMsgDotaScenario_Item::set_neutral_drop_team(int32_t value) {
  _internal_set_neutral_drop_team(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Item.neutral_drop_team)
}

// optional int32 charges = 6;
inline bool CMsgDotaScenario_Item::_internal_has_charges() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Item::has_charges() const {
  return _internal_has_charges();
}
inline void CMsgDotaScenario_Item::clear_charges() {
  _impl_.charges_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t CMsgDotaScenario_Item::_internal_charges() const {
  return _impl_.charges_;
}
inline int32_t CMsgDotaScenario_Item::charges() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Item.charges)
  return _internal_charges();
}
inline void CMsgDotaScenario_Item::_internal_set_charges(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.charges_ = value;
}
inline void CMsgDotaScenario_Item::set_charges(int32_t value) {
  _internal_set_charges(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Item.charges)
}

// optional int32 secondary_charges = 7;
inline bool CMsgDotaScenario_Item::_internal_has_secondary_charges() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Item::has_secondary_charges() const {
  return _internal_has_secondary_charges();
}
inline void CMsgDotaScenario_Item::clear_secondary_charges() {
  _impl_.secondary_charges_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t CMsgDotaScenario_Item::_internal_secondary_charges() const {
  return _impl_.secondary_charges_;
}
inline int32_t CMsgDotaScenario_Item::secondary_charges() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Item.secondary_charges)
  return _internal_secondary_charges();
}
inline void CMsgDotaScenario_Item::_internal_set_secondary_charges(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.secondary_charges_ = value;
}
inline void CMsgDotaScenario_Item::set_secondary_charges(int32_t value) {
  _internal_set_secondary_charges(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Item.secondary_charges)
}

// optional float lifetime = 8 [default = -1];
inline bool CMsgDotaScenario_Item::_internal_has_lifetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Item::has_lifetime() const {
  return _internal_has_lifetime();
}
inline void CMsgDotaScenario_Item::clear_lifetime() {
  _impl_.lifetime_ = -1;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float CMsgDotaScenario_Item::_internal_lifetime() const {
  return _impl_.lifetime_;
}
inline float CMsgDotaScenario_Item::lifetime() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Item.lifetime)
  return _internal_lifetime();
}
inline void CMsgDotaScenario_Item::_internal_set_lifetime(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.lifetime_ = value;
}
inline void CMsgDotaScenario_Item::set_lifetime(float value) {
  _internal_set_lifetime(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Item.lifetime)
}

// optional int32 stored_rune_type = 9 [default = -1];
inline bool CMsgDotaScenario_Item::_internal_has_stored_rune_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Item::has_stored_rune_type() const {
  return _internal_has_stored_rune_type();
}
inline void CMsgDotaScenario_Item::clear_stored_rune_type() {
  _impl_.stored_rune_type_ = -1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t CMsgDotaScenario_Item::_internal_stored_rune_type() const {
  return _impl_.stored_rune_type_;
}
inline int32_t CMsgDotaScenario_Item::stored_rune_type() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Item.stored_rune_type)
  return _internal_stored_rune_type();
}
inline void CMsgDotaScenario_Item::_internal_set_stored_rune_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.stored_rune_type_ = value;
}
inline void CMsgDotaScenario_Item::set_stored_rune_type(int32_t value) {
  _internal_set_stored_rune_type(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Item.stored_rune_type)
}

// -------------------------------------------------------------------

// CMsgDotaScenario_Modifier

// optional string name = 1;
inline bool CMsgDotaScenario_Modifier::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_name() const {
  return _internal_has_name();
}
inline void CMsgDotaScenario_Modifier::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDotaScenario_Modifier::name() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDotaScenario_Modifier::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.name)
}
inline std::string* CMsgDotaScenario_Modifier::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Modifier.name)
  return _s;
}
inline const std::string& CMsgDotaScenario_Modifier::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDotaScenario_Modifier::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_Modifier::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDotaScenario_Modifier::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Modifier.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDotaScenario_Modifier::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Modifier.name)
}

// optional .CMsgDotaScenario.EntityRef parent = 2;
inline bool CMsgDotaScenario_Modifier::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_parent() const {
  return _internal_has_parent();
}
inline void CMsgDotaScenario_Modifier::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CMsgDotaScenario_EntityRef& CMsgDotaScenario_Modifier::_internal_parent() const {
  const ::CMsgDotaScenario_EntityRef* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgDotaScenario_EntityRef&>(
      ::_CMsgDotaScenario_EntityRef_default_instance_);
}
inline const ::CMsgDotaScenario_EntityRef& CMsgDotaScenario_Modifier::parent() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.parent)
  return _internal_parent();
}
inline void CMsgDotaScenario_Modifier::unsafe_arena_set_allocated_parent(
    ::CMsgDotaScenario_EntityRef* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDotaScenario.Modifier.parent)
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Modifier::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgDotaScenario_EntityRef* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Modifier::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Modifier.parent)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgDotaScenario_EntityRef* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Modifier::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgDotaScenario_EntityRef>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Modifier::mutable_parent() {
  ::CMsgDotaScenario_EntityRef* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Modifier.parent)
  return _msg;
}
inline void CMsgDotaScenario_Modifier::set_allocated_parent(::CMsgDotaScenario_EntityRef* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Modifier.parent)
}

// optional .CMsgDotaScenario.EntityRef caster = 3;
inline bool CMsgDotaScenario_Modifier::_internal_has_caster() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.caster_ != nullptr);
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_caster() const {
  return _internal_has_caster();
}
inline void CMsgDotaScenario_Modifier::clear_caster() {
  if (_impl_.caster_ != nullptr) _impl_.caster_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::CMsgDotaScenario_EntityRef& CMsgDotaScenario_Modifier::_internal_caster() const {
  const ::CMsgDotaScenario_EntityRef* p = _impl_.caster_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgDotaScenario_EntityRef&>(
      ::_CMsgDotaScenario_EntityRef_default_instance_);
}
inline const ::CMsgDotaScenario_EntityRef& CMsgDotaScenario_Modifier::caster() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.caster)
  return _internal_caster();
}
inline void CMsgDotaScenario_Modifier::unsafe_arena_set_allocated_caster(
    ::CMsgDotaScenario_EntityRef* caster) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.caster_);
  }
  _impl_.caster_ = caster;
  if (caster) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDotaScenario.Modifier.caster)
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Modifier::release_caster() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgDotaScenario_EntityRef* temp = _impl_.caster_;
  _impl_.caster_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Modifier::unsafe_arena_release_caster() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Modifier.caster)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgDotaScenario_EntityRef* temp = _impl_.caster_;
  _impl_.caster_ = nullptr;
  return temp;
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Modifier::_internal_mutable_caster() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.caster_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgDotaScenario_EntityRef>(GetArenaForAllocation());
    _impl_.caster_ = p;
  }
  return _impl_.caster_;
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Modifier::mutable_caster() {
  ::CMsgDotaScenario_EntityRef* _msg = _internal_mutable_caster();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Modifier.caster)
  return _msg;
}
inline void CMsgDotaScenario_Modifier::set_allocated_caster(::CMsgDotaScenario_EntityRef* caster) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.caster_;
  }
  if (caster) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(caster);
    if (message_arena != submessage_arena) {
      caster = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, caster, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.caster_ = caster;
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Modifier.caster)
}

// optional .CMsgDotaScenario.EntityRef ability = 4;
inline bool CMsgDotaScenario_Modifier::_internal_has_ability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ability_ != nullptr);
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_ability() const {
  return _internal_has_ability();
}
inline void CMsgDotaScenario_Modifier::clear_ability() {
  if (_impl_.ability_ != nullptr) _impl_.ability_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::CMsgDotaScenario_EntityRef& CMsgDotaScenario_Modifier::_internal_ability() const {
  const ::CMsgDotaScenario_EntityRef* p = _impl_.ability_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgDotaScenario_EntityRef&>(
      ::_CMsgDotaScenario_EntityRef_default_instance_);
}
inline const ::CMsgDotaScenario_EntityRef& CMsgDotaScenario_Modifier::ability() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.ability)
  return _internal_ability();
}
inline void CMsgDotaScenario_Modifier::unsafe_arena_set_allocated_ability(
    ::CMsgDotaScenario_EntityRef* ability) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ability_);
  }
  _impl_.ability_ = ability;
  if (ability) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDotaScenario.Modifier.ability)
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Modifier::release_ability() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CMsgDotaScenario_EntityRef* temp = _impl_.ability_;
  _impl_.ability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Modifier::unsafe_arena_release_ability() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.Modifier.ability)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CMsgDotaScenario_EntityRef* temp = _impl_.ability_;
  _impl_.ability_ = nullptr;
  return temp;
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Modifier::_internal_mutable_ability() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.ability_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgDotaScenario_EntityRef>(GetArenaForAllocation());
    _impl_.ability_ = p;
  }
  return _impl_.ability_;
}
inline ::CMsgDotaScenario_EntityRef* CMsgDotaScenario_Modifier::mutable_ability() {
  ::CMsgDotaScenario_EntityRef* _msg = _internal_mutable_ability();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.Modifier.ability)
  return _msg;
}
inline void CMsgDotaScenario_Modifier::set_allocated_ability(::CMsgDotaScenario_EntityRef* ability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ability_;
  }
  if (ability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ability);
    if (message_arena != submessage_arena) {
      ability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ability, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.ability_ = ability;
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.Modifier.ability)
}

// optional float duration = 5 [default = -1];
inline bool CMsgDotaScenario_Modifier::_internal_has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_duration() const {
  return _internal_has_duration();
}
inline void CMsgDotaScenario_Modifier::clear_duration() {
  _impl_.duration_ = -1;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline float CMsgDotaScenario_Modifier::_internal_duration() const {
  return _impl_.duration_;
}
inline float CMsgDotaScenario_Modifier::duration() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.duration)
  return _internal_duration();
}
inline void CMsgDotaScenario_Modifier::_internal_set_duration(float value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.duration_ = value;
}
inline void CMsgDotaScenario_Modifier::set_duration(float value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.duration)
}

// optional float lifetime_remaining = 6 [default = 0];
inline bool CMsgDotaScenario_Modifier::_internal_has_lifetime_remaining() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_lifetime_remaining() const {
  return _internal_has_lifetime_remaining();
}
inline void CMsgDotaScenario_Modifier::clear_lifetime_remaining() {
  _impl_.lifetime_remaining_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float CMsgDotaScenario_Modifier::_internal_lifetime_remaining() const {
  return _impl_.lifetime_remaining_;
}
inline float CMsgDotaScenario_Modifier::lifetime_remaining() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.lifetime_remaining)
  return _internal_lifetime_remaining();
}
inline void CMsgDotaScenario_Modifier::_internal_set_lifetime_remaining(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.lifetime_remaining_ = value;
}
inline void CMsgDotaScenario_Modifier::set_lifetime_remaining(float value) {
  _internal_set_lifetime_remaining(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.lifetime_remaining)
}

// optional int32 stack_count = 7;
inline bool CMsgDotaScenario_Modifier::_internal_has_stack_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_stack_count() const {
  return _internal_has_stack_count();
}
inline void CMsgDotaScenario_Modifier::clear_stack_count() {
  _impl_.stack_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t CMsgDotaScenario_Modifier::_internal_stack_count() const {
  return _impl_.stack_count_;
}
inline int32_t CMsgDotaScenario_Modifier::stack_count() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.stack_count)
  return _internal_stack_count();
}
inline void CMsgDotaScenario_Modifier::_internal_set_stack_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.stack_count_ = value;
}
inline void CMsgDotaScenario_Modifier::set_stack_count(int32_t value) {
  _internal_set_stack_count(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.stack_count)
}

// optional bool create_even_if_existing = 8;
inline bool CMsgDotaScenario_Modifier::_internal_has_create_even_if_existing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_create_even_if_existing() const {
  return _internal_has_create_even_if_existing();
}
inline void CMsgDotaScenario_Modifier::clear_create_even_if_existing() {
  _impl_.create_even_if_existing_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool CMsgDotaScenario_Modifier::_internal_create_even_if_existing() const {
  return _impl_.create_even_if_existing_;
}
inline bool CMsgDotaScenario_Modifier::create_even_if_existing() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.create_even_if_existing)
  return _internal_create_even_if_existing();
}
inline void CMsgDotaScenario_Modifier::_internal_set_create_even_if_existing(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.create_even_if_existing_ = value;
}
inline void CMsgDotaScenario_Modifier::set_create_even_if_existing(bool value) {
  _internal_set_create_even_if_existing(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.create_even_if_existing)
}

// optional bool create_without_caster = 9;
inline bool CMsgDotaScenario_Modifier::_internal_has_create_without_caster() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_create_without_caster() const {
  return _internal_has_create_without_caster();
}
inline void CMsgDotaScenario_Modifier::clear_create_without_caster() {
  _impl_.create_without_caster_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool CMsgDotaScenario_Modifier::_internal_create_without_caster() const {
  return _impl_.create_without_caster_;
}
inline bool CMsgDotaScenario_Modifier::create_without_caster() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.create_without_caster)
  return _internal_create_without_caster();
}
inline void CMsgDotaScenario_Modifier::_internal_set_create_without_caster(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.create_without_caster_ = value;
}
inline void CMsgDotaScenario_Modifier::set_create_without_caster(bool value) {
  _internal_set_create_without_caster(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.create_without_caster)
}

// optional bool create_without_ability = 10;
inline bool CMsgDotaScenario_Modifier::_internal_has_create_without_ability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_create_without_ability() const {
  return _internal_has_create_without_ability();
}
inline void CMsgDotaScenario_Modifier::clear_create_without_ability() {
  _impl_.create_without_ability_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool CMsgDotaScenario_Modifier::_internal_create_without_ability() const {
  return _impl_.create_without_ability_;
}
inline bool CMsgDotaScenario_Modifier::create_without_ability() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.create_without_ability)
  return _internal_create_without_ability();
}
inline void CMsgDotaScenario_Modifier::_internal_set_create_without_ability(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.create_without_ability_ = value;
}
inline void CMsgDotaScenario_Modifier::set_create_without_ability(bool value) {
  _internal_set_create_without_ability(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.create_without_ability)
}

// optional int32 moonshard_consumed_bonus = 100;
inline bool CMsgDotaScenario_Modifier::_internal_has_moonshard_consumed_bonus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_moonshard_consumed_bonus() const {
  return _internal_has_moonshard_consumed_bonus();
}
inline void CMsgDotaScenario_Modifier::clear_moonshard_consumed_bonus() {
  _impl_.moonshard_consumed_bonus_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t CMsgDotaScenario_Modifier::_internal_moonshard_consumed_bonus() const {
  return _impl_.moonshard_consumed_bonus_;
}
inline int32_t CMsgDotaScenario_Modifier::moonshard_consumed_bonus() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.moonshard_consumed_bonus)
  return _internal_moonshard_consumed_bonus();
}
inline void CMsgDotaScenario_Modifier::_internal_set_moonshard_consumed_bonus(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.moonshard_consumed_bonus_ = value;
}
inline void CMsgDotaScenario_Modifier::set_moonshard_consumed_bonus(int32_t value) {
  _internal_set_moonshard_consumed_bonus(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.moonshard_consumed_bonus)
}

// optional int32 moonshard_consumed_bonus_night_vision = 101;
inline bool CMsgDotaScenario_Modifier::_internal_has_moonshard_consumed_bonus_night_vision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_moonshard_consumed_bonus_night_vision() const {
  return _internal_has_moonshard_consumed_bonus_night_vision();
}
inline void CMsgDotaScenario_Modifier::clear_moonshard_consumed_bonus_night_vision() {
  _impl_.moonshard_consumed_bonus_night_vision_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int32_t CMsgDotaScenario_Modifier::_internal_moonshard_consumed_bonus_night_vision() const {
  return _impl_.moonshard_consumed_bonus_night_vision_;
}
inline int32_t CMsgDotaScenario_Modifier::moonshard_consumed_bonus_night_vision() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.moonshard_consumed_bonus_night_vision)
  return _internal_moonshard_consumed_bonus_night_vision();
}
inline void CMsgDotaScenario_Modifier::_internal_set_moonshard_consumed_bonus_night_vision(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.moonshard_consumed_bonus_night_vision_ = value;
}
inline void CMsgDotaScenario_Modifier::set_moonshard_consumed_bonus_night_vision(int32_t value) {
  _internal_set_moonshard_consumed_bonus_night_vision(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.moonshard_consumed_bonus_night_vision)
}

// optional int32 wardtruesight_range = 110;
inline bool CMsgDotaScenario_Modifier::_internal_has_wardtruesight_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_wardtruesight_range() const {
  return _internal_has_wardtruesight_range();
}
inline void CMsgDotaScenario_Modifier::clear_wardtruesight_range() {
  _impl_.wardtruesight_range_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int32_t CMsgDotaScenario_Modifier::_internal_wardtruesight_range() const {
  return _impl_.wardtruesight_range_;
}
inline int32_t CMsgDotaScenario_Modifier::wardtruesight_range() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.wardtruesight_range)
  return _internal_wardtruesight_range();
}
inline void CMsgDotaScenario_Modifier::_internal_set_wardtruesight_range(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.wardtruesight_range_ = value;
}
inline void CMsgDotaScenario_Modifier::set_wardtruesight_range(int32_t value) {
  _internal_set_wardtruesight_range(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.wardtruesight_range)
}

// optional int32 ultimate_scepter_consumed_alchemist_bonus_all_stats = 120;
inline bool CMsgDotaScenario_Modifier::_internal_has_ultimate_scepter_consumed_alchemist_bonus_all_stats() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_ultimate_scepter_consumed_alchemist_bonus_all_stats() const {
  return _internal_has_ultimate_scepter_consumed_alchemist_bonus_all_stats();
}
inline void CMsgDotaScenario_Modifier::clear_ultimate_scepter_consumed_alchemist_bonus_all_stats() {
  _impl_.ultimate_scepter_consumed_alchemist_bonus_all_stats_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int32_t CMsgDotaScenario_Modifier::_internal_ultimate_scepter_consumed_alchemist_bonus_all_stats() const {
  return _impl_.ultimate_scepter_consumed_alchemist_bonus_all_stats_;
}
inline int32_t CMsgDotaScenario_Modifier::ultimate_scepter_consumed_alchemist_bonus_all_stats() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.ultimate_scepter_consumed_alchemist_bonus_all_stats)
  return _internal_ultimate_scepter_consumed_alchemist_bonus_all_stats();
}
inline void CMsgDotaScenario_Modifier::_internal_set_ultimate_scepter_consumed_alchemist_bonus_all_stats(int32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.ultimate_scepter_consumed_alchemist_bonus_all_stats_ = value;
}
inline void CMsgDotaScenario_Modifier::set_ultimate_scepter_consumed_alchemist_bonus_all_stats(int32_t value) {
  _internal_set_ultimate_scepter_consumed_alchemist_bonus_all_stats(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.ultimate_scepter_consumed_alchemist_bonus_all_stats)
}

// optional int32 ultimate_scepter_consumed_alchemist_bonus_health = 121;
inline bool CMsgDotaScenario_Modifier::_internal_has_ultimate_scepter_consumed_alchemist_bonus_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_ultimate_scepter_consumed_alchemist_bonus_health() const {
  return _internal_has_ultimate_scepter_consumed_alchemist_bonus_health();
}
inline void CMsgDotaScenario_Modifier::clear_ultimate_scepter_consumed_alchemist_bonus_health() {
  _impl_.ultimate_scepter_consumed_alchemist_bonus_health_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int32_t CMsgDotaScenario_Modifier::_internal_ultimate_scepter_consumed_alchemist_bonus_health() const {
  return _impl_.ultimate_scepter_consumed_alchemist_bonus_health_;
}
inline int32_t CMsgDotaScenario_Modifier::ultimate_scepter_consumed_alchemist_bonus_health() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.ultimate_scepter_consumed_alchemist_bonus_health)
  return _internal_ultimate_scepter_consumed_alchemist_bonus_health();
}
inline void CMsgDotaScenario_Modifier::_internal_set_ultimate_scepter_consumed_alchemist_bonus_health(int32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.ultimate_scepter_consumed_alchemist_bonus_health_ = value;
}
inline void CMsgDotaScenario_Modifier::set_ultimate_scepter_consumed_alchemist_bonus_health(int32_t value) {
  _internal_set_ultimate_scepter_consumed_alchemist_bonus_health(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.ultimate_scepter_consumed_alchemist_bonus_health)
}

// optional int32 ultimate_scepter_consumed_alchemist_bonus_mana = 122;
inline bool CMsgDotaScenario_Modifier::_internal_has_ultimate_scepter_consumed_alchemist_bonus_mana() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgDotaScenario_Modifier::has_ultimate_scepter_consumed_alchemist_bonus_mana() const {
  return _internal_has_ultimate_scepter_consumed_alchemist_bonus_mana();
}
inline void CMsgDotaScenario_Modifier::clear_ultimate_scepter_consumed_alchemist_bonus_mana() {
  _impl_.ultimate_scepter_consumed_alchemist_bonus_mana_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t CMsgDotaScenario_Modifier::_internal_ultimate_scepter_consumed_alchemist_bonus_mana() const {
  return _impl_.ultimate_scepter_consumed_alchemist_bonus_mana_;
}
inline int32_t CMsgDotaScenario_Modifier::ultimate_scepter_consumed_alchemist_bonus_mana() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.Modifier.ultimate_scepter_consumed_alchemist_bonus_mana)
  return _internal_ultimate_scepter_consumed_alchemist_bonus_mana();
}
inline void CMsgDotaScenario_Modifier::_internal_set_ultimate_scepter_consumed_alchemist_bonus_mana(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.ultimate_scepter_consumed_alchemist_bonus_mana_ = value;
}
inline void CMsgDotaScenario_Modifier::set_ultimate_scepter_consumed_alchemist_bonus_mana(int32_t value) {
  _internal_set_ultimate_scepter_consumed_alchemist_bonus_mana(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.Modifier.ultimate_scepter_consumed_alchemist_bonus_mana)
}

// -------------------------------------------------------------------

// CMsgDotaScenario

// optional uint64 lobby_id = 1;
inline bool CMsgDotaScenario::_internal_has_lobby_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDotaScenario::has_lobby_id() const {
  return _internal_has_lobby_id();
}
inline void CMsgDotaScenario::clear_lobby_id() {
  _impl_.lobby_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CMsgDotaScenario::_internal_lobby_id() const {
  return _impl_.lobby_id_;
}
inline uint64_t CMsgDotaScenario::lobby_id() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.lobby_id)
  return _internal_lobby_id();
}
inline void CMsgDotaScenario::_internal_set_lobby_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.lobby_id_ = value;
}
inline void CMsgDotaScenario::set_lobby_id(uint64_t value) {
  _internal_set_lobby_id(value);
  // @@protoc_insertion_point(field_set:CMsgDotaScenario.lobby_id)
}

// optional .CMsgDotaScenario.Game game = 2;
inline bool CMsgDotaScenario::_internal_has_game() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.game_ != nullptr);
  return value;
}
inline bool CMsgDotaScenario::has_game() const {
  return _internal_has_game();
}
inline void CMsgDotaScenario::clear_game() {
  if (_impl_.game_ != nullptr) _impl_.game_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgDotaScenario_Game& CMsgDotaScenario::_internal_game() const {
  const ::CMsgDotaScenario_Game* p = _impl_.game_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgDotaScenario_Game&>(
      ::_CMsgDotaScenario_Game_default_instance_);
}
inline const ::CMsgDotaScenario_Game& CMsgDotaScenario::game() const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.game)
  return _internal_game();
}
inline void CMsgDotaScenario::unsafe_arena_set_allocated_game(
    ::CMsgDotaScenario_Game* game) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.game_);
  }
  _impl_.game_ = game;
  if (game) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDotaScenario.game)
}
inline ::CMsgDotaScenario_Game* CMsgDotaScenario::release_game() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgDotaScenario_Game* temp = _impl_.game_;
  _impl_.game_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgDotaScenario_Game* CMsgDotaScenario::unsafe_arena_release_game() {
  // @@protoc_insertion_point(field_release:CMsgDotaScenario.game)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgDotaScenario_Game* temp = _impl_.game_;
  _impl_.game_ = nullptr;
  return temp;
}
inline ::CMsgDotaScenario_Game* CMsgDotaScenario::_internal_mutable_game() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.game_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgDotaScenario_Game>(GetArenaForAllocation());
    _impl_.game_ = p;
  }
  return _impl_.game_;
}
inline ::CMsgDotaScenario_Game* CMsgDotaScenario::mutable_game() {
  ::CMsgDotaScenario_Game* _msg = _internal_mutable_game();
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.game)
  return _msg;
}
inline void CMsgDotaScenario::set_allocated_game(::CMsgDotaScenario_Game* game) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.game_;
  }
  if (game) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(game);
    if (message_arena != submessage_arena) {
      game = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.game_ = game;
  // @@protoc_insertion_point(field_set_allocated:CMsgDotaScenario.game)
}

// repeated .CMsgDotaScenario.Team teams = 3;
inline int CMsgDotaScenario::_internal_teams_size() const {
  return _impl_.teams_.size();
}
inline int CMsgDotaScenario::teams_size() const {
  return _internal_teams_size();
}
inline void CMsgDotaScenario::clear_teams() {
  _impl_.teams_.Clear();
}
inline ::CMsgDotaScenario_Team* CMsgDotaScenario::mutable_teams(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.teams)
  return _impl_.teams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Team >*
CMsgDotaScenario::mutable_teams() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDotaScenario.teams)
  return &_impl_.teams_;
}
inline const ::CMsgDotaScenario_Team& CMsgDotaScenario::_internal_teams(int index) const {
  return _impl_.teams_.Get(index);
}
inline const ::CMsgDotaScenario_Team& CMsgDotaScenario::teams(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.teams)
  return _internal_teams(index);
}
inline ::CMsgDotaScenario_Team* CMsgDotaScenario::_internal_add_teams() {
  return _impl_.teams_.Add();
}
inline ::CMsgDotaScenario_Team* CMsgDotaScenario::add_teams() {
  ::CMsgDotaScenario_Team* _add = _internal_add_teams();
  // @@protoc_insertion_point(field_add:CMsgDotaScenario.teams)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Team >&
CMsgDotaScenario::teams() const {
  // @@protoc_insertion_point(field_list:CMsgDotaScenario.teams)
  return _impl_.teams_;
}

// repeated .CMsgDotaScenario.Hero heroes = 4;
inline int CMsgDotaScenario::_internal_heroes_size() const {
  return _impl_.heroes_.size();
}
inline int CMsgDotaScenario::heroes_size() const {
  return _internal_heroes_size();
}
inline void CMsgDotaScenario::clear_heroes() {
  _impl_.heroes_.Clear();
}
inline ::CMsgDotaScenario_Hero* CMsgDotaScenario::mutable_heroes(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.heroes)
  return _impl_.heroes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Hero >*
CMsgDotaScenario::mutable_heroes() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDotaScenario.heroes)
  return &_impl_.heroes_;
}
inline const ::CMsgDotaScenario_Hero& CMsgDotaScenario::_internal_heroes(int index) const {
  return _impl_.heroes_.Get(index);
}
inline const ::CMsgDotaScenario_Hero& CMsgDotaScenario::heroes(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.heroes)
  return _internal_heroes(index);
}
inline ::CMsgDotaScenario_Hero* CMsgDotaScenario::_internal_add_heroes() {
  return _impl_.heroes_.Add();
}
inline ::CMsgDotaScenario_Hero* CMsgDotaScenario::add_heroes() {
  ::CMsgDotaScenario_Hero* _add = _internal_add_heroes();
  // @@protoc_insertion_point(field_add:CMsgDotaScenario.heroes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Hero >&
CMsgDotaScenario::heroes() const {
  // @@protoc_insertion_point(field_list:CMsgDotaScenario.heroes)
  return _impl_.heroes_;
}

// repeated .CMsgDotaScenario.Stock stock = 5;
inline int CMsgDotaScenario::_internal_stock_size() const {
  return _impl_.stock_.size();
}
inline int CMsgDotaScenario::stock_size() const {
  return _internal_stock_size();
}
inline void CMsgDotaScenario::clear_stock() {
  _impl_.stock_.Clear();
}
inline ::CMsgDotaScenario_Stock* CMsgDotaScenario::mutable_stock(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.stock)
  return _impl_.stock_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Stock >*
CMsgDotaScenario::mutable_stock() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDotaScenario.stock)
  return &_impl_.stock_;
}
inline const ::CMsgDotaScenario_Stock& CMsgDotaScenario::_internal_stock(int index) const {
  return _impl_.stock_.Get(index);
}
inline const ::CMsgDotaScenario_Stock& CMsgDotaScenario::stock(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.stock)
  return _internal_stock(index);
}
inline ::CMsgDotaScenario_Stock* CMsgDotaScenario::_internal_add_stock() {
  return _impl_.stock_.Add();
}
inline ::CMsgDotaScenario_Stock* CMsgDotaScenario::add_stock() {
  ::CMsgDotaScenario_Stock* _add = _internal_add_stock();
  // @@protoc_insertion_point(field_add:CMsgDotaScenario.stock)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Stock >&
CMsgDotaScenario::stock() const {
  // @@protoc_insertion_point(field_list:CMsgDotaScenario.stock)
  return _impl_.stock_;
}

// repeated .CMsgDotaScenario.Building buildings = 6;
inline int CMsgDotaScenario::_internal_buildings_size() const {
  return _impl_.buildings_.size();
}
inline int CMsgDotaScenario::buildings_size() const {
  return _internal_buildings_size();
}
inline void CMsgDotaScenario::clear_buildings() {
  _impl_.buildings_.Clear();
}
inline ::CMsgDotaScenario_Building* CMsgDotaScenario::mutable_buildings(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.buildings)
  return _impl_.buildings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Building >*
CMsgDotaScenario::mutable_buildings() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDotaScenario.buildings)
  return &_impl_.buildings_;
}
inline const ::CMsgDotaScenario_Building& CMsgDotaScenario::_internal_buildings(int index) const {
  return _impl_.buildings_.Get(index);
}
inline const ::CMsgDotaScenario_Building& CMsgDotaScenario::buildings(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.buildings)
  return _internal_buildings(index);
}
inline ::CMsgDotaScenario_Building* CMsgDotaScenario::_internal_add_buildings() {
  return _impl_.buildings_.Add();
}
inline ::CMsgDotaScenario_Building* CMsgDotaScenario::add_buildings() {
  ::CMsgDotaScenario_Building* _add = _internal_add_buildings();
  // @@protoc_insertion_point(field_add:CMsgDotaScenario.buildings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Building >&
CMsgDotaScenario::buildings() const {
  // @@protoc_insertion_point(field_list:CMsgDotaScenario.buildings)
  return _impl_.buildings_;
}

// repeated .CMsgDotaScenario.Entity entities = 7;
inline int CMsgDotaScenario::_internal_entities_size() const {
  return _impl_.entities_.size();
}
inline int CMsgDotaScenario::entities_size() const {
  return _internal_entities_size();
}
inline void CMsgDotaScenario::clear_entities() {
  _impl_.entities_.Clear();
}
inline ::CMsgDotaScenario_Entity* CMsgDotaScenario::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.entities)
  return _impl_.entities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Entity >*
CMsgDotaScenario::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDotaScenario.entities)
  return &_impl_.entities_;
}
inline const ::CMsgDotaScenario_Entity& CMsgDotaScenario::_internal_entities(int index) const {
  return _impl_.entities_.Get(index);
}
inline const ::CMsgDotaScenario_Entity& CMsgDotaScenario::entities(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.entities)
  return _internal_entities(index);
}
inline ::CMsgDotaScenario_Entity* CMsgDotaScenario::_internal_add_entities() {
  return _impl_.entities_.Add();
}
inline ::CMsgDotaScenario_Entity* CMsgDotaScenario::add_entities() {
  ::CMsgDotaScenario_Entity* _add = _internal_add_entities();
  // @@protoc_insertion_point(field_add:CMsgDotaScenario.entities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Entity >&
CMsgDotaScenario::entities() const {
  // @@protoc_insertion_point(field_list:CMsgDotaScenario.entities)
  return _impl_.entities_;
}

// repeated .CMsgDotaScenario.Item items = 8;
inline int CMsgDotaScenario::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int CMsgDotaScenario::items_size() const {
  return _internal_items_size();
}
inline void CMsgDotaScenario::clear_items() {
  _impl_.items_.Clear();
}
inline ::CMsgDotaScenario_Item* CMsgDotaScenario::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Item >*
CMsgDotaScenario::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDotaScenario.items)
  return &_impl_.items_;
}
inline const ::CMsgDotaScenario_Item& CMsgDotaScenario::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::CMsgDotaScenario_Item& CMsgDotaScenario::items(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.items)
  return _internal_items(index);
}
inline ::CMsgDotaScenario_Item* CMsgDotaScenario::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::CMsgDotaScenario_Item* CMsgDotaScenario::add_items() {
  ::CMsgDotaScenario_Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:CMsgDotaScenario.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Item >&
CMsgDotaScenario::items() const {
  // @@protoc_insertion_point(field_list:CMsgDotaScenario.items)
  return _impl_.items_;
}

// repeated .CMsgDotaScenario.Modifier modifiers = 9;
inline int CMsgDotaScenario::_internal_modifiers_size() const {
  return _impl_.modifiers_.size();
}
inline int CMsgDotaScenario::modifiers_size() const {
  return _internal_modifiers_size();
}
inline void CMsgDotaScenario::clear_modifiers() {
  _impl_.modifiers_.Clear();
}
inline ::CMsgDotaScenario_Modifier* CMsgDotaScenario::mutable_modifiers(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDotaScenario.modifiers)
  return _impl_.modifiers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Modifier >*
CMsgDotaScenario::mutable_modifiers() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDotaScenario.modifiers)
  return &_impl_.modifiers_;
}
inline const ::CMsgDotaScenario_Modifier& CMsgDotaScenario::_internal_modifiers(int index) const {
  return _impl_.modifiers_.Get(index);
}
inline const ::CMsgDotaScenario_Modifier& CMsgDotaScenario::modifiers(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDotaScenario.modifiers)
  return _internal_modifiers(index);
}
inline ::CMsgDotaScenario_Modifier* CMsgDotaScenario::_internal_add_modifiers() {
  return _impl_.modifiers_.Add();
}
inline ::CMsgDotaScenario_Modifier* CMsgDotaScenario::add_modifiers() {
  ::CMsgDotaScenario_Modifier* _add = _internal_add_modifiers();
  // @@protoc_insertion_point(field_add:CMsgDotaScenario.modifiers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDotaScenario_Modifier >&
CMsgDotaScenario::modifiers() const {
  // @@protoc_insertion_point(field_list:CMsgDotaScenario.modifiers)
  return _impl_.modifiers_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dota_5fscenariomessages_2eproto
