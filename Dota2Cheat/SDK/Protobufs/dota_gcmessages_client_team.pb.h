// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_client_team.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dota_5fgcmessages_5fclient_5fteam_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dota_5fgcmessages_5fclient_5fteam_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dota_shared_enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dota_5fgcmessages_5fclient_5fteam_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dota_5fgcmessages_5fclient_5fteam_2eproto;
class CMsgDOTABetaParticipation;
struct CMsgDOTABetaParticipationDefaultTypeInternal;
extern CMsgDOTABetaParticipationDefaultTypeInternal _CMsgDOTABetaParticipation_default_instance_;
class CMsgDOTACreateTeam;
struct CMsgDOTACreateTeamDefaultTypeInternal;
extern CMsgDOTACreateTeamDefaultTypeInternal _CMsgDOTACreateTeam_default_instance_;
class CMsgDOTACreateTeamResponse;
struct CMsgDOTACreateTeamResponseDefaultTypeInternal;
extern CMsgDOTACreateTeamResponseDefaultTypeInternal _CMsgDOTACreateTeamResponse_default_instance_;
class CMsgDOTAEditTeamDetails;
struct CMsgDOTAEditTeamDetailsDefaultTypeInternal;
extern CMsgDOTAEditTeamDetailsDefaultTypeInternal _CMsgDOTAEditTeamDetails_default_instance_;
class CMsgDOTAEditTeamDetailsResponse;
struct CMsgDOTAEditTeamDetailsResponseDefaultTypeInternal;
extern CMsgDOTAEditTeamDetailsResponseDefaultTypeInternal _CMsgDOTAEditTeamDetailsResponse_default_instance_;
class CMsgDOTAKickTeamMember;
struct CMsgDOTAKickTeamMemberDefaultTypeInternal;
extern CMsgDOTAKickTeamMemberDefaultTypeInternal _CMsgDOTAKickTeamMember_default_instance_;
class CMsgDOTAKickTeamMemberResponse;
struct CMsgDOTAKickTeamMemberResponseDefaultTypeInternal;
extern CMsgDOTAKickTeamMemberResponseDefaultTypeInternal _CMsgDOTAKickTeamMemberResponse_default_instance_;
class CMsgDOTALeaveTeam;
struct CMsgDOTALeaveTeamDefaultTypeInternal;
extern CMsgDOTALeaveTeamDefaultTypeInternal _CMsgDOTALeaveTeam_default_instance_;
class CMsgDOTALeaveTeamResponse;
struct CMsgDOTALeaveTeamResponseDefaultTypeInternal;
extern CMsgDOTALeaveTeamResponseDefaultTypeInternal _CMsgDOTALeaveTeamResponse_default_instance_;
class CMsgDOTAMyTeamInfoRequest;
struct CMsgDOTAMyTeamInfoRequestDefaultTypeInternal;
extern CMsgDOTAMyTeamInfoRequestDefaultTypeInternal _CMsgDOTAMyTeamInfoRequest_default_instance_;
class CMsgDOTATeamInfo;
struct CMsgDOTATeamInfoDefaultTypeInternal;
extern CMsgDOTATeamInfoDefaultTypeInternal _CMsgDOTATeamInfo_default_instance_;
class CMsgDOTATeamInfoList;
struct CMsgDOTATeamInfoListDefaultTypeInternal;
extern CMsgDOTATeamInfoListDefaultTypeInternal _CMsgDOTATeamInfoList_default_instance_;
class CMsgDOTATeamInfo_AuditEntry;
struct CMsgDOTATeamInfo_AuditEntryDefaultTypeInternal;
extern CMsgDOTATeamInfo_AuditEntryDefaultTypeInternal _CMsgDOTATeamInfo_AuditEntry_default_instance_;
class CMsgDOTATeamInfo_DPCResult;
struct CMsgDOTATeamInfo_DPCResultDefaultTypeInternal;
extern CMsgDOTATeamInfo_DPCResultDefaultTypeInternal _CMsgDOTATeamInfo_DPCResult_default_instance_;
class CMsgDOTATeamInfo_HeroStats;
struct CMsgDOTATeamInfo_HeroStatsDefaultTypeInternal;
extern CMsgDOTATeamInfo_HeroStatsDefaultTypeInternal _CMsgDOTATeamInfo_HeroStats_default_instance_;
class CMsgDOTATeamInfo_Member;
struct CMsgDOTATeamInfo_MemberDefaultTypeInternal;
extern CMsgDOTATeamInfo_MemberDefaultTypeInternal _CMsgDOTATeamInfo_Member_default_instance_;
class CMsgDOTATeamInfo_MemberStats;
struct CMsgDOTATeamInfo_MemberStatsDefaultTypeInternal;
extern CMsgDOTATeamInfo_MemberStatsDefaultTypeInternal _CMsgDOTATeamInfo_MemberStats_default_instance_;
class CMsgDOTATeamInfo_TeamStats;
struct CMsgDOTATeamInfo_TeamStatsDefaultTypeInternal;
extern CMsgDOTATeamInfo_TeamStatsDefaultTypeInternal _CMsgDOTATeamInfo_TeamStats_default_instance_;
class CMsgDOTATeamInvite_GCImmediateResponseToInviter;
struct CMsgDOTATeamInvite_GCImmediateResponseToInviterDefaultTypeInternal;
extern CMsgDOTATeamInvite_GCImmediateResponseToInviterDefaultTypeInternal _CMsgDOTATeamInvite_GCImmediateResponseToInviter_default_instance_;
class CMsgDOTATeamInvite_GCRequestToInvitee;
struct CMsgDOTATeamInvite_GCRequestToInviteeDefaultTypeInternal;
extern CMsgDOTATeamInvite_GCRequestToInviteeDefaultTypeInternal _CMsgDOTATeamInvite_GCRequestToInvitee_default_instance_;
class CMsgDOTATeamInvite_GCResponseToInvitee;
struct CMsgDOTATeamInvite_GCResponseToInviteeDefaultTypeInternal;
extern CMsgDOTATeamInvite_GCResponseToInviteeDefaultTypeInternal _CMsgDOTATeamInvite_GCResponseToInvitee_default_instance_;
class CMsgDOTATeamInvite_GCResponseToInviter;
struct CMsgDOTATeamInvite_GCResponseToInviterDefaultTypeInternal;
extern CMsgDOTATeamInvite_GCResponseToInviterDefaultTypeInternal _CMsgDOTATeamInvite_GCResponseToInviter_default_instance_;
class CMsgDOTATeamInvite_InviteeResponseToGC;
struct CMsgDOTATeamInvite_InviteeResponseToGCDefaultTypeInternal;
extern CMsgDOTATeamInvite_InviteeResponseToGCDefaultTypeInternal _CMsgDOTATeamInvite_InviteeResponseToGC_default_instance_;
class CMsgDOTATeamInvite_InviterToGC;
struct CMsgDOTATeamInvite_InviterToGCDefaultTypeInternal;
extern CMsgDOTATeamInvite_InviterToGCDefaultTypeInternal _CMsgDOTATeamInvite_InviterToGC_default_instance_;
class CMsgDOTATeamsInfo;
struct CMsgDOTATeamsInfoDefaultTypeInternal;
extern CMsgDOTATeamsInfoDefaultTypeInternal _CMsgDOTATeamsInfo_default_instance_;
class CMsgDOTATransferTeamAdmin;
struct CMsgDOTATransferTeamAdminDefaultTypeInternal;
extern CMsgDOTATransferTeamAdminDefaultTypeInternal _CMsgDOTATransferTeamAdmin_default_instance_;
class CMsgDOTATransferTeamAdminResponse;
struct CMsgDOTATransferTeamAdminResponseDefaultTypeInternal;
extern CMsgDOTATransferTeamAdminResponseDefaultTypeInternal _CMsgDOTATransferTeamAdminResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CMsgDOTABetaParticipation* Arena::CreateMaybeMessage<::CMsgDOTABetaParticipation>(Arena*);
template<> ::CMsgDOTACreateTeam* Arena::CreateMaybeMessage<::CMsgDOTACreateTeam>(Arena*);
template<> ::CMsgDOTACreateTeamResponse* Arena::CreateMaybeMessage<::CMsgDOTACreateTeamResponse>(Arena*);
template<> ::CMsgDOTAEditTeamDetails* Arena::CreateMaybeMessage<::CMsgDOTAEditTeamDetails>(Arena*);
template<> ::CMsgDOTAEditTeamDetailsResponse* Arena::CreateMaybeMessage<::CMsgDOTAEditTeamDetailsResponse>(Arena*);
template<> ::CMsgDOTAKickTeamMember* Arena::CreateMaybeMessage<::CMsgDOTAKickTeamMember>(Arena*);
template<> ::CMsgDOTAKickTeamMemberResponse* Arena::CreateMaybeMessage<::CMsgDOTAKickTeamMemberResponse>(Arena*);
template<> ::CMsgDOTALeaveTeam* Arena::CreateMaybeMessage<::CMsgDOTALeaveTeam>(Arena*);
template<> ::CMsgDOTALeaveTeamResponse* Arena::CreateMaybeMessage<::CMsgDOTALeaveTeamResponse>(Arena*);
template<> ::CMsgDOTAMyTeamInfoRequest* Arena::CreateMaybeMessage<::CMsgDOTAMyTeamInfoRequest>(Arena*);
template<> ::CMsgDOTATeamInfo* Arena::CreateMaybeMessage<::CMsgDOTATeamInfo>(Arena*);
template<> ::CMsgDOTATeamInfoList* Arena::CreateMaybeMessage<::CMsgDOTATeamInfoList>(Arena*);
template<> ::CMsgDOTATeamInfo_AuditEntry* Arena::CreateMaybeMessage<::CMsgDOTATeamInfo_AuditEntry>(Arena*);
template<> ::CMsgDOTATeamInfo_DPCResult* Arena::CreateMaybeMessage<::CMsgDOTATeamInfo_DPCResult>(Arena*);
template<> ::CMsgDOTATeamInfo_HeroStats* Arena::CreateMaybeMessage<::CMsgDOTATeamInfo_HeroStats>(Arena*);
template<> ::CMsgDOTATeamInfo_Member* Arena::CreateMaybeMessage<::CMsgDOTATeamInfo_Member>(Arena*);
template<> ::CMsgDOTATeamInfo_MemberStats* Arena::CreateMaybeMessage<::CMsgDOTATeamInfo_MemberStats>(Arena*);
template<> ::CMsgDOTATeamInfo_TeamStats* Arena::CreateMaybeMessage<::CMsgDOTATeamInfo_TeamStats>(Arena*);
template<> ::CMsgDOTATeamInvite_GCImmediateResponseToInviter* Arena::CreateMaybeMessage<::CMsgDOTATeamInvite_GCImmediateResponseToInviter>(Arena*);
template<> ::CMsgDOTATeamInvite_GCRequestToInvitee* Arena::CreateMaybeMessage<::CMsgDOTATeamInvite_GCRequestToInvitee>(Arena*);
template<> ::CMsgDOTATeamInvite_GCResponseToInvitee* Arena::CreateMaybeMessage<::CMsgDOTATeamInvite_GCResponseToInvitee>(Arena*);
template<> ::CMsgDOTATeamInvite_GCResponseToInviter* Arena::CreateMaybeMessage<::CMsgDOTATeamInvite_GCResponseToInviter>(Arena*);
template<> ::CMsgDOTATeamInvite_InviteeResponseToGC* Arena::CreateMaybeMessage<::CMsgDOTATeamInvite_InviteeResponseToGC>(Arena*);
template<> ::CMsgDOTATeamInvite_InviterToGC* Arena::CreateMaybeMessage<::CMsgDOTATeamInvite_InviterToGC>(Arena*);
template<> ::CMsgDOTATeamsInfo* Arena::CreateMaybeMessage<::CMsgDOTATeamsInfo>(Arena*);
template<> ::CMsgDOTATransferTeamAdmin* Arena::CreateMaybeMessage<::CMsgDOTATransferTeamAdmin>(Arena*);
template<> ::CMsgDOTATransferTeamAdminResponse* Arena::CreateMaybeMessage<::CMsgDOTATransferTeamAdminResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum CMsgDOTACreateTeamResponse_Result : int {
  CMsgDOTACreateTeamResponse_Result_INVALID = -1,
  CMsgDOTACreateTeamResponse_Result_SUCCESS = 0,
  CMsgDOTACreateTeamResponse_Result_NAME_EMPTY = 1,
  CMsgDOTACreateTeamResponse_Result_NAME_BAD_CHARACTERS = 2,
  CMsgDOTACreateTeamResponse_Result_NAME_TAKEN = 3,
  CMsgDOTACreateTeamResponse_Result_NAME_TOO_LONG = 4,
  CMsgDOTACreateTeamResponse_Result_TAG_EMPTY = 5,
  CMsgDOTACreateTeamResponse_Result_TAG_BAD_CHARACTERS = 6,
  CMsgDOTACreateTeamResponse_Result_TAG_TAKEN = 7,
  CMsgDOTACreateTeamResponse_Result_TAG_TOO_LONG = 8,
  CMsgDOTACreateTeamResponse_Result_CREATOR_BUSY = 9,
  CMsgDOTACreateTeamResponse_Result_UNSPECIFIED_ERROR = 10,
  CMsgDOTACreateTeamResponse_Result_CREATOR_TEAM_LIMIT_REACHED = 11,
  CMsgDOTACreateTeamResponse_Result_NO_LOGO = 12,
  CMsgDOTACreateTeamResponse_Result_CREATOR_TEAM_CREATION_COOLDOWN = 13,
  CMsgDOTACreateTeamResponse_Result_LOGO_UPLOAD_FAILED = 14,
  CMsgDOTACreateTeamResponse_Result_NAME_CHANGED_TOO_RECENTLY = 15,
  CMsgDOTACreateTeamResponse_Result_CREATOR_INSUFFICIENT_LEVEL = 16,
  CMsgDOTACreateTeamResponse_Result_INVALID_ACCOUNT_TYPE = 17
};
bool CMsgDOTACreateTeamResponse_Result_IsValid(int value);
constexpr CMsgDOTACreateTeamResponse_Result CMsgDOTACreateTeamResponse_Result_Result_MIN = CMsgDOTACreateTeamResponse_Result_INVALID;
constexpr CMsgDOTACreateTeamResponse_Result CMsgDOTACreateTeamResponse_Result_Result_MAX = CMsgDOTACreateTeamResponse_Result_INVALID_ACCOUNT_TYPE;
constexpr int CMsgDOTACreateTeamResponse_Result_Result_ARRAYSIZE = CMsgDOTACreateTeamResponse_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTACreateTeamResponse_Result_descriptor();
template<typename T>
inline const std::string& CMsgDOTACreateTeamResponse_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgDOTACreateTeamResponse_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgDOTACreateTeamResponse_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgDOTACreateTeamResponse_Result_descriptor(), enum_t_value);
}
inline bool CMsgDOTACreateTeamResponse_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgDOTACreateTeamResponse_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgDOTACreateTeamResponse_Result>(
    CMsgDOTACreateTeamResponse_Result_descriptor(), name, value);
}
enum CMsgDOTAEditTeamDetailsResponse_Result : int {
  CMsgDOTAEditTeamDetailsResponse_Result_SUCCESS = 0,
  CMsgDOTAEditTeamDetailsResponse_Result_FAILURE_INVALID_ACCOUNT_TYPE = 1,
  CMsgDOTAEditTeamDetailsResponse_Result_FAILURE_NOT_MEMBER = 2,
  CMsgDOTAEditTeamDetailsResponse_Result_FAILURE_TEAM_LOCKED = 3,
  CMsgDOTAEditTeamDetailsResponse_Result_FAILURE_UNSPECIFIED_ERROR = 4
};
bool CMsgDOTAEditTeamDetailsResponse_Result_IsValid(int value);
constexpr CMsgDOTAEditTeamDetailsResponse_Result CMsgDOTAEditTeamDetailsResponse_Result_Result_MIN = CMsgDOTAEditTeamDetailsResponse_Result_SUCCESS;
constexpr CMsgDOTAEditTeamDetailsResponse_Result CMsgDOTAEditTeamDetailsResponse_Result_Result_MAX = CMsgDOTAEditTeamDetailsResponse_Result_FAILURE_UNSPECIFIED_ERROR;
constexpr int CMsgDOTAEditTeamDetailsResponse_Result_Result_ARRAYSIZE = CMsgDOTAEditTeamDetailsResponse_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTAEditTeamDetailsResponse_Result_descriptor();
template<typename T>
inline const std::string& CMsgDOTAEditTeamDetailsResponse_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgDOTAEditTeamDetailsResponse_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgDOTAEditTeamDetailsResponse_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgDOTAEditTeamDetailsResponse_Result_descriptor(), enum_t_value);
}
inline bool CMsgDOTAEditTeamDetailsResponse_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgDOTAEditTeamDetailsResponse_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgDOTAEditTeamDetailsResponse_Result>(
    CMsgDOTAEditTeamDetailsResponse_Result_descriptor(), name, value);
}
enum CMsgDOTAKickTeamMemberResponse_Result : int {
  CMsgDOTAKickTeamMemberResponse_Result_SUCCESS = 0,
  CMsgDOTAKickTeamMemberResponse_Result_FAILURE_INVALID_ACCOUNT_TYPE = 1,
  CMsgDOTAKickTeamMemberResponse_Result_FAILURE_KICKER_NOT_ADMIN = 2,
  CMsgDOTAKickTeamMemberResponse_Result_FAILURE_KICKEE_NOT_MEMBER = 3,
  CMsgDOTAKickTeamMemberResponse_Result_FAILURE_TEAM_LOCKED = 4,
  CMsgDOTAKickTeamMemberResponse_Result_FAILURE_UNSPECIFIED_ERROR = 5
};
bool CMsgDOTAKickTeamMemberResponse_Result_IsValid(int value);
constexpr CMsgDOTAKickTeamMemberResponse_Result CMsgDOTAKickTeamMemberResponse_Result_Result_MIN = CMsgDOTAKickTeamMemberResponse_Result_SUCCESS;
constexpr CMsgDOTAKickTeamMemberResponse_Result CMsgDOTAKickTeamMemberResponse_Result_Result_MAX = CMsgDOTAKickTeamMemberResponse_Result_FAILURE_UNSPECIFIED_ERROR;
constexpr int CMsgDOTAKickTeamMemberResponse_Result_Result_ARRAYSIZE = CMsgDOTAKickTeamMemberResponse_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTAKickTeamMemberResponse_Result_descriptor();
template<typename T>
inline const std::string& CMsgDOTAKickTeamMemberResponse_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgDOTAKickTeamMemberResponse_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgDOTAKickTeamMemberResponse_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgDOTAKickTeamMemberResponse_Result_descriptor(), enum_t_value);
}
inline bool CMsgDOTAKickTeamMemberResponse_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgDOTAKickTeamMemberResponse_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgDOTAKickTeamMemberResponse_Result>(
    CMsgDOTAKickTeamMemberResponse_Result_descriptor(), name, value);
}
enum CMsgDOTATransferTeamAdminResponse_Result : int {
  CMsgDOTATransferTeamAdminResponse_Result_SUCCESS = 0,
  CMsgDOTATransferTeamAdminResponse_Result_FAILURE_INVALID_ACCOUNT_TYPE = 1,
  CMsgDOTATransferTeamAdminResponse_Result_FAILURE_NOT_ADMIN = 2,
  CMsgDOTATransferTeamAdminResponse_Result_FAILURE_SAME_ACCOUNT = 3,
  CMsgDOTATransferTeamAdminResponse_Result_FAILURE_NOT_MEMBER = 4,
  CMsgDOTATransferTeamAdminResponse_Result_FAILURE_UNSPECIFIED_ERROR = 5
};
bool CMsgDOTATransferTeamAdminResponse_Result_IsValid(int value);
constexpr CMsgDOTATransferTeamAdminResponse_Result CMsgDOTATransferTeamAdminResponse_Result_Result_MIN = CMsgDOTATransferTeamAdminResponse_Result_SUCCESS;
constexpr CMsgDOTATransferTeamAdminResponse_Result CMsgDOTATransferTeamAdminResponse_Result_Result_MAX = CMsgDOTATransferTeamAdminResponse_Result_FAILURE_UNSPECIFIED_ERROR;
constexpr int CMsgDOTATransferTeamAdminResponse_Result_Result_ARRAYSIZE = CMsgDOTATransferTeamAdminResponse_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTATransferTeamAdminResponse_Result_descriptor();
template<typename T>
inline const std::string& CMsgDOTATransferTeamAdminResponse_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgDOTATransferTeamAdminResponse_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgDOTATransferTeamAdminResponse_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgDOTATransferTeamAdminResponse_Result_descriptor(), enum_t_value);
}
inline bool CMsgDOTATransferTeamAdminResponse_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgDOTATransferTeamAdminResponse_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgDOTATransferTeamAdminResponse_Result>(
    CMsgDOTATransferTeamAdminResponse_Result_descriptor(), name, value);
}
enum CMsgDOTALeaveTeamResponse_Result : int {
  CMsgDOTALeaveTeamResponse_Result_SUCCESS = 0,
  CMsgDOTALeaveTeamResponse_Result_FAILURE_NOT_MEMBER = 1,
  CMsgDOTALeaveTeamResponse_Result_FAILURE_TEAM_LOCKED = 2,
  CMsgDOTALeaveTeamResponse_Result_FAILURE_UNSPECIFIED_ERROR = 3
};
bool CMsgDOTALeaveTeamResponse_Result_IsValid(int value);
constexpr CMsgDOTALeaveTeamResponse_Result CMsgDOTALeaveTeamResponse_Result_Result_MIN = CMsgDOTALeaveTeamResponse_Result_SUCCESS;
constexpr CMsgDOTALeaveTeamResponse_Result CMsgDOTALeaveTeamResponse_Result_Result_MAX = CMsgDOTALeaveTeamResponse_Result_FAILURE_UNSPECIFIED_ERROR;
constexpr int CMsgDOTALeaveTeamResponse_Result_Result_ARRAYSIZE = CMsgDOTALeaveTeamResponse_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTALeaveTeamResponse_Result_descriptor();
template<typename T>
inline const std::string& CMsgDOTALeaveTeamResponse_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgDOTALeaveTeamResponse_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgDOTALeaveTeamResponse_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgDOTALeaveTeamResponse_Result_descriptor(), enum_t_value);
}
inline bool CMsgDOTALeaveTeamResponse_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgDOTALeaveTeamResponse_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgDOTALeaveTeamResponse_Result>(
    CMsgDOTALeaveTeamResponse_Result_descriptor(), name, value);
}
enum ETeamInviteResult : int {
  TEAM_INVITE_SUCCESS = 0,
  TEAM_INVITE_FAILURE_INVITE_REJECTED = 1,
  TEAM_INVITE_FAILURE_INVITE_TIMEOUT = 2,
  TEAM_INVITE_ERROR_TEAM_AT_MEMBER_LIMIT = 3,
  TEAM_INVITE_ERROR_TEAM_LOCKED = 4,
  TEAM_INVITE_ERROR_INVITEE_NOT_AVAILABLE = 5,
  TEAM_INVITE_ERROR_INVITEE_BUSY = 6,
  TEAM_INVITE_ERROR_INVITEE_ALREADY_MEMBER = 7,
  TEAM_INVITE_ERROR_INVITEE_AT_TEAM_LIMIT = 8,
  TEAM_INVITE_ERROR_INVITEE_INSUFFICIENT_PLAY_TIME = 9,
  TEAM_INVITE_ERROR_INVITER_INVALID_ACCOUNT_TYPE = 10,
  TEAM_INVITE_ERROR_INVITER_NOT_ADMIN = 11,
  TEAM_INVITE_ERROR_INCORRECT_USER_RESPONDED = 12,
  TEAM_INVITE_ERROR_UNSPECIFIED = 13
};
bool ETeamInviteResult_IsValid(int value);
constexpr ETeamInviteResult ETeamInviteResult_MIN = TEAM_INVITE_SUCCESS;
constexpr ETeamInviteResult ETeamInviteResult_MAX = TEAM_INVITE_ERROR_UNSPECIFIED;
constexpr int ETeamInviteResult_ARRAYSIZE = ETeamInviteResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETeamInviteResult_descriptor();
template<typename T>
inline const std::string& ETeamInviteResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ETeamInviteResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ETeamInviteResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ETeamInviteResult_descriptor(), enum_t_value);
}
inline bool ETeamInviteResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ETeamInviteResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ETeamInviteResult>(
    ETeamInviteResult_descriptor(), name, value);
}
// ===================================================================

class CMsgDOTATeamInfo_HeroStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInfo.HeroStats) */ {
 public:
  inline CMsgDOTATeamInfo_HeroStats() : CMsgDOTATeamInfo_HeroStats(nullptr) {}
  ~CMsgDOTATeamInfo_HeroStats() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInfo_HeroStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInfo_HeroStats(const CMsgDOTATeamInfo_HeroStats& from);
  CMsgDOTATeamInfo_HeroStats(CMsgDOTATeamInfo_HeroStats&& from) noexcept
    : CMsgDOTATeamInfo_HeroStats() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInfo_HeroStats& operator=(const CMsgDOTATeamInfo_HeroStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInfo_HeroStats& operator=(CMsgDOTATeamInfo_HeroStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInfo_HeroStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInfo_HeroStats* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInfo_HeroStats*>(
               &_CMsgDOTATeamInfo_HeroStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CMsgDOTATeamInfo_HeroStats& a, CMsgDOTATeamInfo_HeroStats& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInfo_HeroStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInfo_HeroStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInfo_HeroStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInfo_HeroStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInfo_HeroStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInfo_HeroStats& from) {
    CMsgDOTATeamInfo_HeroStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInfo_HeroStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInfo.HeroStats";
  }
  protected:
  explicit CMsgDOTATeamInfo_HeroStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeroIdFieldNumber = 1,
    kPicksFieldNumber = 2,
    kWinsFieldNumber = 3,
    kBansFieldNumber = 4,
    kAvgKillsFieldNumber = 5,
    kAvgDeathsFieldNumber = 6,
    kAvgAssistsFieldNumber = 7,
    kAvgGpmFieldNumber = 8,
    kAvgXpmFieldNumber = 9,
  };
  // optional uint32 hero_id = 1;
  bool has_hero_id() const;
  private:
  bool _internal_has_hero_id() const;
  public:
  void clear_hero_id();
  uint32_t hero_id() const;
  void set_hero_id(uint32_t value);
  private:
  uint32_t _internal_hero_id() const;
  void _internal_set_hero_id(uint32_t value);
  public:

  // optional uint32 picks = 2;
  bool has_picks() const;
  private:
  bool _internal_has_picks() const;
  public:
  void clear_picks();
  uint32_t picks() const;
  void set_picks(uint32_t value);
  private:
  uint32_t _internal_picks() const;
  void _internal_set_picks(uint32_t value);
  public:

  // optional uint32 wins = 3;
  bool has_wins() const;
  private:
  bool _internal_has_wins() const;
  public:
  void clear_wins();
  uint32_t wins() const;
  void set_wins(uint32_t value);
  private:
  uint32_t _internal_wins() const;
  void _internal_set_wins(uint32_t value);
  public:

  // optional uint32 bans = 4;
  bool has_bans() const;
  private:
  bool _internal_has_bans() const;
  public:
  void clear_bans();
  uint32_t bans() const;
  void set_bans(uint32_t value);
  private:
  uint32_t _internal_bans() const;
  void _internal_set_bans(uint32_t value);
  public:

  // optional float avg_kills = 5;
  bool has_avg_kills() const;
  private:
  bool _internal_has_avg_kills() const;
  public:
  void clear_avg_kills();
  float avg_kills() const;
  void set_avg_kills(float value);
  private:
  float _internal_avg_kills() const;
  void _internal_set_avg_kills(float value);
  public:

  // optional float avg_deaths = 6;
  bool has_avg_deaths() const;
  private:
  bool _internal_has_avg_deaths() const;
  public:
  void clear_avg_deaths();
  float avg_deaths() const;
  void set_avg_deaths(float value);
  private:
  float _internal_avg_deaths() const;
  void _internal_set_avg_deaths(float value);
  public:

  // optional float avg_assists = 7;
  bool has_avg_assists() const;
  private:
  bool _internal_has_avg_assists() const;
  public:
  void clear_avg_assists();
  float avg_assists() const;
  void set_avg_assists(float value);
  private:
  float _internal_avg_assists() const;
  void _internal_set_avg_assists(float value);
  public:

  // optional float avg_gpm = 8;
  bool has_avg_gpm() const;
  private:
  bool _internal_has_avg_gpm() const;
  public:
  void clear_avg_gpm();
  float avg_gpm() const;
  void set_avg_gpm(float value);
  private:
  float _internal_avg_gpm() const;
  void _internal_set_avg_gpm(float value);
  public:

  // optional float avg_xpm = 9;
  bool has_avg_xpm() const;
  private:
  bool _internal_has_avg_xpm() const;
  public:
  void clear_avg_xpm();
  float avg_xpm() const;
  void set_avg_xpm(float value);
  private:
  float _internal_avg_xpm() const;
  void _internal_set_avg_xpm(float value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInfo.HeroStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t hero_id_;
    uint32_t picks_;
    uint32_t wins_;
    uint32_t bans_;
    float avg_kills_;
    float avg_deaths_;
    float avg_assists_;
    float avg_gpm_;
    float avg_xpm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInfo_MemberStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInfo.MemberStats) */ {
 public:
  inline CMsgDOTATeamInfo_MemberStats() : CMsgDOTATeamInfo_MemberStats(nullptr) {}
  ~CMsgDOTATeamInfo_MemberStats() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInfo_MemberStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInfo_MemberStats(const CMsgDOTATeamInfo_MemberStats& from);
  CMsgDOTATeamInfo_MemberStats(CMsgDOTATeamInfo_MemberStats&& from) noexcept
    : CMsgDOTATeamInfo_MemberStats() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInfo_MemberStats& operator=(const CMsgDOTATeamInfo_MemberStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInfo_MemberStats& operator=(CMsgDOTATeamInfo_MemberStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInfo_MemberStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInfo_MemberStats* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInfo_MemberStats*>(
               &_CMsgDOTATeamInfo_MemberStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CMsgDOTATeamInfo_MemberStats& a, CMsgDOTATeamInfo_MemberStats& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInfo_MemberStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInfo_MemberStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInfo_MemberStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInfo_MemberStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInfo_MemberStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInfo_MemberStats& from) {
    CMsgDOTATeamInfo_MemberStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInfo_MemberStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInfo.MemberStats";
  }
  protected:
  explicit CMsgDOTATeamInfo_MemberStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopHeroesFieldNumber = 4,
    kAccountIdFieldNumber = 1,
    kWinsWithTeamFieldNumber = 2,
    kLossesWithTeamFieldNumber = 3,
    kAvgKillsFieldNumber = 5,
    kAvgDeathsFieldNumber = 6,
    kAvgAssistsFieldNumber = 7,
  };
  // repeated .CMsgDOTATeamInfo.HeroStats top_heroes = 4;
  int top_heroes_size() const;
  private:
  int _internal_top_heroes_size() const;
  public:
  void clear_top_heroes();
  ::CMsgDOTATeamInfo_HeroStats* mutable_top_heroes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_HeroStats >*
      mutable_top_heroes();
  private:
  const ::CMsgDOTATeamInfo_HeroStats& _internal_top_heroes(int index) const;
  ::CMsgDOTATeamInfo_HeroStats* _internal_add_top_heroes();
  public:
  const ::CMsgDOTATeamInfo_HeroStats& top_heroes(int index) const;
  ::CMsgDOTATeamInfo_HeroStats* add_top_heroes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_HeroStats >&
      top_heroes() const;

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  uint32_t account_id() const;
  void set_account_id(uint32_t value);
  private:
  uint32_t _internal_account_id() const;
  void _internal_set_account_id(uint32_t value);
  public:

  // optional uint32 wins_with_team = 2;
  bool has_wins_with_team() const;
  private:
  bool _internal_has_wins_with_team() const;
  public:
  void clear_wins_with_team();
  uint32_t wins_with_team() const;
  void set_wins_with_team(uint32_t value);
  private:
  uint32_t _internal_wins_with_team() const;
  void _internal_set_wins_with_team(uint32_t value);
  public:

  // optional uint32 losses_with_team = 3;
  bool has_losses_with_team() const;
  private:
  bool _internal_has_losses_with_team() const;
  public:
  void clear_losses_with_team();
  uint32_t losses_with_team() const;
  void set_losses_with_team(uint32_t value);
  private:
  uint32_t _internal_losses_with_team() const;
  void _internal_set_losses_with_team(uint32_t value);
  public:

  // optional float avg_kills = 5;
  bool has_avg_kills() const;
  private:
  bool _internal_has_avg_kills() const;
  public:
  void clear_avg_kills();
  float avg_kills() const;
  void set_avg_kills(float value);
  private:
  float _internal_avg_kills() const;
  void _internal_set_avg_kills(float value);
  public:

  // optional float avg_deaths = 6;
  bool has_avg_deaths() const;
  private:
  bool _internal_has_avg_deaths() const;
  public:
  void clear_avg_deaths();
  float avg_deaths() const;
  void set_avg_deaths(float value);
  private:
  float _internal_avg_deaths() const;
  void _internal_set_avg_deaths(float value);
  public:

  // optional float avg_assists = 7;
  bool has_avg_assists() const;
  private:
  bool _internal_has_avg_assists() const;
  public:
  void clear_avg_assists();
  float avg_assists() const;
  void set_avg_assists(float value);
  private:
  float _internal_avg_assists() const;
  void _internal_set_avg_assists(float value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInfo.MemberStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_HeroStats > top_heroes_;
    uint32_t account_id_;
    uint32_t wins_with_team_;
    uint32_t losses_with_team_;
    float avg_kills_;
    float avg_deaths_;
    float avg_assists_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInfo_TeamStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInfo.TeamStats) */ {
 public:
  inline CMsgDOTATeamInfo_TeamStats() : CMsgDOTATeamInfo_TeamStats(nullptr) {}
  ~CMsgDOTATeamInfo_TeamStats() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInfo_TeamStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInfo_TeamStats(const CMsgDOTATeamInfo_TeamStats& from);
  CMsgDOTATeamInfo_TeamStats(CMsgDOTATeamInfo_TeamStats&& from) noexcept
    : CMsgDOTATeamInfo_TeamStats() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInfo_TeamStats& operator=(const CMsgDOTATeamInfo_TeamStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInfo_TeamStats& operator=(CMsgDOTATeamInfo_TeamStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInfo_TeamStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInfo_TeamStats* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInfo_TeamStats*>(
               &_CMsgDOTATeamInfo_TeamStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CMsgDOTATeamInfo_TeamStats& a, CMsgDOTATeamInfo_TeamStats& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInfo_TeamStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInfo_TeamStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInfo_TeamStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInfo_TeamStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInfo_TeamStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInfo_TeamStats& from) {
    CMsgDOTATeamInfo_TeamStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInfo_TeamStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInfo.TeamStats";
  }
  protected:
  explicit CMsgDOTATeamInfo_TeamStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayedHeroesFieldNumber = 1,
    kFarmingFieldNumber = 2,
    kFightingFieldNumber = 3,
    kVersatilityFieldNumber = 4,
    kAvgKillsFieldNumber = 5,
    kAvgDeathsFieldNumber = 6,
    kAvgDurationFieldNumber = 7,
  };
  // repeated .CMsgDOTATeamInfo.HeroStats played_heroes = 1;
  int played_heroes_size() const;
  private:
  int _internal_played_heroes_size() const;
  public:
  void clear_played_heroes();
  ::CMsgDOTATeamInfo_HeroStats* mutable_played_heroes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_HeroStats >*
      mutable_played_heroes();
  private:
  const ::CMsgDOTATeamInfo_HeroStats& _internal_played_heroes(int index) const;
  ::CMsgDOTATeamInfo_HeroStats* _internal_add_played_heroes();
  public:
  const ::CMsgDOTATeamInfo_HeroStats& played_heroes(int index) const;
  ::CMsgDOTATeamInfo_HeroStats* add_played_heroes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_HeroStats >&
      played_heroes() const;

  // optional float farming = 2;
  bool has_farming() const;
  private:
  bool _internal_has_farming() const;
  public:
  void clear_farming();
  float farming() const;
  void set_farming(float value);
  private:
  float _internal_farming() const;
  void _internal_set_farming(float value);
  public:

  // optional float fighting = 3;
  bool has_fighting() const;
  private:
  bool _internal_has_fighting() const;
  public:
  void clear_fighting();
  float fighting() const;
  void set_fighting(float value);
  private:
  float _internal_fighting() const;
  void _internal_set_fighting(float value);
  public:

  // optional float versatility = 4;
  bool has_versatility() const;
  private:
  bool _internal_has_versatility() const;
  public:
  void clear_versatility();
  float versatility() const;
  void set_versatility(float value);
  private:
  float _internal_versatility() const;
  void _internal_set_versatility(float value);
  public:

  // optional float avg_kills = 5;
  bool has_avg_kills() const;
  private:
  bool _internal_has_avg_kills() const;
  public:
  void clear_avg_kills();
  float avg_kills() const;
  void set_avg_kills(float value);
  private:
  float _internal_avg_kills() const;
  void _internal_set_avg_kills(float value);
  public:

  // optional float avg_deaths = 6;
  bool has_avg_deaths() const;
  private:
  bool _internal_has_avg_deaths() const;
  public:
  void clear_avg_deaths();
  float avg_deaths() const;
  void set_avg_deaths(float value);
  private:
  float _internal_avg_deaths() const;
  void _internal_set_avg_deaths(float value);
  public:

  // optional float avg_duration = 7;
  bool has_avg_duration() const;
  private:
  bool _internal_has_avg_duration() const;
  public:
  void clear_avg_duration();
  float avg_duration() const;
  void set_avg_duration(float value);
  private:
  float _internal_avg_duration() const;
  void _internal_set_avg_duration(float value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInfo.TeamStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_HeroStats > played_heroes_;
    float farming_;
    float fighting_;
    float versatility_;
    float avg_kills_;
    float avg_deaths_;
    float avg_duration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInfo_DPCResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInfo.DPCResult) */ {
 public:
  inline CMsgDOTATeamInfo_DPCResult() : CMsgDOTATeamInfo_DPCResult(nullptr) {}
  ~CMsgDOTATeamInfo_DPCResult() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInfo_DPCResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInfo_DPCResult(const CMsgDOTATeamInfo_DPCResult& from);
  CMsgDOTATeamInfo_DPCResult(CMsgDOTATeamInfo_DPCResult&& from) noexcept
    : CMsgDOTATeamInfo_DPCResult() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInfo_DPCResult& operator=(const CMsgDOTATeamInfo_DPCResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInfo_DPCResult& operator=(CMsgDOTATeamInfo_DPCResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInfo_DPCResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInfo_DPCResult* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInfo_DPCResult*>(
               &_CMsgDOTATeamInfo_DPCResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CMsgDOTATeamInfo_DPCResult& a, CMsgDOTATeamInfo_DPCResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInfo_DPCResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInfo_DPCResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInfo_DPCResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInfo_DPCResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInfo_DPCResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInfo_DPCResult& from) {
    CMsgDOTATeamInfo_DPCResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInfo_DPCResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInfo.DPCResult";
  }
  protected:
  explicit CMsgDOTATeamInfo_DPCResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeagueIdFieldNumber = 1,
    kStandingFieldNumber = 2,
    kPointsFieldNumber = 3,
    kEarningsFieldNumber = 4,
    kTimestampFieldNumber = 5,
  };
  // optional uint32 league_id = 1;
  bool has_league_id() const;
  private:
  bool _internal_has_league_id() const;
  public:
  void clear_league_id();
  uint32_t league_id() const;
  void set_league_id(uint32_t value);
  private:
  uint32_t _internal_league_id() const;
  void _internal_set_league_id(uint32_t value);
  public:

  // optional uint32 standing = 2;
  bool has_standing() const;
  private:
  bool _internal_has_standing() const;
  public:
  void clear_standing();
  uint32_t standing() const;
  void set_standing(uint32_t value);
  private:
  uint32_t _internal_standing() const;
  void _internal_set_standing(uint32_t value);
  public:

  // optional uint32 points = 3;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  uint32_t points() const;
  void set_points(uint32_t value);
  private:
  uint32_t _internal_points() const;
  void _internal_set_points(uint32_t value);
  public:

  // optional uint32 earnings = 4;
  bool has_earnings() const;
  private:
  bool _internal_has_earnings() const;
  public:
  void clear_earnings();
  uint32_t earnings() const;
  void set_earnings(uint32_t value);
  private:
  uint32_t _internal_earnings() const;
  void _internal_set_earnings(uint32_t value);
  public:

  // optional uint32 timestamp = 5;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInfo.DPCResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t league_id_;
    uint32_t standing_;
    uint32_t points_;
    uint32_t earnings_;
    uint32_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInfo_Member final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInfo.Member) */ {
 public:
  inline CMsgDOTATeamInfo_Member() : CMsgDOTATeamInfo_Member(nullptr) {}
  ~CMsgDOTATeamInfo_Member() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInfo_Member(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInfo_Member(const CMsgDOTATeamInfo_Member& from);
  CMsgDOTATeamInfo_Member(CMsgDOTATeamInfo_Member&& from) noexcept
    : CMsgDOTATeamInfo_Member() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInfo_Member& operator=(const CMsgDOTATeamInfo_Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInfo_Member& operator=(CMsgDOTATeamInfo_Member&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInfo_Member& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInfo_Member* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInfo_Member*>(
               &_CMsgDOTATeamInfo_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CMsgDOTATeamInfo_Member& a, CMsgDOTATeamInfo_Member& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInfo_Member* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInfo_Member* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInfo_Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInfo_Member>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInfo_Member& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInfo_Member& from) {
    CMsgDOTATeamInfo_Member::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInfo_Member* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInfo.Member";
  }
  protected:
  explicit CMsgDOTATeamInfo_Member(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProNameFieldNumber = 6,
    kRealNameFieldNumber = 9,
    kAccountIdFieldNumber = 1,
    kTimeJoinedFieldNumber = 2,
    kAdminFieldNumber = 3,
    kRoleFieldNumber = 8,
  };
  // optional string pro_name = 6;
  bool has_pro_name() const;
  private:
  bool _internal_has_pro_name() const;
  public:
  void clear_pro_name();
  const std::string& pro_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pro_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pro_name();
  PROTOBUF_NODISCARD std::string* release_pro_name();
  void set_allocated_pro_name(std::string* pro_name);
  private:
  const std::string& _internal_pro_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pro_name(const std::string& value);
  std::string* _internal_mutable_pro_name();
  public:

  // optional string real_name = 9;
  bool has_real_name() const;
  private:
  bool _internal_has_real_name() const;
  public:
  void clear_real_name();
  const std::string& real_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_real_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_real_name();
  PROTOBUF_NODISCARD std::string* release_real_name();
  void set_allocated_real_name(std::string* real_name);
  private:
  const std::string& _internal_real_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_real_name(const std::string& value);
  std::string* _internal_mutable_real_name();
  public:

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  uint32_t account_id() const;
  void set_account_id(uint32_t value);
  private:
  uint32_t _internal_account_id() const;
  void _internal_set_account_id(uint32_t value);
  public:

  // optional uint32 time_joined = 2;
  bool has_time_joined() const;
  private:
  bool _internal_has_time_joined() const;
  public:
  void clear_time_joined();
  uint32_t time_joined() const;
  void set_time_joined(uint32_t value);
  private:
  uint32_t _internal_time_joined() const;
  void _internal_set_time_joined(uint32_t value);
  public:

  // optional bool admin = 3;
  bool has_admin() const;
  private:
  bool _internal_has_admin() const;
  public:
  void clear_admin();
  bool admin() const;
  void set_admin(bool value);
  private:
  bool _internal_admin() const;
  void _internal_set_admin(bool value);
  public:

  // optional .Fantasy_Roles role = 8 [default = FANTASY_ROLE_UNDEFINED];
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  ::Fantasy_Roles role() const;
  void set_role(::Fantasy_Roles value);
  private:
  ::Fantasy_Roles _internal_role() const;
  void _internal_set_role(::Fantasy_Roles value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInfo.Member)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pro_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr real_name_;
    uint32_t account_id_;
    uint32_t time_joined_;
    bool admin_;
    int role_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInfo_AuditEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInfo.AuditEntry) */ {
 public:
  inline CMsgDOTATeamInfo_AuditEntry() : CMsgDOTATeamInfo_AuditEntry(nullptr) {}
  ~CMsgDOTATeamInfo_AuditEntry() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInfo_AuditEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInfo_AuditEntry(const CMsgDOTATeamInfo_AuditEntry& from);
  CMsgDOTATeamInfo_AuditEntry(CMsgDOTATeamInfo_AuditEntry&& from) noexcept
    : CMsgDOTATeamInfo_AuditEntry() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInfo_AuditEntry& operator=(const CMsgDOTATeamInfo_AuditEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInfo_AuditEntry& operator=(CMsgDOTATeamInfo_AuditEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInfo_AuditEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInfo_AuditEntry* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInfo_AuditEntry*>(
               &_CMsgDOTATeamInfo_AuditEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CMsgDOTATeamInfo_AuditEntry& a, CMsgDOTATeamInfo_AuditEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInfo_AuditEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInfo_AuditEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInfo_AuditEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInfo_AuditEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInfo_AuditEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInfo_AuditEntry& from) {
    CMsgDOTATeamInfo_AuditEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInfo_AuditEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInfo.AuditEntry";
  }
  protected:
  explicit CMsgDOTATeamInfo_AuditEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuditActionFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kAccountIdFieldNumber = 3,
  };
  // optional uint32 audit_action = 1;
  bool has_audit_action() const;
  private:
  bool _internal_has_audit_action() const;
  public:
  void clear_audit_action();
  uint32_t audit_action() const;
  void set_audit_action(uint32_t value);
  private:
  uint32_t _internal_audit_action() const;
  void _internal_set_audit_action(uint32_t value);
  public:

  // optional uint32 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // optional uint32 account_id = 3;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  uint32_t account_id() const;
  void set_account_id(uint32_t value);
  private:
  uint32_t _internal_account_id() const;
  void _internal_set_account_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInfo.AuditEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t audit_action_;
    uint32_t timestamp_;
    uint32_t account_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInfo) */ {
 public:
  inline CMsgDOTATeamInfo() : CMsgDOTATeamInfo(nullptr) {}
  ~CMsgDOTATeamInfo() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInfo(const CMsgDOTATeamInfo& from);
  CMsgDOTATeamInfo(CMsgDOTATeamInfo&& from) noexcept
    : CMsgDOTATeamInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInfo& operator=(const CMsgDOTATeamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInfo& operator=(CMsgDOTATeamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInfo*>(
               &_CMsgDOTATeamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CMsgDOTATeamInfo& a, CMsgDOTATeamInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInfo& from) {
    CMsgDOTATeamInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInfo";
  }
  protected:
  explicit CMsgDOTATeamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTATeamInfo_HeroStats HeroStats;
  typedef CMsgDOTATeamInfo_MemberStats MemberStats;
  typedef CMsgDOTATeamInfo_TeamStats TeamStats;
  typedef CMsgDOTATeamInfo_DPCResult DPCResult;
  typedef CMsgDOTATeamInfo_Member Member;
  typedef CMsgDOTATeamInfo_AuditEntry AuditEntry;

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 1,
    kRegisteredMemberAccountIdsFieldNumber = 30,
    kAuditEntriesFieldNumber = 31,
    kMemberStatsFieldNumber = 33,
    kDpcResultsFieldNumber = 35,
    kNameFieldNumber = 3,
    kTagFieldNumber = 4,
    kCountryCodeFieldNumber = 13,
    kUrlFieldNumber = 14,
    kUrlLogoFieldNumber = 24,
    kAbbreviationFieldNumber = 32,
    kColorPrimaryFieldNumber = 37,
    kColorSecondaryFieldNumber = 38,
    kTeamStatsFieldNumber = 34,
    kTeamIdFieldNumber = 2,
    kTimeCreatedFieldNumber = 5,
    kUgcLogoFieldNumber = 9,
    kProFieldNumber = 6,
    kPickupTeamFieldNumber = 8,
    kWinsFieldNumber = 15,
    kUgcBaseLogoFieldNumber = 10,
    kUgcBannerLogoFieldNumber = 11,
    kUgcSponsorLogoFieldNumber = 12,
    kLossesFieldNumber = 16,
    kGamesPlayedTotalFieldNumber = 19,
    kGamesPlayedMatchmakingFieldNumber = 20,
    kRegionFieldNumber = 29,
    kCoachAccountIdFieldNumber = 36,
    kTeamCaptainFieldNumber = 39,
  };
  // repeated .CMsgDOTATeamInfo.Member members = 1;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::CMsgDOTATeamInfo_Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_Member >*
      mutable_members();
  private:
  const ::CMsgDOTATeamInfo_Member& _internal_members(int index) const;
  ::CMsgDOTATeamInfo_Member* _internal_add_members();
  public:
  const ::CMsgDOTATeamInfo_Member& members(int index) const;
  ::CMsgDOTATeamInfo_Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_Member >&
      members() const;

  // repeated uint32 registered_member_account_ids = 30;
  int registered_member_account_ids_size() const;
  private:
  int _internal_registered_member_account_ids_size() const;
  public:
  void clear_registered_member_account_ids();
  private:
  uint32_t _internal_registered_member_account_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_registered_member_account_ids() const;
  void _internal_add_registered_member_account_ids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_registered_member_account_ids();
  public:
  uint32_t registered_member_account_ids(int index) const;
  void set_registered_member_account_ids(int index, uint32_t value);
  void add_registered_member_account_ids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      registered_member_account_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_registered_member_account_ids();

  // repeated .CMsgDOTATeamInfo.AuditEntry audit_entries = 31;
  int audit_entries_size() const;
  private:
  int _internal_audit_entries_size() const;
  public:
  void clear_audit_entries();
  ::CMsgDOTATeamInfo_AuditEntry* mutable_audit_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_AuditEntry >*
      mutable_audit_entries();
  private:
  const ::CMsgDOTATeamInfo_AuditEntry& _internal_audit_entries(int index) const;
  ::CMsgDOTATeamInfo_AuditEntry* _internal_add_audit_entries();
  public:
  const ::CMsgDOTATeamInfo_AuditEntry& audit_entries(int index) const;
  ::CMsgDOTATeamInfo_AuditEntry* add_audit_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_AuditEntry >&
      audit_entries() const;

  // repeated .CMsgDOTATeamInfo.MemberStats member_stats = 33;
  int member_stats_size() const;
  private:
  int _internal_member_stats_size() const;
  public:
  void clear_member_stats();
  ::CMsgDOTATeamInfo_MemberStats* mutable_member_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_MemberStats >*
      mutable_member_stats();
  private:
  const ::CMsgDOTATeamInfo_MemberStats& _internal_member_stats(int index) const;
  ::CMsgDOTATeamInfo_MemberStats* _internal_add_member_stats();
  public:
  const ::CMsgDOTATeamInfo_MemberStats& member_stats(int index) const;
  ::CMsgDOTATeamInfo_MemberStats* add_member_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_MemberStats >&
      member_stats() const;

  // repeated .CMsgDOTATeamInfo.DPCResult dpc_results = 35;
  int dpc_results_size() const;
  private:
  int _internal_dpc_results_size() const;
  public:
  void clear_dpc_results();
  ::CMsgDOTATeamInfo_DPCResult* mutable_dpc_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_DPCResult >*
      mutable_dpc_results();
  private:
  const ::CMsgDOTATeamInfo_DPCResult& _internal_dpc_results(int index) const;
  ::CMsgDOTATeamInfo_DPCResult* _internal_add_dpc_results();
  public:
  const ::CMsgDOTATeamInfo_DPCResult& dpc_results(int index) const;
  ::CMsgDOTATeamInfo_DPCResult* add_dpc_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_DPCResult >&
      dpc_results() const;

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string tag = 4;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional string country_code = 13;
  bool has_country_code() const;
  private:
  bool _internal_has_country_code() const;
  public:
  void clear_country_code();
  const std::string& country_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* country_code);
  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(const std::string& value);
  std::string* _internal_mutable_country_code();
  public:

  // optional string url = 14;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string url_logo = 24;
  bool has_url_logo() const;
  private:
  bool _internal_has_url_logo() const;
  public:
  void clear_url_logo();
  const std::string& url_logo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url_logo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url_logo();
  PROTOBUF_NODISCARD std::string* release_url_logo();
  void set_allocated_url_logo(std::string* url_logo);
  private:
  const std::string& _internal_url_logo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url_logo(const std::string& value);
  std::string* _internal_mutable_url_logo();
  public:

  // optional string abbreviation = 32;
  bool has_abbreviation() const;
  private:
  bool _internal_has_abbreviation() const;
  public:
  void clear_abbreviation();
  const std::string& abbreviation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_abbreviation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_abbreviation();
  PROTOBUF_NODISCARD std::string* release_abbreviation();
  void set_allocated_abbreviation(std::string* abbreviation);
  private:
  const std::string& _internal_abbreviation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_abbreviation(const std::string& value);
  std::string* _internal_mutable_abbreviation();
  public:

  // optional string color_primary = 37;
  bool has_color_primary() const;
  private:
  bool _internal_has_color_primary() const;
  public:
  void clear_color_primary();
  const std::string& color_primary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color_primary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color_primary();
  PROTOBUF_NODISCARD std::string* release_color_primary();
  void set_allocated_color_primary(std::string* color_primary);
  private:
  const std::string& _internal_color_primary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color_primary(const std::string& value);
  std::string* _internal_mutable_color_primary();
  public:

  // optional string color_secondary = 38;
  bool has_color_secondary() const;
  private:
  bool _internal_has_color_secondary() const;
  public:
  void clear_color_secondary();
  const std::string& color_secondary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color_secondary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color_secondary();
  PROTOBUF_NODISCARD std::string* release_color_secondary();
  void set_allocated_color_secondary(std::string* color_secondary);
  private:
  const std::string& _internal_color_secondary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color_secondary(const std::string& value);
  std::string* _internal_mutable_color_secondary();
  public:

  // optional .CMsgDOTATeamInfo.TeamStats team_stats = 34;
  bool has_team_stats() const;
  private:
  bool _internal_has_team_stats() const;
  public:
  void clear_team_stats();
  const ::CMsgDOTATeamInfo_TeamStats& team_stats() const;
  PROTOBUF_NODISCARD ::CMsgDOTATeamInfo_TeamStats* release_team_stats();
  ::CMsgDOTATeamInfo_TeamStats* mutable_team_stats();
  void set_allocated_team_stats(::CMsgDOTATeamInfo_TeamStats* team_stats);
  private:
  const ::CMsgDOTATeamInfo_TeamStats& _internal_team_stats() const;
  ::CMsgDOTATeamInfo_TeamStats* _internal_mutable_team_stats();
  public:
  void unsafe_arena_set_allocated_team_stats(
      ::CMsgDOTATeamInfo_TeamStats* team_stats);
  ::CMsgDOTATeamInfo_TeamStats* unsafe_arena_release_team_stats();

  // optional uint32 team_id = 2;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  uint32_t team_id() const;
  void set_team_id(uint32_t value);
  private:
  uint32_t _internal_team_id() const;
  void _internal_set_team_id(uint32_t value);
  public:

  // optional uint32 time_created = 5;
  bool has_time_created() const;
  private:
  bool _internal_has_time_created() const;
  public:
  void clear_time_created();
  uint32_t time_created() const;
  void set_time_created(uint32_t value);
  private:
  uint32_t _internal_time_created() const;
  void _internal_set_time_created(uint32_t value);
  public:

  // optional uint64 ugc_logo = 9;
  bool has_ugc_logo() const;
  private:
  bool _internal_has_ugc_logo() const;
  public:
  void clear_ugc_logo();
  uint64_t ugc_logo() const;
  void set_ugc_logo(uint64_t value);
  private:
  uint64_t _internal_ugc_logo() const;
  void _internal_set_ugc_logo(uint64_t value);
  public:

  // optional bool pro = 6;
  bool has_pro() const;
  private:
  bool _internal_has_pro() const;
  public:
  void clear_pro();
  bool pro() const;
  void set_pro(bool value);
  private:
  bool _internal_pro() const;
  void _internal_set_pro(bool value);
  public:

  // optional bool pickup_team = 8;
  bool has_pickup_team() const;
  private:
  bool _internal_has_pickup_team() const;
  public:
  void clear_pickup_team();
  bool pickup_team() const;
  void set_pickup_team(bool value);
  private:
  bool _internal_pickup_team() const;
  void _internal_set_pickup_team(bool value);
  public:

  // optional uint32 wins = 15;
  bool has_wins() const;
  private:
  bool _internal_has_wins() const;
  public:
  void clear_wins();
  uint32_t wins() const;
  void set_wins(uint32_t value);
  private:
  uint32_t _internal_wins() const;
  void _internal_set_wins(uint32_t value);
  public:

  // optional uint64 ugc_base_logo = 10;
  bool has_ugc_base_logo() const;
  private:
  bool _internal_has_ugc_base_logo() const;
  public:
  void clear_ugc_base_logo();
  uint64_t ugc_base_logo() const;
  void set_ugc_base_logo(uint64_t value);
  private:
  uint64_t _internal_ugc_base_logo() const;
  void _internal_set_ugc_base_logo(uint64_t value);
  public:

  // optional uint64 ugc_banner_logo = 11;
  bool has_ugc_banner_logo() const;
  private:
  bool _internal_has_ugc_banner_logo() const;
  public:
  void clear_ugc_banner_logo();
  uint64_t ugc_banner_logo() const;
  void set_ugc_banner_logo(uint64_t value);
  private:
  uint64_t _internal_ugc_banner_logo() const;
  void _internal_set_ugc_banner_logo(uint64_t value);
  public:

  // optional uint64 ugc_sponsor_logo = 12;
  bool has_ugc_sponsor_logo() const;
  private:
  bool _internal_has_ugc_sponsor_logo() const;
  public:
  void clear_ugc_sponsor_logo();
  uint64_t ugc_sponsor_logo() const;
  void set_ugc_sponsor_logo(uint64_t value);
  private:
  uint64_t _internal_ugc_sponsor_logo() const;
  void _internal_set_ugc_sponsor_logo(uint64_t value);
  public:

  // optional uint32 losses = 16;
  bool has_losses() const;
  private:
  bool _internal_has_losses() const;
  public:
  void clear_losses();
  uint32_t losses() const;
  void set_losses(uint32_t value);
  private:
  uint32_t _internal_losses() const;
  void _internal_set_losses(uint32_t value);
  public:

  // optional uint32 games_played_total = 19;
  bool has_games_played_total() const;
  private:
  bool _internal_has_games_played_total() const;
  public:
  void clear_games_played_total();
  uint32_t games_played_total() const;
  void set_games_played_total(uint32_t value);
  private:
  uint32_t _internal_games_played_total() const;
  void _internal_set_games_played_total(uint32_t value);
  public:

  // optional uint32 games_played_matchmaking = 20;
  bool has_games_played_matchmaking() const;
  private:
  bool _internal_has_games_played_matchmaking() const;
  public:
  void clear_games_played_matchmaking();
  uint32_t games_played_matchmaking() const;
  void set_games_played_matchmaking(uint32_t value);
  private:
  uint32_t _internal_games_played_matchmaking() const;
  void _internal_set_games_played_matchmaking(uint32_t value);
  public:

  // optional .ELeagueRegion region = 29 [default = LEAGUE_REGION_UNSET];
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  ::ELeagueRegion region() const;
  void set_region(::ELeagueRegion value);
  private:
  ::ELeagueRegion _internal_region() const;
  void _internal_set_region(::ELeagueRegion value);
  public:

  // optional uint32 coach_account_id = 36;
  bool has_coach_account_id() const;
  private:
  bool _internal_has_coach_account_id() const;
  public:
  void clear_coach_account_id();
  uint32_t coach_account_id() const;
  void set_coach_account_id(uint32_t value);
  private:
  uint32_t _internal_coach_account_id() const;
  void _internal_set_coach_account_id(uint32_t value);
  public:

  // optional uint32 team_captain = 39;
  bool has_team_captain() const;
  private:
  bool _internal_has_team_captain() const;
  public:
  void clear_team_captain();
  uint32_t team_captain() const;
  void set_team_captain(uint32_t value);
  private:
  uint32_t _internal_team_captain() const;
  void _internal_set_team_captain(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_Member > members_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > registered_member_account_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_AuditEntry > audit_entries_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_MemberStats > member_stats_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_DPCResult > dpc_results_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_logo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr abbreviation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_primary_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_secondary_;
    ::CMsgDOTATeamInfo_TeamStats* team_stats_;
    uint32_t team_id_;
    uint32_t time_created_;
    uint64_t ugc_logo_;
    bool pro_;
    bool pickup_team_;
    uint32_t wins_;
    uint64_t ugc_base_logo_;
    uint64_t ugc_banner_logo_;
    uint64_t ugc_sponsor_logo_;
    uint32_t losses_;
    uint32_t games_played_total_;
    uint32_t games_played_matchmaking_;
    int region_;
    uint32_t coach_account_id_;
    uint32_t team_captain_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamsInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamsInfo) */ {
 public:
  inline CMsgDOTATeamsInfo() : CMsgDOTATeamsInfo(nullptr) {}
  ~CMsgDOTATeamsInfo() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamsInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamsInfo(const CMsgDOTATeamsInfo& from);
  CMsgDOTATeamsInfo(CMsgDOTATeamsInfo&& from) noexcept
    : CMsgDOTATeamsInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamsInfo& operator=(const CMsgDOTATeamsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamsInfo& operator=(CMsgDOTATeamsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamsInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamsInfo*>(
               &_CMsgDOTATeamsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CMsgDOTATeamsInfo& a, CMsgDOTATeamsInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamsInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamsInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamsInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamsInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamsInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamsInfo& from) {
    CMsgDOTATeamsInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamsInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamsInfo";
  }
  protected:
  explicit CMsgDOTATeamsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamsFieldNumber = 2,
    kLeagueIdFieldNumber = 1,
  };
  // repeated .CMsgDOTATeamInfo teams = 2;
  int teams_size() const;
  private:
  int _internal_teams_size() const;
  public:
  void clear_teams();
  ::CMsgDOTATeamInfo* mutable_teams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo >*
      mutable_teams();
  private:
  const ::CMsgDOTATeamInfo& _internal_teams(int index) const;
  ::CMsgDOTATeamInfo* _internal_add_teams();
  public:
  const ::CMsgDOTATeamInfo& teams(int index) const;
  ::CMsgDOTATeamInfo* add_teams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo >&
      teams() const;

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  private:
  bool _internal_has_league_id() const;
  public:
  void clear_league_id();
  uint32_t league_id() const;
  void set_league_id(uint32_t value);
  private:
  uint32_t _internal_league_id() const;
  void _internal_set_league_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamsInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo > teams_;
    uint32_t league_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInfoList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInfoList) */ {
 public:
  inline CMsgDOTATeamInfoList() : CMsgDOTATeamInfoList(nullptr) {}
  ~CMsgDOTATeamInfoList() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInfoList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInfoList(const CMsgDOTATeamInfoList& from);
  CMsgDOTATeamInfoList(CMsgDOTATeamInfoList&& from) noexcept
    : CMsgDOTATeamInfoList() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInfoList& operator=(const CMsgDOTATeamInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInfoList& operator=(CMsgDOTATeamInfoList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInfoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInfoList* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInfoList*>(
               &_CMsgDOTATeamInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CMsgDOTATeamInfoList& a, CMsgDOTATeamInfoList& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInfoList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInfoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInfoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInfoList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInfoList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInfoList& from) {
    CMsgDOTATeamInfoList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInfoList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInfoList";
  }
  protected:
  explicit CMsgDOTATeamInfoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamsFieldNumber = 1,
  };
  // repeated .CMsgDOTATeamInfo teams = 1;
  int teams_size() const;
  private:
  int _internal_teams_size() const;
  public:
  void clear_teams();
  ::CMsgDOTATeamInfo* mutable_teams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo >*
      mutable_teams();
  private:
  const ::CMsgDOTATeamInfo& _internal_teams(int index) const;
  ::CMsgDOTATeamInfo* _internal_add_teams();
  public:
  const ::CMsgDOTATeamInfo& teams(int index) const;
  ::CMsgDOTATeamInfo* add_teams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo >&
      teams() const;

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInfoList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo > teams_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAMyTeamInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CMsgDOTAMyTeamInfoRequest) */ {
 public:
  inline CMsgDOTAMyTeamInfoRequest() : CMsgDOTAMyTeamInfoRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CMsgDOTAMyTeamInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTAMyTeamInfoRequest(const CMsgDOTAMyTeamInfoRequest& from);
  CMsgDOTAMyTeamInfoRequest(CMsgDOTAMyTeamInfoRequest&& from) noexcept
    : CMsgDOTAMyTeamInfoRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAMyTeamInfoRequest& operator=(const CMsgDOTAMyTeamInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTAMyTeamInfoRequest& operator=(CMsgDOTAMyTeamInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTAMyTeamInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTAMyTeamInfoRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAMyTeamInfoRequest*>(
               &_CMsgDOTAMyTeamInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CMsgDOTAMyTeamInfoRequest& a, CMsgDOTAMyTeamInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTAMyTeamInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTAMyTeamInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTAMyTeamInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTAMyTeamInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CMsgDOTAMyTeamInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CMsgDOTAMyTeamInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTAMyTeamInfoRequest";
  }
  protected:
  explicit CMsgDOTAMyTeamInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CMsgDOTAMyTeamInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTACreateTeam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTACreateTeam) */ {
 public:
  inline CMsgDOTACreateTeam() : CMsgDOTACreateTeam(nullptr) {}
  ~CMsgDOTACreateTeam() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTACreateTeam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTACreateTeam(const CMsgDOTACreateTeam& from);
  CMsgDOTACreateTeam(CMsgDOTACreateTeam&& from) noexcept
    : CMsgDOTACreateTeam() {
    *this = ::std::move(from);
  }

  inline CMsgDOTACreateTeam& operator=(const CMsgDOTACreateTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTACreateTeam& operator=(CMsgDOTACreateTeam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTACreateTeam& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTACreateTeam* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTACreateTeam*>(
               &_CMsgDOTACreateTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CMsgDOTACreateTeam& a, CMsgDOTACreateTeam& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTACreateTeam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTACreateTeam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTACreateTeam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTACreateTeam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTACreateTeam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTACreateTeam& from) {
    CMsgDOTACreateTeam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTACreateTeam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTACreateTeam";
  }
  protected:
  explicit CMsgDOTACreateTeam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTagFieldNumber = 2,
    kCountryCodeFieldNumber = 7,
    kUrlFieldNumber = 8,
    kAbbreviationFieldNumber = 10,
    kLogoFieldNumber = 3,
    kBaseLogoFieldNumber = 4,
    kBannerLogoFieldNumber = 5,
    kSponsorLogoFieldNumber = 6,
    kPickupTeamFieldNumber = 9,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string tag = 2;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional string country_code = 7;
  bool has_country_code() const;
  private:
  bool _internal_has_country_code() const;
  public:
  void clear_country_code();
  const std::string& country_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* country_code);
  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(const std::string& value);
  std::string* _internal_mutable_country_code();
  public:

  // optional string url = 8;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string abbreviation = 10;
  bool has_abbreviation() const;
  private:
  bool _internal_has_abbreviation() const;
  public:
  void clear_abbreviation();
  const std::string& abbreviation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_abbreviation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_abbreviation();
  PROTOBUF_NODISCARD std::string* release_abbreviation();
  void set_allocated_abbreviation(std::string* abbreviation);
  private:
  const std::string& _internal_abbreviation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_abbreviation(const std::string& value);
  std::string* _internal_mutable_abbreviation();
  public:

  // optional uint64 logo = 3;
  bool has_logo() const;
  private:
  bool _internal_has_logo() const;
  public:
  void clear_logo();
  uint64_t logo() const;
  void set_logo(uint64_t value);
  private:
  uint64_t _internal_logo() const;
  void _internal_set_logo(uint64_t value);
  public:

  // optional uint64 base_logo = 4;
  bool has_base_logo() const;
  private:
  bool _internal_has_base_logo() const;
  public:
  void clear_base_logo();
  uint64_t base_logo() const;
  void set_base_logo(uint64_t value);
  private:
  uint64_t _internal_base_logo() const;
  void _internal_set_base_logo(uint64_t value);
  public:

  // optional uint64 banner_logo = 5;
  bool has_banner_logo() const;
  private:
  bool _internal_has_banner_logo() const;
  public:
  void clear_banner_logo();
  uint64_t banner_logo() const;
  void set_banner_logo(uint64_t value);
  private:
  uint64_t _internal_banner_logo() const;
  void _internal_set_banner_logo(uint64_t value);
  public:

  // optional uint64 sponsor_logo = 6;
  bool has_sponsor_logo() const;
  private:
  bool _internal_has_sponsor_logo() const;
  public:
  void clear_sponsor_logo();
  uint64_t sponsor_logo() const;
  void set_sponsor_logo(uint64_t value);
  private:
  uint64_t _internal_sponsor_logo() const;
  void _internal_set_sponsor_logo(uint64_t value);
  public:

  // optional bool pickup_team = 9;
  bool has_pickup_team() const;
  private:
  bool _internal_has_pickup_team() const;
  public:
  void clear_pickup_team();
  bool pickup_team() const;
  void set_pickup_team(bool value);
  private:
  bool _internal_pickup_team() const;
  void _internal_set_pickup_team(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTACreateTeam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr abbreviation_;
    uint64_t logo_;
    uint64_t base_logo_;
    uint64_t banner_logo_;
    uint64_t sponsor_logo_;
    bool pickup_team_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTACreateTeamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTACreateTeamResponse) */ {
 public:
  inline CMsgDOTACreateTeamResponse() : CMsgDOTACreateTeamResponse(nullptr) {}
  ~CMsgDOTACreateTeamResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTACreateTeamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTACreateTeamResponse(const CMsgDOTACreateTeamResponse& from);
  CMsgDOTACreateTeamResponse(CMsgDOTACreateTeamResponse&& from) noexcept
    : CMsgDOTACreateTeamResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTACreateTeamResponse& operator=(const CMsgDOTACreateTeamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTACreateTeamResponse& operator=(CMsgDOTACreateTeamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTACreateTeamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTACreateTeamResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTACreateTeamResponse*>(
               &_CMsgDOTACreateTeamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CMsgDOTACreateTeamResponse& a, CMsgDOTACreateTeamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTACreateTeamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTACreateTeamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTACreateTeamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTACreateTeamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTACreateTeamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTACreateTeamResponse& from) {
    CMsgDOTACreateTeamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTACreateTeamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTACreateTeamResponse";
  }
  protected:
  explicit CMsgDOTACreateTeamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTACreateTeamResponse_Result Result;
  static constexpr Result INVALID =
    CMsgDOTACreateTeamResponse_Result_INVALID;
  static constexpr Result SUCCESS =
    CMsgDOTACreateTeamResponse_Result_SUCCESS;
  static constexpr Result NAME_EMPTY =
    CMsgDOTACreateTeamResponse_Result_NAME_EMPTY;
  static constexpr Result NAME_BAD_CHARACTERS =
    CMsgDOTACreateTeamResponse_Result_NAME_BAD_CHARACTERS;
  static constexpr Result NAME_TAKEN =
    CMsgDOTACreateTeamResponse_Result_NAME_TAKEN;
  static constexpr Result NAME_TOO_LONG =
    CMsgDOTACreateTeamResponse_Result_NAME_TOO_LONG;
  static constexpr Result TAG_EMPTY =
    CMsgDOTACreateTeamResponse_Result_TAG_EMPTY;
  static constexpr Result TAG_BAD_CHARACTERS =
    CMsgDOTACreateTeamResponse_Result_TAG_BAD_CHARACTERS;
  static constexpr Result TAG_TAKEN =
    CMsgDOTACreateTeamResponse_Result_TAG_TAKEN;
  static constexpr Result TAG_TOO_LONG =
    CMsgDOTACreateTeamResponse_Result_TAG_TOO_LONG;
  static constexpr Result CREATOR_BUSY =
    CMsgDOTACreateTeamResponse_Result_CREATOR_BUSY;
  static constexpr Result UNSPECIFIED_ERROR =
    CMsgDOTACreateTeamResponse_Result_UNSPECIFIED_ERROR;
  static constexpr Result CREATOR_TEAM_LIMIT_REACHED =
    CMsgDOTACreateTeamResponse_Result_CREATOR_TEAM_LIMIT_REACHED;
  static constexpr Result NO_LOGO =
    CMsgDOTACreateTeamResponse_Result_NO_LOGO;
  static constexpr Result CREATOR_TEAM_CREATION_COOLDOWN =
    CMsgDOTACreateTeamResponse_Result_CREATOR_TEAM_CREATION_COOLDOWN;
  static constexpr Result LOGO_UPLOAD_FAILED =
    CMsgDOTACreateTeamResponse_Result_LOGO_UPLOAD_FAILED;
  static constexpr Result NAME_CHANGED_TOO_RECENTLY =
    CMsgDOTACreateTeamResponse_Result_NAME_CHANGED_TOO_RECENTLY;
  static constexpr Result CREATOR_INSUFFICIENT_LEVEL =
    CMsgDOTACreateTeamResponse_Result_CREATOR_INSUFFICIENT_LEVEL;
  static constexpr Result INVALID_ACCOUNT_TYPE =
    CMsgDOTACreateTeamResponse_Result_INVALID_ACCOUNT_TYPE;
  static inline bool Result_IsValid(int value) {
    return CMsgDOTACreateTeamResponse_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    CMsgDOTACreateTeamResponse_Result_Result_MIN;
  static constexpr Result Result_MAX =
    CMsgDOTACreateTeamResponse_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    CMsgDOTACreateTeamResponse_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return CMsgDOTACreateTeamResponse_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return CMsgDOTACreateTeamResponse_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return CMsgDOTACreateTeamResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTeamIdFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // optional uint32 team_id = 2;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  uint32_t team_id() const;
  void set_team_id(uint32_t value);
  private:
  uint32_t _internal_team_id() const;
  void _internal_set_team_id(uint32_t value);
  public:

  // optional .CMsgDOTACreateTeamResponse.Result result = 1 [default = INVALID];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::CMsgDOTACreateTeamResponse_Result result() const;
  void set_result(::CMsgDOTACreateTeamResponse_Result value);
  private:
  ::CMsgDOTACreateTeamResponse_Result _internal_result() const;
  void _internal_set_result(::CMsgDOTACreateTeamResponse_Result value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTACreateTeamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t team_id_;
    int result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAEditTeamDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTAEditTeamDetails) */ {
 public:
  inline CMsgDOTAEditTeamDetails() : CMsgDOTAEditTeamDetails(nullptr) {}
  ~CMsgDOTAEditTeamDetails() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTAEditTeamDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTAEditTeamDetails(const CMsgDOTAEditTeamDetails& from);
  CMsgDOTAEditTeamDetails(CMsgDOTAEditTeamDetails&& from) noexcept
    : CMsgDOTAEditTeamDetails() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAEditTeamDetails& operator=(const CMsgDOTAEditTeamDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTAEditTeamDetails& operator=(CMsgDOTAEditTeamDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTAEditTeamDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTAEditTeamDetails* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAEditTeamDetails*>(
               &_CMsgDOTAEditTeamDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CMsgDOTAEditTeamDetails& a, CMsgDOTAEditTeamDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTAEditTeamDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTAEditTeamDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTAEditTeamDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTAEditTeamDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTAEditTeamDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTAEditTeamDetails& from) {
    CMsgDOTAEditTeamDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAEditTeamDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTAEditTeamDetails";
  }
  protected:
  explicit CMsgDOTAEditTeamDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTagFieldNumber = 3,
    kCountryCodeFieldNumber = 8,
    kUrlFieldNumber = 9,
    kAbbreviationFieldNumber = 11,
    kLogoFieldNumber = 4,
    kBaseLogoFieldNumber = 5,
    kTeamIdFieldNumber = 1,
    kInUseByPartyFieldNumber = 10,
    kBannerLogoFieldNumber = 6,
    kSponsorLogoFieldNumber = 7,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string tag = 3;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional string country_code = 8;
  bool has_country_code() const;
  private:
  bool _internal_has_country_code() const;
  public:
  void clear_country_code();
  const std::string& country_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* country_code);
  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(const std::string& value);
  std::string* _internal_mutable_country_code();
  public:

  // optional string url = 9;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string abbreviation = 11;
  bool has_abbreviation() const;
  private:
  bool _internal_has_abbreviation() const;
  public:
  void clear_abbreviation();
  const std::string& abbreviation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_abbreviation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_abbreviation();
  PROTOBUF_NODISCARD std::string* release_abbreviation();
  void set_allocated_abbreviation(std::string* abbreviation);
  private:
  const std::string& _internal_abbreviation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_abbreviation(const std::string& value);
  std::string* _internal_mutable_abbreviation();
  public:

  // optional uint64 logo = 4;
  bool has_logo() const;
  private:
  bool _internal_has_logo() const;
  public:
  void clear_logo();
  uint64_t logo() const;
  void set_logo(uint64_t value);
  private:
  uint64_t _internal_logo() const;
  void _internal_set_logo(uint64_t value);
  public:

  // optional uint64 base_logo = 5;
  bool has_base_logo() const;
  private:
  bool _internal_has_base_logo() const;
  public:
  void clear_base_logo();
  uint64_t base_logo() const;
  void set_base_logo(uint64_t value);
  private:
  uint64_t _internal_base_logo() const;
  void _internal_set_base_logo(uint64_t value);
  public:

  // optional uint32 team_id = 1;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  uint32_t team_id() const;
  void set_team_id(uint32_t value);
  private:
  uint32_t _internal_team_id() const;
  void _internal_set_team_id(uint32_t value);
  public:

  // optional bool in_use_by_party = 10;
  bool has_in_use_by_party() const;
  private:
  bool _internal_has_in_use_by_party() const;
  public:
  void clear_in_use_by_party();
  bool in_use_by_party() const;
  void set_in_use_by_party(bool value);
  private:
  bool _internal_in_use_by_party() const;
  void _internal_set_in_use_by_party(bool value);
  public:

  // optional uint64 banner_logo = 6;
  bool has_banner_logo() const;
  private:
  bool _internal_has_banner_logo() const;
  public:
  void clear_banner_logo();
  uint64_t banner_logo() const;
  void set_banner_logo(uint64_t value);
  private:
  uint64_t _internal_banner_logo() const;
  void _internal_set_banner_logo(uint64_t value);
  public:

  // optional uint64 sponsor_logo = 7;
  bool has_sponsor_logo() const;
  private:
  bool _internal_has_sponsor_logo() const;
  public:
  void clear_sponsor_logo();
  uint64_t sponsor_logo() const;
  void set_sponsor_logo(uint64_t value);
  private:
  uint64_t _internal_sponsor_logo() const;
  void _internal_set_sponsor_logo(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTAEditTeamDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr abbreviation_;
    uint64_t logo_;
    uint64_t base_logo_;
    uint32_t team_id_;
    bool in_use_by_party_;
    uint64_t banner_logo_;
    uint64_t sponsor_logo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAEditTeamDetailsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTAEditTeamDetailsResponse) */ {
 public:
  inline CMsgDOTAEditTeamDetailsResponse() : CMsgDOTAEditTeamDetailsResponse(nullptr) {}
  ~CMsgDOTAEditTeamDetailsResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTAEditTeamDetailsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTAEditTeamDetailsResponse(const CMsgDOTAEditTeamDetailsResponse& from);
  CMsgDOTAEditTeamDetailsResponse(CMsgDOTAEditTeamDetailsResponse&& from) noexcept
    : CMsgDOTAEditTeamDetailsResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAEditTeamDetailsResponse& operator=(const CMsgDOTAEditTeamDetailsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTAEditTeamDetailsResponse& operator=(CMsgDOTAEditTeamDetailsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTAEditTeamDetailsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTAEditTeamDetailsResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAEditTeamDetailsResponse*>(
               &_CMsgDOTAEditTeamDetailsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CMsgDOTAEditTeamDetailsResponse& a, CMsgDOTAEditTeamDetailsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTAEditTeamDetailsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTAEditTeamDetailsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTAEditTeamDetailsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTAEditTeamDetailsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTAEditTeamDetailsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTAEditTeamDetailsResponse& from) {
    CMsgDOTAEditTeamDetailsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAEditTeamDetailsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTAEditTeamDetailsResponse";
  }
  protected:
  explicit CMsgDOTAEditTeamDetailsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAEditTeamDetailsResponse_Result Result;
  static constexpr Result SUCCESS =
    CMsgDOTAEditTeamDetailsResponse_Result_SUCCESS;
  static constexpr Result FAILURE_INVALID_ACCOUNT_TYPE =
    CMsgDOTAEditTeamDetailsResponse_Result_FAILURE_INVALID_ACCOUNT_TYPE;
  static constexpr Result FAILURE_NOT_MEMBER =
    CMsgDOTAEditTeamDetailsResponse_Result_FAILURE_NOT_MEMBER;
  static constexpr Result FAILURE_TEAM_LOCKED =
    CMsgDOTAEditTeamDetailsResponse_Result_FAILURE_TEAM_LOCKED;
  static constexpr Result FAILURE_UNSPECIFIED_ERROR =
    CMsgDOTAEditTeamDetailsResponse_Result_FAILURE_UNSPECIFIED_ERROR;
  static inline bool Result_IsValid(int value) {
    return CMsgDOTAEditTeamDetailsResponse_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    CMsgDOTAEditTeamDetailsResponse_Result_Result_MIN;
  static constexpr Result Result_MAX =
    CMsgDOTAEditTeamDetailsResponse_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    CMsgDOTAEditTeamDetailsResponse_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return CMsgDOTAEditTeamDetailsResponse_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return CMsgDOTAEditTeamDetailsResponse_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return CMsgDOTAEditTeamDetailsResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .CMsgDOTAEditTeamDetailsResponse.Result result = 1 [default = SUCCESS];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::CMsgDOTAEditTeamDetailsResponse_Result result() const;
  void set_result(::CMsgDOTAEditTeamDetailsResponse_Result value);
  private:
  ::CMsgDOTAEditTeamDetailsResponse_Result _internal_result() const;
  void _internal_set_result(::CMsgDOTAEditTeamDetailsResponse_Result value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTAEditTeamDetailsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInvite_InviterToGC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInvite_InviterToGC) */ {
 public:
  inline CMsgDOTATeamInvite_InviterToGC() : CMsgDOTATeamInvite_InviterToGC(nullptr) {}
  ~CMsgDOTATeamInvite_InviterToGC() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInvite_InviterToGC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInvite_InviterToGC(const CMsgDOTATeamInvite_InviterToGC& from);
  CMsgDOTATeamInvite_InviterToGC(CMsgDOTATeamInvite_InviterToGC&& from) noexcept
    : CMsgDOTATeamInvite_InviterToGC() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInvite_InviterToGC& operator=(const CMsgDOTATeamInvite_InviterToGC& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInvite_InviterToGC& operator=(CMsgDOTATeamInvite_InviterToGC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInvite_InviterToGC& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInvite_InviterToGC* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInvite_InviterToGC*>(
               &_CMsgDOTATeamInvite_InviterToGC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CMsgDOTATeamInvite_InviterToGC& a, CMsgDOTATeamInvite_InviterToGC& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInvite_InviterToGC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInvite_InviterToGC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInvite_InviterToGC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInvite_InviterToGC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInvite_InviterToGC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInvite_InviterToGC& from) {
    CMsgDOTATeamInvite_InviterToGC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInvite_InviterToGC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInvite_InviterToGC";
  }
  protected:
  explicit CMsgDOTATeamInvite_InviterToGC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kTeamIdFieldNumber = 2,
  };
  // optional uint32 account_id = 1;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  uint32_t account_id() const;
  void set_account_id(uint32_t value);
  private:
  uint32_t _internal_account_id() const;
  void _internal_set_account_id(uint32_t value);
  public:

  // optional uint32 team_id = 2;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  uint32_t team_id() const;
  void set_team_id(uint32_t value);
  private:
  uint32_t _internal_team_id() const;
  void _internal_set_team_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInvite_InviterToGC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t account_id_;
    uint32_t team_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInvite_GCImmediateResponseToInviter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInvite_GCImmediateResponseToInviter) */ {
 public:
  inline CMsgDOTATeamInvite_GCImmediateResponseToInviter() : CMsgDOTATeamInvite_GCImmediateResponseToInviter(nullptr) {}
  ~CMsgDOTATeamInvite_GCImmediateResponseToInviter() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInvite_GCImmediateResponseToInviter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInvite_GCImmediateResponseToInviter(const CMsgDOTATeamInvite_GCImmediateResponseToInviter& from);
  CMsgDOTATeamInvite_GCImmediateResponseToInviter(CMsgDOTATeamInvite_GCImmediateResponseToInviter&& from) noexcept
    : CMsgDOTATeamInvite_GCImmediateResponseToInviter() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInvite_GCImmediateResponseToInviter& operator=(const CMsgDOTATeamInvite_GCImmediateResponseToInviter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInvite_GCImmediateResponseToInviter& operator=(CMsgDOTATeamInvite_GCImmediateResponseToInviter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInvite_GCImmediateResponseToInviter& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInvite_GCImmediateResponseToInviter* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInvite_GCImmediateResponseToInviter*>(
               &_CMsgDOTATeamInvite_GCImmediateResponseToInviter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CMsgDOTATeamInvite_GCImmediateResponseToInviter& a, CMsgDOTATeamInvite_GCImmediateResponseToInviter& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInvite_GCImmediateResponseToInviter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInvite_GCImmediateResponseToInviter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInvite_GCImmediateResponseToInviter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInvite_GCImmediateResponseToInviter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInvite_GCImmediateResponseToInviter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInvite_GCImmediateResponseToInviter& from) {
    CMsgDOTATeamInvite_GCImmediateResponseToInviter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInvite_GCImmediateResponseToInviter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInvite_GCImmediateResponseToInviter";
  }
  protected:
  explicit CMsgDOTATeamInvite_GCImmediateResponseToInviter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInviteeNameFieldNumber = 2,
    kResultFieldNumber = 1,
    kRequiredPlayTimeFieldNumber = 3,
  };
  // optional string invitee_name = 2;
  bool has_invitee_name() const;
  private:
  bool _internal_has_invitee_name() const;
  public:
  void clear_invitee_name();
  const std::string& invitee_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invitee_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invitee_name();
  PROTOBUF_NODISCARD std::string* release_invitee_name();
  void set_allocated_invitee_name(std::string* invitee_name);
  private:
  const std::string& _internal_invitee_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invitee_name(const std::string& value);
  std::string* _internal_mutable_invitee_name();
  public:

  // optional .ETeamInviteResult result = 1 [default = TEAM_INVITE_SUCCESS];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::ETeamInviteResult result() const;
  void set_result(::ETeamInviteResult value);
  private:
  ::ETeamInviteResult _internal_result() const;
  void _internal_set_result(::ETeamInviteResult value);
  public:

  // optional uint32 required_play_time = 3;
  bool has_required_play_time() const;
  private:
  bool _internal_has_required_play_time() const;
  public:
  void clear_required_play_time();
  uint32_t required_play_time() const;
  void set_required_play_time(uint32_t value);
  private:
  uint32_t _internal_required_play_time() const;
  void _internal_set_required_play_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInvite_GCImmediateResponseToInviter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invitee_name_;
    int result_;
    uint32_t required_play_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInvite_GCRequestToInvitee final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInvite_GCRequestToInvitee) */ {
 public:
  inline CMsgDOTATeamInvite_GCRequestToInvitee() : CMsgDOTATeamInvite_GCRequestToInvitee(nullptr) {}
  ~CMsgDOTATeamInvite_GCRequestToInvitee() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInvite_GCRequestToInvitee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInvite_GCRequestToInvitee(const CMsgDOTATeamInvite_GCRequestToInvitee& from);
  CMsgDOTATeamInvite_GCRequestToInvitee(CMsgDOTATeamInvite_GCRequestToInvitee&& from) noexcept
    : CMsgDOTATeamInvite_GCRequestToInvitee() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInvite_GCRequestToInvitee& operator=(const CMsgDOTATeamInvite_GCRequestToInvitee& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInvite_GCRequestToInvitee& operator=(CMsgDOTATeamInvite_GCRequestToInvitee&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInvite_GCRequestToInvitee& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInvite_GCRequestToInvitee* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInvite_GCRequestToInvitee*>(
               &_CMsgDOTATeamInvite_GCRequestToInvitee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CMsgDOTATeamInvite_GCRequestToInvitee& a, CMsgDOTATeamInvite_GCRequestToInvitee& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInvite_GCRequestToInvitee* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInvite_GCRequestToInvitee* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInvite_GCRequestToInvitee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInvite_GCRequestToInvitee>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInvite_GCRequestToInvitee& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInvite_GCRequestToInvitee& from) {
    CMsgDOTATeamInvite_GCRequestToInvitee::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInvite_GCRequestToInvitee* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInvite_GCRequestToInvitee";
  }
  protected:
  explicit CMsgDOTATeamInvite_GCRequestToInvitee(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamNameFieldNumber = 2,
    kTeamTagFieldNumber = 3,
    kLogoFieldNumber = 4,
    kInviterAccountIdFieldNumber = 1,
  };
  // optional string team_name = 2;
  bool has_team_name() const;
  private:
  bool _internal_has_team_name() const;
  public:
  void clear_team_name();
  const std::string& team_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_name();
  PROTOBUF_NODISCARD std::string* release_team_name();
  void set_allocated_team_name(std::string* team_name);
  private:
  const std::string& _internal_team_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_name(const std::string& value);
  std::string* _internal_mutable_team_name();
  public:

  // optional string team_tag = 3;
  bool has_team_tag() const;
  private:
  bool _internal_has_team_tag() const;
  public:
  void clear_team_tag();
  const std::string& team_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_tag();
  PROTOBUF_NODISCARD std::string* release_team_tag();
  void set_allocated_team_tag(std::string* team_tag);
  private:
  const std::string& _internal_team_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_tag(const std::string& value);
  std::string* _internal_mutable_team_tag();
  public:

  // optional uint64 logo = 4;
  bool has_logo() const;
  private:
  bool _internal_has_logo() const;
  public:
  void clear_logo();
  uint64_t logo() const;
  void set_logo(uint64_t value);
  private:
  uint64_t _internal_logo() const;
  void _internal_set_logo(uint64_t value);
  public:

  // optional uint32 inviter_account_id = 1;
  bool has_inviter_account_id() const;
  private:
  bool _internal_has_inviter_account_id() const;
  public:
  void clear_inviter_account_id();
  uint32_t inviter_account_id() const;
  void set_inviter_account_id(uint32_t value);
  private:
  uint32_t _internal_inviter_account_id() const;
  void _internal_set_inviter_account_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInvite_GCRequestToInvitee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_tag_;
    uint64_t logo_;
    uint32_t inviter_account_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInvite_InviteeResponseToGC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInvite_InviteeResponseToGC) */ {
 public:
  inline CMsgDOTATeamInvite_InviteeResponseToGC() : CMsgDOTATeamInvite_InviteeResponseToGC(nullptr) {}
  ~CMsgDOTATeamInvite_InviteeResponseToGC() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInvite_InviteeResponseToGC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInvite_InviteeResponseToGC(const CMsgDOTATeamInvite_InviteeResponseToGC& from);
  CMsgDOTATeamInvite_InviteeResponseToGC(CMsgDOTATeamInvite_InviteeResponseToGC&& from) noexcept
    : CMsgDOTATeamInvite_InviteeResponseToGC() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInvite_InviteeResponseToGC& operator=(const CMsgDOTATeamInvite_InviteeResponseToGC& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInvite_InviteeResponseToGC& operator=(CMsgDOTATeamInvite_InviteeResponseToGC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInvite_InviteeResponseToGC& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInvite_InviteeResponseToGC* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInvite_InviteeResponseToGC*>(
               &_CMsgDOTATeamInvite_InviteeResponseToGC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CMsgDOTATeamInvite_InviteeResponseToGC& a, CMsgDOTATeamInvite_InviteeResponseToGC& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInvite_InviteeResponseToGC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInvite_InviteeResponseToGC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInvite_InviteeResponseToGC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInvite_InviteeResponseToGC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInvite_InviteeResponseToGC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInvite_InviteeResponseToGC& from) {
    CMsgDOTATeamInvite_InviteeResponseToGC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInvite_InviteeResponseToGC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInvite_InviteeResponseToGC";
  }
  protected:
  explicit CMsgDOTATeamInvite_InviteeResponseToGC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .ETeamInviteResult result = 1 [default = TEAM_INVITE_SUCCESS];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::ETeamInviteResult result() const;
  void set_result(::ETeamInviteResult value);
  private:
  ::ETeamInviteResult _internal_result() const;
  void _internal_set_result(::ETeamInviteResult value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInvite_InviteeResponseToGC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInvite_GCResponseToInviter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInvite_GCResponseToInviter) */ {
 public:
  inline CMsgDOTATeamInvite_GCResponseToInviter() : CMsgDOTATeamInvite_GCResponseToInviter(nullptr) {}
  ~CMsgDOTATeamInvite_GCResponseToInviter() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInvite_GCResponseToInviter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInvite_GCResponseToInviter(const CMsgDOTATeamInvite_GCResponseToInviter& from);
  CMsgDOTATeamInvite_GCResponseToInviter(CMsgDOTATeamInvite_GCResponseToInviter&& from) noexcept
    : CMsgDOTATeamInvite_GCResponseToInviter() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInvite_GCResponseToInviter& operator=(const CMsgDOTATeamInvite_GCResponseToInviter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInvite_GCResponseToInviter& operator=(CMsgDOTATeamInvite_GCResponseToInviter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInvite_GCResponseToInviter& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInvite_GCResponseToInviter* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInvite_GCResponseToInviter*>(
               &_CMsgDOTATeamInvite_GCResponseToInviter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CMsgDOTATeamInvite_GCResponseToInviter& a, CMsgDOTATeamInvite_GCResponseToInviter& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInvite_GCResponseToInviter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInvite_GCResponseToInviter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInvite_GCResponseToInviter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInvite_GCResponseToInviter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInvite_GCResponseToInviter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInvite_GCResponseToInviter& from) {
    CMsgDOTATeamInvite_GCResponseToInviter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInvite_GCResponseToInviter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInvite_GCResponseToInviter";
  }
  protected:
  explicit CMsgDOTATeamInvite_GCResponseToInviter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInviteeNameFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // optional string invitee_name = 2;
  bool has_invitee_name() const;
  private:
  bool _internal_has_invitee_name() const;
  public:
  void clear_invitee_name();
  const std::string& invitee_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invitee_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invitee_name();
  PROTOBUF_NODISCARD std::string* release_invitee_name();
  void set_allocated_invitee_name(std::string* invitee_name);
  private:
  const std::string& _internal_invitee_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invitee_name(const std::string& value);
  std::string* _internal_mutable_invitee_name();
  public:

  // optional .ETeamInviteResult result = 1 [default = TEAM_INVITE_SUCCESS];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::ETeamInviteResult result() const;
  void set_result(::ETeamInviteResult value);
  private:
  ::ETeamInviteResult _internal_result() const;
  void _internal_set_result(::ETeamInviteResult value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInvite_GCResponseToInviter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invitee_name_;
    int result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATeamInvite_GCResponseToInvitee final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATeamInvite_GCResponseToInvitee) */ {
 public:
  inline CMsgDOTATeamInvite_GCResponseToInvitee() : CMsgDOTATeamInvite_GCResponseToInvitee(nullptr) {}
  ~CMsgDOTATeamInvite_GCResponseToInvitee() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATeamInvite_GCResponseToInvitee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATeamInvite_GCResponseToInvitee(const CMsgDOTATeamInvite_GCResponseToInvitee& from);
  CMsgDOTATeamInvite_GCResponseToInvitee(CMsgDOTATeamInvite_GCResponseToInvitee&& from) noexcept
    : CMsgDOTATeamInvite_GCResponseToInvitee() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATeamInvite_GCResponseToInvitee& operator=(const CMsgDOTATeamInvite_GCResponseToInvitee& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATeamInvite_GCResponseToInvitee& operator=(CMsgDOTATeamInvite_GCResponseToInvitee&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATeamInvite_GCResponseToInvitee& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATeamInvite_GCResponseToInvitee* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATeamInvite_GCResponseToInvitee*>(
               &_CMsgDOTATeamInvite_GCResponseToInvitee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CMsgDOTATeamInvite_GCResponseToInvitee& a, CMsgDOTATeamInvite_GCResponseToInvitee& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATeamInvite_GCResponseToInvitee* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATeamInvite_GCResponseToInvitee* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATeamInvite_GCResponseToInvitee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATeamInvite_GCResponseToInvitee>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATeamInvite_GCResponseToInvitee& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATeamInvite_GCResponseToInvitee& from) {
    CMsgDOTATeamInvite_GCResponseToInvitee::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATeamInvite_GCResponseToInvitee* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATeamInvite_GCResponseToInvitee";
  }
  protected:
  explicit CMsgDOTATeamInvite_GCResponseToInvitee(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamNameFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // optional string team_name = 2;
  bool has_team_name() const;
  private:
  bool _internal_has_team_name() const;
  public:
  void clear_team_name();
  const std::string& team_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_name();
  PROTOBUF_NODISCARD std::string* release_team_name();
  void set_allocated_team_name(std::string* team_name);
  private:
  const std::string& _internal_team_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_name(const std::string& value);
  std::string* _internal_mutable_team_name();
  public:

  // optional .ETeamInviteResult result = 1 [default = TEAM_INVITE_SUCCESS];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::ETeamInviteResult result() const;
  void set_result(::ETeamInviteResult value);
  private:
  ::ETeamInviteResult _internal_result() const;
  void _internal_set_result(::ETeamInviteResult value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATeamInvite_GCResponseToInvitee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_name_;
    int result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAKickTeamMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTAKickTeamMember) */ {
 public:
  inline CMsgDOTAKickTeamMember() : CMsgDOTAKickTeamMember(nullptr) {}
  ~CMsgDOTAKickTeamMember() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTAKickTeamMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTAKickTeamMember(const CMsgDOTAKickTeamMember& from);
  CMsgDOTAKickTeamMember(CMsgDOTAKickTeamMember&& from) noexcept
    : CMsgDOTAKickTeamMember() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAKickTeamMember& operator=(const CMsgDOTAKickTeamMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTAKickTeamMember& operator=(CMsgDOTAKickTeamMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTAKickTeamMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTAKickTeamMember* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAKickTeamMember*>(
               &_CMsgDOTAKickTeamMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CMsgDOTAKickTeamMember& a, CMsgDOTAKickTeamMember& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTAKickTeamMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTAKickTeamMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTAKickTeamMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTAKickTeamMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTAKickTeamMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTAKickTeamMember& from) {
    CMsgDOTAKickTeamMember::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAKickTeamMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTAKickTeamMember";
  }
  protected:
  explicit CMsgDOTAKickTeamMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kTeamIdFieldNumber = 2,
  };
  // optional uint32 account_id = 1;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  uint32_t account_id() const;
  void set_account_id(uint32_t value);
  private:
  uint32_t _internal_account_id() const;
  void _internal_set_account_id(uint32_t value);
  public:

  // optional uint32 team_id = 2;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  uint32_t team_id() const;
  void set_team_id(uint32_t value);
  private:
  uint32_t _internal_team_id() const;
  void _internal_set_team_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTAKickTeamMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t account_id_;
    uint32_t team_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAKickTeamMemberResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTAKickTeamMemberResponse) */ {
 public:
  inline CMsgDOTAKickTeamMemberResponse() : CMsgDOTAKickTeamMemberResponse(nullptr) {}
  ~CMsgDOTAKickTeamMemberResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTAKickTeamMemberResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTAKickTeamMemberResponse(const CMsgDOTAKickTeamMemberResponse& from);
  CMsgDOTAKickTeamMemberResponse(CMsgDOTAKickTeamMemberResponse&& from) noexcept
    : CMsgDOTAKickTeamMemberResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAKickTeamMemberResponse& operator=(const CMsgDOTAKickTeamMemberResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTAKickTeamMemberResponse& operator=(CMsgDOTAKickTeamMemberResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTAKickTeamMemberResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTAKickTeamMemberResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAKickTeamMemberResponse*>(
               &_CMsgDOTAKickTeamMemberResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CMsgDOTAKickTeamMemberResponse& a, CMsgDOTAKickTeamMemberResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTAKickTeamMemberResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTAKickTeamMemberResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTAKickTeamMemberResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTAKickTeamMemberResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTAKickTeamMemberResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTAKickTeamMemberResponse& from) {
    CMsgDOTAKickTeamMemberResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAKickTeamMemberResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTAKickTeamMemberResponse";
  }
  protected:
  explicit CMsgDOTAKickTeamMemberResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAKickTeamMemberResponse_Result Result;
  static constexpr Result SUCCESS =
    CMsgDOTAKickTeamMemberResponse_Result_SUCCESS;
  static constexpr Result FAILURE_INVALID_ACCOUNT_TYPE =
    CMsgDOTAKickTeamMemberResponse_Result_FAILURE_INVALID_ACCOUNT_TYPE;
  static constexpr Result FAILURE_KICKER_NOT_ADMIN =
    CMsgDOTAKickTeamMemberResponse_Result_FAILURE_KICKER_NOT_ADMIN;
  static constexpr Result FAILURE_KICKEE_NOT_MEMBER =
    CMsgDOTAKickTeamMemberResponse_Result_FAILURE_KICKEE_NOT_MEMBER;
  static constexpr Result FAILURE_TEAM_LOCKED =
    CMsgDOTAKickTeamMemberResponse_Result_FAILURE_TEAM_LOCKED;
  static constexpr Result FAILURE_UNSPECIFIED_ERROR =
    CMsgDOTAKickTeamMemberResponse_Result_FAILURE_UNSPECIFIED_ERROR;
  static inline bool Result_IsValid(int value) {
    return CMsgDOTAKickTeamMemberResponse_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    CMsgDOTAKickTeamMemberResponse_Result_Result_MIN;
  static constexpr Result Result_MAX =
    CMsgDOTAKickTeamMemberResponse_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    CMsgDOTAKickTeamMemberResponse_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return CMsgDOTAKickTeamMemberResponse_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return CMsgDOTAKickTeamMemberResponse_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return CMsgDOTAKickTeamMemberResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .CMsgDOTAKickTeamMemberResponse.Result result = 1 [default = SUCCESS];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::CMsgDOTAKickTeamMemberResponse_Result result() const;
  void set_result(::CMsgDOTAKickTeamMemberResponse_Result value);
  private:
  ::CMsgDOTAKickTeamMemberResponse_Result _internal_result() const;
  void _internal_set_result(::CMsgDOTAKickTeamMemberResponse_Result value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTAKickTeamMemberResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATransferTeamAdmin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATransferTeamAdmin) */ {
 public:
  inline CMsgDOTATransferTeamAdmin() : CMsgDOTATransferTeamAdmin(nullptr) {}
  ~CMsgDOTATransferTeamAdmin() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATransferTeamAdmin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATransferTeamAdmin(const CMsgDOTATransferTeamAdmin& from);
  CMsgDOTATransferTeamAdmin(CMsgDOTATransferTeamAdmin&& from) noexcept
    : CMsgDOTATransferTeamAdmin() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATransferTeamAdmin& operator=(const CMsgDOTATransferTeamAdmin& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATransferTeamAdmin& operator=(CMsgDOTATransferTeamAdmin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATransferTeamAdmin& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATransferTeamAdmin* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATransferTeamAdmin*>(
               &_CMsgDOTATransferTeamAdmin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CMsgDOTATransferTeamAdmin& a, CMsgDOTATransferTeamAdmin& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATransferTeamAdmin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATransferTeamAdmin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATransferTeamAdmin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATransferTeamAdmin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATransferTeamAdmin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATransferTeamAdmin& from) {
    CMsgDOTATransferTeamAdmin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATransferTeamAdmin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATransferTeamAdmin";
  }
  protected:
  explicit CMsgDOTATransferTeamAdmin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewAdminAccountIdFieldNumber = 1,
    kTeamIdFieldNumber = 2,
  };
  // optional uint32 new_admin_account_id = 1;
  bool has_new_admin_account_id() const;
  private:
  bool _internal_has_new_admin_account_id() const;
  public:
  void clear_new_admin_account_id();
  uint32_t new_admin_account_id() const;
  void set_new_admin_account_id(uint32_t value);
  private:
  uint32_t _internal_new_admin_account_id() const;
  void _internal_set_new_admin_account_id(uint32_t value);
  public:

  // optional uint32 team_id = 2;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  uint32_t team_id() const;
  void set_team_id(uint32_t value);
  private:
  uint32_t _internal_team_id() const;
  void _internal_set_team_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATransferTeamAdmin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t new_admin_account_id_;
    uint32_t team_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATransferTeamAdminResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTATransferTeamAdminResponse) */ {
 public:
  inline CMsgDOTATransferTeamAdminResponse() : CMsgDOTATransferTeamAdminResponse(nullptr) {}
  ~CMsgDOTATransferTeamAdminResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTATransferTeamAdminResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTATransferTeamAdminResponse(const CMsgDOTATransferTeamAdminResponse& from);
  CMsgDOTATransferTeamAdminResponse(CMsgDOTATransferTeamAdminResponse&& from) noexcept
    : CMsgDOTATransferTeamAdminResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATransferTeamAdminResponse& operator=(const CMsgDOTATransferTeamAdminResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTATransferTeamAdminResponse& operator=(CMsgDOTATransferTeamAdminResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTATransferTeamAdminResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTATransferTeamAdminResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATransferTeamAdminResponse*>(
               &_CMsgDOTATransferTeamAdminResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CMsgDOTATransferTeamAdminResponse& a, CMsgDOTATransferTeamAdminResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTATransferTeamAdminResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTATransferTeamAdminResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTATransferTeamAdminResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTATransferTeamAdminResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTATransferTeamAdminResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTATransferTeamAdminResponse& from) {
    CMsgDOTATransferTeamAdminResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATransferTeamAdminResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTATransferTeamAdminResponse";
  }
  protected:
  explicit CMsgDOTATransferTeamAdminResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTATransferTeamAdminResponse_Result Result;
  static constexpr Result SUCCESS =
    CMsgDOTATransferTeamAdminResponse_Result_SUCCESS;
  static constexpr Result FAILURE_INVALID_ACCOUNT_TYPE =
    CMsgDOTATransferTeamAdminResponse_Result_FAILURE_INVALID_ACCOUNT_TYPE;
  static constexpr Result FAILURE_NOT_ADMIN =
    CMsgDOTATransferTeamAdminResponse_Result_FAILURE_NOT_ADMIN;
  static constexpr Result FAILURE_SAME_ACCOUNT =
    CMsgDOTATransferTeamAdminResponse_Result_FAILURE_SAME_ACCOUNT;
  static constexpr Result FAILURE_NOT_MEMBER =
    CMsgDOTATransferTeamAdminResponse_Result_FAILURE_NOT_MEMBER;
  static constexpr Result FAILURE_UNSPECIFIED_ERROR =
    CMsgDOTATransferTeamAdminResponse_Result_FAILURE_UNSPECIFIED_ERROR;
  static inline bool Result_IsValid(int value) {
    return CMsgDOTATransferTeamAdminResponse_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    CMsgDOTATransferTeamAdminResponse_Result_Result_MIN;
  static constexpr Result Result_MAX =
    CMsgDOTATransferTeamAdminResponse_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    CMsgDOTATransferTeamAdminResponse_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return CMsgDOTATransferTeamAdminResponse_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return CMsgDOTATransferTeamAdminResponse_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return CMsgDOTATransferTeamAdminResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .CMsgDOTATransferTeamAdminResponse.Result result = 1 [default = SUCCESS];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::CMsgDOTATransferTeamAdminResponse_Result result() const;
  void set_result(::CMsgDOTATransferTeamAdminResponse_Result value);
  private:
  ::CMsgDOTATransferTeamAdminResponse_Result _internal_result() const;
  void _internal_set_result(::CMsgDOTATransferTeamAdminResponse_Result value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTATransferTeamAdminResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeaveTeam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeaveTeam) */ {
 public:
  inline CMsgDOTALeaveTeam() : CMsgDOTALeaveTeam(nullptr) {}
  ~CMsgDOTALeaveTeam() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeaveTeam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeaveTeam(const CMsgDOTALeaveTeam& from);
  CMsgDOTALeaveTeam(CMsgDOTALeaveTeam&& from) noexcept
    : CMsgDOTALeaveTeam() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeaveTeam& operator=(const CMsgDOTALeaveTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeaveTeam& operator=(CMsgDOTALeaveTeam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeaveTeam& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeaveTeam* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeaveTeam*>(
               &_CMsgDOTALeaveTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CMsgDOTALeaveTeam& a, CMsgDOTALeaveTeam& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeaveTeam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeaveTeam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeaveTeam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeaveTeam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeaveTeam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeaveTeam& from) {
    CMsgDOTALeaveTeam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeaveTeam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeaveTeam";
  }
  protected:
  explicit CMsgDOTALeaveTeam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamIdFieldNumber = 1,
  };
  // optional uint32 team_id = 1;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  uint32_t team_id() const;
  void set_team_id(uint32_t value);
  private:
  uint32_t _internal_team_id() const;
  void _internal_set_team_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeaveTeam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t team_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeaveTeamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeaveTeamResponse) */ {
 public:
  inline CMsgDOTALeaveTeamResponse() : CMsgDOTALeaveTeamResponse(nullptr) {}
  ~CMsgDOTALeaveTeamResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeaveTeamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeaveTeamResponse(const CMsgDOTALeaveTeamResponse& from);
  CMsgDOTALeaveTeamResponse(CMsgDOTALeaveTeamResponse&& from) noexcept
    : CMsgDOTALeaveTeamResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeaveTeamResponse& operator=(const CMsgDOTALeaveTeamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeaveTeamResponse& operator=(CMsgDOTALeaveTeamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeaveTeamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeaveTeamResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeaveTeamResponse*>(
               &_CMsgDOTALeaveTeamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CMsgDOTALeaveTeamResponse& a, CMsgDOTALeaveTeamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeaveTeamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeaveTeamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeaveTeamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeaveTeamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeaveTeamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeaveTeamResponse& from) {
    CMsgDOTALeaveTeamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeaveTeamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeaveTeamResponse";
  }
  protected:
  explicit CMsgDOTALeaveTeamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeaveTeamResponse_Result Result;
  static constexpr Result SUCCESS =
    CMsgDOTALeaveTeamResponse_Result_SUCCESS;
  static constexpr Result FAILURE_NOT_MEMBER =
    CMsgDOTALeaveTeamResponse_Result_FAILURE_NOT_MEMBER;
  static constexpr Result FAILURE_TEAM_LOCKED =
    CMsgDOTALeaveTeamResponse_Result_FAILURE_TEAM_LOCKED;
  static constexpr Result FAILURE_UNSPECIFIED_ERROR =
    CMsgDOTALeaveTeamResponse_Result_FAILURE_UNSPECIFIED_ERROR;
  static inline bool Result_IsValid(int value) {
    return CMsgDOTALeaveTeamResponse_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    CMsgDOTALeaveTeamResponse_Result_Result_MIN;
  static constexpr Result Result_MAX =
    CMsgDOTALeaveTeamResponse_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    CMsgDOTALeaveTeamResponse_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return CMsgDOTALeaveTeamResponse_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return CMsgDOTALeaveTeamResponse_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return CMsgDOTALeaveTeamResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .CMsgDOTALeaveTeamResponse.Result result = 1 [default = SUCCESS];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::CMsgDOTALeaveTeamResponse_Result result() const;
  void set_result(::CMsgDOTALeaveTeamResponse_Result value);
  private:
  ::CMsgDOTALeaveTeamResponse_Result _internal_result() const;
  void _internal_set_result(::CMsgDOTALeaveTeamResponse_Result value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeaveTeamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTABetaParticipation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTABetaParticipation) */ {
 public:
  inline CMsgDOTABetaParticipation() : CMsgDOTABetaParticipation(nullptr) {}
  ~CMsgDOTABetaParticipation() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTABetaParticipation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTABetaParticipation(const CMsgDOTABetaParticipation& from);
  CMsgDOTABetaParticipation(CMsgDOTABetaParticipation&& from) noexcept
    : CMsgDOTABetaParticipation() {
    *this = ::std::move(from);
  }

  inline CMsgDOTABetaParticipation& operator=(const CMsgDOTABetaParticipation& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTABetaParticipation& operator=(CMsgDOTABetaParticipation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTABetaParticipation& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTABetaParticipation* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTABetaParticipation*>(
               &_CMsgDOTABetaParticipation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CMsgDOTABetaParticipation& a, CMsgDOTABetaParticipation& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTABetaParticipation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTABetaParticipation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTABetaParticipation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTABetaParticipation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTABetaParticipation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTABetaParticipation& from) {
    CMsgDOTABetaParticipation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTABetaParticipation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTABetaParticipation";
  }
  protected:
  explicit CMsgDOTABetaParticipation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessRightsFieldNumber = 1,
  };
  // optional uint32 access_rights = 1;
  bool has_access_rights() const;
  private:
  bool _internal_has_access_rights() const;
  public:
  void clear_access_rights();
  uint32_t access_rights() const;
  void set_access_rights(uint32_t value);
  private:
  uint32_t _internal_access_rights() const;
  void _internal_set_access_rights(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTABetaParticipation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t access_rights_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fteam_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgDOTATeamInfo_HeroStats

// optional uint32 hero_id = 1;
inline bool CMsgDOTATeamInfo_HeroStats::_internal_has_hero_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_HeroStats::has_hero_id() const {
  return _internal_has_hero_id();
}
inline void CMsgDOTATeamInfo_HeroStats::clear_hero_id() {
  _impl_.hero_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTATeamInfo_HeroStats::_internal_hero_id() const {
  return _impl_.hero_id_;
}
inline uint32_t CMsgDOTATeamInfo_HeroStats::hero_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.HeroStats.hero_id)
  return _internal_hero_id();
}
inline void CMsgDOTATeamInfo_HeroStats::_internal_set_hero_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hero_id_ = value;
}
inline void CMsgDOTATeamInfo_HeroStats::set_hero_id(uint32_t value) {
  _internal_set_hero_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.HeroStats.hero_id)
}

// optional uint32 picks = 2;
inline bool CMsgDOTATeamInfo_HeroStats::_internal_has_picks() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_HeroStats::has_picks() const {
  return _internal_has_picks();
}
inline void CMsgDOTATeamInfo_HeroStats::clear_picks() {
  _impl_.picks_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTATeamInfo_HeroStats::_internal_picks() const {
  return _impl_.picks_;
}
inline uint32_t CMsgDOTATeamInfo_HeroStats::picks() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.HeroStats.picks)
  return _internal_picks();
}
inline void CMsgDOTATeamInfo_HeroStats::_internal_set_picks(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.picks_ = value;
}
inline void CMsgDOTATeamInfo_HeroStats::set_picks(uint32_t value) {
  _internal_set_picks(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.HeroStats.picks)
}

// optional uint32 wins = 3;
inline bool CMsgDOTATeamInfo_HeroStats::_internal_has_wins() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_HeroStats::has_wins() const {
  return _internal_has_wins();
}
inline void CMsgDOTATeamInfo_HeroStats::clear_wins() {
  _impl_.wins_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTATeamInfo_HeroStats::_internal_wins() const {
  return _impl_.wins_;
}
inline uint32_t CMsgDOTATeamInfo_HeroStats::wins() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.HeroStats.wins)
  return _internal_wins();
}
inline void CMsgDOTATeamInfo_HeroStats::_internal_set_wins(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.wins_ = value;
}
inline void CMsgDOTATeamInfo_HeroStats::set_wins(uint32_t value) {
  _internal_set_wins(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.HeroStats.wins)
}

// optional uint32 bans = 4;
inline bool CMsgDOTATeamInfo_HeroStats::_internal_has_bans() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_HeroStats::has_bans() const {
  return _internal_has_bans();
}
inline void CMsgDOTATeamInfo_HeroStats::clear_bans() {
  _impl_.bans_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTATeamInfo_HeroStats::_internal_bans() const {
  return _impl_.bans_;
}
inline uint32_t CMsgDOTATeamInfo_HeroStats::bans() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.HeroStats.bans)
  return _internal_bans();
}
inline void CMsgDOTATeamInfo_HeroStats::_internal_set_bans(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bans_ = value;
}
inline void CMsgDOTATeamInfo_HeroStats::set_bans(uint32_t value) {
  _internal_set_bans(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.HeroStats.bans)
}

// optional float avg_kills = 5;
inline bool CMsgDOTATeamInfo_HeroStats::_internal_has_avg_kills() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_HeroStats::has_avg_kills() const {
  return _internal_has_avg_kills();
}
inline void CMsgDOTATeamInfo_HeroStats::clear_avg_kills() {
  _impl_.avg_kills_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float CMsgDOTATeamInfo_HeroStats::_internal_avg_kills() const {
  return _impl_.avg_kills_;
}
inline float CMsgDOTATeamInfo_HeroStats::avg_kills() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.HeroStats.avg_kills)
  return _internal_avg_kills();
}
inline void CMsgDOTATeamInfo_HeroStats::_internal_set_avg_kills(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.avg_kills_ = value;
}
inline void CMsgDOTATeamInfo_HeroStats::set_avg_kills(float value) {
  _internal_set_avg_kills(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.HeroStats.avg_kills)
}

// optional float avg_deaths = 6;
inline bool CMsgDOTATeamInfo_HeroStats::_internal_has_avg_deaths() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_HeroStats::has_avg_deaths() const {
  return _internal_has_avg_deaths();
}
inline void CMsgDOTATeamInfo_HeroStats::clear_avg_deaths() {
  _impl_.avg_deaths_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float CMsgDOTATeamInfo_HeroStats::_internal_avg_deaths() const {
  return _impl_.avg_deaths_;
}
inline float CMsgDOTATeamInfo_HeroStats::avg_deaths() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.HeroStats.avg_deaths)
  return _internal_avg_deaths();
}
inline void CMsgDOTATeamInfo_HeroStats::_internal_set_avg_deaths(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.avg_deaths_ = value;
}
inline void CMsgDOTATeamInfo_HeroStats::set_avg_deaths(float value) {
  _internal_set_avg_deaths(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.HeroStats.avg_deaths)
}

// optional float avg_assists = 7;
inline bool CMsgDOTATeamInfo_HeroStats::_internal_has_avg_assists() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_HeroStats::has_avg_assists() const {
  return _internal_has_avg_assists();
}
inline void CMsgDOTATeamInfo_HeroStats::clear_avg_assists() {
  _impl_.avg_assists_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float CMsgDOTATeamInfo_HeroStats::_internal_avg_assists() const {
  return _impl_.avg_assists_;
}
inline float CMsgDOTATeamInfo_HeroStats::avg_assists() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.HeroStats.avg_assists)
  return _internal_avg_assists();
}
inline void CMsgDOTATeamInfo_HeroStats::_internal_set_avg_assists(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.avg_assists_ = value;
}
inline void CMsgDOTATeamInfo_HeroStats::set_avg_assists(float value) {
  _internal_set_avg_assists(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.HeroStats.avg_assists)
}

// optional float avg_gpm = 8;
inline bool CMsgDOTATeamInfo_HeroStats::_internal_has_avg_gpm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_HeroStats::has_avg_gpm() const {
  return _internal_has_avg_gpm();
}
inline void CMsgDOTATeamInfo_HeroStats::clear_avg_gpm() {
  _impl_.avg_gpm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float CMsgDOTATeamInfo_HeroStats::_internal_avg_gpm() const {
  return _impl_.avg_gpm_;
}
inline float CMsgDOTATeamInfo_HeroStats::avg_gpm() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.HeroStats.avg_gpm)
  return _internal_avg_gpm();
}
inline void CMsgDOTATeamInfo_HeroStats::_internal_set_avg_gpm(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.avg_gpm_ = value;
}
inline void CMsgDOTATeamInfo_HeroStats::set_avg_gpm(float value) {
  _internal_set_avg_gpm(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.HeroStats.avg_gpm)
}

// optional float avg_xpm = 9;
inline bool CMsgDOTATeamInfo_HeroStats::_internal_has_avg_xpm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_HeroStats::has_avg_xpm() const {
  return _internal_has_avg_xpm();
}
inline void CMsgDOTATeamInfo_HeroStats::clear_avg_xpm() {
  _impl_.avg_xpm_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float CMsgDOTATeamInfo_HeroStats::_internal_avg_xpm() const {
  return _impl_.avg_xpm_;
}
inline float CMsgDOTATeamInfo_HeroStats::avg_xpm() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.HeroStats.avg_xpm)
  return _internal_avg_xpm();
}
inline void CMsgDOTATeamInfo_HeroStats::_internal_set_avg_xpm(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.avg_xpm_ = value;
}
inline void CMsgDOTATeamInfo_HeroStats::set_avg_xpm(float value) {
  _internal_set_avg_xpm(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.HeroStats.avg_xpm)
}

// -------------------------------------------------------------------

// CMsgDOTATeamInfo_MemberStats

// optional uint32 account_id = 1;
inline bool CMsgDOTATeamInfo_MemberStats::_internal_has_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_MemberStats::has_account_id() const {
  return _internal_has_account_id();
}
inline void CMsgDOTATeamInfo_MemberStats::clear_account_id() {
  _impl_.account_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTATeamInfo_MemberStats::_internal_account_id() const {
  return _impl_.account_id_;
}
inline uint32_t CMsgDOTATeamInfo_MemberStats::account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.MemberStats.account_id)
  return _internal_account_id();
}
inline void CMsgDOTATeamInfo_MemberStats::_internal_set_account_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_id_ = value;
}
inline void CMsgDOTATeamInfo_MemberStats::set_account_id(uint32_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.MemberStats.account_id)
}

// optional uint32 wins_with_team = 2;
inline bool CMsgDOTATeamInfo_MemberStats::_internal_has_wins_with_team() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_MemberStats::has_wins_with_team() const {
  return _internal_has_wins_with_team();
}
inline void CMsgDOTATeamInfo_MemberStats::clear_wins_with_team() {
  _impl_.wins_with_team_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTATeamInfo_MemberStats::_internal_wins_with_team() const {
  return _impl_.wins_with_team_;
}
inline uint32_t CMsgDOTATeamInfo_MemberStats::wins_with_team() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.MemberStats.wins_with_team)
  return _internal_wins_with_team();
}
inline void CMsgDOTATeamInfo_MemberStats::_internal_set_wins_with_team(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wins_with_team_ = value;
}
inline void CMsgDOTATeamInfo_MemberStats::set_wins_with_team(uint32_t value) {
  _internal_set_wins_with_team(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.MemberStats.wins_with_team)
}

// optional uint32 losses_with_team = 3;
inline bool CMsgDOTATeamInfo_MemberStats::_internal_has_losses_with_team() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_MemberStats::has_losses_with_team() const {
  return _internal_has_losses_with_team();
}
inline void CMsgDOTATeamInfo_MemberStats::clear_losses_with_team() {
  _impl_.losses_with_team_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTATeamInfo_MemberStats::_internal_losses_with_team() const {
  return _impl_.losses_with_team_;
}
inline uint32_t CMsgDOTATeamInfo_MemberStats::losses_with_team() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.MemberStats.losses_with_team)
  return _internal_losses_with_team();
}
inline void CMsgDOTATeamInfo_MemberStats::_internal_set_losses_with_team(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.losses_with_team_ = value;
}
inline void CMsgDOTATeamInfo_MemberStats::set_losses_with_team(uint32_t value) {
  _internal_set_losses_with_team(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.MemberStats.losses_with_team)
}

// repeated .CMsgDOTATeamInfo.HeroStats top_heroes = 4;
inline int CMsgDOTATeamInfo_MemberStats::_internal_top_heroes_size() const {
  return _impl_.top_heroes_.size();
}
inline int CMsgDOTATeamInfo_MemberStats::top_heroes_size() const {
  return _internal_top_heroes_size();
}
inline void CMsgDOTATeamInfo_MemberStats::clear_top_heroes() {
  _impl_.top_heroes_.Clear();
}
inline ::CMsgDOTATeamInfo_HeroStats* CMsgDOTATeamInfo_MemberStats::mutable_top_heroes(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.MemberStats.top_heroes)
  return _impl_.top_heroes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_HeroStats >*
CMsgDOTATeamInfo_MemberStats::mutable_top_heroes() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTATeamInfo.MemberStats.top_heroes)
  return &_impl_.top_heroes_;
}
inline const ::CMsgDOTATeamInfo_HeroStats& CMsgDOTATeamInfo_MemberStats::_internal_top_heroes(int index) const {
  return _impl_.top_heroes_.Get(index);
}
inline const ::CMsgDOTATeamInfo_HeroStats& CMsgDOTATeamInfo_MemberStats::top_heroes(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.MemberStats.top_heroes)
  return _internal_top_heroes(index);
}
inline ::CMsgDOTATeamInfo_HeroStats* CMsgDOTATeamInfo_MemberStats::_internal_add_top_heroes() {
  return _impl_.top_heroes_.Add();
}
inline ::CMsgDOTATeamInfo_HeroStats* CMsgDOTATeamInfo_MemberStats::add_top_heroes() {
  ::CMsgDOTATeamInfo_HeroStats* _add = _internal_add_top_heroes();
  // @@protoc_insertion_point(field_add:CMsgDOTATeamInfo.MemberStats.top_heroes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_HeroStats >&
CMsgDOTATeamInfo_MemberStats::top_heroes() const {
  // @@protoc_insertion_point(field_list:CMsgDOTATeamInfo.MemberStats.top_heroes)
  return _impl_.top_heroes_;
}

// optional float avg_kills = 5;
inline bool CMsgDOTATeamInfo_MemberStats::_internal_has_avg_kills() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_MemberStats::has_avg_kills() const {
  return _internal_has_avg_kills();
}
inline void CMsgDOTATeamInfo_MemberStats::clear_avg_kills() {
  _impl_.avg_kills_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float CMsgDOTATeamInfo_MemberStats::_internal_avg_kills() const {
  return _impl_.avg_kills_;
}
inline float CMsgDOTATeamInfo_MemberStats::avg_kills() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.MemberStats.avg_kills)
  return _internal_avg_kills();
}
inline void CMsgDOTATeamInfo_MemberStats::_internal_set_avg_kills(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.avg_kills_ = value;
}
inline void CMsgDOTATeamInfo_MemberStats::set_avg_kills(float value) {
  _internal_set_avg_kills(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.MemberStats.avg_kills)
}

// optional float avg_deaths = 6;
inline bool CMsgDOTATeamInfo_MemberStats::_internal_has_avg_deaths() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_MemberStats::has_avg_deaths() const {
  return _internal_has_avg_deaths();
}
inline void CMsgDOTATeamInfo_MemberStats::clear_avg_deaths() {
  _impl_.avg_deaths_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float CMsgDOTATeamInfo_MemberStats::_internal_avg_deaths() const {
  return _impl_.avg_deaths_;
}
inline float CMsgDOTATeamInfo_MemberStats::avg_deaths() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.MemberStats.avg_deaths)
  return _internal_avg_deaths();
}
inline void CMsgDOTATeamInfo_MemberStats::_internal_set_avg_deaths(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.avg_deaths_ = value;
}
inline void CMsgDOTATeamInfo_MemberStats::set_avg_deaths(float value) {
  _internal_set_avg_deaths(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.MemberStats.avg_deaths)
}

// optional float avg_assists = 7;
inline bool CMsgDOTATeamInfo_MemberStats::_internal_has_avg_assists() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_MemberStats::has_avg_assists() const {
  return _internal_has_avg_assists();
}
inline void CMsgDOTATeamInfo_MemberStats::clear_avg_assists() {
  _impl_.avg_assists_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float CMsgDOTATeamInfo_MemberStats::_internal_avg_assists() const {
  return _impl_.avg_assists_;
}
inline float CMsgDOTATeamInfo_MemberStats::avg_assists() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.MemberStats.avg_assists)
  return _internal_avg_assists();
}
inline void CMsgDOTATeamInfo_MemberStats::_internal_set_avg_assists(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.avg_assists_ = value;
}
inline void CMsgDOTATeamInfo_MemberStats::set_avg_assists(float value) {
  _internal_set_avg_assists(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.MemberStats.avg_assists)
}

// -------------------------------------------------------------------

// CMsgDOTATeamInfo_TeamStats

// repeated .CMsgDOTATeamInfo.HeroStats played_heroes = 1;
inline int CMsgDOTATeamInfo_TeamStats::_internal_played_heroes_size() const {
  return _impl_.played_heroes_.size();
}
inline int CMsgDOTATeamInfo_TeamStats::played_heroes_size() const {
  return _internal_played_heroes_size();
}
inline void CMsgDOTATeamInfo_TeamStats::clear_played_heroes() {
  _impl_.played_heroes_.Clear();
}
inline ::CMsgDOTATeamInfo_HeroStats* CMsgDOTATeamInfo_TeamStats::mutable_played_heroes(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.TeamStats.played_heroes)
  return _impl_.played_heroes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_HeroStats >*
CMsgDOTATeamInfo_TeamStats::mutable_played_heroes() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTATeamInfo.TeamStats.played_heroes)
  return &_impl_.played_heroes_;
}
inline const ::CMsgDOTATeamInfo_HeroStats& CMsgDOTATeamInfo_TeamStats::_internal_played_heroes(int index) const {
  return _impl_.played_heroes_.Get(index);
}
inline const ::CMsgDOTATeamInfo_HeroStats& CMsgDOTATeamInfo_TeamStats::played_heroes(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.TeamStats.played_heroes)
  return _internal_played_heroes(index);
}
inline ::CMsgDOTATeamInfo_HeroStats* CMsgDOTATeamInfo_TeamStats::_internal_add_played_heroes() {
  return _impl_.played_heroes_.Add();
}
inline ::CMsgDOTATeamInfo_HeroStats* CMsgDOTATeamInfo_TeamStats::add_played_heroes() {
  ::CMsgDOTATeamInfo_HeroStats* _add = _internal_add_played_heroes();
  // @@protoc_insertion_point(field_add:CMsgDOTATeamInfo.TeamStats.played_heroes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_HeroStats >&
CMsgDOTATeamInfo_TeamStats::played_heroes() const {
  // @@protoc_insertion_point(field_list:CMsgDOTATeamInfo.TeamStats.played_heroes)
  return _impl_.played_heroes_;
}

// optional float farming = 2;
inline bool CMsgDOTATeamInfo_TeamStats::_internal_has_farming() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_TeamStats::has_farming() const {
  return _internal_has_farming();
}
inline void CMsgDOTATeamInfo_TeamStats::clear_farming() {
  _impl_.farming_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float CMsgDOTATeamInfo_TeamStats::_internal_farming() const {
  return _impl_.farming_;
}
inline float CMsgDOTATeamInfo_TeamStats::farming() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.TeamStats.farming)
  return _internal_farming();
}
inline void CMsgDOTATeamInfo_TeamStats::_internal_set_farming(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.farming_ = value;
}
inline void CMsgDOTATeamInfo_TeamStats::set_farming(float value) {
  _internal_set_farming(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.TeamStats.farming)
}

// optional float fighting = 3;
inline bool CMsgDOTATeamInfo_TeamStats::_internal_has_fighting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_TeamStats::has_fighting() const {
  return _internal_has_fighting();
}
inline void CMsgDOTATeamInfo_TeamStats::clear_fighting() {
  _impl_.fighting_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float CMsgDOTATeamInfo_TeamStats::_internal_fighting() const {
  return _impl_.fighting_;
}
inline float CMsgDOTATeamInfo_TeamStats::fighting() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.TeamStats.fighting)
  return _internal_fighting();
}
inline void CMsgDOTATeamInfo_TeamStats::_internal_set_fighting(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fighting_ = value;
}
inline void CMsgDOTATeamInfo_TeamStats::set_fighting(float value) {
  _internal_set_fighting(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.TeamStats.fighting)
}

// optional float versatility = 4;
inline bool CMsgDOTATeamInfo_TeamStats::_internal_has_versatility() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_TeamStats::has_versatility() const {
  return _internal_has_versatility();
}
inline void CMsgDOTATeamInfo_TeamStats::clear_versatility() {
  _impl_.versatility_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float CMsgDOTATeamInfo_TeamStats::_internal_versatility() const {
  return _impl_.versatility_;
}
inline float CMsgDOTATeamInfo_TeamStats::versatility() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.TeamStats.versatility)
  return _internal_versatility();
}
inline void CMsgDOTATeamInfo_TeamStats::_internal_set_versatility(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.versatility_ = value;
}
inline void CMsgDOTATeamInfo_TeamStats::set_versatility(float value) {
  _internal_set_versatility(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.TeamStats.versatility)
}

// optional float avg_kills = 5;
inline bool CMsgDOTATeamInfo_TeamStats::_internal_has_avg_kills() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_TeamStats::has_avg_kills() const {
  return _internal_has_avg_kills();
}
inline void CMsgDOTATeamInfo_TeamStats::clear_avg_kills() {
  _impl_.avg_kills_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float CMsgDOTATeamInfo_TeamStats::_internal_avg_kills() const {
  return _impl_.avg_kills_;
}
inline float CMsgDOTATeamInfo_TeamStats::avg_kills() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.TeamStats.avg_kills)
  return _internal_avg_kills();
}
inline void CMsgDOTATeamInfo_TeamStats::_internal_set_avg_kills(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.avg_kills_ = value;
}
inline void CMsgDOTATeamInfo_TeamStats::set_avg_kills(float value) {
  _internal_set_avg_kills(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.TeamStats.avg_kills)
}

// optional float avg_deaths = 6;
inline bool CMsgDOTATeamInfo_TeamStats::_internal_has_avg_deaths() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_TeamStats::has_avg_deaths() const {
  return _internal_has_avg_deaths();
}
inline void CMsgDOTATeamInfo_TeamStats::clear_avg_deaths() {
  _impl_.avg_deaths_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float CMsgDOTATeamInfo_TeamStats::_internal_avg_deaths() const {
  return _impl_.avg_deaths_;
}
inline float CMsgDOTATeamInfo_TeamStats::avg_deaths() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.TeamStats.avg_deaths)
  return _internal_avg_deaths();
}
inline void CMsgDOTATeamInfo_TeamStats::_internal_set_avg_deaths(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.avg_deaths_ = value;
}
inline void CMsgDOTATeamInfo_TeamStats::set_avg_deaths(float value) {
  _internal_set_avg_deaths(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.TeamStats.avg_deaths)
}

// optional float avg_duration = 7;
inline bool CMsgDOTATeamInfo_TeamStats::_internal_has_avg_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_TeamStats::has_avg_duration() const {
  return _internal_has_avg_duration();
}
inline void CMsgDOTATeamInfo_TeamStats::clear_avg_duration() {
  _impl_.avg_duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float CMsgDOTATeamInfo_TeamStats::_internal_avg_duration() const {
  return _impl_.avg_duration_;
}
inline float CMsgDOTATeamInfo_TeamStats::avg_duration() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.TeamStats.avg_duration)
  return _internal_avg_duration();
}
inline void CMsgDOTATeamInfo_TeamStats::_internal_set_avg_duration(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.avg_duration_ = value;
}
inline void CMsgDOTATeamInfo_TeamStats::set_avg_duration(float value) {
  _internal_set_avg_duration(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.TeamStats.avg_duration)
}

// -------------------------------------------------------------------

// CMsgDOTATeamInfo_DPCResult

// optional uint32 league_id = 1;
inline bool CMsgDOTATeamInfo_DPCResult::_internal_has_league_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_DPCResult::has_league_id() const {
  return _internal_has_league_id();
}
inline void CMsgDOTATeamInfo_DPCResult::clear_league_id() {
  _impl_.league_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTATeamInfo_DPCResult::_internal_league_id() const {
  return _impl_.league_id_;
}
inline uint32_t CMsgDOTATeamInfo_DPCResult::league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.DPCResult.league_id)
  return _internal_league_id();
}
inline void CMsgDOTATeamInfo_DPCResult::_internal_set_league_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.league_id_ = value;
}
inline void CMsgDOTATeamInfo_DPCResult::set_league_id(uint32_t value) {
  _internal_set_league_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.DPCResult.league_id)
}

// optional uint32 standing = 2;
inline bool CMsgDOTATeamInfo_DPCResult::_internal_has_standing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_DPCResult::has_standing() const {
  return _internal_has_standing();
}
inline void CMsgDOTATeamInfo_DPCResult::clear_standing() {
  _impl_.standing_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTATeamInfo_DPCResult::_internal_standing() const {
  return _impl_.standing_;
}
inline uint32_t CMsgDOTATeamInfo_DPCResult::standing() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.DPCResult.standing)
  return _internal_standing();
}
inline void CMsgDOTATeamInfo_DPCResult::_internal_set_standing(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.standing_ = value;
}
inline void CMsgDOTATeamInfo_DPCResult::set_standing(uint32_t value) {
  _internal_set_standing(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.DPCResult.standing)
}

// optional uint32 points = 3;
inline bool CMsgDOTATeamInfo_DPCResult::_internal_has_points() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_DPCResult::has_points() const {
  return _internal_has_points();
}
inline void CMsgDOTATeamInfo_DPCResult::clear_points() {
  _impl_.points_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTATeamInfo_DPCResult::_internal_points() const {
  return _impl_.points_;
}
inline uint32_t CMsgDOTATeamInfo_DPCResult::points() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.DPCResult.points)
  return _internal_points();
}
inline void CMsgDOTATeamInfo_DPCResult::_internal_set_points(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.points_ = value;
}
inline void CMsgDOTATeamInfo_DPCResult::set_points(uint32_t value) {
  _internal_set_points(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.DPCResult.points)
}

// optional uint32 earnings = 4;
inline bool CMsgDOTATeamInfo_DPCResult::_internal_has_earnings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_DPCResult::has_earnings() const {
  return _internal_has_earnings();
}
inline void CMsgDOTATeamInfo_DPCResult::clear_earnings() {
  _impl_.earnings_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTATeamInfo_DPCResult::_internal_earnings() const {
  return _impl_.earnings_;
}
inline uint32_t CMsgDOTATeamInfo_DPCResult::earnings() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.DPCResult.earnings)
  return _internal_earnings();
}
inline void CMsgDOTATeamInfo_DPCResult::_internal_set_earnings(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.earnings_ = value;
}
inline void CMsgDOTATeamInfo_DPCResult::set_earnings(uint32_t value) {
  _internal_set_earnings(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.DPCResult.earnings)
}

// optional uint32 timestamp = 5;
inline bool CMsgDOTATeamInfo_DPCResult::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_DPCResult::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CMsgDOTATeamInfo_DPCResult::clear_timestamp() {
  _impl_.timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTATeamInfo_DPCResult::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint32_t CMsgDOTATeamInfo_DPCResult::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.DPCResult.timestamp)
  return _internal_timestamp();
}
inline void CMsgDOTATeamInfo_DPCResult::_internal_set_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.timestamp_ = value;
}
inline void CMsgDOTATeamInfo_DPCResult::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.DPCResult.timestamp)
}

// -------------------------------------------------------------------

// CMsgDOTATeamInfo_Member

// optional uint32 account_id = 1;
inline bool CMsgDOTATeamInfo_Member::_internal_has_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_Member::has_account_id() const {
  return _internal_has_account_id();
}
inline void CMsgDOTATeamInfo_Member::clear_account_id() {
  _impl_.account_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTATeamInfo_Member::_internal_account_id() const {
  return _impl_.account_id_;
}
inline uint32_t CMsgDOTATeamInfo_Member::account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.Member.account_id)
  return _internal_account_id();
}
inline void CMsgDOTATeamInfo_Member::_internal_set_account_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.account_id_ = value;
}
inline void CMsgDOTATeamInfo_Member::set_account_id(uint32_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.Member.account_id)
}

// optional uint32 time_joined = 2;
inline bool CMsgDOTATeamInfo_Member::_internal_has_time_joined() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_Member::has_time_joined() const {
  return _internal_has_time_joined();
}
inline void CMsgDOTATeamInfo_Member::clear_time_joined() {
  _impl_.time_joined_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTATeamInfo_Member::_internal_time_joined() const {
  return _impl_.time_joined_;
}
inline uint32_t CMsgDOTATeamInfo_Member::time_joined() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.Member.time_joined)
  return _internal_time_joined();
}
inline void CMsgDOTATeamInfo_Member::_internal_set_time_joined(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.time_joined_ = value;
}
inline void CMsgDOTATeamInfo_Member::set_time_joined(uint32_t value) {
  _internal_set_time_joined(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.Member.time_joined)
}

// optional bool admin = 3;
inline bool CMsgDOTATeamInfo_Member::_internal_has_admin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_Member::has_admin() const {
  return _internal_has_admin();
}
inline void CMsgDOTATeamInfo_Member::clear_admin() {
  _impl_.admin_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool CMsgDOTATeamInfo_Member::_internal_admin() const {
  return _impl_.admin_;
}
inline bool CMsgDOTATeamInfo_Member::admin() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.Member.admin)
  return _internal_admin();
}
inline void CMsgDOTATeamInfo_Member::_internal_set_admin(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.admin_ = value;
}
inline void CMsgDOTATeamInfo_Member::set_admin(bool value) {
  _internal_set_admin(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.Member.admin)
}

// optional string pro_name = 6;
inline bool CMsgDOTATeamInfo_Member::_internal_has_pro_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_Member::has_pro_name() const {
  return _internal_has_pro_name();
}
inline void CMsgDOTATeamInfo_Member::clear_pro_name() {
  _impl_.pro_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTATeamInfo_Member::pro_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.Member.pro_name)
  return _internal_pro_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInfo_Member::set_pro_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.pro_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.Member.pro_name)
}
inline std::string* CMsgDOTATeamInfo_Member::mutable_pro_name() {
  std::string* _s = _internal_mutable_pro_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.Member.pro_name)
  return _s;
}
inline const std::string& CMsgDOTATeamInfo_Member::_internal_pro_name() const {
  return _impl_.pro_name_.Get();
}
inline void CMsgDOTATeamInfo_Member::_internal_set_pro_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pro_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo_Member::_internal_mutable_pro_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pro_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo_Member::release_pro_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInfo.Member.pro_name)
  if (!_internal_has_pro_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.pro_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pro_name_.IsDefault()) {
    _impl_.pro_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInfo_Member::set_allocated_pro_name(std::string* pro_name) {
  if (pro_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pro_name_.SetAllocated(pro_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pro_name_.IsDefault()) {
    _impl_.pro_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInfo.Member.pro_name)
}

// optional .Fantasy_Roles role = 8 [default = FANTASY_ROLE_UNDEFINED];
inline bool CMsgDOTATeamInfo_Member::_internal_has_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_Member::has_role() const {
  return _internal_has_role();
}
inline void CMsgDOTATeamInfo_Member::clear_role() {
  _impl_.role_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::Fantasy_Roles CMsgDOTATeamInfo_Member::_internal_role() const {
  return static_cast< ::Fantasy_Roles >(_impl_.role_);
}
inline ::Fantasy_Roles CMsgDOTATeamInfo_Member::role() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.Member.role)
  return _internal_role();
}
inline void CMsgDOTATeamInfo_Member::_internal_set_role(::Fantasy_Roles value) {
  assert(::Fantasy_Roles_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.role_ = value;
}
inline void CMsgDOTATeamInfo_Member::set_role(::Fantasy_Roles value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.Member.role)
}

// optional string real_name = 9;
inline bool CMsgDOTATeamInfo_Member::_internal_has_real_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_Member::has_real_name() const {
  return _internal_has_real_name();
}
inline void CMsgDOTATeamInfo_Member::clear_real_name() {
  _impl_.real_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTATeamInfo_Member::real_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.Member.real_name)
  return _internal_real_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInfo_Member::set_real_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.real_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.Member.real_name)
}
inline std::string* CMsgDOTATeamInfo_Member::mutable_real_name() {
  std::string* _s = _internal_mutable_real_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.Member.real_name)
  return _s;
}
inline const std::string& CMsgDOTATeamInfo_Member::_internal_real_name() const {
  return _impl_.real_name_.Get();
}
inline void CMsgDOTATeamInfo_Member::_internal_set_real_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.real_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo_Member::_internal_mutable_real_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.real_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo_Member::release_real_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInfo.Member.real_name)
  if (!_internal_has_real_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.real_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.real_name_.IsDefault()) {
    _impl_.real_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInfo_Member::set_allocated_real_name(std::string* real_name) {
  if (real_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.real_name_.SetAllocated(real_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.real_name_.IsDefault()) {
    _impl_.real_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInfo.Member.real_name)
}

// -------------------------------------------------------------------

// CMsgDOTATeamInfo_AuditEntry

// optional uint32 audit_action = 1;
inline bool CMsgDOTATeamInfo_AuditEntry::_internal_has_audit_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_AuditEntry::has_audit_action() const {
  return _internal_has_audit_action();
}
inline void CMsgDOTATeamInfo_AuditEntry::clear_audit_action() {
  _impl_.audit_action_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTATeamInfo_AuditEntry::_internal_audit_action() const {
  return _impl_.audit_action_;
}
inline uint32_t CMsgDOTATeamInfo_AuditEntry::audit_action() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.AuditEntry.audit_action)
  return _internal_audit_action();
}
inline void CMsgDOTATeamInfo_AuditEntry::_internal_set_audit_action(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.audit_action_ = value;
}
inline void CMsgDOTATeamInfo_AuditEntry::set_audit_action(uint32_t value) {
  _internal_set_audit_action(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.AuditEntry.audit_action)
}

// optional uint32 timestamp = 2;
inline bool CMsgDOTATeamInfo_AuditEntry::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_AuditEntry::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CMsgDOTATeamInfo_AuditEntry::clear_timestamp() {
  _impl_.timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTATeamInfo_AuditEntry::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint32_t CMsgDOTATeamInfo_AuditEntry::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.AuditEntry.timestamp)
  return _internal_timestamp();
}
inline void CMsgDOTATeamInfo_AuditEntry::_internal_set_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ = value;
}
inline void CMsgDOTATeamInfo_AuditEntry::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.AuditEntry.timestamp)
}

// optional uint32 account_id = 3;
inline bool CMsgDOTATeamInfo_AuditEntry::_internal_has_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo_AuditEntry::has_account_id() const {
  return _internal_has_account_id();
}
inline void CMsgDOTATeamInfo_AuditEntry::clear_account_id() {
  _impl_.account_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTATeamInfo_AuditEntry::_internal_account_id() const {
  return _impl_.account_id_;
}
inline uint32_t CMsgDOTATeamInfo_AuditEntry::account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.AuditEntry.account_id)
  return _internal_account_id();
}
inline void CMsgDOTATeamInfo_AuditEntry::_internal_set_account_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.account_id_ = value;
}
inline void CMsgDOTATeamInfo_AuditEntry::set_account_id(uint32_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.AuditEntry.account_id)
}

// -------------------------------------------------------------------

// CMsgDOTATeamInfo

// repeated .CMsgDOTATeamInfo.Member members = 1;
inline int CMsgDOTATeamInfo::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int CMsgDOTATeamInfo::members_size() const {
  return _internal_members_size();
}
inline void CMsgDOTATeamInfo::clear_members() {
  _impl_.members_.Clear();
}
inline ::CMsgDOTATeamInfo_Member* CMsgDOTATeamInfo::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.members)
  return _impl_.members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_Member >*
CMsgDOTATeamInfo::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTATeamInfo.members)
  return &_impl_.members_;
}
inline const ::CMsgDOTATeamInfo_Member& CMsgDOTATeamInfo::_internal_members(int index) const {
  return _impl_.members_.Get(index);
}
inline const ::CMsgDOTATeamInfo_Member& CMsgDOTATeamInfo::members(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.members)
  return _internal_members(index);
}
inline ::CMsgDOTATeamInfo_Member* CMsgDOTATeamInfo::_internal_add_members() {
  return _impl_.members_.Add();
}
inline ::CMsgDOTATeamInfo_Member* CMsgDOTATeamInfo::add_members() {
  ::CMsgDOTATeamInfo_Member* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:CMsgDOTATeamInfo.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_Member >&
CMsgDOTATeamInfo::members() const {
  // @@protoc_insertion_point(field_list:CMsgDOTATeamInfo.members)
  return _impl_.members_;
}

// optional uint32 team_id = 2;
inline bool CMsgDOTATeamInfo::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDOTATeamInfo::clear_team_id() {
  _impl_.team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t CMsgDOTATeamInfo::_internal_team_id() const {
  return _impl_.team_id_;
}
inline uint32_t CMsgDOTATeamInfo::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.team_id)
  return _internal_team_id();
}
inline void CMsgDOTATeamInfo::_internal_set_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.team_id_ = value;
}
inline void CMsgDOTATeamInfo::set_team_id(uint32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.team_id)
}

// optional string name = 3;
inline bool CMsgDOTATeamInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_name() const {
  return _internal_has_name();
}
inline void CMsgDOTATeamInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTATeamInfo::name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.name)
}
inline std::string* CMsgDOTATeamInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.name)
  return _s;
}
inline const std::string& CMsgDOTATeamInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDOTATeamInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInfo.name)
}

// optional string tag = 4;
inline bool CMsgDOTATeamInfo::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_tag() const {
  return _internal_has_tag();
}
inline void CMsgDOTATeamInfo::clear_tag() {
  _impl_.tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTATeamInfo::tag() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInfo::set_tag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.tag)
}
inline std::string* CMsgDOTATeamInfo::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.tag)
  return _s;
}
inline const std::string& CMsgDOTATeamInfo::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void CMsgDOTATeamInfo::_internal_set_tag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::_internal_mutable_tag() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::release_tag() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInfo.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInfo::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInfo.tag)
}

// optional uint32 time_created = 5;
inline bool CMsgDOTATeamInfo::_internal_has_time_created() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_time_created() const {
  return _internal_has_time_created();
}
inline void CMsgDOTATeamInfo::clear_time_created() {
  _impl_.time_created_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t CMsgDOTATeamInfo::_internal_time_created() const {
  return _impl_.time_created_;
}
inline uint32_t CMsgDOTATeamInfo::time_created() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.time_created)
  return _internal_time_created();
}
inline void CMsgDOTATeamInfo::_internal_set_time_created(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.time_created_ = value;
}
inline void CMsgDOTATeamInfo::set_time_created(uint32_t value) {
  _internal_set_time_created(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.time_created)
}

// optional bool pro = 6;
inline bool CMsgDOTATeamInfo::_internal_has_pro() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_pro() const {
  return _internal_has_pro();
}
inline void CMsgDOTATeamInfo::clear_pro() {
  _impl_.pro_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool CMsgDOTATeamInfo::_internal_pro() const {
  return _impl_.pro_;
}
inline bool CMsgDOTATeamInfo::pro() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.pro)
  return _internal_pro();
}
inline void CMsgDOTATeamInfo::_internal_set_pro(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.pro_ = value;
}
inline void CMsgDOTATeamInfo::set_pro(bool value) {
  _internal_set_pro(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.pro)
}

// optional bool pickup_team = 8;
inline bool CMsgDOTATeamInfo::_internal_has_pickup_team() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_pickup_team() const {
  return _internal_has_pickup_team();
}
inline void CMsgDOTATeamInfo::clear_pickup_team() {
  _impl_.pickup_team_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool CMsgDOTATeamInfo::_internal_pickup_team() const {
  return _impl_.pickup_team_;
}
inline bool CMsgDOTATeamInfo::pickup_team() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.pickup_team)
  return _internal_pickup_team();
}
inline void CMsgDOTATeamInfo::_internal_set_pickup_team(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.pickup_team_ = value;
}
inline void CMsgDOTATeamInfo::set_pickup_team(bool value) {
  _internal_set_pickup_team(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.pickup_team)
}

// optional uint64 ugc_logo = 9;
inline bool CMsgDOTATeamInfo::_internal_has_ugc_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_ugc_logo() const {
  return _internal_has_ugc_logo();
}
inline void CMsgDOTATeamInfo::clear_ugc_logo() {
  _impl_.ugc_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint64_t CMsgDOTATeamInfo::_internal_ugc_logo() const {
  return _impl_.ugc_logo_;
}
inline uint64_t CMsgDOTATeamInfo::ugc_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.ugc_logo)
  return _internal_ugc_logo();
}
inline void CMsgDOTATeamInfo::_internal_set_ugc_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.ugc_logo_ = value;
}
inline void CMsgDOTATeamInfo::set_ugc_logo(uint64_t value) {
  _internal_set_ugc_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.ugc_logo)
}

// optional uint64 ugc_base_logo = 10;
inline bool CMsgDOTATeamInfo::_internal_has_ugc_base_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_ugc_base_logo() const {
  return _internal_has_ugc_base_logo();
}
inline void CMsgDOTATeamInfo::clear_ugc_base_logo() {
  _impl_.ugc_base_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline uint64_t CMsgDOTATeamInfo::_internal_ugc_base_logo() const {
  return _impl_.ugc_base_logo_;
}
inline uint64_t CMsgDOTATeamInfo::ugc_base_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.ugc_base_logo)
  return _internal_ugc_base_logo();
}
inline void CMsgDOTATeamInfo::_internal_set_ugc_base_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.ugc_base_logo_ = value;
}
inline void CMsgDOTATeamInfo::set_ugc_base_logo(uint64_t value) {
  _internal_set_ugc_base_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.ugc_base_logo)
}

// optional uint64 ugc_banner_logo = 11;
inline bool CMsgDOTATeamInfo::_internal_has_ugc_banner_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_ugc_banner_logo() const {
  return _internal_has_ugc_banner_logo();
}
inline void CMsgDOTATeamInfo::clear_ugc_banner_logo() {
  _impl_.ugc_banner_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline uint64_t CMsgDOTATeamInfo::_internal_ugc_banner_logo() const {
  return _impl_.ugc_banner_logo_;
}
inline uint64_t CMsgDOTATeamInfo::ugc_banner_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.ugc_banner_logo)
  return _internal_ugc_banner_logo();
}
inline void CMsgDOTATeamInfo::_internal_set_ugc_banner_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.ugc_banner_logo_ = value;
}
inline void CMsgDOTATeamInfo::set_ugc_banner_logo(uint64_t value) {
  _internal_set_ugc_banner_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.ugc_banner_logo)
}

// optional uint64 ugc_sponsor_logo = 12;
inline bool CMsgDOTATeamInfo::_internal_has_ugc_sponsor_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_ugc_sponsor_logo() const {
  return _internal_has_ugc_sponsor_logo();
}
inline void CMsgDOTATeamInfo::clear_ugc_sponsor_logo() {
  _impl_.ugc_sponsor_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline uint64_t CMsgDOTATeamInfo::_internal_ugc_sponsor_logo() const {
  return _impl_.ugc_sponsor_logo_;
}
inline uint64_t CMsgDOTATeamInfo::ugc_sponsor_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.ugc_sponsor_logo)
  return _internal_ugc_sponsor_logo();
}
inline void CMsgDOTATeamInfo::_internal_set_ugc_sponsor_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.ugc_sponsor_logo_ = value;
}
inline void CMsgDOTATeamInfo::set_ugc_sponsor_logo(uint64_t value) {
  _internal_set_ugc_sponsor_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.ugc_sponsor_logo)
}

// optional string country_code = 13;
inline bool CMsgDOTATeamInfo::_internal_has_country_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_country_code() const {
  return _internal_has_country_code();
}
inline void CMsgDOTATeamInfo::clear_country_code() {
  _impl_.country_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgDOTATeamInfo::country_code() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.country_code)
  return _internal_country_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInfo::set_country_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.country_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.country_code)
}
inline std::string* CMsgDOTATeamInfo::mutable_country_code() {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.country_code)
  return _s;
}
inline const std::string& CMsgDOTATeamInfo::_internal_country_code() const {
  return _impl_.country_code_.Get();
}
inline void CMsgDOTATeamInfo::_internal_set_country_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.country_code_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::_internal_mutable_country_code() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.country_code_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::release_country_code() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInfo.country_code)
  if (!_internal_has_country_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.country_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_code_.IsDefault()) {
    _impl_.country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInfo::set_allocated_country_code(std::string* country_code) {
  if (country_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.country_code_.SetAllocated(country_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_code_.IsDefault()) {
    _impl_.country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInfo.country_code)
}

// optional string url = 14;
inline bool CMsgDOTATeamInfo::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_url() const {
  return _internal_has_url();
}
inline void CMsgDOTATeamInfo::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CMsgDOTATeamInfo::url() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInfo::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.url)
}
inline std::string* CMsgDOTATeamInfo::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.url)
  return _s;
}
inline const std::string& CMsgDOTATeamInfo::_internal_url() const {
  return _impl_.url_.Get();
}
inline void CMsgDOTATeamInfo::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::release_url() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInfo.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInfo.url)
}

// optional uint32 wins = 15;
inline bool CMsgDOTATeamInfo::_internal_has_wins() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_wins() const {
  return _internal_has_wins();
}
inline void CMsgDOTATeamInfo::clear_wins() {
  _impl_.wins_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline uint32_t CMsgDOTATeamInfo::_internal_wins() const {
  return _impl_.wins_;
}
inline uint32_t CMsgDOTATeamInfo::wins() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.wins)
  return _internal_wins();
}
inline void CMsgDOTATeamInfo::_internal_set_wins(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.wins_ = value;
}
inline void CMsgDOTATeamInfo::set_wins(uint32_t value) {
  _internal_set_wins(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.wins)
}

// optional uint32 losses = 16;
inline bool CMsgDOTATeamInfo::_internal_has_losses() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_losses() const {
  return _internal_has_losses();
}
inline void CMsgDOTATeamInfo::clear_losses() {
  _impl_.losses_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline uint32_t CMsgDOTATeamInfo::_internal_losses() const {
  return _impl_.losses_;
}
inline uint32_t CMsgDOTATeamInfo::losses() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.losses)
  return _internal_losses();
}
inline void CMsgDOTATeamInfo::_internal_set_losses(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.losses_ = value;
}
inline void CMsgDOTATeamInfo::set_losses(uint32_t value) {
  _internal_set_losses(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.losses)
}

// optional uint32 games_played_total = 19;
inline bool CMsgDOTATeamInfo::_internal_has_games_played_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_games_played_total() const {
  return _internal_has_games_played_total();
}
inline void CMsgDOTATeamInfo::clear_games_played_total() {
  _impl_.games_played_total_ = 0u;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline uint32_t CMsgDOTATeamInfo::_internal_games_played_total() const {
  return _impl_.games_played_total_;
}
inline uint32_t CMsgDOTATeamInfo::games_played_total() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.games_played_total)
  return _internal_games_played_total();
}
inline void CMsgDOTATeamInfo::_internal_set_games_played_total(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.games_played_total_ = value;
}
inline void CMsgDOTATeamInfo::set_games_played_total(uint32_t value) {
  _internal_set_games_played_total(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.games_played_total)
}

// optional uint32 games_played_matchmaking = 20;
inline bool CMsgDOTATeamInfo::_internal_has_games_played_matchmaking() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_games_played_matchmaking() const {
  return _internal_has_games_played_matchmaking();
}
inline void CMsgDOTATeamInfo::clear_games_played_matchmaking() {
  _impl_.games_played_matchmaking_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline uint32_t CMsgDOTATeamInfo::_internal_games_played_matchmaking() const {
  return _impl_.games_played_matchmaking_;
}
inline uint32_t CMsgDOTATeamInfo::games_played_matchmaking() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.games_played_matchmaking)
  return _internal_games_played_matchmaking();
}
inline void CMsgDOTATeamInfo::_internal_set_games_played_matchmaking(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.games_played_matchmaking_ = value;
}
inline void CMsgDOTATeamInfo::set_games_played_matchmaking(uint32_t value) {
  _internal_set_games_played_matchmaking(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.games_played_matchmaking)
}

// optional string url_logo = 24;
inline bool CMsgDOTATeamInfo::_internal_has_url_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_url_logo() const {
  return _internal_has_url_logo();
}
inline void CMsgDOTATeamInfo::clear_url_logo() {
  _impl_.url_logo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CMsgDOTATeamInfo::url_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.url_logo)
  return _internal_url_logo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInfo::set_url_logo(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.url_logo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.url_logo)
}
inline std::string* CMsgDOTATeamInfo::mutable_url_logo() {
  std::string* _s = _internal_mutable_url_logo();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.url_logo)
  return _s;
}
inline const std::string& CMsgDOTATeamInfo::_internal_url_logo() const {
  return _impl_.url_logo_.Get();
}
inline void CMsgDOTATeamInfo::_internal_set_url_logo(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.url_logo_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::_internal_mutable_url_logo() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.url_logo_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::release_url_logo() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInfo.url_logo)
  if (!_internal_has_url_logo()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.url_logo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_logo_.IsDefault()) {
    _impl_.url_logo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInfo::set_allocated_url_logo(std::string* url_logo) {
  if (url_logo != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.url_logo_.SetAllocated(url_logo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_logo_.IsDefault()) {
    _impl_.url_logo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInfo.url_logo)
}

// repeated uint32 registered_member_account_ids = 30;
inline int CMsgDOTATeamInfo::_internal_registered_member_account_ids_size() const {
  return _impl_.registered_member_account_ids_.size();
}
inline int CMsgDOTATeamInfo::registered_member_account_ids_size() const {
  return _internal_registered_member_account_ids_size();
}
inline void CMsgDOTATeamInfo::clear_registered_member_account_ids() {
  _impl_.registered_member_account_ids_.Clear();
}
inline uint32_t CMsgDOTATeamInfo::_internal_registered_member_account_ids(int index) const {
  return _impl_.registered_member_account_ids_.Get(index);
}
inline uint32_t CMsgDOTATeamInfo::registered_member_account_ids(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.registered_member_account_ids)
  return _internal_registered_member_account_ids(index);
}
inline void CMsgDOTATeamInfo::set_registered_member_account_ids(int index, uint32_t value) {
  _impl_.registered_member_account_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.registered_member_account_ids)
}
inline void CMsgDOTATeamInfo::_internal_add_registered_member_account_ids(uint32_t value) {
  _impl_.registered_member_account_ids_.Add(value);
}
inline void CMsgDOTATeamInfo::add_registered_member_account_ids(uint32_t value) {
  _internal_add_registered_member_account_ids(value);
  // @@protoc_insertion_point(field_add:CMsgDOTATeamInfo.registered_member_account_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgDOTATeamInfo::_internal_registered_member_account_ids() const {
  return _impl_.registered_member_account_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgDOTATeamInfo::registered_member_account_ids() const {
  // @@protoc_insertion_point(field_list:CMsgDOTATeamInfo.registered_member_account_ids)
  return _internal_registered_member_account_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgDOTATeamInfo::_internal_mutable_registered_member_account_ids() {
  return &_impl_.registered_member_account_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgDOTATeamInfo::mutable_registered_member_account_ids() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTATeamInfo.registered_member_account_ids)
  return _internal_mutable_registered_member_account_ids();
}

// optional uint32 coach_account_id = 36;
inline bool CMsgDOTATeamInfo::_internal_has_coach_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_coach_account_id() const {
  return _internal_has_coach_account_id();
}
inline void CMsgDOTATeamInfo::clear_coach_account_id() {
  _impl_.coach_account_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline uint32_t CMsgDOTATeamInfo::_internal_coach_account_id() const {
  return _impl_.coach_account_id_;
}
inline uint32_t CMsgDOTATeamInfo::coach_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.coach_account_id)
  return _internal_coach_account_id();
}
inline void CMsgDOTATeamInfo::_internal_set_coach_account_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.coach_account_id_ = value;
}
inline void CMsgDOTATeamInfo::set_coach_account_id(uint32_t value) {
  _internal_set_coach_account_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.coach_account_id)
}

// repeated .CMsgDOTATeamInfo.AuditEntry audit_entries = 31;
inline int CMsgDOTATeamInfo::_internal_audit_entries_size() const {
  return _impl_.audit_entries_.size();
}
inline int CMsgDOTATeamInfo::audit_entries_size() const {
  return _internal_audit_entries_size();
}
inline void CMsgDOTATeamInfo::clear_audit_entries() {
  _impl_.audit_entries_.Clear();
}
inline ::CMsgDOTATeamInfo_AuditEntry* CMsgDOTATeamInfo::mutable_audit_entries(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.audit_entries)
  return _impl_.audit_entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_AuditEntry >*
CMsgDOTATeamInfo::mutable_audit_entries() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTATeamInfo.audit_entries)
  return &_impl_.audit_entries_;
}
inline const ::CMsgDOTATeamInfo_AuditEntry& CMsgDOTATeamInfo::_internal_audit_entries(int index) const {
  return _impl_.audit_entries_.Get(index);
}
inline const ::CMsgDOTATeamInfo_AuditEntry& CMsgDOTATeamInfo::audit_entries(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.audit_entries)
  return _internal_audit_entries(index);
}
inline ::CMsgDOTATeamInfo_AuditEntry* CMsgDOTATeamInfo::_internal_add_audit_entries() {
  return _impl_.audit_entries_.Add();
}
inline ::CMsgDOTATeamInfo_AuditEntry* CMsgDOTATeamInfo::add_audit_entries() {
  ::CMsgDOTATeamInfo_AuditEntry* _add = _internal_add_audit_entries();
  // @@protoc_insertion_point(field_add:CMsgDOTATeamInfo.audit_entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_AuditEntry >&
CMsgDOTATeamInfo::audit_entries() const {
  // @@protoc_insertion_point(field_list:CMsgDOTATeamInfo.audit_entries)
  return _impl_.audit_entries_;
}

// optional .ELeagueRegion region = 29 [default = LEAGUE_REGION_UNSET];
inline bool CMsgDOTATeamInfo::_internal_has_region() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_region() const {
  return _internal_has_region();
}
inline void CMsgDOTATeamInfo::clear_region() {
  _impl_.region_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::ELeagueRegion CMsgDOTATeamInfo::_internal_region() const {
  return static_cast< ::ELeagueRegion >(_impl_.region_);
}
inline ::ELeagueRegion CMsgDOTATeamInfo::region() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.region)
  return _internal_region();
}
inline void CMsgDOTATeamInfo::_internal_set_region(::ELeagueRegion value) {
  assert(::ELeagueRegion_IsValid(value));
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.region_ = value;
}
inline void CMsgDOTATeamInfo::set_region(::ELeagueRegion value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.region)
}

// optional string abbreviation = 32;
inline bool CMsgDOTATeamInfo::_internal_has_abbreviation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_abbreviation() const {
  return _internal_has_abbreviation();
}
inline void CMsgDOTATeamInfo::clear_abbreviation() {
  _impl_.abbreviation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CMsgDOTATeamInfo::abbreviation() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.abbreviation)
  return _internal_abbreviation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInfo::set_abbreviation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.abbreviation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.abbreviation)
}
inline std::string* CMsgDOTATeamInfo::mutable_abbreviation() {
  std::string* _s = _internal_mutable_abbreviation();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.abbreviation)
  return _s;
}
inline const std::string& CMsgDOTATeamInfo::_internal_abbreviation() const {
  return _impl_.abbreviation_.Get();
}
inline void CMsgDOTATeamInfo::_internal_set_abbreviation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.abbreviation_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::_internal_mutable_abbreviation() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.abbreviation_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::release_abbreviation() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInfo.abbreviation)
  if (!_internal_has_abbreviation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.abbreviation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.abbreviation_.IsDefault()) {
    _impl_.abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInfo::set_allocated_abbreviation(std::string* abbreviation) {
  if (abbreviation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.abbreviation_.SetAllocated(abbreviation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.abbreviation_.IsDefault()) {
    _impl_.abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInfo.abbreviation)
}

// repeated .CMsgDOTATeamInfo.MemberStats member_stats = 33;
inline int CMsgDOTATeamInfo::_internal_member_stats_size() const {
  return _impl_.member_stats_.size();
}
inline int CMsgDOTATeamInfo::member_stats_size() const {
  return _internal_member_stats_size();
}
inline void CMsgDOTATeamInfo::clear_member_stats() {
  _impl_.member_stats_.Clear();
}
inline ::CMsgDOTATeamInfo_MemberStats* CMsgDOTATeamInfo::mutable_member_stats(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.member_stats)
  return _impl_.member_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_MemberStats >*
CMsgDOTATeamInfo::mutable_member_stats() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTATeamInfo.member_stats)
  return &_impl_.member_stats_;
}
inline const ::CMsgDOTATeamInfo_MemberStats& CMsgDOTATeamInfo::_internal_member_stats(int index) const {
  return _impl_.member_stats_.Get(index);
}
inline const ::CMsgDOTATeamInfo_MemberStats& CMsgDOTATeamInfo::member_stats(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.member_stats)
  return _internal_member_stats(index);
}
inline ::CMsgDOTATeamInfo_MemberStats* CMsgDOTATeamInfo::_internal_add_member_stats() {
  return _impl_.member_stats_.Add();
}
inline ::CMsgDOTATeamInfo_MemberStats* CMsgDOTATeamInfo::add_member_stats() {
  ::CMsgDOTATeamInfo_MemberStats* _add = _internal_add_member_stats();
  // @@protoc_insertion_point(field_add:CMsgDOTATeamInfo.member_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_MemberStats >&
CMsgDOTATeamInfo::member_stats() const {
  // @@protoc_insertion_point(field_list:CMsgDOTATeamInfo.member_stats)
  return _impl_.member_stats_;
}

// optional .CMsgDOTATeamInfo.TeamStats team_stats = 34;
inline bool CMsgDOTATeamInfo::_internal_has_team_stats() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.team_stats_ != nullptr);
  return value;
}
inline bool CMsgDOTATeamInfo::has_team_stats() const {
  return _internal_has_team_stats();
}
inline void CMsgDOTATeamInfo::clear_team_stats() {
  if (_impl_.team_stats_ != nullptr) _impl_.team_stats_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::CMsgDOTATeamInfo_TeamStats& CMsgDOTATeamInfo::_internal_team_stats() const {
  const ::CMsgDOTATeamInfo_TeamStats* p = _impl_.team_stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgDOTATeamInfo_TeamStats&>(
      ::_CMsgDOTATeamInfo_TeamStats_default_instance_);
}
inline const ::CMsgDOTATeamInfo_TeamStats& CMsgDOTATeamInfo::team_stats() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.team_stats)
  return _internal_team_stats();
}
inline void CMsgDOTATeamInfo::unsafe_arena_set_allocated_team_stats(
    ::CMsgDOTATeamInfo_TeamStats* team_stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.team_stats_);
  }
  _impl_.team_stats_ = team_stats;
  if (team_stats) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDOTATeamInfo.team_stats)
}
inline ::CMsgDOTATeamInfo_TeamStats* CMsgDOTATeamInfo::release_team_stats() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::CMsgDOTATeamInfo_TeamStats* temp = _impl_.team_stats_;
  _impl_.team_stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgDOTATeamInfo_TeamStats* CMsgDOTATeamInfo::unsafe_arena_release_team_stats() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInfo.team_stats)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::CMsgDOTATeamInfo_TeamStats* temp = _impl_.team_stats_;
  _impl_.team_stats_ = nullptr;
  return temp;
}
inline ::CMsgDOTATeamInfo_TeamStats* CMsgDOTATeamInfo::_internal_mutable_team_stats() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.team_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgDOTATeamInfo_TeamStats>(GetArenaForAllocation());
    _impl_.team_stats_ = p;
  }
  return _impl_.team_stats_;
}
inline ::CMsgDOTATeamInfo_TeamStats* CMsgDOTATeamInfo::mutable_team_stats() {
  ::CMsgDOTATeamInfo_TeamStats* _msg = _internal_mutable_team_stats();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.team_stats)
  return _msg;
}
inline void CMsgDOTATeamInfo::set_allocated_team_stats(::CMsgDOTATeamInfo_TeamStats* team_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.team_stats_;
  }
  if (team_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(team_stats);
    if (message_arena != submessage_arena) {
      team_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, team_stats, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.team_stats_ = team_stats;
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInfo.team_stats)
}

// repeated .CMsgDOTATeamInfo.DPCResult dpc_results = 35;
inline int CMsgDOTATeamInfo::_internal_dpc_results_size() const {
  return _impl_.dpc_results_.size();
}
inline int CMsgDOTATeamInfo::dpc_results_size() const {
  return _internal_dpc_results_size();
}
inline void CMsgDOTATeamInfo::clear_dpc_results() {
  _impl_.dpc_results_.Clear();
}
inline ::CMsgDOTATeamInfo_DPCResult* CMsgDOTATeamInfo::mutable_dpc_results(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.dpc_results)
  return _impl_.dpc_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_DPCResult >*
CMsgDOTATeamInfo::mutable_dpc_results() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTATeamInfo.dpc_results)
  return &_impl_.dpc_results_;
}
inline const ::CMsgDOTATeamInfo_DPCResult& CMsgDOTATeamInfo::_internal_dpc_results(int index) const {
  return _impl_.dpc_results_.Get(index);
}
inline const ::CMsgDOTATeamInfo_DPCResult& CMsgDOTATeamInfo::dpc_results(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.dpc_results)
  return _internal_dpc_results(index);
}
inline ::CMsgDOTATeamInfo_DPCResult* CMsgDOTATeamInfo::_internal_add_dpc_results() {
  return _impl_.dpc_results_.Add();
}
inline ::CMsgDOTATeamInfo_DPCResult* CMsgDOTATeamInfo::add_dpc_results() {
  ::CMsgDOTATeamInfo_DPCResult* _add = _internal_add_dpc_results();
  // @@protoc_insertion_point(field_add:CMsgDOTATeamInfo.dpc_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo_DPCResult >&
CMsgDOTATeamInfo::dpc_results() const {
  // @@protoc_insertion_point(field_list:CMsgDOTATeamInfo.dpc_results)
  return _impl_.dpc_results_;
}

// optional string color_primary = 37;
inline bool CMsgDOTATeamInfo::_internal_has_color_primary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_color_primary() const {
  return _internal_has_color_primary();
}
inline void CMsgDOTATeamInfo::clear_color_primary() {
  _impl_.color_primary_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CMsgDOTATeamInfo::color_primary() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.color_primary)
  return _internal_color_primary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInfo::set_color_primary(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.color_primary_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.color_primary)
}
inline std::string* CMsgDOTATeamInfo::mutable_color_primary() {
  std::string* _s = _internal_mutable_color_primary();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.color_primary)
  return _s;
}
inline const std::string& CMsgDOTATeamInfo::_internal_color_primary() const {
  return _impl_.color_primary_.Get();
}
inline void CMsgDOTATeamInfo::_internal_set_color_primary(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.color_primary_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::_internal_mutable_color_primary() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.color_primary_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::release_color_primary() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInfo.color_primary)
  if (!_internal_has_color_primary()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.color_primary_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_primary_.IsDefault()) {
    _impl_.color_primary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInfo::set_allocated_color_primary(std::string* color_primary) {
  if (color_primary != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.color_primary_.SetAllocated(color_primary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_primary_.IsDefault()) {
    _impl_.color_primary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInfo.color_primary)
}

// optional string color_secondary = 38;
inline bool CMsgDOTATeamInfo::_internal_has_color_secondary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_color_secondary() const {
  return _internal_has_color_secondary();
}
inline void CMsgDOTATeamInfo::clear_color_secondary() {
  _impl_.color_secondary_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CMsgDOTATeamInfo::color_secondary() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.color_secondary)
  return _internal_color_secondary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInfo::set_color_secondary(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.color_secondary_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.color_secondary)
}
inline std::string* CMsgDOTATeamInfo::mutable_color_secondary() {
  std::string* _s = _internal_mutable_color_secondary();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfo.color_secondary)
  return _s;
}
inline const std::string& CMsgDOTATeamInfo::_internal_color_secondary() const {
  return _impl_.color_secondary_.Get();
}
inline void CMsgDOTATeamInfo::_internal_set_color_secondary(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.color_secondary_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::_internal_mutable_color_secondary() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.color_secondary_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInfo::release_color_secondary() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInfo.color_secondary)
  if (!_internal_has_color_secondary()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.color_secondary_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_secondary_.IsDefault()) {
    _impl_.color_secondary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInfo::set_allocated_color_secondary(std::string* color_secondary) {
  if (color_secondary != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.color_secondary_.SetAllocated(color_secondary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_secondary_.IsDefault()) {
    _impl_.color_secondary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInfo.color_secondary)
}

// optional uint32 team_captain = 39;
inline bool CMsgDOTATeamInfo::_internal_has_team_captain() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CMsgDOTATeamInfo::has_team_captain() const {
  return _internal_has_team_captain();
}
inline void CMsgDOTATeamInfo::clear_team_captain() {
  _impl_.team_captain_ = 0u;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline uint32_t CMsgDOTATeamInfo::_internal_team_captain() const {
  return _impl_.team_captain_;
}
inline uint32_t CMsgDOTATeamInfo::team_captain() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfo.team_captain)
  return _internal_team_captain();
}
inline void CMsgDOTATeamInfo::_internal_set_team_captain(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.team_captain_ = value;
}
inline void CMsgDOTATeamInfo::set_team_captain(uint32_t value) {
  _internal_set_team_captain(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInfo.team_captain)
}

// -------------------------------------------------------------------

// CMsgDOTATeamsInfo

// optional uint32 league_id = 1;
inline bool CMsgDOTATeamsInfo::_internal_has_league_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamsInfo::has_league_id() const {
  return _internal_has_league_id();
}
inline void CMsgDOTATeamsInfo::clear_league_id() {
  _impl_.league_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTATeamsInfo::_internal_league_id() const {
  return _impl_.league_id_;
}
inline uint32_t CMsgDOTATeamsInfo::league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamsInfo.league_id)
  return _internal_league_id();
}
inline void CMsgDOTATeamsInfo::_internal_set_league_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.league_id_ = value;
}
inline void CMsgDOTATeamsInfo::set_league_id(uint32_t value) {
  _internal_set_league_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamsInfo.league_id)
}

// repeated .CMsgDOTATeamInfo teams = 2;
inline int CMsgDOTATeamsInfo::_internal_teams_size() const {
  return _impl_.teams_.size();
}
inline int CMsgDOTATeamsInfo::teams_size() const {
  return _internal_teams_size();
}
inline void CMsgDOTATeamsInfo::clear_teams() {
  _impl_.teams_.Clear();
}
inline ::CMsgDOTATeamInfo* CMsgDOTATeamsInfo::mutable_teams(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamsInfo.teams)
  return _impl_.teams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo >*
CMsgDOTATeamsInfo::mutable_teams() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTATeamsInfo.teams)
  return &_impl_.teams_;
}
inline const ::CMsgDOTATeamInfo& CMsgDOTATeamsInfo::_internal_teams(int index) const {
  return _impl_.teams_.Get(index);
}
inline const ::CMsgDOTATeamInfo& CMsgDOTATeamsInfo::teams(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamsInfo.teams)
  return _internal_teams(index);
}
inline ::CMsgDOTATeamInfo* CMsgDOTATeamsInfo::_internal_add_teams() {
  return _impl_.teams_.Add();
}
inline ::CMsgDOTATeamInfo* CMsgDOTATeamsInfo::add_teams() {
  ::CMsgDOTATeamInfo* _add = _internal_add_teams();
  // @@protoc_insertion_point(field_add:CMsgDOTATeamsInfo.teams)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo >&
CMsgDOTATeamsInfo::teams() const {
  // @@protoc_insertion_point(field_list:CMsgDOTATeamsInfo.teams)
  return _impl_.teams_;
}

// -------------------------------------------------------------------

// CMsgDOTATeamInfoList

// repeated .CMsgDOTATeamInfo teams = 1;
inline int CMsgDOTATeamInfoList::_internal_teams_size() const {
  return _impl_.teams_.size();
}
inline int CMsgDOTATeamInfoList::teams_size() const {
  return _internal_teams_size();
}
inline void CMsgDOTATeamInfoList::clear_teams() {
  _impl_.teams_.Clear();
}
inline ::CMsgDOTATeamInfo* CMsgDOTATeamInfoList::mutable_teams(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInfoList.teams)
  return _impl_.teams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo >*
CMsgDOTATeamInfoList::mutable_teams() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTATeamInfoList.teams)
  return &_impl_.teams_;
}
inline const ::CMsgDOTATeamInfo& CMsgDOTATeamInfoList::_internal_teams(int index) const {
  return _impl_.teams_.Get(index);
}
inline const ::CMsgDOTATeamInfo& CMsgDOTATeamInfoList::teams(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInfoList.teams)
  return _internal_teams(index);
}
inline ::CMsgDOTATeamInfo* CMsgDOTATeamInfoList::_internal_add_teams() {
  return _impl_.teams_.Add();
}
inline ::CMsgDOTATeamInfo* CMsgDOTATeamInfoList::add_teams() {
  ::CMsgDOTATeamInfo* _add = _internal_add_teams();
  // @@protoc_insertion_point(field_add:CMsgDOTATeamInfoList.teams)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTATeamInfo >&
CMsgDOTATeamInfoList::teams() const {
  // @@protoc_insertion_point(field_list:CMsgDOTATeamInfoList.teams)
  return _impl_.teams_;
}

// -------------------------------------------------------------------

// CMsgDOTAMyTeamInfoRequest

// -------------------------------------------------------------------

// CMsgDOTACreateTeam

// optional string name = 1;
inline bool CMsgDOTACreateTeam::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTACreateTeam::has_name() const {
  return _internal_has_name();
}
inline void CMsgDOTACreateTeam::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTACreateTeam::name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateTeam.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTACreateTeam::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTACreateTeam.name)
}
inline std::string* CMsgDOTACreateTeam::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTACreateTeam.name)
  return _s;
}
inline const std::string& CMsgDOTACreateTeam::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDOTACreateTeam::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTACreateTeam::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTACreateTeam::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTACreateTeam.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTACreateTeam::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTACreateTeam.name)
}

// optional string tag = 2;
inline bool CMsgDOTACreateTeam::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTACreateTeam::has_tag() const {
  return _internal_has_tag();
}
inline void CMsgDOTACreateTeam::clear_tag() {
  _impl_.tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTACreateTeam::tag() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateTeam.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTACreateTeam::set_tag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTACreateTeam.tag)
}
inline std::string* CMsgDOTACreateTeam::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:CMsgDOTACreateTeam.tag)
  return _s;
}
inline const std::string& CMsgDOTACreateTeam::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void CMsgDOTACreateTeam::_internal_set_tag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTACreateTeam::_internal_mutable_tag() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTACreateTeam::release_tag() {
  // @@protoc_insertion_point(field_release:CMsgDOTACreateTeam.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTACreateTeam::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTACreateTeam.tag)
}

// optional uint64 logo = 3;
inline bool CMsgDOTACreateTeam::_internal_has_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTACreateTeam::has_logo() const {
  return _internal_has_logo();
}
inline void CMsgDOTACreateTeam::clear_logo() {
  _impl_.logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t CMsgDOTACreateTeam::_internal_logo() const {
  return _impl_.logo_;
}
inline uint64_t CMsgDOTACreateTeam::logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateTeam.logo)
  return _internal_logo();
}
inline void CMsgDOTACreateTeam::_internal_set_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.logo_ = value;
}
inline void CMsgDOTACreateTeam::set_logo(uint64_t value) {
  _internal_set_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACreateTeam.logo)
}

// optional uint64 base_logo = 4;
inline bool CMsgDOTACreateTeam::_internal_has_base_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTACreateTeam::has_base_logo() const {
  return _internal_has_base_logo();
}
inline void CMsgDOTACreateTeam::clear_base_logo() {
  _impl_.base_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t CMsgDOTACreateTeam::_internal_base_logo() const {
  return _impl_.base_logo_;
}
inline uint64_t CMsgDOTACreateTeam::base_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateTeam.base_logo)
  return _internal_base_logo();
}
inline void CMsgDOTACreateTeam::_internal_set_base_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.base_logo_ = value;
}
inline void CMsgDOTACreateTeam::set_base_logo(uint64_t value) {
  _internal_set_base_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACreateTeam.base_logo)
}

// optional uint64 banner_logo = 5;
inline bool CMsgDOTACreateTeam::_internal_has_banner_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTACreateTeam::has_banner_logo() const {
  return _internal_has_banner_logo();
}
inline void CMsgDOTACreateTeam::clear_banner_logo() {
  _impl_.banner_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint64_t CMsgDOTACreateTeam::_internal_banner_logo() const {
  return _impl_.banner_logo_;
}
inline uint64_t CMsgDOTACreateTeam::banner_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateTeam.banner_logo)
  return _internal_banner_logo();
}
inline void CMsgDOTACreateTeam::_internal_set_banner_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.banner_logo_ = value;
}
inline void CMsgDOTACreateTeam::set_banner_logo(uint64_t value) {
  _internal_set_banner_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACreateTeam.banner_logo)
}

// optional uint64 sponsor_logo = 6;
inline bool CMsgDOTACreateTeam::_internal_has_sponsor_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTACreateTeam::has_sponsor_logo() const {
  return _internal_has_sponsor_logo();
}
inline void CMsgDOTACreateTeam::clear_sponsor_logo() {
  _impl_.sponsor_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint64_t CMsgDOTACreateTeam::_internal_sponsor_logo() const {
  return _impl_.sponsor_logo_;
}
inline uint64_t CMsgDOTACreateTeam::sponsor_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateTeam.sponsor_logo)
  return _internal_sponsor_logo();
}
inline void CMsgDOTACreateTeam::_internal_set_sponsor_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.sponsor_logo_ = value;
}
inline void CMsgDOTACreateTeam::set_sponsor_logo(uint64_t value) {
  _internal_set_sponsor_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACreateTeam.sponsor_logo)
}

// optional string country_code = 7;
inline bool CMsgDOTACreateTeam::_internal_has_country_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTACreateTeam::has_country_code() const {
  return _internal_has_country_code();
}
inline void CMsgDOTACreateTeam::clear_country_code() {
  _impl_.country_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgDOTACreateTeam::country_code() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateTeam.country_code)
  return _internal_country_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTACreateTeam::set_country_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.country_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTACreateTeam.country_code)
}
inline std::string* CMsgDOTACreateTeam::mutable_country_code() {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:CMsgDOTACreateTeam.country_code)
  return _s;
}
inline const std::string& CMsgDOTACreateTeam::_internal_country_code() const {
  return _impl_.country_code_.Get();
}
inline void CMsgDOTACreateTeam::_internal_set_country_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.country_code_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTACreateTeam::_internal_mutable_country_code() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.country_code_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTACreateTeam::release_country_code() {
  // @@protoc_insertion_point(field_release:CMsgDOTACreateTeam.country_code)
  if (!_internal_has_country_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.country_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_code_.IsDefault()) {
    _impl_.country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTACreateTeam::set_allocated_country_code(std::string* country_code) {
  if (country_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.country_code_.SetAllocated(country_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_code_.IsDefault()) {
    _impl_.country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTACreateTeam.country_code)
}

// optional string url = 8;
inline bool CMsgDOTACreateTeam::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTACreateTeam::has_url() const {
  return _internal_has_url();
}
inline void CMsgDOTACreateTeam::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CMsgDOTACreateTeam::url() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateTeam.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTACreateTeam::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTACreateTeam.url)
}
inline std::string* CMsgDOTACreateTeam::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:CMsgDOTACreateTeam.url)
  return _s;
}
inline const std::string& CMsgDOTACreateTeam::_internal_url() const {
  return _impl_.url_.Get();
}
inline void CMsgDOTACreateTeam::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTACreateTeam::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTACreateTeam::release_url() {
  // @@protoc_insertion_point(field_release:CMsgDOTACreateTeam.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTACreateTeam::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTACreateTeam.url)
}

// optional bool pickup_team = 9;
inline bool CMsgDOTACreateTeam::_internal_has_pickup_team() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTACreateTeam::has_pickup_team() const {
  return _internal_has_pickup_team();
}
inline void CMsgDOTACreateTeam::clear_pickup_team() {
  _impl_.pickup_team_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool CMsgDOTACreateTeam::_internal_pickup_team() const {
  return _impl_.pickup_team_;
}
inline bool CMsgDOTACreateTeam::pickup_team() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateTeam.pickup_team)
  return _internal_pickup_team();
}
inline void CMsgDOTACreateTeam::_internal_set_pickup_team(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.pickup_team_ = value;
}
inline void CMsgDOTACreateTeam::set_pickup_team(bool value) {
  _internal_set_pickup_team(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACreateTeam.pickup_team)
}

// optional string abbreviation = 10;
inline bool CMsgDOTACreateTeam::_internal_has_abbreviation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTACreateTeam::has_abbreviation() const {
  return _internal_has_abbreviation();
}
inline void CMsgDOTACreateTeam::clear_abbreviation() {
  _impl_.abbreviation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CMsgDOTACreateTeam::abbreviation() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateTeam.abbreviation)
  return _internal_abbreviation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTACreateTeam::set_abbreviation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.abbreviation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTACreateTeam.abbreviation)
}
inline std::string* CMsgDOTACreateTeam::mutable_abbreviation() {
  std::string* _s = _internal_mutable_abbreviation();
  // @@protoc_insertion_point(field_mutable:CMsgDOTACreateTeam.abbreviation)
  return _s;
}
inline const std::string& CMsgDOTACreateTeam::_internal_abbreviation() const {
  return _impl_.abbreviation_.Get();
}
inline void CMsgDOTACreateTeam::_internal_set_abbreviation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.abbreviation_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTACreateTeam::_internal_mutable_abbreviation() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.abbreviation_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTACreateTeam::release_abbreviation() {
  // @@protoc_insertion_point(field_release:CMsgDOTACreateTeam.abbreviation)
  if (!_internal_has_abbreviation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.abbreviation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.abbreviation_.IsDefault()) {
    _impl_.abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTACreateTeam::set_allocated_abbreviation(std::string* abbreviation) {
  if (abbreviation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.abbreviation_.SetAllocated(abbreviation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.abbreviation_.IsDefault()) {
    _impl_.abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTACreateTeam.abbreviation)
}

// -------------------------------------------------------------------

// CMsgDOTACreateTeamResponse

// optional .CMsgDOTACreateTeamResponse.Result result = 1 [default = INVALID];
inline bool CMsgDOTACreateTeamResponse::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTACreateTeamResponse::has_result() const {
  return _internal_has_result();
}
inline void CMsgDOTACreateTeamResponse::clear_result() {
  _impl_.result_ = -1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::CMsgDOTACreateTeamResponse_Result CMsgDOTACreateTeamResponse::_internal_result() const {
  return static_cast< ::CMsgDOTACreateTeamResponse_Result >(_impl_.result_);
}
inline ::CMsgDOTACreateTeamResponse_Result CMsgDOTACreateTeamResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateTeamResponse.result)
  return _internal_result();
}
inline void CMsgDOTACreateTeamResponse::_internal_set_result(::CMsgDOTACreateTeamResponse_Result value) {
  assert(::CMsgDOTACreateTeamResponse_Result_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.result_ = value;
}
inline void CMsgDOTACreateTeamResponse::set_result(::CMsgDOTACreateTeamResponse_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACreateTeamResponse.result)
}

// optional uint32 team_id = 2;
inline bool CMsgDOTACreateTeamResponse::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTACreateTeamResponse::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDOTACreateTeamResponse::clear_team_id() {
  _impl_.team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTACreateTeamResponse::_internal_team_id() const {
  return _impl_.team_id_;
}
inline uint32_t CMsgDOTACreateTeamResponse::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACreateTeamResponse.team_id)
  return _internal_team_id();
}
inline void CMsgDOTACreateTeamResponse::_internal_set_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.team_id_ = value;
}
inline void CMsgDOTACreateTeamResponse::set_team_id(uint32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACreateTeamResponse.team_id)
}

// -------------------------------------------------------------------

// CMsgDOTAEditTeamDetails

// optional uint32 team_id = 1;
inline bool CMsgDOTAEditTeamDetails::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTAEditTeamDetails::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDOTAEditTeamDetails::clear_team_id() {
  _impl_.team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CMsgDOTAEditTeamDetails::_internal_team_id() const {
  return _impl_.team_id_;
}
inline uint32_t CMsgDOTAEditTeamDetails::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditTeamDetails.team_id)
  return _internal_team_id();
}
inline void CMsgDOTAEditTeamDetails::_internal_set_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.team_id_ = value;
}
inline void CMsgDOTAEditTeamDetails::set_team_id(uint32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAEditTeamDetails.team_id)
}

// optional string name = 2;
inline bool CMsgDOTAEditTeamDetails::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTAEditTeamDetails::has_name() const {
  return _internal_has_name();
}
inline void CMsgDOTAEditTeamDetails::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTAEditTeamDetails::name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditTeamDetails.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTAEditTeamDetails::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTAEditTeamDetails.name)
}
inline std::string* CMsgDOTAEditTeamDetails::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTAEditTeamDetails.name)
  return _s;
}
inline const std::string& CMsgDOTAEditTeamDetails::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDOTAEditTeamDetails::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTAEditTeamDetails::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTAEditTeamDetails::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTAEditTeamDetails.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTAEditTeamDetails::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAEditTeamDetails.name)
}

// optional string tag = 3;
inline bool CMsgDOTAEditTeamDetails::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTAEditTeamDetails::has_tag() const {
  return _internal_has_tag();
}
inline void CMsgDOTAEditTeamDetails::clear_tag() {
  _impl_.tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTAEditTeamDetails::tag() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditTeamDetails.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTAEditTeamDetails::set_tag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTAEditTeamDetails.tag)
}
inline std::string* CMsgDOTAEditTeamDetails::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:CMsgDOTAEditTeamDetails.tag)
  return _s;
}
inline const std::string& CMsgDOTAEditTeamDetails::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void CMsgDOTAEditTeamDetails::_internal_set_tag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTAEditTeamDetails::_internal_mutable_tag() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTAEditTeamDetails::release_tag() {
  // @@protoc_insertion_point(field_release:CMsgDOTAEditTeamDetails.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTAEditTeamDetails::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAEditTeamDetails.tag)
}

// optional uint64 logo = 4;
inline bool CMsgDOTAEditTeamDetails::_internal_has_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTAEditTeamDetails::has_logo() const {
  return _internal_has_logo();
}
inline void CMsgDOTAEditTeamDetails::clear_logo() {
  _impl_.logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t CMsgDOTAEditTeamDetails::_internal_logo() const {
  return _impl_.logo_;
}
inline uint64_t CMsgDOTAEditTeamDetails::logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditTeamDetails.logo)
  return _internal_logo();
}
inline void CMsgDOTAEditTeamDetails::_internal_set_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.logo_ = value;
}
inline void CMsgDOTAEditTeamDetails::set_logo(uint64_t value) {
  _internal_set_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAEditTeamDetails.logo)
}

// optional uint64 base_logo = 5;
inline bool CMsgDOTAEditTeamDetails::_internal_has_base_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTAEditTeamDetails::has_base_logo() const {
  return _internal_has_base_logo();
}
inline void CMsgDOTAEditTeamDetails::clear_base_logo() {
  _impl_.base_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t CMsgDOTAEditTeamDetails::_internal_base_logo() const {
  return _impl_.base_logo_;
}
inline uint64_t CMsgDOTAEditTeamDetails::base_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditTeamDetails.base_logo)
  return _internal_base_logo();
}
inline void CMsgDOTAEditTeamDetails::_internal_set_base_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.base_logo_ = value;
}
inline void CMsgDOTAEditTeamDetails::set_base_logo(uint64_t value) {
  _internal_set_base_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAEditTeamDetails.base_logo)
}

// optional uint64 banner_logo = 6;
inline bool CMsgDOTAEditTeamDetails::_internal_has_banner_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTAEditTeamDetails::has_banner_logo() const {
  return _internal_has_banner_logo();
}
inline void CMsgDOTAEditTeamDetails::clear_banner_logo() {
  _impl_.banner_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint64_t CMsgDOTAEditTeamDetails::_internal_banner_logo() const {
  return _impl_.banner_logo_;
}
inline uint64_t CMsgDOTAEditTeamDetails::banner_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditTeamDetails.banner_logo)
  return _internal_banner_logo();
}
inline void CMsgDOTAEditTeamDetails::_internal_set_banner_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.banner_logo_ = value;
}
inline void CMsgDOTAEditTeamDetails::set_banner_logo(uint64_t value) {
  _internal_set_banner_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAEditTeamDetails.banner_logo)
}

// optional uint64 sponsor_logo = 7;
inline bool CMsgDOTAEditTeamDetails::_internal_has_sponsor_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDOTAEditTeamDetails::has_sponsor_logo() const {
  return _internal_has_sponsor_logo();
}
inline void CMsgDOTAEditTeamDetails::clear_sponsor_logo() {
  _impl_.sponsor_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint64_t CMsgDOTAEditTeamDetails::_internal_sponsor_logo() const {
  return _impl_.sponsor_logo_;
}
inline uint64_t CMsgDOTAEditTeamDetails::sponsor_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditTeamDetails.sponsor_logo)
  return _internal_sponsor_logo();
}
inline void CMsgDOTAEditTeamDetails::_internal_set_sponsor_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.sponsor_logo_ = value;
}
inline void CMsgDOTAEditTeamDetails::set_sponsor_logo(uint64_t value) {
  _internal_set_sponsor_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAEditTeamDetails.sponsor_logo)
}

// optional string country_code = 8;
inline bool CMsgDOTAEditTeamDetails::_internal_has_country_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTAEditTeamDetails::has_country_code() const {
  return _internal_has_country_code();
}
inline void CMsgDOTAEditTeamDetails::clear_country_code() {
  _impl_.country_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgDOTAEditTeamDetails::country_code() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditTeamDetails.country_code)
  return _internal_country_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTAEditTeamDetails::set_country_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.country_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTAEditTeamDetails.country_code)
}
inline std::string* CMsgDOTAEditTeamDetails::mutable_country_code() {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:CMsgDOTAEditTeamDetails.country_code)
  return _s;
}
inline const std::string& CMsgDOTAEditTeamDetails::_internal_country_code() const {
  return _impl_.country_code_.Get();
}
inline void CMsgDOTAEditTeamDetails::_internal_set_country_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.country_code_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTAEditTeamDetails::_internal_mutable_country_code() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.country_code_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTAEditTeamDetails::release_country_code() {
  // @@protoc_insertion_point(field_release:CMsgDOTAEditTeamDetails.country_code)
  if (!_internal_has_country_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.country_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_code_.IsDefault()) {
    _impl_.country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTAEditTeamDetails::set_allocated_country_code(std::string* country_code) {
  if (country_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.country_code_.SetAllocated(country_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_code_.IsDefault()) {
    _impl_.country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAEditTeamDetails.country_code)
}

// optional string url = 9;
inline bool CMsgDOTAEditTeamDetails::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTAEditTeamDetails::has_url() const {
  return _internal_has_url();
}
inline void CMsgDOTAEditTeamDetails::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CMsgDOTAEditTeamDetails::url() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditTeamDetails.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTAEditTeamDetails::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTAEditTeamDetails.url)
}
inline std::string* CMsgDOTAEditTeamDetails::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:CMsgDOTAEditTeamDetails.url)
  return _s;
}
inline const std::string& CMsgDOTAEditTeamDetails::_internal_url() const {
  return _impl_.url_.Get();
}
inline void CMsgDOTAEditTeamDetails::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTAEditTeamDetails::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTAEditTeamDetails::release_url() {
  // @@protoc_insertion_point(field_release:CMsgDOTAEditTeamDetails.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTAEditTeamDetails::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAEditTeamDetails.url)
}

// optional bool in_use_by_party = 10;
inline bool CMsgDOTAEditTeamDetails::_internal_has_in_use_by_party() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTAEditTeamDetails::has_in_use_by_party() const {
  return _internal_has_in_use_by_party();
}
inline void CMsgDOTAEditTeamDetails::clear_in_use_by_party() {
  _impl_.in_use_by_party_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool CMsgDOTAEditTeamDetails::_internal_in_use_by_party() const {
  return _impl_.in_use_by_party_;
}
inline bool CMsgDOTAEditTeamDetails::in_use_by_party() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditTeamDetails.in_use_by_party)
  return _internal_in_use_by_party();
}
inline void CMsgDOTAEditTeamDetails::_internal_set_in_use_by_party(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.in_use_by_party_ = value;
}
inline void CMsgDOTAEditTeamDetails::set_in_use_by_party(bool value) {
  _internal_set_in_use_by_party(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAEditTeamDetails.in_use_by_party)
}

// optional string abbreviation = 11;
inline bool CMsgDOTAEditTeamDetails::_internal_has_abbreviation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTAEditTeamDetails::has_abbreviation() const {
  return _internal_has_abbreviation();
}
inline void CMsgDOTAEditTeamDetails::clear_abbreviation() {
  _impl_.abbreviation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CMsgDOTAEditTeamDetails::abbreviation() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditTeamDetails.abbreviation)
  return _internal_abbreviation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTAEditTeamDetails::set_abbreviation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.abbreviation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTAEditTeamDetails.abbreviation)
}
inline std::string* CMsgDOTAEditTeamDetails::mutable_abbreviation() {
  std::string* _s = _internal_mutable_abbreviation();
  // @@protoc_insertion_point(field_mutable:CMsgDOTAEditTeamDetails.abbreviation)
  return _s;
}
inline const std::string& CMsgDOTAEditTeamDetails::_internal_abbreviation() const {
  return _impl_.abbreviation_.Get();
}
inline void CMsgDOTAEditTeamDetails::_internal_set_abbreviation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.abbreviation_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTAEditTeamDetails::_internal_mutable_abbreviation() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.abbreviation_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTAEditTeamDetails::release_abbreviation() {
  // @@protoc_insertion_point(field_release:CMsgDOTAEditTeamDetails.abbreviation)
  if (!_internal_has_abbreviation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.abbreviation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.abbreviation_.IsDefault()) {
    _impl_.abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTAEditTeamDetails::set_allocated_abbreviation(std::string* abbreviation) {
  if (abbreviation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.abbreviation_.SetAllocated(abbreviation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.abbreviation_.IsDefault()) {
    _impl_.abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTAEditTeamDetails.abbreviation)
}

// -------------------------------------------------------------------

// CMsgDOTAEditTeamDetailsResponse

// optional .CMsgDOTAEditTeamDetailsResponse.Result result = 1 [default = SUCCESS];
inline bool CMsgDOTAEditTeamDetailsResponse::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTAEditTeamDetailsResponse::has_result() const {
  return _internal_has_result();
}
inline void CMsgDOTAEditTeamDetailsResponse::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CMsgDOTAEditTeamDetailsResponse_Result CMsgDOTAEditTeamDetailsResponse::_internal_result() const {
  return static_cast< ::CMsgDOTAEditTeamDetailsResponse_Result >(_impl_.result_);
}
inline ::CMsgDOTAEditTeamDetailsResponse_Result CMsgDOTAEditTeamDetailsResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAEditTeamDetailsResponse.result)
  return _internal_result();
}
inline void CMsgDOTAEditTeamDetailsResponse::_internal_set_result(::CMsgDOTAEditTeamDetailsResponse_Result value) {
  assert(::CMsgDOTAEditTeamDetailsResponse_Result_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void CMsgDOTAEditTeamDetailsResponse::set_result(::CMsgDOTAEditTeamDetailsResponse_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAEditTeamDetailsResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTATeamInvite_InviterToGC

// optional uint32 account_id = 1;
inline bool CMsgDOTATeamInvite_InviterToGC::_internal_has_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_InviterToGC::has_account_id() const {
  return _internal_has_account_id();
}
inline void CMsgDOTATeamInvite_InviterToGC::clear_account_id() {
  _impl_.account_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTATeamInvite_InviterToGC::_internal_account_id() const {
  return _impl_.account_id_;
}
inline uint32_t CMsgDOTATeamInvite_InviterToGC::account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_InviterToGC.account_id)
  return _internal_account_id();
}
inline void CMsgDOTATeamInvite_InviterToGC::_internal_set_account_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_id_ = value;
}
inline void CMsgDOTATeamInvite_InviterToGC::set_account_id(uint32_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_InviterToGC.account_id)
}

// optional uint32 team_id = 2;
inline bool CMsgDOTATeamInvite_InviterToGC::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_InviterToGC::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDOTATeamInvite_InviterToGC::clear_team_id() {
  _impl_.team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTATeamInvite_InviterToGC::_internal_team_id() const {
  return _impl_.team_id_;
}
inline uint32_t CMsgDOTATeamInvite_InviterToGC::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_InviterToGC.team_id)
  return _internal_team_id();
}
inline void CMsgDOTATeamInvite_InviterToGC::_internal_set_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.team_id_ = value;
}
inline void CMsgDOTATeamInvite_InviterToGC::set_team_id(uint32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_InviterToGC.team_id)
}

// -------------------------------------------------------------------

// CMsgDOTATeamInvite_GCImmediateResponseToInviter

// optional .ETeamInviteResult result = 1 [default = TEAM_INVITE_SUCCESS];
inline bool CMsgDOTATeamInvite_GCImmediateResponseToInviter::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_GCImmediateResponseToInviter::has_result() const {
  return _internal_has_result();
}
inline void CMsgDOTATeamInvite_GCImmediateResponseToInviter::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::ETeamInviteResult CMsgDOTATeamInvite_GCImmediateResponseToInviter::_internal_result() const {
  return static_cast< ::ETeamInviteResult >(_impl_.result_);
}
inline ::ETeamInviteResult CMsgDOTATeamInvite_GCImmediateResponseToInviter::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_GCImmediateResponseToInviter.result)
  return _internal_result();
}
inline void CMsgDOTATeamInvite_GCImmediateResponseToInviter::_internal_set_result(::ETeamInviteResult value) {
  assert(::ETeamInviteResult_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.result_ = value;
}
inline void CMsgDOTATeamInvite_GCImmediateResponseToInviter::set_result(::ETeamInviteResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_GCImmediateResponseToInviter.result)
}

// optional string invitee_name = 2;
inline bool CMsgDOTATeamInvite_GCImmediateResponseToInviter::_internal_has_invitee_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_GCImmediateResponseToInviter::has_invitee_name() const {
  return _internal_has_invitee_name();
}
inline void CMsgDOTATeamInvite_GCImmediateResponseToInviter::clear_invitee_name() {
  _impl_.invitee_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTATeamInvite_GCImmediateResponseToInviter::invitee_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_GCImmediateResponseToInviter.invitee_name)
  return _internal_invitee_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInvite_GCImmediateResponseToInviter::set_invitee_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.invitee_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_GCImmediateResponseToInviter.invitee_name)
}
inline std::string* CMsgDOTATeamInvite_GCImmediateResponseToInviter::mutable_invitee_name() {
  std::string* _s = _internal_mutable_invitee_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInvite_GCImmediateResponseToInviter.invitee_name)
  return _s;
}
inline const std::string& CMsgDOTATeamInvite_GCImmediateResponseToInviter::_internal_invitee_name() const {
  return _impl_.invitee_name_.Get();
}
inline void CMsgDOTATeamInvite_GCImmediateResponseToInviter::_internal_set_invitee_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.invitee_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInvite_GCImmediateResponseToInviter::_internal_mutable_invitee_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.invitee_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInvite_GCImmediateResponseToInviter::release_invitee_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInvite_GCImmediateResponseToInviter.invitee_name)
  if (!_internal_has_invitee_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.invitee_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invitee_name_.IsDefault()) {
    _impl_.invitee_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInvite_GCImmediateResponseToInviter::set_allocated_invitee_name(std::string* invitee_name) {
  if (invitee_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.invitee_name_.SetAllocated(invitee_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invitee_name_.IsDefault()) {
    _impl_.invitee_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInvite_GCImmediateResponseToInviter.invitee_name)
}

// optional uint32 required_play_time = 3;
inline bool CMsgDOTATeamInvite_GCImmediateResponseToInviter::_internal_has_required_play_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_GCImmediateResponseToInviter::has_required_play_time() const {
  return _internal_has_required_play_time();
}
inline void CMsgDOTATeamInvite_GCImmediateResponseToInviter::clear_required_play_time() {
  _impl_.required_play_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTATeamInvite_GCImmediateResponseToInviter::_internal_required_play_time() const {
  return _impl_.required_play_time_;
}
inline uint32_t CMsgDOTATeamInvite_GCImmediateResponseToInviter::required_play_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_GCImmediateResponseToInviter.required_play_time)
  return _internal_required_play_time();
}
inline void CMsgDOTATeamInvite_GCImmediateResponseToInviter::_internal_set_required_play_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.required_play_time_ = value;
}
inline void CMsgDOTATeamInvite_GCImmediateResponseToInviter::set_required_play_time(uint32_t value) {
  _internal_set_required_play_time(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_GCImmediateResponseToInviter.required_play_time)
}

// -------------------------------------------------------------------

// CMsgDOTATeamInvite_GCRequestToInvitee

// optional uint32 inviter_account_id = 1;
inline bool CMsgDOTATeamInvite_GCRequestToInvitee::_internal_has_inviter_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_GCRequestToInvitee::has_inviter_account_id() const {
  return _internal_has_inviter_account_id();
}
inline void CMsgDOTATeamInvite_GCRequestToInvitee::clear_inviter_account_id() {
  _impl_.inviter_account_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTATeamInvite_GCRequestToInvitee::_internal_inviter_account_id() const {
  return _impl_.inviter_account_id_;
}
inline uint32_t CMsgDOTATeamInvite_GCRequestToInvitee::inviter_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_GCRequestToInvitee.inviter_account_id)
  return _internal_inviter_account_id();
}
inline void CMsgDOTATeamInvite_GCRequestToInvitee::_internal_set_inviter_account_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.inviter_account_id_ = value;
}
inline void CMsgDOTATeamInvite_GCRequestToInvitee::set_inviter_account_id(uint32_t value) {
  _internal_set_inviter_account_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_GCRequestToInvitee.inviter_account_id)
}

// optional string team_name = 2;
inline bool CMsgDOTATeamInvite_GCRequestToInvitee::_internal_has_team_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_GCRequestToInvitee::has_team_name() const {
  return _internal_has_team_name();
}
inline void CMsgDOTATeamInvite_GCRequestToInvitee::clear_team_name() {
  _impl_.team_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTATeamInvite_GCRequestToInvitee::team_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_GCRequestToInvitee.team_name)
  return _internal_team_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInvite_GCRequestToInvitee::set_team_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.team_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_GCRequestToInvitee.team_name)
}
inline std::string* CMsgDOTATeamInvite_GCRequestToInvitee::mutable_team_name() {
  std::string* _s = _internal_mutable_team_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInvite_GCRequestToInvitee.team_name)
  return _s;
}
inline const std::string& CMsgDOTATeamInvite_GCRequestToInvitee::_internal_team_name() const {
  return _impl_.team_name_.Get();
}
inline void CMsgDOTATeamInvite_GCRequestToInvitee::_internal_set_team_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.team_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInvite_GCRequestToInvitee::_internal_mutable_team_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.team_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInvite_GCRequestToInvitee::release_team_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInvite_GCRequestToInvitee.team_name)
  if (!_internal_has_team_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.team_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_name_.IsDefault()) {
    _impl_.team_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInvite_GCRequestToInvitee::set_allocated_team_name(std::string* team_name) {
  if (team_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.team_name_.SetAllocated(team_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_name_.IsDefault()) {
    _impl_.team_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInvite_GCRequestToInvitee.team_name)
}

// optional string team_tag = 3;
inline bool CMsgDOTATeamInvite_GCRequestToInvitee::_internal_has_team_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_GCRequestToInvitee::has_team_tag() const {
  return _internal_has_team_tag();
}
inline void CMsgDOTATeamInvite_GCRequestToInvitee::clear_team_tag() {
  _impl_.team_tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTATeamInvite_GCRequestToInvitee::team_tag() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_GCRequestToInvitee.team_tag)
  return _internal_team_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInvite_GCRequestToInvitee::set_team_tag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.team_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_GCRequestToInvitee.team_tag)
}
inline std::string* CMsgDOTATeamInvite_GCRequestToInvitee::mutable_team_tag() {
  std::string* _s = _internal_mutable_team_tag();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInvite_GCRequestToInvitee.team_tag)
  return _s;
}
inline const std::string& CMsgDOTATeamInvite_GCRequestToInvitee::_internal_team_tag() const {
  return _impl_.team_tag_.Get();
}
inline void CMsgDOTATeamInvite_GCRequestToInvitee::_internal_set_team_tag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.team_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInvite_GCRequestToInvitee::_internal_mutable_team_tag() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.team_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInvite_GCRequestToInvitee::release_team_tag() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInvite_GCRequestToInvitee.team_tag)
  if (!_internal_has_team_tag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.team_tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_tag_.IsDefault()) {
    _impl_.team_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInvite_GCRequestToInvitee::set_allocated_team_tag(std::string* team_tag) {
  if (team_tag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.team_tag_.SetAllocated(team_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_tag_.IsDefault()) {
    _impl_.team_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInvite_GCRequestToInvitee.team_tag)
}

// optional uint64 logo = 4;
inline bool CMsgDOTATeamInvite_GCRequestToInvitee::_internal_has_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_GCRequestToInvitee::has_logo() const {
  return _internal_has_logo();
}
inline void CMsgDOTATeamInvite_GCRequestToInvitee::clear_logo() {
  _impl_.logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CMsgDOTATeamInvite_GCRequestToInvitee::_internal_logo() const {
  return _impl_.logo_;
}
inline uint64_t CMsgDOTATeamInvite_GCRequestToInvitee::logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_GCRequestToInvitee.logo)
  return _internal_logo();
}
inline void CMsgDOTATeamInvite_GCRequestToInvitee::_internal_set_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.logo_ = value;
}
inline void CMsgDOTATeamInvite_GCRequestToInvitee::set_logo(uint64_t value) {
  _internal_set_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_GCRequestToInvitee.logo)
}

// -------------------------------------------------------------------

// CMsgDOTATeamInvite_InviteeResponseToGC

// optional .ETeamInviteResult result = 1 [default = TEAM_INVITE_SUCCESS];
inline bool CMsgDOTATeamInvite_InviteeResponseToGC::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_InviteeResponseToGC::has_result() const {
  return _internal_has_result();
}
inline void CMsgDOTATeamInvite_InviteeResponseToGC::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::ETeamInviteResult CMsgDOTATeamInvite_InviteeResponseToGC::_internal_result() const {
  return static_cast< ::ETeamInviteResult >(_impl_.result_);
}
inline ::ETeamInviteResult CMsgDOTATeamInvite_InviteeResponseToGC::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_InviteeResponseToGC.result)
  return _internal_result();
}
inline void CMsgDOTATeamInvite_InviteeResponseToGC::_internal_set_result(::ETeamInviteResult value) {
  assert(::ETeamInviteResult_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void CMsgDOTATeamInvite_InviteeResponseToGC::set_result(::ETeamInviteResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_InviteeResponseToGC.result)
}

// -------------------------------------------------------------------

// CMsgDOTATeamInvite_GCResponseToInviter

// optional .ETeamInviteResult result = 1 [default = TEAM_INVITE_SUCCESS];
inline bool CMsgDOTATeamInvite_GCResponseToInviter::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_GCResponseToInviter::has_result() const {
  return _internal_has_result();
}
inline void CMsgDOTATeamInvite_GCResponseToInviter::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::ETeamInviteResult CMsgDOTATeamInvite_GCResponseToInviter::_internal_result() const {
  return static_cast< ::ETeamInviteResult >(_impl_.result_);
}
inline ::ETeamInviteResult CMsgDOTATeamInvite_GCResponseToInviter::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_GCResponseToInviter.result)
  return _internal_result();
}
inline void CMsgDOTATeamInvite_GCResponseToInviter::_internal_set_result(::ETeamInviteResult value) {
  assert(::ETeamInviteResult_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.result_ = value;
}
inline void CMsgDOTATeamInvite_GCResponseToInviter::set_result(::ETeamInviteResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_GCResponseToInviter.result)
}

// optional string invitee_name = 2;
inline bool CMsgDOTATeamInvite_GCResponseToInviter::_internal_has_invitee_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_GCResponseToInviter::has_invitee_name() const {
  return _internal_has_invitee_name();
}
inline void CMsgDOTATeamInvite_GCResponseToInviter::clear_invitee_name() {
  _impl_.invitee_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTATeamInvite_GCResponseToInviter::invitee_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_GCResponseToInviter.invitee_name)
  return _internal_invitee_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInvite_GCResponseToInviter::set_invitee_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.invitee_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_GCResponseToInviter.invitee_name)
}
inline std::string* CMsgDOTATeamInvite_GCResponseToInviter::mutable_invitee_name() {
  std::string* _s = _internal_mutable_invitee_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInvite_GCResponseToInviter.invitee_name)
  return _s;
}
inline const std::string& CMsgDOTATeamInvite_GCResponseToInviter::_internal_invitee_name() const {
  return _impl_.invitee_name_.Get();
}
inline void CMsgDOTATeamInvite_GCResponseToInviter::_internal_set_invitee_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.invitee_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInvite_GCResponseToInviter::_internal_mutable_invitee_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.invitee_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInvite_GCResponseToInviter::release_invitee_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInvite_GCResponseToInviter.invitee_name)
  if (!_internal_has_invitee_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.invitee_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invitee_name_.IsDefault()) {
    _impl_.invitee_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInvite_GCResponseToInviter::set_allocated_invitee_name(std::string* invitee_name) {
  if (invitee_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.invitee_name_.SetAllocated(invitee_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invitee_name_.IsDefault()) {
    _impl_.invitee_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInvite_GCResponseToInviter.invitee_name)
}

// -------------------------------------------------------------------

// CMsgDOTATeamInvite_GCResponseToInvitee

// optional .ETeamInviteResult result = 1 [default = TEAM_INVITE_SUCCESS];
inline bool CMsgDOTATeamInvite_GCResponseToInvitee::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_GCResponseToInvitee::has_result() const {
  return _internal_has_result();
}
inline void CMsgDOTATeamInvite_GCResponseToInvitee::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::ETeamInviteResult CMsgDOTATeamInvite_GCResponseToInvitee::_internal_result() const {
  return static_cast< ::ETeamInviteResult >(_impl_.result_);
}
inline ::ETeamInviteResult CMsgDOTATeamInvite_GCResponseToInvitee::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_GCResponseToInvitee.result)
  return _internal_result();
}
inline void CMsgDOTATeamInvite_GCResponseToInvitee::_internal_set_result(::ETeamInviteResult value) {
  assert(::ETeamInviteResult_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.result_ = value;
}
inline void CMsgDOTATeamInvite_GCResponseToInvitee::set_result(::ETeamInviteResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_GCResponseToInvitee.result)
}

// optional string team_name = 2;
inline bool CMsgDOTATeamInvite_GCResponseToInvitee::_internal_has_team_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATeamInvite_GCResponseToInvitee::has_team_name() const {
  return _internal_has_team_name();
}
inline void CMsgDOTATeamInvite_GCResponseToInvitee::clear_team_name() {
  _impl_.team_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTATeamInvite_GCResponseToInvitee::team_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATeamInvite_GCResponseToInvitee.team_name)
  return _internal_team_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTATeamInvite_GCResponseToInvitee::set_team_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.team_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTATeamInvite_GCResponseToInvitee.team_name)
}
inline std::string* CMsgDOTATeamInvite_GCResponseToInvitee::mutable_team_name() {
  std::string* _s = _internal_mutable_team_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTATeamInvite_GCResponseToInvitee.team_name)
  return _s;
}
inline const std::string& CMsgDOTATeamInvite_GCResponseToInvitee::_internal_team_name() const {
  return _impl_.team_name_.Get();
}
inline void CMsgDOTATeamInvite_GCResponseToInvitee::_internal_set_team_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.team_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInvite_GCResponseToInvitee::_internal_mutable_team_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.team_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTATeamInvite_GCResponseToInvitee::release_team_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTATeamInvite_GCResponseToInvitee.team_name)
  if (!_internal_has_team_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.team_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_name_.IsDefault()) {
    _impl_.team_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTATeamInvite_GCResponseToInvitee::set_allocated_team_name(std::string* team_name) {
  if (team_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.team_name_.SetAllocated(team_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_name_.IsDefault()) {
    _impl_.team_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTATeamInvite_GCResponseToInvitee.team_name)
}

// -------------------------------------------------------------------

// CMsgDOTAKickTeamMember

// optional uint32 account_id = 1;
inline bool CMsgDOTAKickTeamMember::_internal_has_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTAKickTeamMember::has_account_id() const {
  return _internal_has_account_id();
}
inline void CMsgDOTAKickTeamMember::clear_account_id() {
  _impl_.account_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTAKickTeamMember::_internal_account_id() const {
  return _impl_.account_id_;
}
inline uint32_t CMsgDOTAKickTeamMember::account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAKickTeamMember.account_id)
  return _internal_account_id();
}
inline void CMsgDOTAKickTeamMember::_internal_set_account_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_id_ = value;
}
inline void CMsgDOTAKickTeamMember::set_account_id(uint32_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAKickTeamMember.account_id)
}

// optional uint32 team_id = 2;
inline bool CMsgDOTAKickTeamMember::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTAKickTeamMember::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDOTAKickTeamMember::clear_team_id() {
  _impl_.team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTAKickTeamMember::_internal_team_id() const {
  return _impl_.team_id_;
}
inline uint32_t CMsgDOTAKickTeamMember::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAKickTeamMember.team_id)
  return _internal_team_id();
}
inline void CMsgDOTAKickTeamMember::_internal_set_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.team_id_ = value;
}
inline void CMsgDOTAKickTeamMember::set_team_id(uint32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAKickTeamMember.team_id)
}

// -------------------------------------------------------------------

// CMsgDOTAKickTeamMemberResponse

// optional .CMsgDOTAKickTeamMemberResponse.Result result = 1 [default = SUCCESS];
inline bool CMsgDOTAKickTeamMemberResponse::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTAKickTeamMemberResponse::has_result() const {
  return _internal_has_result();
}
inline void CMsgDOTAKickTeamMemberResponse::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CMsgDOTAKickTeamMemberResponse_Result CMsgDOTAKickTeamMemberResponse::_internal_result() const {
  return static_cast< ::CMsgDOTAKickTeamMemberResponse_Result >(_impl_.result_);
}
inline ::CMsgDOTAKickTeamMemberResponse_Result CMsgDOTAKickTeamMemberResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTAKickTeamMemberResponse.result)
  return _internal_result();
}
inline void CMsgDOTAKickTeamMemberResponse::_internal_set_result(::CMsgDOTAKickTeamMemberResponse_Result value) {
  assert(::CMsgDOTAKickTeamMemberResponse_Result_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void CMsgDOTAKickTeamMemberResponse::set_result(::CMsgDOTAKickTeamMemberResponse_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CMsgDOTAKickTeamMemberResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTATransferTeamAdmin

// optional uint32 new_admin_account_id = 1;
inline bool CMsgDOTATransferTeamAdmin::_internal_has_new_admin_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATransferTeamAdmin::has_new_admin_account_id() const {
  return _internal_has_new_admin_account_id();
}
inline void CMsgDOTATransferTeamAdmin::clear_new_admin_account_id() {
  _impl_.new_admin_account_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTATransferTeamAdmin::_internal_new_admin_account_id() const {
  return _impl_.new_admin_account_id_;
}
inline uint32_t CMsgDOTATransferTeamAdmin::new_admin_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATransferTeamAdmin.new_admin_account_id)
  return _internal_new_admin_account_id();
}
inline void CMsgDOTATransferTeamAdmin::_internal_set_new_admin_account_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_admin_account_id_ = value;
}
inline void CMsgDOTATransferTeamAdmin::set_new_admin_account_id(uint32_t value) {
  _internal_set_new_admin_account_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATransferTeamAdmin.new_admin_account_id)
}

// optional uint32 team_id = 2;
inline bool CMsgDOTATransferTeamAdmin::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTATransferTeamAdmin::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDOTATransferTeamAdmin::clear_team_id() {
  _impl_.team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTATransferTeamAdmin::_internal_team_id() const {
  return _impl_.team_id_;
}
inline uint32_t CMsgDOTATransferTeamAdmin::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATransferTeamAdmin.team_id)
  return _internal_team_id();
}
inline void CMsgDOTATransferTeamAdmin::_internal_set_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.team_id_ = value;
}
inline void CMsgDOTATransferTeamAdmin::set_team_id(uint32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATransferTeamAdmin.team_id)
}

// -------------------------------------------------------------------

// CMsgDOTATransferTeamAdminResponse

// optional .CMsgDOTATransferTeamAdminResponse.Result result = 1 [default = SUCCESS];
inline bool CMsgDOTATransferTeamAdminResponse::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTATransferTeamAdminResponse::has_result() const {
  return _internal_has_result();
}
inline void CMsgDOTATransferTeamAdminResponse::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CMsgDOTATransferTeamAdminResponse_Result CMsgDOTATransferTeamAdminResponse::_internal_result() const {
  return static_cast< ::CMsgDOTATransferTeamAdminResponse_Result >(_impl_.result_);
}
inline ::CMsgDOTATransferTeamAdminResponse_Result CMsgDOTATransferTeamAdminResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTATransferTeamAdminResponse.result)
  return _internal_result();
}
inline void CMsgDOTATransferTeamAdminResponse::_internal_set_result(::CMsgDOTATransferTeamAdminResponse_Result value) {
  assert(::CMsgDOTATransferTeamAdminResponse_Result_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void CMsgDOTATransferTeamAdminResponse::set_result(::CMsgDOTATransferTeamAdminResponse_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CMsgDOTATransferTeamAdminResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTALeaveTeam

// optional uint32 team_id = 1;
inline bool CMsgDOTALeaveTeam::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeaveTeam::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDOTALeaveTeam::clear_team_id() {
  _impl_.team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTALeaveTeam::_internal_team_id() const {
  return _impl_.team_id_;
}
inline uint32_t CMsgDOTALeaveTeam::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeaveTeam.team_id)
  return _internal_team_id();
}
inline void CMsgDOTALeaveTeam::_internal_set_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.team_id_ = value;
}
inline void CMsgDOTALeaveTeam::set_team_id(uint32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeaveTeam.team_id)
}

// -------------------------------------------------------------------

// CMsgDOTALeaveTeamResponse

// optional .CMsgDOTALeaveTeamResponse.Result result = 1 [default = SUCCESS];
inline bool CMsgDOTALeaveTeamResponse::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeaveTeamResponse::has_result() const {
  return _internal_has_result();
}
inline void CMsgDOTALeaveTeamResponse::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CMsgDOTALeaveTeamResponse_Result CMsgDOTALeaveTeamResponse::_internal_result() const {
  return static_cast< ::CMsgDOTALeaveTeamResponse_Result >(_impl_.result_);
}
inline ::CMsgDOTALeaveTeamResponse_Result CMsgDOTALeaveTeamResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeaveTeamResponse.result)
  return _internal_result();
}
inline void CMsgDOTALeaveTeamResponse::_internal_set_result(::CMsgDOTALeaveTeamResponse_Result value) {
  assert(::CMsgDOTALeaveTeamResponse_Result_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void CMsgDOTALeaveTeamResponse::set_result(::CMsgDOTALeaveTeamResponse_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeaveTeamResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTABetaParticipation

// optional uint32 access_rights = 1;
inline bool CMsgDOTABetaParticipation::_internal_has_access_rights() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTABetaParticipation::has_access_rights() const {
  return _internal_has_access_rights();
}
inline void CMsgDOTABetaParticipation::clear_access_rights() {
  _impl_.access_rights_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTABetaParticipation::_internal_access_rights() const {
  return _impl_.access_rights_;
}
inline uint32_t CMsgDOTABetaParticipation::access_rights() const {
  // @@protoc_insertion_point(field_get:CMsgDOTABetaParticipation.access_rights)
  return _internal_access_rights();
}
inline void CMsgDOTABetaParticipation::_internal_set_access_rights(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.access_rights_ = value;
}
inline void CMsgDOTABetaParticipation::set_access_rights(uint32_t value) {
  _internal_set_access_rights(value);
  // @@protoc_insertion_point(field_set:CMsgDOTABetaParticipation.access_rights)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CMsgDOTACreateTeamResponse_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTACreateTeamResponse_Result>() {
  return ::CMsgDOTACreateTeamResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAEditTeamDetailsResponse_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAEditTeamDetailsResponse_Result>() {
  return ::CMsgDOTAEditTeamDetailsResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTAKickTeamMemberResponse_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTAKickTeamMemberResponse_Result>() {
  return ::CMsgDOTAKickTeamMemberResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTATransferTeamAdminResponse_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTATransferTeamAdminResponse_Result>() {
  return ::CMsgDOTATransferTeamAdminResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::CMsgDOTALeaveTeamResponse_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgDOTALeaveTeamResponse_Result>() {
  return ::CMsgDOTALeaveTeamResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::ETeamInviteResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ETeamInviteResult>() {
  return ::ETeamInviteResult_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dota_5fgcmessages_5fclient_5fteam_2eproto
