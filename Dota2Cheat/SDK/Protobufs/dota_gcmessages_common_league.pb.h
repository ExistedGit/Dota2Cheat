// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_common_league.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dota_5fgcmessages_5fcommon_5fleague_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dota_5fgcmessages_5fcommon_5fleague_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dota_shared_enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dota_5fgcmessages_5fcommon_5fleague_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dota_5fgcmessages_5fcommon_5fleague_2eproto;
class CMsgDOTADPCLeagueResults;
struct CMsgDOTADPCLeagueResultsDefaultTypeInternal;
extern CMsgDOTADPCLeagueResultsDefaultTypeInternal _CMsgDOTADPCLeagueResults_default_instance_;
class CMsgDOTADPCLeagueResults_Result;
struct CMsgDOTADPCLeagueResults_ResultDefaultTypeInternal;
extern CMsgDOTADPCLeagueResults_ResultDefaultTypeInternal _CMsgDOTADPCLeagueResults_Result_default_instance_;
class CMsgDOTADPCSeasonResults;
struct CMsgDOTADPCSeasonResultsDefaultTypeInternal;
extern CMsgDOTADPCSeasonResultsDefaultTypeInternal _CMsgDOTADPCSeasonResults_default_instance_;
class CMsgDOTADPCSeasonResults_Standing;
struct CMsgDOTADPCSeasonResults_StandingDefaultTypeInternal;
extern CMsgDOTADPCSeasonResults_StandingDefaultTypeInternal _CMsgDOTADPCSeasonResults_Standing_default_instance_;
class CMsgDOTADPCSeasonResults_StandingEntry;
struct CMsgDOTADPCSeasonResults_StandingEntryDefaultTypeInternal;
extern CMsgDOTADPCSeasonResults_StandingEntryDefaultTypeInternal _CMsgDOTADPCSeasonResults_StandingEntry_default_instance_;
class CMsgDOTADPCSeasonResults_TeamLeagueResult;
struct CMsgDOTADPCSeasonResults_TeamLeagueResultDefaultTypeInternal;
extern CMsgDOTADPCSeasonResults_TeamLeagueResultDefaultTypeInternal _CMsgDOTADPCSeasonResults_TeamLeagueResult_default_instance_;
class CMsgDOTADPCSeasonResults_TeamResult;
struct CMsgDOTADPCSeasonResults_TeamResultDefaultTypeInternal;
extern CMsgDOTADPCSeasonResults_TeamResultDefaultTypeInternal _CMsgDOTADPCSeasonResults_TeamResult_default_instance_;
class CMsgDOTADPCSeasonSpoilerResults;
struct CMsgDOTADPCSeasonSpoilerResultsDefaultTypeInternal;
extern CMsgDOTADPCSeasonSpoilerResultsDefaultTypeInternal _CMsgDOTADPCSeasonSpoilerResults_default_instance_;
class CMsgDOTADPCTeamResults;
struct CMsgDOTADPCTeamResultsDefaultTypeInternal;
extern CMsgDOTADPCTeamResultsDefaultTypeInternal _CMsgDOTADPCTeamResults_default_instance_;
class CMsgDOTADPCTeamResults_Result;
struct CMsgDOTADPCTeamResults_ResultDefaultTypeInternal;
extern CMsgDOTADPCTeamResults_ResultDefaultTypeInternal _CMsgDOTADPCTeamResults_Result_default_instance_;
class CMsgDOTALeague;
struct CMsgDOTALeagueDefaultTypeInternal;
extern CMsgDOTALeagueDefaultTypeInternal _CMsgDOTALeague_default_instance_;
class CMsgDOTALeagueAvailableLobbyNodes;
struct CMsgDOTALeagueAvailableLobbyNodesDefaultTypeInternal;
extern CMsgDOTALeagueAvailableLobbyNodesDefaultTypeInternal _CMsgDOTALeagueAvailableLobbyNodes_default_instance_;
class CMsgDOTALeagueAvailableLobbyNodesRequest;
struct CMsgDOTALeagueAvailableLobbyNodesRequestDefaultTypeInternal;
extern CMsgDOTALeagueAvailableLobbyNodesRequestDefaultTypeInternal _CMsgDOTALeagueAvailableLobbyNodesRequest_default_instance_;
class CMsgDOTALeagueAvailableLobbyNodes_NodeInfo;
struct CMsgDOTALeagueAvailableLobbyNodes_NodeInfoDefaultTypeInternal;
extern CMsgDOTALeagueAvailableLobbyNodes_NodeInfoDefaultTypeInternal _CMsgDOTALeagueAvailableLobbyNodes_NodeInfo_default_instance_;
class CMsgDOTALeagueInfo;
struct CMsgDOTALeagueInfoDefaultTypeInternal;
extern CMsgDOTALeagueInfoDefaultTypeInternal _CMsgDOTALeagueInfo_default_instance_;
class CMsgDOTALeagueInfoList;
struct CMsgDOTALeagueInfoListDefaultTypeInternal;
extern CMsgDOTALeagueInfoListDefaultTypeInternal _CMsgDOTALeagueInfoList_default_instance_;
class CMsgDOTALeagueInfoListAdminsRequest;
struct CMsgDOTALeagueInfoListAdminsRequestDefaultTypeInternal;
extern CMsgDOTALeagueInfoListAdminsRequestDefaultTypeInternal _CMsgDOTALeagueInfoListAdminsRequest_default_instance_;
class CMsgDOTALeagueList;
struct CMsgDOTALeagueListDefaultTypeInternal;
extern CMsgDOTALeagueListDefaultTypeInternal _CMsgDOTALeagueList_default_instance_;
class CMsgDOTALeagueLiveGames;
struct CMsgDOTALeagueLiveGamesDefaultTypeInternal;
extern CMsgDOTALeagueLiveGamesDefaultTypeInternal _CMsgDOTALeagueLiveGames_default_instance_;
class CMsgDOTALeagueLiveGames_LiveGame;
struct CMsgDOTALeagueLiveGames_LiveGameDefaultTypeInternal;
extern CMsgDOTALeagueLiveGames_LiveGameDefaultTypeInternal _CMsgDOTALeagueLiveGames_LiveGame_default_instance_;
class CMsgDOTALeagueMessages;
struct CMsgDOTALeagueMessagesDefaultTypeInternal;
extern CMsgDOTALeagueMessagesDefaultTypeInternal _CMsgDOTALeagueMessages_default_instance_;
class CMsgDOTALeagueMessages_Message;
struct CMsgDOTALeagueMessages_MessageDefaultTypeInternal;
extern CMsgDOTALeagueMessages_MessageDefaultTypeInternal _CMsgDOTALeagueMessages_Message_default_instance_;
class CMsgDOTALeagueNode;
struct CMsgDOTALeagueNodeDefaultTypeInternal;
extern CMsgDOTALeagueNodeDefaultTypeInternal _CMsgDOTALeagueNode_default_instance_;
class CMsgDOTALeagueNodeGroup;
struct CMsgDOTALeagueNodeGroupDefaultTypeInternal;
extern CMsgDOTALeagueNodeGroupDefaultTypeInternal _CMsgDOTALeagueNodeGroup_default_instance_;
class CMsgDOTALeagueNodeGroup_TeamStanding;
struct CMsgDOTALeagueNodeGroup_TeamStandingDefaultTypeInternal;
extern CMsgDOTALeagueNodeGroup_TeamStandingDefaultTypeInternal _CMsgDOTALeagueNodeGroup_TeamStanding_default_instance_;
class CMsgDOTALeagueNodeResults;
struct CMsgDOTALeagueNodeResultsDefaultTypeInternal;
extern CMsgDOTALeagueNodeResultsDefaultTypeInternal _CMsgDOTALeagueNodeResults_default_instance_;
class CMsgDOTALeagueNodeResults_Result;
struct CMsgDOTALeagueNodeResults_ResultDefaultTypeInternal;
extern CMsgDOTALeagueNodeResults_ResultDefaultTypeInternal _CMsgDOTALeagueNodeResults_Result_default_instance_;
class CMsgDOTALeagueNode_MatchDetails;
struct CMsgDOTALeagueNode_MatchDetailsDefaultTypeInternal;
extern CMsgDOTALeagueNode_MatchDetailsDefaultTypeInternal _CMsgDOTALeagueNode_MatchDetails_default_instance_;
class CMsgDOTALeagueNode_VOD;
struct CMsgDOTALeagueNode_VODDefaultTypeInternal;
extern CMsgDOTALeagueNode_VODDefaultTypeInternal _CMsgDOTALeagueNode_VOD_default_instance_;
class CMsgDOTALeaguePrizePool;
struct CMsgDOTALeaguePrizePoolDefaultTypeInternal;
extern CMsgDOTALeaguePrizePoolDefaultTypeInternal _CMsgDOTALeaguePrizePool_default_instance_;
class CMsgDOTALeague_Admin;
struct CMsgDOTALeague_AdminDefaultTypeInternal;
extern CMsgDOTALeague_AdminDefaultTypeInternal _CMsgDOTALeague_Admin_default_instance_;
class CMsgDOTALeague_Info;
struct CMsgDOTALeague_InfoDefaultTypeInternal;
extern CMsgDOTALeague_InfoDefaultTypeInternal _CMsgDOTALeague_Info_default_instance_;
class CMsgDOTALeague_Player;
struct CMsgDOTALeague_PlayerDefaultTypeInternal;
extern CMsgDOTALeague_PlayerDefaultTypeInternal _CMsgDOTALeague_Player_default_instance_;
class CMsgDOTALeague_PrizePool;
struct CMsgDOTALeague_PrizePoolDefaultTypeInternal;
extern CMsgDOTALeague_PrizePoolDefaultTypeInternal _CMsgDOTALeague_PrizePool_default_instance_;
class CMsgDOTALeague_PrizePoolItem;
struct CMsgDOTALeague_PrizePoolItemDefaultTypeInternal;
extern CMsgDOTALeague_PrizePoolItemDefaultTypeInternal _CMsgDOTALeague_PrizePoolItem_default_instance_;
class CMsgDOTALeague_SeriesInfo;
struct CMsgDOTALeague_SeriesInfoDefaultTypeInternal;
extern CMsgDOTALeague_SeriesInfoDefaultTypeInternal _CMsgDOTALeague_SeriesInfo_default_instance_;
class CMsgDOTALeague_Stream;
struct CMsgDOTALeague_StreamDefaultTypeInternal;
extern CMsgDOTALeague_StreamDefaultTypeInternal _CMsgDOTALeague_Stream_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CMsgDOTADPCLeagueResults* Arena::CreateMaybeMessage<::CMsgDOTADPCLeagueResults>(Arena*);
template<> ::CMsgDOTADPCLeagueResults_Result* Arena::CreateMaybeMessage<::CMsgDOTADPCLeagueResults_Result>(Arena*);
template<> ::CMsgDOTADPCSeasonResults* Arena::CreateMaybeMessage<::CMsgDOTADPCSeasonResults>(Arena*);
template<> ::CMsgDOTADPCSeasonResults_Standing* Arena::CreateMaybeMessage<::CMsgDOTADPCSeasonResults_Standing>(Arena*);
template<> ::CMsgDOTADPCSeasonResults_StandingEntry* Arena::CreateMaybeMessage<::CMsgDOTADPCSeasonResults_StandingEntry>(Arena*);
template<> ::CMsgDOTADPCSeasonResults_TeamLeagueResult* Arena::CreateMaybeMessage<::CMsgDOTADPCSeasonResults_TeamLeagueResult>(Arena*);
template<> ::CMsgDOTADPCSeasonResults_TeamResult* Arena::CreateMaybeMessage<::CMsgDOTADPCSeasonResults_TeamResult>(Arena*);
template<> ::CMsgDOTADPCSeasonSpoilerResults* Arena::CreateMaybeMessage<::CMsgDOTADPCSeasonSpoilerResults>(Arena*);
template<> ::CMsgDOTADPCTeamResults* Arena::CreateMaybeMessage<::CMsgDOTADPCTeamResults>(Arena*);
template<> ::CMsgDOTADPCTeamResults_Result* Arena::CreateMaybeMessage<::CMsgDOTADPCTeamResults_Result>(Arena*);
template<> ::CMsgDOTALeague* Arena::CreateMaybeMessage<::CMsgDOTALeague>(Arena*);
template<> ::CMsgDOTALeagueAvailableLobbyNodes* Arena::CreateMaybeMessage<::CMsgDOTALeagueAvailableLobbyNodes>(Arena*);
template<> ::CMsgDOTALeagueAvailableLobbyNodesRequest* Arena::CreateMaybeMessage<::CMsgDOTALeagueAvailableLobbyNodesRequest>(Arena*);
template<> ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* Arena::CreateMaybeMessage<::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo>(Arena*);
template<> ::CMsgDOTALeagueInfo* Arena::CreateMaybeMessage<::CMsgDOTALeagueInfo>(Arena*);
template<> ::CMsgDOTALeagueInfoList* Arena::CreateMaybeMessage<::CMsgDOTALeagueInfoList>(Arena*);
template<> ::CMsgDOTALeagueInfoListAdminsRequest* Arena::CreateMaybeMessage<::CMsgDOTALeagueInfoListAdminsRequest>(Arena*);
template<> ::CMsgDOTALeagueList* Arena::CreateMaybeMessage<::CMsgDOTALeagueList>(Arena*);
template<> ::CMsgDOTALeagueLiveGames* Arena::CreateMaybeMessage<::CMsgDOTALeagueLiveGames>(Arena*);
template<> ::CMsgDOTALeagueLiveGames_LiveGame* Arena::CreateMaybeMessage<::CMsgDOTALeagueLiveGames_LiveGame>(Arena*);
template<> ::CMsgDOTALeagueMessages* Arena::CreateMaybeMessage<::CMsgDOTALeagueMessages>(Arena*);
template<> ::CMsgDOTALeagueMessages_Message* Arena::CreateMaybeMessage<::CMsgDOTALeagueMessages_Message>(Arena*);
template<> ::CMsgDOTALeagueNode* Arena::CreateMaybeMessage<::CMsgDOTALeagueNode>(Arena*);
template<> ::CMsgDOTALeagueNodeGroup* Arena::CreateMaybeMessage<::CMsgDOTALeagueNodeGroup>(Arena*);
template<> ::CMsgDOTALeagueNodeGroup_TeamStanding* Arena::CreateMaybeMessage<::CMsgDOTALeagueNodeGroup_TeamStanding>(Arena*);
template<> ::CMsgDOTALeagueNodeResults* Arena::CreateMaybeMessage<::CMsgDOTALeagueNodeResults>(Arena*);
template<> ::CMsgDOTALeagueNodeResults_Result* Arena::CreateMaybeMessage<::CMsgDOTALeagueNodeResults_Result>(Arena*);
template<> ::CMsgDOTALeagueNode_MatchDetails* Arena::CreateMaybeMessage<::CMsgDOTALeagueNode_MatchDetails>(Arena*);
template<> ::CMsgDOTALeagueNode_VOD* Arena::CreateMaybeMessage<::CMsgDOTALeagueNode_VOD>(Arena*);
template<> ::CMsgDOTALeaguePrizePool* Arena::CreateMaybeMessage<::CMsgDOTALeaguePrizePool>(Arena*);
template<> ::CMsgDOTALeague_Admin* Arena::CreateMaybeMessage<::CMsgDOTALeague_Admin>(Arena*);
template<> ::CMsgDOTALeague_Info* Arena::CreateMaybeMessage<::CMsgDOTALeague_Info>(Arena*);
template<> ::CMsgDOTALeague_Player* Arena::CreateMaybeMessage<::CMsgDOTALeague_Player>(Arena*);
template<> ::CMsgDOTALeague_PrizePool* Arena::CreateMaybeMessage<::CMsgDOTALeague_PrizePool>(Arena*);
template<> ::CMsgDOTALeague_PrizePoolItem* Arena::CreateMaybeMessage<::CMsgDOTALeague_PrizePoolItem>(Arena*);
template<> ::CMsgDOTALeague_SeriesInfo* Arena::CreateMaybeMessage<::CMsgDOTALeague_SeriesInfo>(Arena*);
template<> ::CMsgDOTALeague_Stream* Arena::CreateMaybeMessage<::CMsgDOTALeague_Stream>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum ELeagueNodeGroupType : int {
  INVALID_GROUP_TYPE = 0,
  ORGANIZATIONAL = 1,
  ROUND_ROBIN = 2,
  SWISS = 3,
  BRACKET_SINGLE = 4,
  BRACKET_DOUBLE_SEED_LOSER = 5,
  BRACKET_DOUBLE_ALL_WINNER = 6,
  SHOWMATCH = 7,
  GSL = 8
};
bool ELeagueNodeGroupType_IsValid(int value);
constexpr ELeagueNodeGroupType ELeagueNodeGroupType_MIN = INVALID_GROUP_TYPE;
constexpr ELeagueNodeGroupType ELeagueNodeGroupType_MAX = GSL;
constexpr int ELeagueNodeGroupType_ARRAYSIZE = ELeagueNodeGroupType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueNodeGroupType_descriptor();
template<typename T>
inline const std::string& ELeagueNodeGroupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELeagueNodeGroupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELeagueNodeGroupType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELeagueNodeGroupType_descriptor(), enum_t_value);
}
inline bool ELeagueNodeGroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELeagueNodeGroupType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELeagueNodeGroupType>(
    ELeagueNodeGroupType_descriptor(), name, value);
}
enum ELeagueNodeType : int {
  INVALID_NODE_TYPE = 0,
  BEST_OF_ONE = 1,
  BEST_OF_THREE = 2,
  BEST_OF_FIVE = 3,
  BEST_OF_TWO = 4
};
bool ELeagueNodeType_IsValid(int value);
constexpr ELeagueNodeType ELeagueNodeType_MIN = INVALID_NODE_TYPE;
constexpr ELeagueNodeType ELeagueNodeType_MAX = BEST_OF_TWO;
constexpr int ELeagueNodeType_ARRAYSIZE = ELeagueNodeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueNodeType_descriptor();
template<typename T>
inline const std::string& ELeagueNodeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELeagueNodeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELeagueNodeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELeagueNodeType_descriptor(), enum_t_value);
}
inline bool ELeagueNodeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELeagueNodeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELeagueNodeType>(
    ELeagueNodeType_descriptor(), name, value);
}
// ===================================================================

class CMsgDOTALeagueNode_MatchDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueNode.MatchDetails) */ {
 public:
  inline CMsgDOTALeagueNode_MatchDetails() : CMsgDOTALeagueNode_MatchDetails(nullptr) {}
  ~CMsgDOTALeagueNode_MatchDetails() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueNode_MatchDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueNode_MatchDetails(const CMsgDOTALeagueNode_MatchDetails& from);
  CMsgDOTALeagueNode_MatchDetails(CMsgDOTALeagueNode_MatchDetails&& from) noexcept
    : CMsgDOTALeagueNode_MatchDetails() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNode_MatchDetails& operator=(const CMsgDOTALeagueNode_MatchDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueNode_MatchDetails& operator=(CMsgDOTALeagueNode_MatchDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueNode_MatchDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueNode_MatchDetails* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNode_MatchDetails*>(
               &_CMsgDOTALeagueNode_MatchDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CMsgDOTALeagueNode_MatchDetails& a, CMsgDOTALeagueNode_MatchDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueNode_MatchDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueNode_MatchDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueNode_MatchDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNode_MatchDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueNode_MatchDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueNode_MatchDetails& from) {
    CMsgDOTALeagueNode_MatchDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNode_MatchDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueNode.MatchDetails";
  }
  protected:
  explicit CMsgDOTALeagueNode_MatchDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchIdFieldNumber = 1,
    kWinningTeamIdFieldNumber = 2,
  };
  // optional uint64 match_id = 1;
  bool has_match_id() const;
  private:
  bool _internal_has_match_id() const;
  public:
  void clear_match_id();
  uint64_t match_id() const;
  void set_match_id(uint64_t value);
  private:
  uint64_t _internal_match_id() const;
  void _internal_set_match_id(uint64_t value);
  public:

  // optional uint32 winning_team_id = 2;
  bool has_winning_team_id() const;
  private:
  bool _internal_has_winning_team_id() const;
  public:
  void clear_winning_team_id();
  uint32_t winning_team_id() const;
  void set_winning_team_id(uint32_t value);
  private:
  uint32_t _internal_winning_team_id() const;
  void _internal_set_winning_team_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueNode.MatchDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t match_id_;
    uint32_t winning_team_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNode_VOD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueNode.VOD) */ {
 public:
  inline CMsgDOTALeagueNode_VOD() : CMsgDOTALeagueNode_VOD(nullptr) {}
  ~CMsgDOTALeagueNode_VOD() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueNode_VOD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueNode_VOD(const CMsgDOTALeagueNode_VOD& from);
  CMsgDOTALeagueNode_VOD(CMsgDOTALeagueNode_VOD&& from) noexcept
    : CMsgDOTALeagueNode_VOD() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNode_VOD& operator=(const CMsgDOTALeagueNode_VOD& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueNode_VOD& operator=(CMsgDOTALeagueNode_VOD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueNode_VOD& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueNode_VOD* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNode_VOD*>(
               &_CMsgDOTALeagueNode_VOD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CMsgDOTALeagueNode_VOD& a, CMsgDOTALeagueNode_VOD& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueNode_VOD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueNode_VOD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueNode_VOD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNode_VOD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueNode_VOD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueNode_VOD& from) {
    CMsgDOTALeagueNode_VOD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNode_VOD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueNode.VOD";
  }
  protected:
  explicit CMsgDOTALeagueNode_VOD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 3,
    kSeriesGameFieldNumber = 1,
    kStreamIdFieldNumber = 2,
  };
  // optional string url = 3;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional uint32 series_game = 1;
  bool has_series_game() const;
  private:
  bool _internal_has_series_game() const;
  public:
  void clear_series_game();
  uint32_t series_game() const;
  void set_series_game(uint32_t value);
  private:
  uint32_t _internal_series_game() const;
  void _internal_set_series_game(uint32_t value);
  public:

  // optional uint32 stream_id = 2;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  uint32_t stream_id() const;
  void set_stream_id(uint32_t value);
  private:
  uint32_t _internal_stream_id() const;
  void _internal_set_stream_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueNode.VOD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    uint32_t series_game_;
    uint32_t stream_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueNode) */ {
 public:
  inline CMsgDOTALeagueNode() : CMsgDOTALeagueNode(nullptr) {}
  ~CMsgDOTALeagueNode() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueNode(const CMsgDOTALeagueNode& from);
  CMsgDOTALeagueNode(CMsgDOTALeagueNode&& from) noexcept
    : CMsgDOTALeagueNode() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNode& operator=(const CMsgDOTALeagueNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueNode& operator=(CMsgDOTALeagueNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueNode* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNode*>(
               &_CMsgDOTALeagueNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CMsgDOTALeagueNode& a, CMsgDOTALeagueNode& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueNode& from) {
    CMsgDOTALeagueNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueNode";
  }
  protected:
  explicit CMsgDOTALeagueNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeagueNode_MatchDetails MatchDetails;
  typedef CMsgDOTALeagueNode_VOD VOD;

  // accessors -------------------------------------------------------

  enum : int {
    kMatchesFieldNumber = 13,
    kStreamIdsFieldNumber = 18,
    kVodsFieldNumber = 20,
    kNameFieldNumber = 1,
    kNodeIdFieldNumber = 2,
    kNodeGroupIdFieldNumber = 3,
    kWinningNodeIdFieldNumber = 4,
    kLosingNodeIdFieldNumber = 5,
    kIncomingNodeId1FieldNumber = 6,
    kIncomingNodeId2FieldNumber = 7,
    kNodeTypeFieldNumber = 8,
    kScheduledTimeFieldNumber = 9,
    kSeriesIdFieldNumber = 10,
    kTeamId1FieldNumber = 11,
    kTeamId2FieldNumber = 12,
    kTeam1WinsFieldNumber = 14,
    kTeam2WinsFieldNumber = 15,
    kHasStartedFieldNumber = 16,
    kIsCompletedFieldNumber = 17,
    kActualTimeFieldNumber = 19,
  };
  // repeated .CMsgDOTALeagueNode.MatchDetails matches = 13;
  int matches_size() const;
  private:
  int _internal_matches_size() const;
  public:
  void clear_matches();
  ::CMsgDOTALeagueNode_MatchDetails* mutable_matches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode_MatchDetails >*
      mutable_matches();
  private:
  const ::CMsgDOTALeagueNode_MatchDetails& _internal_matches(int index) const;
  ::CMsgDOTALeagueNode_MatchDetails* _internal_add_matches();
  public:
  const ::CMsgDOTALeagueNode_MatchDetails& matches(int index) const;
  ::CMsgDOTALeagueNode_MatchDetails* add_matches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode_MatchDetails >&
      matches() const;

  // repeated uint32 stream_ids = 18;
  int stream_ids_size() const;
  private:
  int _internal_stream_ids_size() const;
  public:
  void clear_stream_ids();
  private:
  uint32_t _internal_stream_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_stream_ids() const;
  void _internal_add_stream_ids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_stream_ids();
  public:
  uint32_t stream_ids(int index) const;
  void set_stream_ids(int index, uint32_t value);
  void add_stream_ids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      stream_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_stream_ids();

  // repeated .CMsgDOTALeagueNode.VOD vods = 20;
  int vods_size() const;
  private:
  int _internal_vods_size() const;
  public:
  void clear_vods();
  ::CMsgDOTALeagueNode_VOD* mutable_vods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode_VOD >*
      mutable_vods();
  private:
  const ::CMsgDOTALeagueNode_VOD& _internal_vods(int index) const;
  ::CMsgDOTALeagueNode_VOD* _internal_add_vods();
  public:
  const ::CMsgDOTALeagueNode_VOD& vods(int index) const;
  ::CMsgDOTALeagueNode_VOD* add_vods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode_VOD >&
      vods() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint32 node_id = 2;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  uint32_t node_id() const;
  void set_node_id(uint32_t value);
  private:
  uint32_t _internal_node_id() const;
  void _internal_set_node_id(uint32_t value);
  public:

  // optional uint32 node_group_id = 3;
  bool has_node_group_id() const;
  private:
  bool _internal_has_node_group_id() const;
  public:
  void clear_node_group_id();
  uint32_t node_group_id() const;
  void set_node_group_id(uint32_t value);
  private:
  uint32_t _internal_node_group_id() const;
  void _internal_set_node_group_id(uint32_t value);
  public:

  // optional uint32 winning_node_id = 4;
  bool has_winning_node_id() const;
  private:
  bool _internal_has_winning_node_id() const;
  public:
  void clear_winning_node_id();
  uint32_t winning_node_id() const;
  void set_winning_node_id(uint32_t value);
  private:
  uint32_t _internal_winning_node_id() const;
  void _internal_set_winning_node_id(uint32_t value);
  public:

  // optional uint32 losing_node_id = 5;
  bool has_losing_node_id() const;
  private:
  bool _internal_has_losing_node_id() const;
  public:
  void clear_losing_node_id();
  uint32_t losing_node_id() const;
  void set_losing_node_id(uint32_t value);
  private:
  uint32_t _internal_losing_node_id() const;
  void _internal_set_losing_node_id(uint32_t value);
  public:

  // optional uint32 incoming_node_id_1 = 6;
  bool has_incoming_node_id_1() const;
  private:
  bool _internal_has_incoming_node_id_1() const;
  public:
  void clear_incoming_node_id_1();
  uint32_t incoming_node_id_1() const;
  void set_incoming_node_id_1(uint32_t value);
  private:
  uint32_t _internal_incoming_node_id_1() const;
  void _internal_set_incoming_node_id_1(uint32_t value);
  public:

  // optional uint32 incoming_node_id_2 = 7;
  bool has_incoming_node_id_2() const;
  private:
  bool _internal_has_incoming_node_id_2() const;
  public:
  void clear_incoming_node_id_2();
  uint32_t incoming_node_id_2() const;
  void set_incoming_node_id_2(uint32_t value);
  private:
  uint32_t _internal_incoming_node_id_2() const;
  void _internal_set_incoming_node_id_2(uint32_t value);
  public:

  // optional .ELeagueNodeType node_type = 8 [default = INVALID_NODE_TYPE];
  bool has_node_type() const;
  private:
  bool _internal_has_node_type() const;
  public:
  void clear_node_type();
  ::ELeagueNodeType node_type() const;
  void set_node_type(::ELeagueNodeType value);
  private:
  ::ELeagueNodeType _internal_node_type() const;
  void _internal_set_node_type(::ELeagueNodeType value);
  public:

  // optional uint32 scheduled_time = 9;
  bool has_scheduled_time() const;
  private:
  bool _internal_has_scheduled_time() const;
  public:
  void clear_scheduled_time();
  uint32_t scheduled_time() const;
  void set_scheduled_time(uint32_t value);
  private:
  uint32_t _internal_scheduled_time() const;
  void _internal_set_scheduled_time(uint32_t value);
  public:

  // optional uint32 series_id = 10;
  bool has_series_id() const;
  private:
  bool _internal_has_series_id() const;
  public:
  void clear_series_id();
  uint32_t series_id() const;
  void set_series_id(uint32_t value);
  private:
  uint32_t _internal_series_id() const;
  void _internal_set_series_id(uint32_t value);
  public:

  // optional uint32 team_id_1 = 11;
  bool has_team_id_1() const;
  private:
  bool _internal_has_team_id_1() const;
  public:
  void clear_team_id_1();
  uint32_t team_id_1() const;
  void set_team_id_1(uint32_t value);
  private:
  uint32_t _internal_team_id_1() const;
  void _internal_set_team_id_1(uint32_t value);
  public:

  // optional uint32 team_id_2 = 12;
  bool has_team_id_2() const;
  private:
  bool _internal_has_team_id_2() const;
  public:
  void clear_team_id_2();
  uint32_t team_id_2() const;
  void set_team_id_2(uint32_t value);
  private:
  uint32_t _internal_team_id_2() const;
  void _internal_set_team_id_2(uint32_t value);
  public:

  // optional uint32 team_1_wins = 14;
  bool has_team_1_wins() const;
  private:
  bool _internal_has_team_1_wins() const;
  public:
  void clear_team_1_wins();
  uint32_t team_1_wins() const;
  void set_team_1_wins(uint32_t value);
  private:
  uint32_t _internal_team_1_wins() const;
  void _internal_set_team_1_wins(uint32_t value);
  public:

  // optional uint32 team_2_wins = 15;
  bool has_team_2_wins() const;
  private:
  bool _internal_has_team_2_wins() const;
  public:
  void clear_team_2_wins();
  uint32_t team_2_wins() const;
  void set_team_2_wins(uint32_t value);
  private:
  uint32_t _internal_team_2_wins() const;
  void _internal_set_team_2_wins(uint32_t value);
  public:

  // optional bool has_started = 16;
  bool has_has_started() const;
  private:
  bool _internal_has_has_started() const;
  public:
  void clear_has_started();
  bool has_started() const;
  void set_has_started(bool value);
  private:
  bool _internal_has_started() const;
  void _internal_set_has_started(bool value);
  public:

  // optional bool is_completed = 17;
  bool has_is_completed() const;
  private:
  bool _internal_has_is_completed() const;
  public:
  void clear_is_completed();
  bool is_completed() const;
  void set_is_completed(bool value);
  private:
  bool _internal_is_completed() const;
  void _internal_set_is_completed(bool value);
  public:

  // optional uint32 actual_time = 19;
  bool has_actual_time() const;
  private:
  bool _internal_has_actual_time() const;
  public:
  void clear_actual_time();
  uint32_t actual_time() const;
  void set_actual_time(uint32_t value);
  private:
  uint32_t _internal_actual_time() const;
  void _internal_set_actual_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode_MatchDetails > matches_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > stream_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode_VOD > vods_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t node_id_;
    uint32_t node_group_id_;
    uint32_t winning_node_id_;
    uint32_t losing_node_id_;
    uint32_t incoming_node_id_1_;
    uint32_t incoming_node_id_2_;
    int node_type_;
    uint32_t scheduled_time_;
    uint32_t series_id_;
    uint32_t team_id_1_;
    uint32_t team_id_2_;
    uint32_t team_1_wins_;
    uint32_t team_2_wins_;
    bool has_started_;
    bool is_completed_;
    uint32_t actual_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNodeGroup_TeamStanding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueNodeGroup.TeamStanding) */ {
 public:
  inline CMsgDOTALeagueNodeGroup_TeamStanding() : CMsgDOTALeagueNodeGroup_TeamStanding(nullptr) {}
  ~CMsgDOTALeagueNodeGroup_TeamStanding() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeGroup_TeamStanding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueNodeGroup_TeamStanding(const CMsgDOTALeagueNodeGroup_TeamStanding& from);
  CMsgDOTALeagueNodeGroup_TeamStanding(CMsgDOTALeagueNodeGroup_TeamStanding&& from) noexcept
    : CMsgDOTALeagueNodeGroup_TeamStanding() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNodeGroup_TeamStanding& operator=(const CMsgDOTALeagueNodeGroup_TeamStanding& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueNodeGroup_TeamStanding& operator=(CMsgDOTALeagueNodeGroup_TeamStanding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueNodeGroup_TeamStanding& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueNodeGroup_TeamStanding* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNodeGroup_TeamStanding*>(
               &_CMsgDOTALeagueNodeGroup_TeamStanding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CMsgDOTALeagueNodeGroup_TeamStanding& a, CMsgDOTALeagueNodeGroup_TeamStanding& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueNodeGroup_TeamStanding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueNodeGroup_TeamStanding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueNodeGroup_TeamStanding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeGroup_TeamStanding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueNodeGroup_TeamStanding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueNodeGroup_TeamStanding& from) {
    CMsgDOTALeagueNodeGroup_TeamStanding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNodeGroup_TeamStanding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueNodeGroup.TeamStanding";
  }
  protected:
  explicit CMsgDOTALeagueNodeGroup_TeamStanding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamNameFieldNumber = 3,
    kTeamTagFieldNumber = 4,
    kTeamLogoUrlFieldNumber = 6,
    kTeamAbbreviationFieldNumber = 10,
    kStandingFieldNumber = 1,
    kTeamIdFieldNumber = 2,
    kTeamLogoFieldNumber = 5,
    kWinsFieldNumber = 7,
    kLossesFieldNumber = 8,
    kScoreFieldNumber = 9,
    kScoreTiebreakGroupFieldNumber = 11,
    kScoreTiebreakBelowFieldNumber = 12,
    kScoreTiebreakRandomFieldNumber = 13,
    kIsProFieldNumber = 14,
  };
  // optional string team_name = 3;
  bool has_team_name() const;
  private:
  bool _internal_has_team_name() const;
  public:
  void clear_team_name();
  const std::string& team_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_name();
  PROTOBUF_NODISCARD std::string* release_team_name();
  void set_allocated_team_name(std::string* team_name);
  private:
  const std::string& _internal_team_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_name(const std::string& value);
  std::string* _internal_mutable_team_name();
  public:

  // optional string team_tag = 4;
  bool has_team_tag() const;
  private:
  bool _internal_has_team_tag() const;
  public:
  void clear_team_tag();
  const std::string& team_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_tag();
  PROTOBUF_NODISCARD std::string* release_team_tag();
  void set_allocated_team_tag(std::string* team_tag);
  private:
  const std::string& _internal_team_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_tag(const std::string& value);
  std::string* _internal_mutable_team_tag();
  public:

  // optional string team_logo_url = 6;
  bool has_team_logo_url() const;
  private:
  bool _internal_has_team_logo_url() const;
  public:
  void clear_team_logo_url();
  const std::string& team_logo_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_logo_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_logo_url();
  PROTOBUF_NODISCARD std::string* release_team_logo_url();
  void set_allocated_team_logo_url(std::string* team_logo_url);
  private:
  const std::string& _internal_team_logo_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_logo_url(const std::string& value);
  std::string* _internal_mutable_team_logo_url();
  public:

  // optional string team_abbreviation = 10;
  bool has_team_abbreviation() const;
  private:
  bool _internal_has_team_abbreviation() const;
  public:
  void clear_team_abbreviation();
  const std::string& team_abbreviation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_abbreviation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_abbreviation();
  PROTOBUF_NODISCARD std::string* release_team_abbreviation();
  void set_allocated_team_abbreviation(std::string* team_abbreviation);
  private:
  const std::string& _internal_team_abbreviation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_abbreviation(const std::string& value);
  std::string* _internal_mutable_team_abbreviation();
  public:

  // optional uint32 standing = 1;
  bool has_standing() const;
  private:
  bool _internal_has_standing() const;
  public:
  void clear_standing();
  uint32_t standing() const;
  void set_standing(uint32_t value);
  private:
  uint32_t _internal_standing() const;
  void _internal_set_standing(uint32_t value);
  public:

  // optional uint32 team_id = 2;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  uint32_t team_id() const;
  void set_team_id(uint32_t value);
  private:
  uint32_t _internal_team_id() const;
  void _internal_set_team_id(uint32_t value);
  public:

  // optional uint64 team_logo = 5;
  bool has_team_logo() const;
  private:
  bool _internal_has_team_logo() const;
  public:
  void clear_team_logo();
  uint64_t team_logo() const;
  void set_team_logo(uint64_t value);
  private:
  uint64_t _internal_team_logo() const;
  void _internal_set_team_logo(uint64_t value);
  public:

  // optional uint32 wins = 7;
  bool has_wins() const;
  private:
  bool _internal_has_wins() const;
  public:
  void clear_wins();
  uint32_t wins() const;
  void set_wins(uint32_t value);
  private:
  uint32_t _internal_wins() const;
  void _internal_set_wins(uint32_t value);
  public:

  // optional uint32 losses = 8;
  bool has_losses() const;
  private:
  bool _internal_has_losses() const;
  public:
  void clear_losses();
  uint32_t losses() const;
  void set_losses(uint32_t value);
  private:
  uint32_t _internal_losses() const;
  void _internal_set_losses(uint32_t value);
  public:

  // optional int64 score = 9;
  bool has_score() const;
  private:
  bool _internal_has_score() const;
  public:
  void clear_score();
  int64_t score() const;
  void set_score(int64_t value);
  private:
  int64_t _internal_score() const;
  void _internal_set_score(int64_t value);
  public:

  // optional int64 score_tiebreak_group = 11;
  bool has_score_tiebreak_group() const;
  private:
  bool _internal_has_score_tiebreak_group() const;
  public:
  void clear_score_tiebreak_group();
  int64_t score_tiebreak_group() const;
  void set_score_tiebreak_group(int64_t value);
  private:
  int64_t _internal_score_tiebreak_group() const;
  void _internal_set_score_tiebreak_group(int64_t value);
  public:

  // optional int64 score_tiebreak_below = 12;
  bool has_score_tiebreak_below() const;
  private:
  bool _internal_has_score_tiebreak_below() const;
  public:
  void clear_score_tiebreak_below();
  int64_t score_tiebreak_below() const;
  void set_score_tiebreak_below(int64_t value);
  private:
  int64_t _internal_score_tiebreak_below() const;
  void _internal_set_score_tiebreak_below(int64_t value);
  public:

  // optional int64 score_tiebreak_random = 13;
  bool has_score_tiebreak_random() const;
  private:
  bool _internal_has_score_tiebreak_random() const;
  public:
  void clear_score_tiebreak_random();
  int64_t score_tiebreak_random() const;
  void set_score_tiebreak_random(int64_t value);
  private:
  int64_t _internal_score_tiebreak_random() const;
  void _internal_set_score_tiebreak_random(int64_t value);
  public:

  // optional bool is_pro = 14;
  bool has_is_pro() const;
  private:
  bool _internal_has_is_pro() const;
  public:
  void clear_is_pro();
  bool is_pro() const;
  void set_is_pro(bool value);
  private:
  bool _internal_is_pro() const;
  void _internal_set_is_pro(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueNodeGroup.TeamStanding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_logo_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_abbreviation_;
    uint32_t standing_;
    uint32_t team_id_;
    uint64_t team_logo_;
    uint32_t wins_;
    uint32_t losses_;
    int64_t score_;
    int64_t score_tiebreak_group_;
    int64_t score_tiebreak_below_;
    int64_t score_tiebreak_random_;
    bool is_pro_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNodeGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueNodeGroup) */ {
 public:
  inline CMsgDOTALeagueNodeGroup() : CMsgDOTALeagueNodeGroup(nullptr) {}
  ~CMsgDOTALeagueNodeGroup() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueNodeGroup(const CMsgDOTALeagueNodeGroup& from);
  CMsgDOTALeagueNodeGroup(CMsgDOTALeagueNodeGroup&& from) noexcept
    : CMsgDOTALeagueNodeGroup() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNodeGroup& operator=(const CMsgDOTALeagueNodeGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueNodeGroup& operator=(CMsgDOTALeagueNodeGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueNodeGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueNodeGroup* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNodeGroup*>(
               &_CMsgDOTALeagueNodeGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CMsgDOTALeagueNodeGroup& a, CMsgDOTALeagueNodeGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueNodeGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueNodeGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueNodeGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueNodeGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueNodeGroup& from) {
    CMsgDOTALeagueNodeGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNodeGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueNodeGroup";
  }
  protected:
  explicit CMsgDOTALeagueNodeGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeagueNodeGroup_TeamStanding TeamStanding;

  // accessors -------------------------------------------------------

  enum : int {
    kIncomingNodeGroupIdsFieldNumber = 4,
    kTeamStandingsFieldNumber = 15,
    kNodesFieldNumber = 16,
    kNodeGroupsFieldNumber = 17,
    kNameFieldNumber = 1,
    kNodeGroupIdFieldNumber = 2,
    kParentNodeGroupIdFieldNumber = 3,
    kAdvancingNodeGroupIdFieldNumber = 5,
    kAdvancingTeamCountFieldNumber = 6,
    kTeamCountFieldNumber = 7,
    kNodeGroupTypeFieldNumber = 8,
    kDefaultNodeTypeFieldNumber = 9,
    kRoundFieldNumber = 10,
    kMaxRoundsFieldNumber = 11,
    kIsTiebreakerFieldNumber = 12,
    kIsFinalGroupFieldNumber = 13,
    kIsCompletedFieldNumber = 14,
    kPhaseFieldNumber = 18,
    kRegionFieldNumber = 19,
    kStartTimeFieldNumber = 20,
    kEndTimeFieldNumber = 21,
    kSecondaryAdvancingNodeGroupIdFieldNumber = 22,
    kSecondaryAdvancingTeamCountFieldNumber = 23,
    kTertiaryAdvancingNodeGroupIdFieldNumber = 24,
    kTertiaryAdvancingTeamCountFieldNumber = 25,
    kEliminationDpcPointsFieldNumber = 26,
  };
  // repeated uint32 incoming_node_group_ids = 4;
  int incoming_node_group_ids_size() const;
  private:
  int _internal_incoming_node_group_ids_size() const;
  public:
  void clear_incoming_node_group_ids();
  private:
  uint32_t _internal_incoming_node_group_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_incoming_node_group_ids() const;
  void _internal_add_incoming_node_group_ids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_incoming_node_group_ids();
  public:
  uint32_t incoming_node_group_ids(int index) const;
  void set_incoming_node_group_ids(int index, uint32_t value);
  void add_incoming_node_group_ids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      incoming_node_group_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_incoming_node_group_ids();

  // repeated .CMsgDOTALeagueNodeGroup.TeamStanding team_standings = 15;
  int team_standings_size() const;
  private:
  int _internal_team_standings_size() const;
  public:
  void clear_team_standings();
  ::CMsgDOTALeagueNodeGroup_TeamStanding* mutable_team_standings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup_TeamStanding >*
      mutable_team_standings();
  private:
  const ::CMsgDOTALeagueNodeGroup_TeamStanding& _internal_team_standings(int index) const;
  ::CMsgDOTALeagueNodeGroup_TeamStanding* _internal_add_team_standings();
  public:
  const ::CMsgDOTALeagueNodeGroup_TeamStanding& team_standings(int index) const;
  ::CMsgDOTALeagueNodeGroup_TeamStanding* add_team_standings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup_TeamStanding >&
      team_standings() const;

  // repeated .CMsgDOTALeagueNode nodes = 16;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::CMsgDOTALeagueNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode >*
      mutable_nodes();
  private:
  const ::CMsgDOTALeagueNode& _internal_nodes(int index) const;
  ::CMsgDOTALeagueNode* _internal_add_nodes();
  public:
  const ::CMsgDOTALeagueNode& nodes(int index) const;
  ::CMsgDOTALeagueNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode >&
      nodes() const;

  // repeated .CMsgDOTALeagueNodeGroup node_groups = 17;
  int node_groups_size() const;
  private:
  int _internal_node_groups_size() const;
  public:
  void clear_node_groups();
  ::CMsgDOTALeagueNodeGroup* mutable_node_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup >*
      mutable_node_groups();
  private:
  const ::CMsgDOTALeagueNodeGroup& _internal_node_groups(int index) const;
  ::CMsgDOTALeagueNodeGroup* _internal_add_node_groups();
  public:
  const ::CMsgDOTALeagueNodeGroup& node_groups(int index) const;
  ::CMsgDOTALeagueNodeGroup* add_node_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup >&
      node_groups() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint32 node_group_id = 2;
  bool has_node_group_id() const;
  private:
  bool _internal_has_node_group_id() const;
  public:
  void clear_node_group_id();
  uint32_t node_group_id() const;
  void set_node_group_id(uint32_t value);
  private:
  uint32_t _internal_node_group_id() const;
  void _internal_set_node_group_id(uint32_t value);
  public:

  // optional uint32 parent_node_group_id = 3;
  bool has_parent_node_group_id() const;
  private:
  bool _internal_has_parent_node_group_id() const;
  public:
  void clear_parent_node_group_id();
  uint32_t parent_node_group_id() const;
  void set_parent_node_group_id(uint32_t value);
  private:
  uint32_t _internal_parent_node_group_id() const;
  void _internal_set_parent_node_group_id(uint32_t value);
  public:

  // optional uint32 advancing_node_group_id = 5;
  bool has_advancing_node_group_id() const;
  private:
  bool _internal_has_advancing_node_group_id() const;
  public:
  void clear_advancing_node_group_id();
  uint32_t advancing_node_group_id() const;
  void set_advancing_node_group_id(uint32_t value);
  private:
  uint32_t _internal_advancing_node_group_id() const;
  void _internal_set_advancing_node_group_id(uint32_t value);
  public:

  // optional uint32 advancing_team_count = 6;
  bool has_advancing_team_count() const;
  private:
  bool _internal_has_advancing_team_count() const;
  public:
  void clear_advancing_team_count();
  uint32_t advancing_team_count() const;
  void set_advancing_team_count(uint32_t value);
  private:
  uint32_t _internal_advancing_team_count() const;
  void _internal_set_advancing_team_count(uint32_t value);
  public:

  // optional uint32 team_count = 7;
  bool has_team_count() const;
  private:
  bool _internal_has_team_count() const;
  public:
  void clear_team_count();
  uint32_t team_count() const;
  void set_team_count(uint32_t value);
  private:
  uint32_t _internal_team_count() const;
  void _internal_set_team_count(uint32_t value);
  public:

  // optional .ELeagueNodeGroupType node_group_type = 8 [default = INVALID_GROUP_TYPE];
  bool has_node_group_type() const;
  private:
  bool _internal_has_node_group_type() const;
  public:
  void clear_node_group_type();
  ::ELeagueNodeGroupType node_group_type() const;
  void set_node_group_type(::ELeagueNodeGroupType value);
  private:
  ::ELeagueNodeGroupType _internal_node_group_type() const;
  void _internal_set_node_group_type(::ELeagueNodeGroupType value);
  public:

  // optional .ELeagueNodeType default_node_type = 9 [default = INVALID_NODE_TYPE];
  bool has_default_node_type() const;
  private:
  bool _internal_has_default_node_type() const;
  public:
  void clear_default_node_type();
  ::ELeagueNodeType default_node_type() const;
  void set_default_node_type(::ELeagueNodeType value);
  private:
  ::ELeagueNodeType _internal_default_node_type() const;
  void _internal_set_default_node_type(::ELeagueNodeType value);
  public:

  // optional uint32 round = 10;
  bool has_round() const;
  private:
  bool _internal_has_round() const;
  public:
  void clear_round();
  uint32_t round() const;
  void set_round(uint32_t value);
  private:
  uint32_t _internal_round() const;
  void _internal_set_round(uint32_t value);
  public:

  // optional uint32 max_rounds = 11;
  bool has_max_rounds() const;
  private:
  bool _internal_has_max_rounds() const;
  public:
  void clear_max_rounds();
  uint32_t max_rounds() const;
  void set_max_rounds(uint32_t value);
  private:
  uint32_t _internal_max_rounds() const;
  void _internal_set_max_rounds(uint32_t value);
  public:

  // optional bool is_tiebreaker = 12;
  bool has_is_tiebreaker() const;
  private:
  bool _internal_has_is_tiebreaker() const;
  public:
  void clear_is_tiebreaker();
  bool is_tiebreaker() const;
  void set_is_tiebreaker(bool value);
  private:
  bool _internal_is_tiebreaker() const;
  void _internal_set_is_tiebreaker(bool value);
  public:

  // optional bool is_final_group = 13;
  bool has_is_final_group() const;
  private:
  bool _internal_has_is_final_group() const;
  public:
  void clear_is_final_group();
  bool is_final_group() const;
  void set_is_final_group(bool value);
  private:
  bool _internal_is_final_group() const;
  void _internal_set_is_final_group(bool value);
  public:

  // optional bool is_completed = 14;
  bool has_is_completed() const;
  private:
  bool _internal_has_is_completed() const;
  public:
  void clear_is_completed();
  bool is_completed() const;
  void set_is_completed(bool value);
  private:
  bool _internal_is_completed() const;
  void _internal_set_is_completed(bool value);
  public:

  // optional .ELeaguePhase phase = 18 [default = LEAGUE_PHASE_UNSET];
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;
  public:
  void clear_phase();
  ::ELeaguePhase phase() const;
  void set_phase(::ELeaguePhase value);
  private:
  ::ELeaguePhase _internal_phase() const;
  void _internal_set_phase(::ELeaguePhase value);
  public:

  // optional .ELeagueRegion region = 19 [default = LEAGUE_REGION_UNSET];
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  ::ELeagueRegion region() const;
  void set_region(::ELeagueRegion value);
  private:
  ::ELeagueRegion _internal_region() const;
  void _internal_set_region(::ELeagueRegion value);
  public:

  // optional uint32 start_time = 20;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  uint32_t start_time() const;
  void set_start_time(uint32_t value);
  private:
  uint32_t _internal_start_time() const;
  void _internal_set_start_time(uint32_t value);
  public:

  // optional uint32 end_time = 21;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  uint32_t end_time() const;
  void set_end_time(uint32_t value);
  private:
  uint32_t _internal_end_time() const;
  void _internal_set_end_time(uint32_t value);
  public:

  // optional uint32 secondary_advancing_node_group_id = 22;
  bool has_secondary_advancing_node_group_id() const;
  private:
  bool _internal_has_secondary_advancing_node_group_id() const;
  public:
  void clear_secondary_advancing_node_group_id();
  uint32_t secondary_advancing_node_group_id() const;
  void set_secondary_advancing_node_group_id(uint32_t value);
  private:
  uint32_t _internal_secondary_advancing_node_group_id() const;
  void _internal_set_secondary_advancing_node_group_id(uint32_t value);
  public:

  // optional uint32 secondary_advancing_team_count = 23;
  bool has_secondary_advancing_team_count() const;
  private:
  bool _internal_has_secondary_advancing_team_count() const;
  public:
  void clear_secondary_advancing_team_count();
  uint32_t secondary_advancing_team_count() const;
  void set_secondary_advancing_team_count(uint32_t value);
  private:
  uint32_t _internal_secondary_advancing_team_count() const;
  void _internal_set_secondary_advancing_team_count(uint32_t value);
  public:

  // optional uint32 tertiary_advancing_node_group_id = 24;
  bool has_tertiary_advancing_node_group_id() const;
  private:
  bool _internal_has_tertiary_advancing_node_group_id() const;
  public:
  void clear_tertiary_advancing_node_group_id();
  uint32_t tertiary_advancing_node_group_id() const;
  void set_tertiary_advancing_node_group_id(uint32_t value);
  private:
  uint32_t _internal_tertiary_advancing_node_group_id() const;
  void _internal_set_tertiary_advancing_node_group_id(uint32_t value);
  public:

  // optional uint32 tertiary_advancing_team_count = 25;
  bool has_tertiary_advancing_team_count() const;
  private:
  bool _internal_has_tertiary_advancing_team_count() const;
  public:
  void clear_tertiary_advancing_team_count();
  uint32_t tertiary_advancing_team_count() const;
  void set_tertiary_advancing_team_count(uint32_t value);
  private:
  uint32_t _internal_tertiary_advancing_team_count() const;
  void _internal_set_tertiary_advancing_team_count(uint32_t value);
  public:

  // optional uint32 elimination_dpc_points = 26;
  bool has_elimination_dpc_points() const;
  private:
  bool _internal_has_elimination_dpc_points() const;
  public:
  void clear_elimination_dpc_points();
  uint32_t elimination_dpc_points() const;
  void set_elimination_dpc_points(uint32_t value);
  private:
  uint32_t _internal_elimination_dpc_points() const;
  void _internal_set_elimination_dpc_points(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueNodeGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > incoming_node_group_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup_TeamStanding > team_standings_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode > nodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup > node_groups_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t node_group_id_;
    uint32_t parent_node_group_id_;
    uint32_t advancing_node_group_id_;
    uint32_t advancing_team_count_;
    uint32_t team_count_;
    int node_group_type_;
    int default_node_type_;
    uint32_t round_;
    uint32_t max_rounds_;
    bool is_tiebreaker_;
    bool is_final_group_;
    bool is_completed_;
    int phase_;
    int region_;
    uint32_t start_time_;
    uint32_t end_time_;
    uint32_t secondary_advancing_node_group_id_;
    uint32_t secondary_advancing_team_count_;
    uint32_t tertiary_advancing_node_group_id_;
    uint32_t tertiary_advancing_team_count_;
    uint32_t elimination_dpc_points_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeague.Info) */ {
 public:
  inline CMsgDOTALeague_Info() : CMsgDOTALeague_Info(nullptr) {}
  ~CMsgDOTALeague_Info() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeague_Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeague_Info(const CMsgDOTALeague_Info& from);
  CMsgDOTALeague_Info(CMsgDOTALeague_Info&& from) noexcept
    : CMsgDOTALeague_Info() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_Info& operator=(const CMsgDOTALeague_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeague_Info& operator=(CMsgDOTALeague_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeague_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeague_Info* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_Info*>(
               &_CMsgDOTALeague_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CMsgDOTALeague_Info& a, CMsgDOTALeague_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeague_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeague_Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeague_Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeague_Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeague_Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeague_Info& from) {
    CMsgDOTALeague_Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeague.Info";
  }
  protected:
  explicit CMsgDOTALeague_Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kUrlFieldNumber = 5,
    kDescriptionFieldNumber = 6,
    kNotesFieldNumber = 7,
    kLeagueIdFieldNumber = 1,
    kTierFieldNumber = 3,
    kRegionFieldNumber = 4,
    kStartTimestampFieldNumber = 8,
    kEndTimestampFieldNumber = 9,
    kProCircuitPointsFieldNumber = 10,
    kImageBitsFieldNumber = 11,
    kStatusFieldNumber = 12,
    kMostRecentActivityFieldNumber = 13,
    kRegistrationPeriodFieldNumber = 14,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string url = 5;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string description = 6;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string notes = 7;
  bool has_notes() const;
  private:
  bool _internal_has_notes() const;
  public:
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  private:
  bool _internal_has_league_id() const;
  public:
  void clear_league_id();
  uint32_t league_id() const;
  void set_league_id(uint32_t value);
  private:
  uint32_t _internal_league_id() const;
  void _internal_set_league_id(uint32_t value);
  public:

  // optional .ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
  bool has_tier() const;
  private:
  bool _internal_has_tier() const;
  public:
  void clear_tier();
  ::ELeagueTier tier() const;
  void set_tier(::ELeagueTier value);
  private:
  ::ELeagueTier _internal_tier() const;
  void _internal_set_tier(::ELeagueTier value);
  public:

  // optional .ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  ::ELeagueRegion region() const;
  void set_region(::ELeagueRegion value);
  private:
  ::ELeagueRegion _internal_region() const;
  void _internal_set_region(::ELeagueRegion value);
  public:

  // optional uint32 start_timestamp = 8;
  bool has_start_timestamp() const;
  private:
  bool _internal_has_start_timestamp() const;
  public:
  void clear_start_timestamp();
  uint32_t start_timestamp() const;
  void set_start_timestamp(uint32_t value);
  private:
  uint32_t _internal_start_timestamp() const;
  void _internal_set_start_timestamp(uint32_t value);
  public:

  // optional uint32 end_timestamp = 9;
  bool has_end_timestamp() const;
  private:
  bool _internal_has_end_timestamp() const;
  public:
  void clear_end_timestamp();
  uint32_t end_timestamp() const;
  void set_end_timestamp(uint32_t value);
  private:
  uint32_t _internal_end_timestamp() const;
  void _internal_set_end_timestamp(uint32_t value);
  public:

  // optional uint32 pro_circuit_points = 10;
  bool has_pro_circuit_points() const;
  private:
  bool _internal_has_pro_circuit_points() const;
  public:
  void clear_pro_circuit_points();
  uint32_t pro_circuit_points() const;
  void set_pro_circuit_points(uint32_t value);
  private:
  uint32_t _internal_pro_circuit_points() const;
  void _internal_set_pro_circuit_points(uint32_t value);
  public:

  // optional uint32 image_bits = 11;
  bool has_image_bits() const;
  private:
  bool _internal_has_image_bits() const;
  public:
  void clear_image_bits();
  uint32_t image_bits() const;
  void set_image_bits(uint32_t value);
  private:
  uint32_t _internal_image_bits() const;
  void _internal_set_image_bits(uint32_t value);
  public:

  // optional .ELeagueStatus status = 12 [default = LEAGUE_STATUS_UNSET];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::ELeagueStatus status() const;
  void set_status(::ELeagueStatus value);
  private:
  ::ELeagueStatus _internal_status() const;
  void _internal_set_status(::ELeagueStatus value);
  public:

  // optional uint32 most_recent_activity = 13;
  bool has_most_recent_activity() const;
  private:
  bool _internal_has_most_recent_activity() const;
  public:
  void clear_most_recent_activity();
  uint32_t most_recent_activity() const;
  void set_most_recent_activity(uint32_t value);
  private:
  uint32_t _internal_most_recent_activity() const;
  void _internal_set_most_recent_activity(uint32_t value);
  public:

  // optional uint32 registration_period = 14;
  bool has_registration_period() const;
  private:
  bool _internal_has_registration_period() const;
  public:
  void clear_registration_period();
  uint32_t registration_period() const;
  void set_registration_period(uint32_t value);
  private:
  uint32_t _internal_registration_period() const;
  void _internal_set_registration_period(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeague.Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
    uint32_t league_id_;
    int tier_;
    int region_;
    uint32_t start_timestamp_;
    uint32_t end_timestamp_;
    uint32_t pro_circuit_points_;
    uint32_t image_bits_;
    int status_;
    uint32_t most_recent_activity_;
    uint32_t registration_period_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_Admin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeague.Admin) */ {
 public:
  inline CMsgDOTALeague_Admin() : CMsgDOTALeague_Admin(nullptr) {}
  ~CMsgDOTALeague_Admin() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeague_Admin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeague_Admin(const CMsgDOTALeague_Admin& from);
  CMsgDOTALeague_Admin(CMsgDOTALeague_Admin&& from) noexcept
    : CMsgDOTALeague_Admin() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_Admin& operator=(const CMsgDOTALeague_Admin& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeague_Admin& operator=(CMsgDOTALeague_Admin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeague_Admin& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeague_Admin* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_Admin*>(
               &_CMsgDOTALeague_Admin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CMsgDOTALeague_Admin& a, CMsgDOTALeague_Admin& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeague_Admin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeague_Admin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeague_Admin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeague_Admin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeague_Admin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeague_Admin& from) {
    CMsgDOTALeague_Admin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_Admin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeague.Admin";
  }
  protected:
  explicit CMsgDOTALeague_Admin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailAddressFieldNumber = 3,
    kAccountIdFieldNumber = 1,
    kIsPrimaryFieldNumber = 2,
  };
  // optional string email_address = 3;
  bool has_email_address() const;
  private:
  bool _internal_has_email_address() const;
  public:
  void clear_email_address();
  const std::string& email_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email_address();
  PROTOBUF_NODISCARD std::string* release_email_address();
  void set_allocated_email_address(std::string* email_address);
  private:
  const std::string& _internal_email_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email_address(const std::string& value);
  std::string* _internal_mutable_email_address();
  public:

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  uint32_t account_id() const;
  void set_account_id(uint32_t value);
  private:
  uint32_t _internal_account_id() const;
  void _internal_set_account_id(uint32_t value);
  public:

  // optional bool is_primary = 2;
  bool has_is_primary() const;
  private:
  bool _internal_has_is_primary() const;
  public:
  void clear_is_primary();
  bool is_primary() const;
  void set_is_primary(bool value);
  private:
  bool _internal_is_primary() const;
  void _internal_set_is_primary(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeague.Admin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_address_;
    uint32_t account_id_;
    bool is_primary_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_PrizePoolItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeague.PrizePoolItem) */ {
 public:
  inline CMsgDOTALeague_PrizePoolItem() : CMsgDOTALeague_PrizePoolItem(nullptr) {}
  ~CMsgDOTALeague_PrizePoolItem() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeague_PrizePoolItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeague_PrizePoolItem(const CMsgDOTALeague_PrizePoolItem& from);
  CMsgDOTALeague_PrizePoolItem(CMsgDOTALeague_PrizePoolItem&& from) noexcept
    : CMsgDOTALeague_PrizePoolItem() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_PrizePoolItem& operator=(const CMsgDOTALeague_PrizePoolItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeague_PrizePoolItem& operator=(CMsgDOTALeague_PrizePoolItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeague_PrizePoolItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeague_PrizePoolItem* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_PrizePoolItem*>(
               &_CMsgDOTALeague_PrizePoolItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CMsgDOTALeague_PrizePoolItem& a, CMsgDOTALeague_PrizePoolItem& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeague_PrizePoolItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeague_PrizePoolItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeague_PrizePoolItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeague_PrizePoolItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeague_PrizePoolItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeague_PrizePoolItem& from) {
    CMsgDOTALeague_PrizePoolItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_PrizePoolItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeague.PrizePoolItem";
  }
  protected:
  explicit CMsgDOTALeague_PrizePoolItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemDefFieldNumber = 1,
    kSalesStopTimestampFieldNumber = 2,
    kRevenuePctFieldNumber = 3,
    kRevenueCentsPerSaleFieldNumber = 4,
  };
  // optional uint32 item_def = 1;
  bool has_item_def() const;
  private:
  bool _internal_has_item_def() const;
  public:
  void clear_item_def();
  uint32_t item_def() const;
  void set_item_def(uint32_t value);
  private:
  uint32_t _internal_item_def() const;
  void _internal_set_item_def(uint32_t value);
  public:

  // optional uint32 sales_stop_timestamp = 2;
  bool has_sales_stop_timestamp() const;
  private:
  bool _internal_has_sales_stop_timestamp() const;
  public:
  void clear_sales_stop_timestamp();
  uint32_t sales_stop_timestamp() const;
  void set_sales_stop_timestamp(uint32_t value);
  private:
  uint32_t _internal_sales_stop_timestamp() const;
  void _internal_set_sales_stop_timestamp(uint32_t value);
  public:

  // optional uint32 revenue_pct = 3;
  bool has_revenue_pct() const;
  private:
  bool _internal_has_revenue_pct() const;
  public:
  void clear_revenue_pct();
  uint32_t revenue_pct() const;
  void set_revenue_pct(uint32_t value);
  private:
  uint32_t _internal_revenue_pct() const;
  void _internal_set_revenue_pct(uint32_t value);
  public:

  // optional uint32 revenue_cents_per_sale = 4;
  bool has_revenue_cents_per_sale() const;
  private:
  bool _internal_has_revenue_cents_per_sale() const;
  public:
  void clear_revenue_cents_per_sale();
  uint32_t revenue_cents_per_sale() const;
  void set_revenue_cents_per_sale(uint32_t value);
  private:
  uint32_t _internal_revenue_cents_per_sale() const;
  void _internal_set_revenue_cents_per_sale(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeague.PrizePoolItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t item_def_;
    uint32_t sales_stop_timestamp_;
    uint32_t revenue_pct_;
    uint32_t revenue_cents_per_sale_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_PrizePool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeague.PrizePool) */ {
 public:
  inline CMsgDOTALeague_PrizePool() : CMsgDOTALeague_PrizePool(nullptr) {}
  ~CMsgDOTALeague_PrizePool() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeague_PrizePool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeague_PrizePool(const CMsgDOTALeague_PrizePool& from);
  CMsgDOTALeague_PrizePool(CMsgDOTALeague_PrizePool&& from) noexcept
    : CMsgDOTALeague_PrizePool() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_PrizePool& operator=(const CMsgDOTALeague_PrizePool& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeague_PrizePool& operator=(CMsgDOTALeague_PrizePool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeague_PrizePool& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeague_PrizePool* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_PrizePool*>(
               &_CMsgDOTALeague_PrizePool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CMsgDOTALeague_PrizePool& a, CMsgDOTALeague_PrizePool& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeague_PrizePool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeague_PrizePool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeague_PrizePool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeague_PrizePool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeague_PrizePool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeague_PrizePool& from) {
    CMsgDOTALeague_PrizePool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_PrizePool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeague.PrizePool";
  }
  protected:
  explicit CMsgDOTALeague_PrizePool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrizeSplitPctX100FieldNumber = 3,
    kPrizePoolItemsFieldNumber = 4,
    kBasePrizePoolFieldNumber = 1,
    kTotalPrizePoolFieldNumber = 2,
  };
  // repeated uint32 prize_split_pct_x100 = 3;
  int prize_split_pct_x100_size() const;
  private:
  int _internal_prize_split_pct_x100_size() const;
  public:
  void clear_prize_split_pct_x100();
  private:
  uint32_t _internal_prize_split_pct_x100(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_prize_split_pct_x100() const;
  void _internal_add_prize_split_pct_x100(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_prize_split_pct_x100();
  public:
  uint32_t prize_split_pct_x100(int index) const;
  void set_prize_split_pct_x100(int index, uint32_t value);
  void add_prize_split_pct_x100(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      prize_split_pct_x100() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_prize_split_pct_x100();

  // repeated .CMsgDOTALeague.PrizePoolItem prize_pool_items = 4;
  int prize_pool_items_size() const;
  private:
  int _internal_prize_pool_items_size() const;
  public:
  void clear_prize_pool_items();
  ::CMsgDOTALeague_PrizePoolItem* mutable_prize_pool_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_PrizePoolItem >*
      mutable_prize_pool_items();
  private:
  const ::CMsgDOTALeague_PrizePoolItem& _internal_prize_pool_items(int index) const;
  ::CMsgDOTALeague_PrizePoolItem* _internal_add_prize_pool_items();
  public:
  const ::CMsgDOTALeague_PrizePoolItem& prize_pool_items(int index) const;
  ::CMsgDOTALeague_PrizePoolItem* add_prize_pool_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_PrizePoolItem >&
      prize_pool_items() const;

  // optional uint32 base_prize_pool = 1;
  bool has_base_prize_pool() const;
  private:
  bool _internal_has_base_prize_pool() const;
  public:
  void clear_base_prize_pool();
  uint32_t base_prize_pool() const;
  void set_base_prize_pool(uint32_t value);
  private:
  uint32_t _internal_base_prize_pool() const;
  void _internal_set_base_prize_pool(uint32_t value);
  public:

  // optional uint32 total_prize_pool = 2;
  bool has_total_prize_pool() const;
  private:
  bool _internal_has_total_prize_pool() const;
  public:
  void clear_total_prize_pool();
  uint32_t total_prize_pool() const;
  void set_total_prize_pool(uint32_t value);
  private:
  uint32_t _internal_total_prize_pool() const;
  void _internal_set_total_prize_pool(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeague.PrizePool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > prize_split_pct_x100_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_PrizePoolItem > prize_pool_items_;
    uint32_t base_prize_pool_;
    uint32_t total_prize_pool_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_Stream final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeague.Stream) */ {
 public:
  inline CMsgDOTALeague_Stream() : CMsgDOTALeague_Stream(nullptr) {}
  ~CMsgDOTALeague_Stream() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeague_Stream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeague_Stream(const CMsgDOTALeague_Stream& from);
  CMsgDOTALeague_Stream(CMsgDOTALeague_Stream&& from) noexcept
    : CMsgDOTALeague_Stream() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_Stream& operator=(const CMsgDOTALeague_Stream& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeague_Stream& operator=(CMsgDOTALeague_Stream&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeague_Stream& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeague_Stream* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_Stream*>(
               &_CMsgDOTALeague_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CMsgDOTALeague_Stream& a, CMsgDOTALeague_Stream& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeague_Stream* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeague_Stream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeague_Stream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeague_Stream>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeague_Stream& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeague_Stream& from) {
    CMsgDOTALeague_Stream::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_Stream* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeague.Stream";
  }
  protected:
  explicit CMsgDOTALeague_Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kStreamUrlFieldNumber = 5,
    kVodUrlFieldNumber = 6,
    kStreamIdFieldNumber = 1,
    kLanguageFieldNumber = 2,
    kBroadcastProviderFieldNumber = 4,
  };
  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string stream_url = 5;
  bool has_stream_url() const;
  private:
  bool _internal_has_stream_url() const;
  public:
  void clear_stream_url();
  const std::string& stream_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_url();
  PROTOBUF_NODISCARD std::string* release_stream_url();
  void set_allocated_stream_url(std::string* stream_url);
  private:
  const std::string& _internal_stream_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_url(const std::string& value);
  std::string* _internal_mutable_stream_url();
  public:

  // optional string vod_url = 6;
  bool has_vod_url() const;
  private:
  bool _internal_has_vod_url() const;
  public:
  void clear_vod_url();
  const std::string& vod_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vod_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vod_url();
  PROTOBUF_NODISCARD std::string* release_vod_url();
  void set_allocated_vod_url(std::string* vod_url);
  private:
  const std::string& _internal_vod_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vod_url(const std::string& value);
  std::string* _internal_mutable_vod_url();
  public:

  // optional uint32 stream_id = 1;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  uint32_t stream_id() const;
  void set_stream_id(uint32_t value);
  private:
  uint32_t _internal_stream_id() const;
  void _internal_set_stream_id(uint32_t value);
  public:

  // optional uint32 language = 2;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  uint32_t language() const;
  void set_language(uint32_t value);
  private:
  uint32_t _internal_language() const;
  void _internal_set_language(uint32_t value);
  public:

  // optional .ELeagueBroadcastProvider broadcast_provider = 4 [default = LEAGUE_BROADCAST_UNKNOWN];
  bool has_broadcast_provider() const;
  private:
  bool _internal_has_broadcast_provider() const;
  public:
  void clear_broadcast_provider();
  ::ELeagueBroadcastProvider broadcast_provider() const;
  void set_broadcast_provider(::ELeagueBroadcastProvider value);
  private:
  ::ELeagueBroadcastProvider _internal_broadcast_provider() const;
  void _internal_set_broadcast_provider(::ELeagueBroadcastProvider value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeague.Stream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vod_url_;
    uint32_t stream_id_;
    uint32_t language_;
    int broadcast_provider_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_SeriesInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeague.SeriesInfo) */ {
 public:
  inline CMsgDOTALeague_SeriesInfo() : CMsgDOTALeague_SeriesInfo(nullptr) {}
  ~CMsgDOTALeague_SeriesInfo() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeague_SeriesInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeague_SeriesInfo(const CMsgDOTALeague_SeriesInfo& from);
  CMsgDOTALeague_SeriesInfo(CMsgDOTALeague_SeriesInfo&& from) noexcept
    : CMsgDOTALeague_SeriesInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_SeriesInfo& operator=(const CMsgDOTALeague_SeriesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeague_SeriesInfo& operator=(CMsgDOTALeague_SeriesInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeague_SeriesInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeague_SeriesInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_SeriesInfo*>(
               &_CMsgDOTALeague_SeriesInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CMsgDOTALeague_SeriesInfo& a, CMsgDOTALeague_SeriesInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeague_SeriesInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeague_SeriesInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeague_SeriesInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeague_SeriesInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeague_SeriesInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeague_SeriesInfo& from) {
    CMsgDOTALeague_SeriesInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_SeriesInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeague.SeriesInfo";
  }
  protected:
  explicit CMsgDOTALeague_SeriesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchIdsFieldNumber = 4,
    kSeriesIdFieldNumber = 1,
    kSeriesTypeFieldNumber = 2,
    kStartTimeFieldNumber = 3,
    kTeamId1FieldNumber = 5,
    kTeamId2FieldNumber = 6,
  };
  // repeated uint64 match_ids = 4;
  int match_ids_size() const;
  private:
  int _internal_match_ids_size() const;
  public:
  void clear_match_ids();
  private:
  uint64_t _internal_match_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_match_ids() const;
  void _internal_add_match_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_match_ids();
  public:
  uint64_t match_ids(int index) const;
  void set_match_ids(int index, uint64_t value);
  void add_match_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      match_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_match_ids();

  // optional uint32 series_id = 1;
  bool has_series_id() const;
  private:
  bool _internal_has_series_id() const;
  public:
  void clear_series_id();
  uint32_t series_id() const;
  void set_series_id(uint32_t value);
  private:
  uint32_t _internal_series_id() const;
  void _internal_set_series_id(uint32_t value);
  public:

  // optional uint32 series_type = 2;
  bool has_series_type() const;
  private:
  bool _internal_has_series_type() const;
  public:
  void clear_series_type();
  uint32_t series_type() const;
  void set_series_type(uint32_t value);
  private:
  uint32_t _internal_series_type() const;
  void _internal_set_series_type(uint32_t value);
  public:

  // optional uint32 start_time = 3;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  uint32_t start_time() const;
  void set_start_time(uint32_t value);
  private:
  uint32_t _internal_start_time() const;
  void _internal_set_start_time(uint32_t value);
  public:

  // optional uint32 team_id_1 = 5;
  bool has_team_id_1() const;
  private:
  bool _internal_has_team_id_1() const;
  public:
  void clear_team_id_1();
  uint32_t team_id_1() const;
  void set_team_id_1(uint32_t value);
  private:
  uint32_t _internal_team_id_1() const;
  void _internal_set_team_id_1(uint32_t value);
  public:

  // optional uint32 team_id_2 = 6;
  bool has_team_id_2() const;
  private:
  bool _internal_has_team_id_2() const;
  public:
  void clear_team_id_2();
  uint32_t team_id_2() const;
  void set_team_id_2(uint32_t value);
  private:
  uint32_t _internal_team_id_2() const;
  void _internal_set_team_id_2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeague.SeriesInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > match_ids_;
    uint32_t series_id_;
    uint32_t series_type_;
    uint32_t start_time_;
    uint32_t team_id_1_;
    uint32_t team_id_2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeague.Player) */ {
 public:
  inline CMsgDOTALeague_Player() : CMsgDOTALeague_Player(nullptr) {}
  ~CMsgDOTALeague_Player() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeague_Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeague_Player(const CMsgDOTALeague_Player& from);
  CMsgDOTALeague_Player(CMsgDOTALeague_Player&& from) noexcept
    : CMsgDOTALeague_Player() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_Player& operator=(const CMsgDOTALeague_Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeague_Player& operator=(CMsgDOTALeague_Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeague_Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeague_Player* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_Player*>(
               &_CMsgDOTALeague_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CMsgDOTALeague_Player& a, CMsgDOTALeague_Player& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeague_Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeague_Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeague_Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeague_Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeague_Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeague_Player& from) {
    CMsgDOTALeague_Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeague.Player";
  }
  protected:
  explicit CMsgDOTALeague_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kAccountIdFieldNumber = 1,
    kTeamIdFieldNumber = 3,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  private:
  bool _internal_has_account_id() const;
  public:
  void clear_account_id();
  uint32_t account_id() const;
  void set_account_id(uint32_t value);
  private:
  uint32_t _internal_account_id() const;
  void _internal_set_account_id(uint32_t value);
  public:

  // optional uint32 team_id = 3;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  uint32_t team_id() const;
  void set_team_id(uint32_t value);
  private:
  uint32_t _internal_team_id() const;
  void _internal_set_team_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeague.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t account_id_;
    uint32_t team_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeague) */ {
 public:
  inline CMsgDOTALeague() : CMsgDOTALeague(nullptr) {}
  ~CMsgDOTALeague() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeague(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeague(const CMsgDOTALeague& from);
  CMsgDOTALeague(CMsgDOTALeague&& from) noexcept
    : CMsgDOTALeague() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague& operator=(const CMsgDOTALeague& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeague& operator=(CMsgDOTALeague&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeague& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeague* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague*>(
               &_CMsgDOTALeague_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CMsgDOTALeague& a, CMsgDOTALeague& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeague* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeague* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeague* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeague>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeague& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeague& from) {
    CMsgDOTALeague::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeague";
  }
  protected:
  explicit CMsgDOTALeague(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeague_Info Info;
  typedef CMsgDOTALeague_Admin Admin;
  typedef CMsgDOTALeague_PrizePoolItem PrizePoolItem;
  typedef CMsgDOTALeague_PrizePool PrizePool;
  typedef CMsgDOTALeague_Stream Stream;
  typedef CMsgDOTALeague_SeriesInfo SeriesInfo;
  typedef CMsgDOTALeague_Player Player;

  // accessors -------------------------------------------------------

  enum : int {
    kAdminsFieldNumber = 3,
    kStreamsFieldNumber = 4,
    kNodeGroupsFieldNumber = 5,
    kSeriesInfosFieldNumber = 6,
    kRegisteredPlayersFieldNumber = 7,
    kInfoFieldNumber = 1,
    kPrizePoolFieldNumber = 2,
  };
  // repeated .CMsgDOTALeague.Admin admins = 3;
  int admins_size() const;
  private:
  int _internal_admins_size() const;
  public:
  void clear_admins();
  ::CMsgDOTALeague_Admin* mutable_admins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Admin >*
      mutable_admins();
  private:
  const ::CMsgDOTALeague_Admin& _internal_admins(int index) const;
  ::CMsgDOTALeague_Admin* _internal_add_admins();
  public:
  const ::CMsgDOTALeague_Admin& admins(int index) const;
  ::CMsgDOTALeague_Admin* add_admins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Admin >&
      admins() const;

  // repeated .CMsgDOTALeague.Stream streams = 4;
  int streams_size() const;
  private:
  int _internal_streams_size() const;
  public:
  void clear_streams();
  ::CMsgDOTALeague_Stream* mutable_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Stream >*
      mutable_streams();
  private:
  const ::CMsgDOTALeague_Stream& _internal_streams(int index) const;
  ::CMsgDOTALeague_Stream* _internal_add_streams();
  public:
  const ::CMsgDOTALeague_Stream& streams(int index) const;
  ::CMsgDOTALeague_Stream* add_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Stream >&
      streams() const;

  // repeated .CMsgDOTALeagueNodeGroup node_groups = 5;
  int node_groups_size() const;
  private:
  int _internal_node_groups_size() const;
  public:
  void clear_node_groups();
  ::CMsgDOTALeagueNodeGroup* mutable_node_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup >*
      mutable_node_groups();
  private:
  const ::CMsgDOTALeagueNodeGroup& _internal_node_groups(int index) const;
  ::CMsgDOTALeagueNodeGroup* _internal_add_node_groups();
  public:
  const ::CMsgDOTALeagueNodeGroup& node_groups(int index) const;
  ::CMsgDOTALeagueNodeGroup* add_node_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup >&
      node_groups() const;

  // repeated .CMsgDOTALeague.SeriesInfo series_infos = 6;
  int series_infos_size() const;
  private:
  int _internal_series_infos_size() const;
  public:
  void clear_series_infos();
  ::CMsgDOTALeague_SeriesInfo* mutable_series_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_SeriesInfo >*
      mutable_series_infos();
  private:
  const ::CMsgDOTALeague_SeriesInfo& _internal_series_infos(int index) const;
  ::CMsgDOTALeague_SeriesInfo* _internal_add_series_infos();
  public:
  const ::CMsgDOTALeague_SeriesInfo& series_infos(int index) const;
  ::CMsgDOTALeague_SeriesInfo* add_series_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_SeriesInfo >&
      series_infos() const;

  // repeated .CMsgDOTALeague.Player registered_players = 7;
  int registered_players_size() const;
  private:
  int _internal_registered_players_size() const;
  public:
  void clear_registered_players();
  ::CMsgDOTALeague_Player* mutable_registered_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Player >*
      mutable_registered_players();
  private:
  const ::CMsgDOTALeague_Player& _internal_registered_players(int index) const;
  ::CMsgDOTALeague_Player* _internal_add_registered_players();
  public:
  const ::CMsgDOTALeague_Player& registered_players(int index) const;
  ::CMsgDOTALeague_Player* add_registered_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Player >&
      registered_players() const;

  // optional .CMsgDOTALeague.Info info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::CMsgDOTALeague_Info& info() const;
  PROTOBUF_NODISCARD ::CMsgDOTALeague_Info* release_info();
  ::CMsgDOTALeague_Info* mutable_info();
  void set_allocated_info(::CMsgDOTALeague_Info* info);
  private:
  const ::CMsgDOTALeague_Info& _internal_info() const;
  ::CMsgDOTALeague_Info* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::CMsgDOTALeague_Info* info);
  ::CMsgDOTALeague_Info* unsafe_arena_release_info();

  // optional .CMsgDOTALeague.PrizePool prize_pool = 2;
  bool has_prize_pool() const;
  private:
  bool _internal_has_prize_pool() const;
  public:
  void clear_prize_pool();
  const ::CMsgDOTALeague_PrizePool& prize_pool() const;
  PROTOBUF_NODISCARD ::CMsgDOTALeague_PrizePool* release_prize_pool();
  ::CMsgDOTALeague_PrizePool* mutable_prize_pool();
  void set_allocated_prize_pool(::CMsgDOTALeague_PrizePool* prize_pool);
  private:
  const ::CMsgDOTALeague_PrizePool& _internal_prize_pool() const;
  ::CMsgDOTALeague_PrizePool* _internal_mutable_prize_pool();
  public:
  void unsafe_arena_set_allocated_prize_pool(
      ::CMsgDOTALeague_PrizePool* prize_pool);
  ::CMsgDOTALeague_PrizePool* unsafe_arena_release_prize_pool();

  // @@protoc_insertion_point(class_scope:CMsgDOTALeague)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Admin > admins_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Stream > streams_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup > node_groups_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_SeriesInfo > series_infos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Player > registered_players_;
    ::CMsgDOTALeague_Info* info_;
    ::CMsgDOTALeague_PrizePool* prize_pool_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueList) */ {
 public:
  inline CMsgDOTALeagueList() : CMsgDOTALeagueList(nullptr) {}
  ~CMsgDOTALeagueList() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueList(const CMsgDOTALeagueList& from);
  CMsgDOTALeagueList(CMsgDOTALeagueList&& from) noexcept
    : CMsgDOTALeagueList() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueList& operator=(const CMsgDOTALeagueList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueList& operator=(CMsgDOTALeagueList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueList* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueList*>(
               &_CMsgDOTALeagueList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CMsgDOTALeagueList& a, CMsgDOTALeagueList& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueList& from) {
    CMsgDOTALeagueList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueList";
  }
  protected:
  explicit CMsgDOTALeagueList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaguesFieldNumber = 1,
  };
  // repeated .CMsgDOTALeague leagues = 1;
  int leagues_size() const;
  private:
  int _internal_leagues_size() const;
  public:
  void clear_leagues();
  ::CMsgDOTALeague* mutable_leagues(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague >*
      mutable_leagues();
  private:
  const ::CMsgDOTALeague& _internal_leagues(int index) const;
  ::CMsgDOTALeague* _internal_add_leagues();
  public:
  const ::CMsgDOTALeague& leagues(int index) const;
  ::CMsgDOTALeague* add_leagues();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague >&
      leagues() const;

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague > leagues_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueInfo) */ {
 public:
  inline CMsgDOTALeagueInfo() : CMsgDOTALeagueInfo(nullptr) {}
  ~CMsgDOTALeagueInfo() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueInfo(const CMsgDOTALeagueInfo& from);
  CMsgDOTALeagueInfo(CMsgDOTALeagueInfo&& from) noexcept
    : CMsgDOTALeagueInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueInfo& operator=(const CMsgDOTALeagueInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueInfo& operator=(CMsgDOTALeagueInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueInfo*>(
               &_CMsgDOTALeagueInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CMsgDOTALeagueInfo& a, CMsgDOTALeagueInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueInfo& from) {
    CMsgDOTALeagueInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueInfo";
  }
  protected:
  explicit CMsgDOTALeagueInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kLeagueIdFieldNumber = 1,
    kTierFieldNumber = 3,
    kRegionFieldNumber = 4,
    kMostRecentActivityFieldNumber = 5,
    kTotalPrizePoolFieldNumber = 6,
    kStartTimestampFieldNumber = 7,
    kEndTimestampFieldNumber = 8,
    kStatusFieldNumber = 9,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  private:
  bool _internal_has_league_id() const;
  public:
  void clear_league_id();
  uint32_t league_id() const;
  void set_league_id(uint32_t value);
  private:
  uint32_t _internal_league_id() const;
  void _internal_set_league_id(uint32_t value);
  public:

  // optional .ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
  bool has_tier() const;
  private:
  bool _internal_has_tier() const;
  public:
  void clear_tier();
  ::ELeagueTier tier() const;
  void set_tier(::ELeagueTier value);
  private:
  ::ELeagueTier _internal_tier() const;
  void _internal_set_tier(::ELeagueTier value);
  public:

  // optional .ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  ::ELeagueRegion region() const;
  void set_region(::ELeagueRegion value);
  private:
  ::ELeagueRegion _internal_region() const;
  void _internal_set_region(::ELeagueRegion value);
  public:

  // optional uint32 most_recent_activity = 5;
  bool has_most_recent_activity() const;
  private:
  bool _internal_has_most_recent_activity() const;
  public:
  void clear_most_recent_activity();
  uint32_t most_recent_activity() const;
  void set_most_recent_activity(uint32_t value);
  private:
  uint32_t _internal_most_recent_activity() const;
  void _internal_set_most_recent_activity(uint32_t value);
  public:

  // optional uint32 total_prize_pool = 6;
  bool has_total_prize_pool() const;
  private:
  bool _internal_has_total_prize_pool() const;
  public:
  void clear_total_prize_pool();
  uint32_t total_prize_pool() const;
  void set_total_prize_pool(uint32_t value);
  private:
  uint32_t _internal_total_prize_pool() const;
  void _internal_set_total_prize_pool(uint32_t value);
  public:

  // optional uint32 start_timestamp = 7;
  bool has_start_timestamp() const;
  private:
  bool _internal_has_start_timestamp() const;
  public:
  void clear_start_timestamp();
  uint32_t start_timestamp() const;
  void set_start_timestamp(uint32_t value);
  private:
  uint32_t _internal_start_timestamp() const;
  void _internal_set_start_timestamp(uint32_t value);
  public:

  // optional uint32 end_timestamp = 8;
  bool has_end_timestamp() const;
  private:
  bool _internal_has_end_timestamp() const;
  public:
  void clear_end_timestamp();
  uint32_t end_timestamp() const;
  void set_end_timestamp(uint32_t value);
  private:
  uint32_t _internal_end_timestamp() const;
  void _internal_set_end_timestamp(uint32_t value);
  public:

  // optional uint32 status = 9;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t league_id_;
    int tier_;
    int region_;
    uint32_t most_recent_activity_;
    uint32_t total_prize_pool_;
    uint32_t start_timestamp_;
    uint32_t end_timestamp_;
    uint32_t status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueInfoList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueInfoList) */ {
 public:
  inline CMsgDOTALeagueInfoList() : CMsgDOTALeagueInfoList(nullptr) {}
  ~CMsgDOTALeagueInfoList() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueInfoList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueInfoList(const CMsgDOTALeagueInfoList& from);
  CMsgDOTALeagueInfoList(CMsgDOTALeagueInfoList&& from) noexcept
    : CMsgDOTALeagueInfoList() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueInfoList& operator=(const CMsgDOTALeagueInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueInfoList& operator=(CMsgDOTALeagueInfoList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueInfoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueInfoList* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueInfoList*>(
               &_CMsgDOTALeagueInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CMsgDOTALeagueInfoList& a, CMsgDOTALeagueInfoList& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueInfoList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueInfoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueInfoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueInfoList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueInfoList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueInfoList& from) {
    CMsgDOTALeagueInfoList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueInfoList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueInfoList";
  }
  protected:
  explicit CMsgDOTALeagueInfoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfosFieldNumber = 1,
  };
  // repeated .CMsgDOTALeagueInfo infos = 1;
  int infos_size() const;
  private:
  int _internal_infos_size() const;
  public:
  void clear_infos();
  ::CMsgDOTALeagueInfo* mutable_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueInfo >*
      mutable_infos();
  private:
  const ::CMsgDOTALeagueInfo& _internal_infos(int index) const;
  ::CMsgDOTALeagueInfo* _internal_add_infos();
  public:
  const ::CMsgDOTALeagueInfo& infos(int index) const;
  ::CMsgDOTALeagueInfo* add_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueInfo >&
      infos() const;

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueInfoList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueInfo > infos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueLiveGames_LiveGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueLiveGames.LiveGame) */ {
 public:
  inline CMsgDOTALeagueLiveGames_LiveGame() : CMsgDOTALeagueLiveGames_LiveGame(nullptr) {}
  ~CMsgDOTALeagueLiveGames_LiveGame() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueLiveGames_LiveGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueLiveGames_LiveGame(const CMsgDOTALeagueLiveGames_LiveGame& from);
  CMsgDOTALeagueLiveGames_LiveGame(CMsgDOTALeagueLiveGames_LiveGame&& from) noexcept
    : CMsgDOTALeagueLiveGames_LiveGame() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueLiveGames_LiveGame& operator=(const CMsgDOTALeagueLiveGames_LiveGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueLiveGames_LiveGame& operator=(CMsgDOTALeagueLiveGames_LiveGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueLiveGames_LiveGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueLiveGames_LiveGame* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueLiveGames_LiveGame*>(
               &_CMsgDOTALeagueLiveGames_LiveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CMsgDOTALeagueLiveGames_LiveGame& a, CMsgDOTALeagueLiveGames_LiveGame& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueLiveGames_LiveGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueLiveGames_LiveGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueLiveGames_LiveGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueLiveGames_LiveGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueLiveGames_LiveGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueLiveGames_LiveGame& from) {
    CMsgDOTALeagueLiveGames_LiveGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueLiveGames_LiveGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueLiveGames.LiveGame";
  }
  protected:
  explicit CMsgDOTALeagueLiveGames_LiveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadiantNameFieldNumber = 3,
    kDireNameFieldNumber = 5,
    kServerSteamIdFieldNumber = 2,
    kRadiantLogoFieldNumber = 4,
    kLeagueIdFieldNumber = 1,
    kTimeFieldNumber = 7,
    kDireLogoFieldNumber = 6,
    kSpectatorsFieldNumber = 8,
    kRadiantTeamIdFieldNumber = 9,
    kDireTeamIdFieldNumber = 10,
    kLeagueNodeIdFieldNumber = 11,
    kMatchIdFieldNumber = 13,
    kSeriesIdFieldNumber = 12,
  };
  // optional string radiant_name = 3;
  bool has_radiant_name() const;
  private:
  bool _internal_has_radiant_name() const;
  public:
  void clear_radiant_name();
  const std::string& radiant_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_radiant_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_radiant_name();
  PROTOBUF_NODISCARD std::string* release_radiant_name();
  void set_allocated_radiant_name(std::string* radiant_name);
  private:
  const std::string& _internal_radiant_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_radiant_name(const std::string& value);
  std::string* _internal_mutable_radiant_name();
  public:

  // optional string dire_name = 5;
  bool has_dire_name() const;
  private:
  bool _internal_has_dire_name() const;
  public:
  void clear_dire_name();
  const std::string& dire_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dire_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dire_name();
  PROTOBUF_NODISCARD std::string* release_dire_name();
  void set_allocated_dire_name(std::string* dire_name);
  private:
  const std::string& _internal_dire_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dire_name(const std::string& value);
  std::string* _internal_mutable_dire_name();
  public:

  // optional uint64 server_steam_id = 2;
  bool has_server_steam_id() const;
  private:
  bool _internal_has_server_steam_id() const;
  public:
  void clear_server_steam_id();
  uint64_t server_steam_id() const;
  void set_server_steam_id(uint64_t value);
  private:
  uint64_t _internal_server_steam_id() const;
  void _internal_set_server_steam_id(uint64_t value);
  public:

  // optional uint64 radiant_logo = 4;
  bool has_radiant_logo() const;
  private:
  bool _internal_has_radiant_logo() const;
  public:
  void clear_radiant_logo();
  uint64_t radiant_logo() const;
  void set_radiant_logo(uint64_t value);
  private:
  uint64_t _internal_radiant_logo() const;
  void _internal_set_radiant_logo(uint64_t value);
  public:

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  private:
  bool _internal_has_league_id() const;
  public:
  void clear_league_id();
  uint32_t league_id() const;
  void set_league_id(uint32_t value);
  private:
  uint32_t _internal_league_id() const;
  void _internal_set_league_id(uint32_t value);
  public:

  // optional uint32 time = 7;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // optional uint64 dire_logo = 6;
  bool has_dire_logo() const;
  private:
  bool _internal_has_dire_logo() const;
  public:
  void clear_dire_logo();
  uint64_t dire_logo() const;
  void set_dire_logo(uint64_t value);
  private:
  uint64_t _internal_dire_logo() const;
  void _internal_set_dire_logo(uint64_t value);
  public:

  // optional uint32 spectators = 8;
  bool has_spectators() const;
  private:
  bool _internal_has_spectators() const;
  public:
  void clear_spectators();
  uint32_t spectators() const;
  void set_spectators(uint32_t value);
  private:
  uint32_t _internal_spectators() const;
  void _internal_set_spectators(uint32_t value);
  public:

  // optional uint32 radiant_team_id = 9;
  bool has_radiant_team_id() const;
  private:
  bool _internal_has_radiant_team_id() const;
  public:
  void clear_radiant_team_id();
  uint32_t radiant_team_id() const;
  void set_radiant_team_id(uint32_t value);
  private:
  uint32_t _internal_radiant_team_id() const;
  void _internal_set_radiant_team_id(uint32_t value);
  public:

  // optional uint32 dire_team_id = 10;
  bool has_dire_team_id() const;
  private:
  bool _internal_has_dire_team_id() const;
  public:
  void clear_dire_team_id();
  uint32_t dire_team_id() const;
  void set_dire_team_id(uint32_t value);
  private:
  uint32_t _internal_dire_team_id() const;
  void _internal_set_dire_team_id(uint32_t value);
  public:

  // optional uint32 league_node_id = 11;
  bool has_league_node_id() const;
  private:
  bool _internal_has_league_node_id() const;
  public:
  void clear_league_node_id();
  uint32_t league_node_id() const;
  void set_league_node_id(uint32_t value);
  private:
  uint32_t _internal_league_node_id() const;
  void _internal_set_league_node_id(uint32_t value);
  public:

  // optional uint64 match_id = 13;
  bool has_match_id() const;
  private:
  bool _internal_has_match_id() const;
  public:
  void clear_match_id();
  uint64_t match_id() const;
  void set_match_id(uint64_t value);
  private:
  uint64_t _internal_match_id() const;
  void _internal_set_match_id(uint64_t value);
  public:

  // optional uint32 series_id = 12;
  bool has_series_id() const;
  private:
  bool _internal_has_series_id() const;
  public:
  void clear_series_id();
  uint32_t series_id() const;
  void set_series_id(uint32_t value);
  private:
  uint32_t _internal_series_id() const;
  void _internal_set_series_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueLiveGames.LiveGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr radiant_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dire_name_;
    uint64_t server_steam_id_;
    uint64_t radiant_logo_;
    uint32_t league_id_;
    uint32_t time_;
    uint64_t dire_logo_;
    uint32_t spectators_;
    uint32_t radiant_team_id_;
    uint32_t dire_team_id_;
    uint32_t league_node_id_;
    uint64_t match_id_;
    uint32_t series_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueLiveGames final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueLiveGames) */ {
 public:
  inline CMsgDOTALeagueLiveGames() : CMsgDOTALeagueLiveGames(nullptr) {}
  ~CMsgDOTALeagueLiveGames() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueLiveGames(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueLiveGames(const CMsgDOTALeagueLiveGames& from);
  CMsgDOTALeagueLiveGames(CMsgDOTALeagueLiveGames&& from) noexcept
    : CMsgDOTALeagueLiveGames() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueLiveGames& operator=(const CMsgDOTALeagueLiveGames& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueLiveGames& operator=(CMsgDOTALeagueLiveGames&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueLiveGames& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueLiveGames* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueLiveGames*>(
               &_CMsgDOTALeagueLiveGames_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CMsgDOTALeagueLiveGames& a, CMsgDOTALeagueLiveGames& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueLiveGames* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueLiveGames* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueLiveGames* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueLiveGames>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueLiveGames& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueLiveGames& from) {
    CMsgDOTALeagueLiveGames::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueLiveGames* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueLiveGames";
  }
  protected:
  explicit CMsgDOTALeagueLiveGames(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeagueLiveGames_LiveGame LiveGame;

  // accessors -------------------------------------------------------

  enum : int {
    kGamesFieldNumber = 1,
  };
  // repeated .CMsgDOTALeagueLiveGames.LiveGame games = 1;
  int games_size() const;
  private:
  int _internal_games_size() const;
  public:
  void clear_games();
  ::CMsgDOTALeagueLiveGames_LiveGame* mutable_games(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueLiveGames_LiveGame >*
      mutable_games();
  private:
  const ::CMsgDOTALeagueLiveGames_LiveGame& _internal_games(int index) const;
  ::CMsgDOTALeagueLiveGames_LiveGame* _internal_add_games();
  public:
  const ::CMsgDOTALeagueLiveGames_LiveGame& games(int index) const;
  ::CMsgDOTALeagueLiveGames_LiveGame* add_games();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueLiveGames_LiveGame >&
      games() const;

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueLiveGames)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueLiveGames_LiveGame > games_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueMessages_Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueMessages.Message) */ {
 public:
  inline CMsgDOTALeagueMessages_Message() : CMsgDOTALeagueMessages_Message(nullptr) {}
  ~CMsgDOTALeagueMessages_Message() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueMessages_Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueMessages_Message(const CMsgDOTALeagueMessages_Message& from);
  CMsgDOTALeagueMessages_Message(CMsgDOTALeagueMessages_Message&& from) noexcept
    : CMsgDOTALeagueMessages_Message() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueMessages_Message& operator=(const CMsgDOTALeagueMessages_Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueMessages_Message& operator=(CMsgDOTALeagueMessages_Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueMessages_Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueMessages_Message* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueMessages_Message*>(
               &_CMsgDOTALeagueMessages_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CMsgDOTALeagueMessages_Message& a, CMsgDOTALeagueMessages_Message& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueMessages_Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueMessages_Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueMessages_Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueMessages_Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueMessages_Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueMessages_Message& from) {
    CMsgDOTALeagueMessages_Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueMessages_Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueMessages.Message";
  }
  protected:
  explicit CMsgDOTALeagueMessages_Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kAuthorAccountIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // optional string message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional uint32 author_account_id = 1;
  bool has_author_account_id() const;
  private:
  bool _internal_has_author_account_id() const;
  public:
  void clear_author_account_id();
  uint32_t author_account_id() const;
  void set_author_account_id(uint32_t value);
  private:
  uint32_t _internal_author_account_id() const;
  void _internal_set_author_account_id(uint32_t value);
  public:

  // optional uint32 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueMessages.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint32_t author_account_id_;
    uint32_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueMessages final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueMessages) */ {
 public:
  inline CMsgDOTALeagueMessages() : CMsgDOTALeagueMessages(nullptr) {}
  ~CMsgDOTALeagueMessages() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueMessages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueMessages(const CMsgDOTALeagueMessages& from);
  CMsgDOTALeagueMessages(CMsgDOTALeagueMessages&& from) noexcept
    : CMsgDOTALeagueMessages() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueMessages& operator=(const CMsgDOTALeagueMessages& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueMessages& operator=(CMsgDOTALeagueMessages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueMessages& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueMessages* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueMessages*>(
               &_CMsgDOTALeagueMessages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CMsgDOTALeagueMessages& a, CMsgDOTALeagueMessages& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueMessages* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueMessages* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueMessages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueMessages>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueMessages& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueMessages& from) {
    CMsgDOTALeagueMessages::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueMessages* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueMessages";
  }
  protected:
  explicit CMsgDOTALeagueMessages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeagueMessages_Message Message;

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .CMsgDOTALeagueMessages.Message messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::CMsgDOTALeagueMessages_Message* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueMessages_Message >*
      mutable_messages();
  private:
  const ::CMsgDOTALeagueMessages_Message& _internal_messages(int index) const;
  ::CMsgDOTALeagueMessages_Message* _internal_add_messages();
  public:
  const ::CMsgDOTALeagueMessages_Message& messages(int index) const;
  ::CMsgDOTALeagueMessages_Message* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueMessages_Message >&
      messages() const;

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueMessages)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueMessages_Message > messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeaguePrizePool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeaguePrizePool) */ {
 public:
  inline CMsgDOTALeaguePrizePool() : CMsgDOTALeaguePrizePool(nullptr) {}
  ~CMsgDOTALeaguePrizePool() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeaguePrizePool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeaguePrizePool(const CMsgDOTALeaguePrizePool& from);
  CMsgDOTALeaguePrizePool(CMsgDOTALeaguePrizePool&& from) noexcept
    : CMsgDOTALeaguePrizePool() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeaguePrizePool& operator=(const CMsgDOTALeaguePrizePool& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeaguePrizePool& operator=(CMsgDOTALeaguePrizePool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeaguePrizePool& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeaguePrizePool* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeaguePrizePool*>(
               &_CMsgDOTALeaguePrizePool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CMsgDOTALeaguePrizePool& a, CMsgDOTALeaguePrizePool& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeaguePrizePool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeaguePrizePool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeaguePrizePool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeaguePrizePool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeaguePrizePool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeaguePrizePool& from) {
    CMsgDOTALeaguePrizePool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeaguePrizePool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeaguePrizePool";
  }
  protected:
  explicit CMsgDOTALeaguePrizePool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrizePoolFieldNumber = 1,
    kIncrementPerSecondFieldNumber = 2,
  };
  // optional uint32 prize_pool = 1;
  bool has_prize_pool() const;
  private:
  bool _internal_has_prize_pool() const;
  public:
  void clear_prize_pool();
  uint32_t prize_pool() const;
  void set_prize_pool(uint32_t value);
  private:
  uint32_t _internal_prize_pool() const;
  void _internal_set_prize_pool(uint32_t value);
  public:

  // optional float increment_per_second = 2;
  bool has_increment_per_second() const;
  private:
  bool _internal_has_increment_per_second() const;
  public:
  void clear_increment_per_second();
  float increment_per_second() const;
  void set_increment_per_second(float value);
  private:
  float _internal_increment_per_second() const;
  void _internal_set_increment_per_second(float value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeaguePrizePool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t prize_pool_;
    float increment_per_second_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueInfoListAdminsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueInfoListAdminsRequest) */ {
 public:
  inline CMsgDOTALeagueInfoListAdminsRequest() : CMsgDOTALeagueInfoListAdminsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueInfoListAdminsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueInfoListAdminsRequest(const CMsgDOTALeagueInfoListAdminsRequest& from);
  CMsgDOTALeagueInfoListAdminsRequest(CMsgDOTALeagueInfoListAdminsRequest&& from) noexcept
    : CMsgDOTALeagueInfoListAdminsRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueInfoListAdminsRequest& operator=(const CMsgDOTALeagueInfoListAdminsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueInfoListAdminsRequest& operator=(CMsgDOTALeagueInfoListAdminsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueInfoListAdminsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueInfoListAdminsRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueInfoListAdminsRequest*>(
               &_CMsgDOTALeagueInfoListAdminsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CMsgDOTALeagueInfoListAdminsRequest& a, CMsgDOTALeagueInfoListAdminsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueInfoListAdminsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueInfoListAdminsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueInfoListAdminsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueInfoListAdminsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CMsgDOTALeagueInfoListAdminsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CMsgDOTALeagueInfoListAdminsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueInfoListAdminsRequest";
  }
  protected:
  explicit CMsgDOTALeagueInfoListAdminsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueInfoListAdminsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueAvailableLobbyNodesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueAvailableLobbyNodesRequest) */ {
 public:
  inline CMsgDOTALeagueAvailableLobbyNodesRequest() : CMsgDOTALeagueAvailableLobbyNodesRequest(nullptr) {}
  ~CMsgDOTALeagueAvailableLobbyNodesRequest() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueAvailableLobbyNodesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueAvailableLobbyNodesRequest(const CMsgDOTALeagueAvailableLobbyNodesRequest& from);
  CMsgDOTALeagueAvailableLobbyNodesRequest(CMsgDOTALeagueAvailableLobbyNodesRequest&& from) noexcept
    : CMsgDOTALeagueAvailableLobbyNodesRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueAvailableLobbyNodesRequest& operator=(const CMsgDOTALeagueAvailableLobbyNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueAvailableLobbyNodesRequest& operator=(CMsgDOTALeagueAvailableLobbyNodesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueAvailableLobbyNodesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueAvailableLobbyNodesRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueAvailableLobbyNodesRequest*>(
               &_CMsgDOTALeagueAvailableLobbyNodesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CMsgDOTALeagueAvailableLobbyNodesRequest& a, CMsgDOTALeagueAvailableLobbyNodesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueAvailableLobbyNodesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueAvailableLobbyNodesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueAvailableLobbyNodesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueAvailableLobbyNodesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueAvailableLobbyNodesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueAvailableLobbyNodesRequest& from) {
    CMsgDOTALeagueAvailableLobbyNodesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueAvailableLobbyNodesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueAvailableLobbyNodesRequest";
  }
  protected:
  explicit CMsgDOTALeagueAvailableLobbyNodesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeagueIdFieldNumber = 1,
  };
  // optional uint32 league_id = 1;
  bool has_league_id() const;
  private:
  bool _internal_has_league_id() const;
  public:
  void clear_league_id();
  uint32_t league_id() const;
  void set_league_id(uint32_t value);
  private:
  uint32_t _internal_league_id() const;
  void _internal_set_league_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueAvailableLobbyNodesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t league_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueAvailableLobbyNodes_NodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo) */ {
 public:
  inline CMsgDOTALeagueAvailableLobbyNodes_NodeInfo() : CMsgDOTALeagueAvailableLobbyNodes_NodeInfo(nullptr) {}
  ~CMsgDOTALeagueAvailableLobbyNodes_NodeInfo() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueAvailableLobbyNodes_NodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueAvailableLobbyNodes_NodeInfo(const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& from);
  CMsgDOTALeagueAvailableLobbyNodes_NodeInfo(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo&& from) noexcept
    : CMsgDOTALeagueAvailableLobbyNodes_NodeInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& operator=(const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& operator=(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo*>(
               &_CMsgDOTALeagueAvailableLobbyNodes_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& a, CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueAvailableLobbyNodes_NodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& from) {
    CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueAvailableLobbyNodes.NodeInfo";
  }
  protected:
  explicit CMsgDOTALeagueAvailableLobbyNodes_NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 2,
    kNodeGroupNameFieldNumber = 3,
    kNodeIdFieldNumber = 1,
    kTeamId1FieldNumber = 4,
    kTeamId2FieldNumber = 5,
  };
  // optional string node_name = 2;
  bool has_node_name() const;
  private:
  bool _internal_has_node_name() const;
  public:
  void clear_node_name();
  const std::string& node_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_name();
  PROTOBUF_NODISCARD std::string* release_node_name();
  void set_allocated_node_name(std::string* node_name);
  private:
  const std::string& _internal_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_name(const std::string& value);
  std::string* _internal_mutable_node_name();
  public:

  // optional string node_group_name = 3;
  bool has_node_group_name() const;
  private:
  bool _internal_has_node_group_name() const;
  public:
  void clear_node_group_name();
  const std::string& node_group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_group_name();
  PROTOBUF_NODISCARD std::string* release_node_group_name();
  void set_allocated_node_group_name(std::string* node_group_name);
  private:
  const std::string& _internal_node_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_group_name(const std::string& value);
  std::string* _internal_mutable_node_group_name();
  public:

  // optional uint32 node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  uint32_t node_id() const;
  void set_node_id(uint32_t value);
  private:
  uint32_t _internal_node_id() const;
  void _internal_set_node_id(uint32_t value);
  public:

  // optional uint32 team_id_1 = 4;
  bool has_team_id_1() const;
  private:
  bool _internal_has_team_id_1() const;
  public:
  void clear_team_id_1();
  uint32_t team_id_1() const;
  void set_team_id_1(uint32_t value);
  private:
  uint32_t _internal_team_id_1() const;
  void _internal_set_team_id_1(uint32_t value);
  public:

  // optional uint32 team_id_2 = 5;
  bool has_team_id_2() const;
  private:
  bool _internal_has_team_id_2() const;
  public:
  void clear_team_id_2();
  uint32_t team_id_2() const;
  void set_team_id_2(uint32_t value);
  private:
  uint32_t _internal_team_id_2() const;
  void _internal_set_team_id_2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_group_name_;
    uint32_t node_id_;
    uint32_t team_id_1_;
    uint32_t team_id_2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueAvailableLobbyNodes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueAvailableLobbyNodes) */ {
 public:
  inline CMsgDOTALeagueAvailableLobbyNodes() : CMsgDOTALeagueAvailableLobbyNodes(nullptr) {}
  ~CMsgDOTALeagueAvailableLobbyNodes() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueAvailableLobbyNodes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueAvailableLobbyNodes(const CMsgDOTALeagueAvailableLobbyNodes& from);
  CMsgDOTALeagueAvailableLobbyNodes(CMsgDOTALeagueAvailableLobbyNodes&& from) noexcept
    : CMsgDOTALeagueAvailableLobbyNodes() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueAvailableLobbyNodes& operator=(const CMsgDOTALeagueAvailableLobbyNodes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueAvailableLobbyNodes& operator=(CMsgDOTALeagueAvailableLobbyNodes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueAvailableLobbyNodes& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueAvailableLobbyNodes* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueAvailableLobbyNodes*>(
               &_CMsgDOTALeagueAvailableLobbyNodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CMsgDOTALeagueAvailableLobbyNodes& a, CMsgDOTALeagueAvailableLobbyNodes& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueAvailableLobbyNodes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueAvailableLobbyNodes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueAvailableLobbyNodes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueAvailableLobbyNodes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueAvailableLobbyNodes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueAvailableLobbyNodes& from) {
    CMsgDOTALeagueAvailableLobbyNodes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueAvailableLobbyNodes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueAvailableLobbyNodes";
  }
  protected:
  explicit CMsgDOTALeagueAvailableLobbyNodes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeagueAvailableLobbyNodes_NodeInfo NodeInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kNodeInfosFieldNumber = 1,
  };
  // repeated .CMsgDOTALeagueAvailableLobbyNodes.NodeInfo node_infos = 1;
  int node_infos_size() const;
  private:
  int _internal_node_infos_size() const;
  public:
  void clear_node_infos();
  ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* mutable_node_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo >*
      mutable_node_infos();
  private:
  const ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& _internal_node_infos(int index) const;
  ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* _internal_add_node_infos();
  public:
  const ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& node_infos(int index) const;
  ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* add_node_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo >&
      node_infos() const;

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueAvailableLobbyNodes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo > node_infos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNodeResults_Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueNodeResults.Result) */ {
 public:
  inline CMsgDOTALeagueNodeResults_Result() : CMsgDOTALeagueNodeResults_Result(nullptr) {}
  ~CMsgDOTALeagueNodeResults_Result() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeResults_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueNodeResults_Result(const CMsgDOTALeagueNodeResults_Result& from);
  CMsgDOTALeagueNodeResults_Result(CMsgDOTALeagueNodeResults_Result&& from) noexcept
    : CMsgDOTALeagueNodeResults_Result() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNodeResults_Result& operator=(const CMsgDOTALeagueNodeResults_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueNodeResults_Result& operator=(CMsgDOTALeagueNodeResults_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueNodeResults_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueNodeResults_Result* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNodeResults_Result*>(
               &_CMsgDOTALeagueNodeResults_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CMsgDOTALeagueNodeResults_Result& a, CMsgDOTALeagueNodeResults_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueNodeResults_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueNodeResults_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueNodeResults_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeResults_Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueNodeResults_Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueNodeResults_Result& from) {
    CMsgDOTALeagueNodeResults_Result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNodeResults_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueNodeResults.Result";
  }
  protected:
  explicit CMsgDOTALeagueNodeResults_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchIdsFieldNumber = 17,
    kTeam1NameFieldNumber = 8,
    kTeam2NameFieldNumber = 9,
    kNodeIdFieldNumber = 1,
    kWinningNodeIdFieldNumber = 2,
    kLosingNodeIdFieldNumber = 3,
    kIncomingNodeId1FieldNumber = 4,
    kIncomingNodeId2FieldNumber = 5,
    kTeamId1FieldNumber = 6,
    kTeamId2FieldNumber = 7,
    kTeam1WinsFieldNumber = 10,
    kTeam2WinsFieldNumber = 11,
    kWinningTeamIdFieldNumber = 12,
    kLosingTeamIdFieldNumber = 13,
    kHasStartedFieldNumber = 14,
    kIsCompletedFieldNumber = 15,
    kScheduledTimeFieldNumber = 16,
  };
  // repeated uint64 match_ids = 17;
  int match_ids_size() const;
  private:
  int _internal_match_ids_size() const;
  public:
  void clear_match_ids();
  private:
  uint64_t _internal_match_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_match_ids() const;
  void _internal_add_match_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_match_ids();
  public:
  uint64_t match_ids(int index) const;
  void set_match_ids(int index, uint64_t value);
  void add_match_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      match_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_match_ids();

  // optional string team_1_name = 8;
  bool has_team_1_name() const;
  private:
  bool _internal_has_team_1_name() const;
  public:
  void clear_team_1_name();
  const std::string& team_1_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_1_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_1_name();
  PROTOBUF_NODISCARD std::string* release_team_1_name();
  void set_allocated_team_1_name(std::string* team_1_name);
  private:
  const std::string& _internal_team_1_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_1_name(const std::string& value);
  std::string* _internal_mutable_team_1_name();
  public:

  // optional string team_2_name = 9;
  bool has_team_2_name() const;
  private:
  bool _internal_has_team_2_name() const;
  public:
  void clear_team_2_name();
  const std::string& team_2_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_2_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_2_name();
  PROTOBUF_NODISCARD std::string* release_team_2_name();
  void set_allocated_team_2_name(std::string* team_2_name);
  private:
  const std::string& _internal_team_2_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_2_name(const std::string& value);
  std::string* _internal_mutable_team_2_name();
  public:

  // optional uint32 node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  uint32_t node_id() const;
  void set_node_id(uint32_t value);
  private:
  uint32_t _internal_node_id() const;
  void _internal_set_node_id(uint32_t value);
  public:

  // optional uint32 winning_node_id = 2;
  bool has_winning_node_id() const;
  private:
  bool _internal_has_winning_node_id() const;
  public:
  void clear_winning_node_id();
  uint32_t winning_node_id() const;
  void set_winning_node_id(uint32_t value);
  private:
  uint32_t _internal_winning_node_id() const;
  void _internal_set_winning_node_id(uint32_t value);
  public:

  // optional uint32 losing_node_id = 3;
  bool has_losing_node_id() const;
  private:
  bool _internal_has_losing_node_id() const;
  public:
  void clear_losing_node_id();
  uint32_t losing_node_id() const;
  void set_losing_node_id(uint32_t value);
  private:
  uint32_t _internal_losing_node_id() const;
  void _internal_set_losing_node_id(uint32_t value);
  public:

  // optional uint32 incoming_node_id_1 = 4;
  bool has_incoming_node_id_1() const;
  private:
  bool _internal_has_incoming_node_id_1() const;
  public:
  void clear_incoming_node_id_1();
  uint32_t incoming_node_id_1() const;
  void set_incoming_node_id_1(uint32_t value);
  private:
  uint32_t _internal_incoming_node_id_1() const;
  void _internal_set_incoming_node_id_1(uint32_t value);
  public:

  // optional uint32 incoming_node_id_2 = 5;
  bool has_incoming_node_id_2() const;
  private:
  bool _internal_has_incoming_node_id_2() const;
  public:
  void clear_incoming_node_id_2();
  uint32_t incoming_node_id_2() const;
  void set_incoming_node_id_2(uint32_t value);
  private:
  uint32_t _internal_incoming_node_id_2() const;
  void _internal_set_incoming_node_id_2(uint32_t value);
  public:

  // optional uint32 team_id_1 = 6;
  bool has_team_id_1() const;
  private:
  bool _internal_has_team_id_1() const;
  public:
  void clear_team_id_1();
  uint32_t team_id_1() const;
  void set_team_id_1(uint32_t value);
  private:
  uint32_t _internal_team_id_1() const;
  void _internal_set_team_id_1(uint32_t value);
  public:

  // optional uint32 team_id_2 = 7;
  bool has_team_id_2() const;
  private:
  bool _internal_has_team_id_2() const;
  public:
  void clear_team_id_2();
  uint32_t team_id_2() const;
  void set_team_id_2(uint32_t value);
  private:
  uint32_t _internal_team_id_2() const;
  void _internal_set_team_id_2(uint32_t value);
  public:

  // optional uint32 team_1_wins = 10;
  bool has_team_1_wins() const;
  private:
  bool _internal_has_team_1_wins() const;
  public:
  void clear_team_1_wins();
  uint32_t team_1_wins() const;
  void set_team_1_wins(uint32_t value);
  private:
  uint32_t _internal_team_1_wins() const;
  void _internal_set_team_1_wins(uint32_t value);
  public:

  // optional uint32 team_2_wins = 11;
  bool has_team_2_wins() const;
  private:
  bool _internal_has_team_2_wins() const;
  public:
  void clear_team_2_wins();
  uint32_t team_2_wins() const;
  void set_team_2_wins(uint32_t value);
  private:
  uint32_t _internal_team_2_wins() const;
  void _internal_set_team_2_wins(uint32_t value);
  public:

  // optional uint32 winning_team_id = 12;
  bool has_winning_team_id() const;
  private:
  bool _internal_has_winning_team_id() const;
  public:
  void clear_winning_team_id();
  uint32_t winning_team_id() const;
  void set_winning_team_id(uint32_t value);
  private:
  uint32_t _internal_winning_team_id() const;
  void _internal_set_winning_team_id(uint32_t value);
  public:

  // optional uint32 losing_team_id = 13;
  bool has_losing_team_id() const;
  private:
  bool _internal_has_losing_team_id() const;
  public:
  void clear_losing_team_id();
  uint32_t losing_team_id() const;
  void set_losing_team_id(uint32_t value);
  private:
  uint32_t _internal_losing_team_id() const;
  void _internal_set_losing_team_id(uint32_t value);
  public:

  // optional bool has_started = 14;
  bool has_has_started() const;
  private:
  bool _internal_has_has_started() const;
  public:
  void clear_has_started();
  bool has_started() const;
  void set_has_started(bool value);
  private:
  bool _internal_has_started() const;
  void _internal_set_has_started(bool value);
  public:

  // optional bool is_completed = 15;
  bool has_is_completed() const;
  private:
  bool _internal_has_is_completed() const;
  public:
  void clear_is_completed();
  bool is_completed() const;
  void set_is_completed(bool value);
  private:
  bool _internal_is_completed() const;
  void _internal_set_is_completed(bool value);
  public:

  // optional uint32 scheduled_time = 16;
  bool has_scheduled_time() const;
  private:
  bool _internal_has_scheduled_time() const;
  public:
  void clear_scheduled_time();
  uint32_t scheduled_time() const;
  void set_scheduled_time(uint32_t value);
  private:
  uint32_t _internal_scheduled_time() const;
  void _internal_set_scheduled_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueNodeResults.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > match_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_1_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_2_name_;
    uint32_t node_id_;
    uint32_t winning_node_id_;
    uint32_t losing_node_id_;
    uint32_t incoming_node_id_1_;
    uint32_t incoming_node_id_2_;
    uint32_t team_id_1_;
    uint32_t team_id_2_;
    uint32_t team_1_wins_;
    uint32_t team_2_wins_;
    uint32_t winning_team_id_;
    uint32_t losing_team_id_;
    bool has_started_;
    bool is_completed_;
    uint32_t scheduled_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNodeResults final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTALeagueNodeResults) */ {
 public:
  inline CMsgDOTALeagueNodeResults() : CMsgDOTALeagueNodeResults(nullptr) {}
  ~CMsgDOTALeagueNodeResults() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTALeagueNodeResults(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTALeagueNodeResults(const CMsgDOTALeagueNodeResults& from);
  CMsgDOTALeagueNodeResults(CMsgDOTALeagueNodeResults&& from) noexcept
    : CMsgDOTALeagueNodeResults() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNodeResults& operator=(const CMsgDOTALeagueNodeResults& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTALeagueNodeResults& operator=(CMsgDOTALeagueNodeResults&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTALeagueNodeResults& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTALeagueNodeResults* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNodeResults*>(
               &_CMsgDOTALeagueNodeResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CMsgDOTALeagueNodeResults& a, CMsgDOTALeagueNodeResults& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTALeagueNodeResults* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTALeagueNodeResults* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTALeagueNodeResults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeResults>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTALeagueNodeResults& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTALeagueNodeResults& from) {
    CMsgDOTALeagueNodeResults::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNodeResults* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTALeagueNodeResults";
  }
  protected:
  explicit CMsgDOTALeagueNodeResults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeagueNodeResults_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kNodeResultsFieldNumber = 1,
  };
  // repeated .CMsgDOTALeagueNodeResults.Result node_results = 1;
  int node_results_size() const;
  private:
  int _internal_node_results_size() const;
  public:
  void clear_node_results();
  ::CMsgDOTALeagueNodeResults_Result* mutable_node_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeResults_Result >*
      mutable_node_results();
  private:
  const ::CMsgDOTALeagueNodeResults_Result& _internal_node_results(int index) const;
  ::CMsgDOTALeagueNodeResults_Result* _internal_add_node_results();
  public:
  const ::CMsgDOTALeagueNodeResults_Result& node_results(int index) const;
  ::CMsgDOTALeagueNodeResults_Result* add_node_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeResults_Result >&
      node_results() const;

  // @@protoc_insertion_point(class_scope:CMsgDOTALeagueNodeResults)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeResults_Result > node_results_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCLeagueResults_Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTADPCLeagueResults.Result) */ {
 public:
  inline CMsgDOTADPCLeagueResults_Result() : CMsgDOTADPCLeagueResults_Result(nullptr) {}
  ~CMsgDOTADPCLeagueResults_Result() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTADPCLeagueResults_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTADPCLeagueResults_Result(const CMsgDOTADPCLeagueResults_Result& from);
  CMsgDOTADPCLeagueResults_Result(CMsgDOTADPCLeagueResults_Result&& from) noexcept
    : CMsgDOTADPCLeagueResults_Result() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCLeagueResults_Result& operator=(const CMsgDOTADPCLeagueResults_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTADPCLeagueResults_Result& operator=(CMsgDOTADPCLeagueResults_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTADPCLeagueResults_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTADPCLeagueResults_Result* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCLeagueResults_Result*>(
               &_CMsgDOTADPCLeagueResults_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CMsgDOTADPCLeagueResults_Result& a, CMsgDOTADPCLeagueResults_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTADPCLeagueResults_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTADPCLeagueResults_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTADPCLeagueResults_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTADPCLeagueResults_Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTADPCLeagueResults_Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTADPCLeagueResults_Result& from) {
    CMsgDOTADPCLeagueResults_Result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCLeagueResults_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTADPCLeagueResults.Result";
  }
  protected:
  explicit CMsgDOTADPCLeagueResults_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamNameFieldNumber = 3,
    kTeamLogoUrlFieldNumber = 5,
    kTeamAbbreviationFieldNumber = 10,
    kStandingFieldNumber = 1,
    kTeamIdFieldNumber = 2,
    kTeamLogoFieldNumber = 4,
    kPointsFieldNumber = 6,
    kEarningsFieldNumber = 7,
    kTimestampFieldNumber = 8,
    kPhaseFieldNumber = 9,
  };
  // optional string team_name = 3;
  bool has_team_name() const;
  private:
  bool _internal_has_team_name() const;
  public:
  void clear_team_name();
  const std::string& team_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_name();
  PROTOBUF_NODISCARD std::string* release_team_name();
  void set_allocated_team_name(std::string* team_name);
  private:
  const std::string& _internal_team_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_name(const std::string& value);
  std::string* _internal_mutable_team_name();
  public:

  // optional string team_logo_url = 5;
  bool has_team_logo_url() const;
  private:
  bool _internal_has_team_logo_url() const;
  public:
  void clear_team_logo_url();
  const std::string& team_logo_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_logo_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_logo_url();
  PROTOBUF_NODISCARD std::string* release_team_logo_url();
  void set_allocated_team_logo_url(std::string* team_logo_url);
  private:
  const std::string& _internal_team_logo_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_logo_url(const std::string& value);
  std::string* _internal_mutable_team_logo_url();
  public:

  // optional string team_abbreviation = 10;
  bool has_team_abbreviation() const;
  private:
  bool _internal_has_team_abbreviation() const;
  public:
  void clear_team_abbreviation();
  const std::string& team_abbreviation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_abbreviation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_abbreviation();
  PROTOBUF_NODISCARD std::string* release_team_abbreviation();
  void set_allocated_team_abbreviation(std::string* team_abbreviation);
  private:
  const std::string& _internal_team_abbreviation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_abbreviation(const std::string& value);
  std::string* _internal_mutable_team_abbreviation();
  public:

  // optional uint32 standing = 1;
  bool has_standing() const;
  private:
  bool _internal_has_standing() const;
  public:
  void clear_standing();
  uint32_t standing() const;
  void set_standing(uint32_t value);
  private:
  uint32_t _internal_standing() const;
  void _internal_set_standing(uint32_t value);
  public:

  // optional uint32 team_id = 2;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  uint32_t team_id() const;
  void set_team_id(uint32_t value);
  private:
  uint32_t _internal_team_id() const;
  void _internal_set_team_id(uint32_t value);
  public:

  // optional uint64 team_logo = 4;
  bool has_team_logo() const;
  private:
  bool _internal_has_team_logo() const;
  public:
  void clear_team_logo();
  uint64_t team_logo() const;
  void set_team_logo(uint64_t value);
  private:
  uint64_t _internal_team_logo() const;
  void _internal_set_team_logo(uint64_t value);
  public:

  // optional uint32 points = 6;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  uint32_t points() const;
  void set_points(uint32_t value);
  private:
  uint32_t _internal_points() const;
  void _internal_set_points(uint32_t value);
  public:

  // optional uint32 earnings = 7;
  bool has_earnings() const;
  private:
  bool _internal_has_earnings() const;
  public:
  void clear_earnings();
  uint32_t earnings() const;
  void set_earnings(uint32_t value);
  private:
  uint32_t _internal_earnings() const;
  void _internal_set_earnings(uint32_t value);
  public:

  // optional uint32 timestamp = 8;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // optional .ELeaguePhase phase = 9 [default = LEAGUE_PHASE_UNSET];
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;
  public:
  void clear_phase();
  ::ELeaguePhase phase() const;
  void set_phase(::ELeaguePhase value);
  private:
  ::ELeaguePhase _internal_phase() const;
  void _internal_set_phase(::ELeaguePhase value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTADPCLeagueResults.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_logo_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_abbreviation_;
    uint32_t standing_;
    uint32_t team_id_;
    uint64_t team_logo_;
    uint32_t points_;
    uint32_t earnings_;
    uint32_t timestamp_;
    int phase_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCLeagueResults final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTADPCLeagueResults) */ {
 public:
  inline CMsgDOTADPCLeagueResults() : CMsgDOTADPCLeagueResults(nullptr) {}
  ~CMsgDOTADPCLeagueResults() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTADPCLeagueResults(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTADPCLeagueResults(const CMsgDOTADPCLeagueResults& from);
  CMsgDOTADPCLeagueResults(CMsgDOTADPCLeagueResults&& from) noexcept
    : CMsgDOTADPCLeagueResults() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCLeagueResults& operator=(const CMsgDOTADPCLeagueResults& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTADPCLeagueResults& operator=(CMsgDOTADPCLeagueResults&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTADPCLeagueResults& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTADPCLeagueResults* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCLeagueResults*>(
               &_CMsgDOTADPCLeagueResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CMsgDOTADPCLeagueResults& a, CMsgDOTADPCLeagueResults& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTADPCLeagueResults* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTADPCLeagueResults* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTADPCLeagueResults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTADPCLeagueResults>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTADPCLeagueResults& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTADPCLeagueResults& from) {
    CMsgDOTADPCLeagueResults::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCLeagueResults* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTADPCLeagueResults";
  }
  protected:
  explicit CMsgDOTADPCLeagueResults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTADPCLeagueResults_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
    kPointsFieldNumber = 2,
    kDollarsFieldNumber = 3,
  };
  // repeated .CMsgDOTADPCLeagueResults.Result results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::CMsgDOTADPCLeagueResults_Result* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCLeagueResults_Result >*
      mutable_results();
  private:
  const ::CMsgDOTADPCLeagueResults_Result& _internal_results(int index) const;
  ::CMsgDOTADPCLeagueResults_Result* _internal_add_results();
  public:
  const ::CMsgDOTADPCLeagueResults_Result& results(int index) const;
  ::CMsgDOTADPCLeagueResults_Result* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCLeagueResults_Result >&
      results() const;

  // repeated uint32 points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  private:
  uint32_t _internal_points(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_points() const;
  void _internal_add_points(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_points();
  public:
  uint32_t points(int index) const;
  void set_points(int index, uint32_t value);
  void add_points(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      points() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_points();

  // repeated uint32 dollars = 3;
  int dollars_size() const;
  private:
  int _internal_dollars_size() const;
  public:
  void clear_dollars();
  private:
  uint32_t _internal_dollars(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_dollars() const;
  void _internal_add_dollars(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_dollars();
  public:
  uint32_t dollars(int index) const;
  void set_dollars(int index, uint32_t value);
  void add_dollars(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      dollars() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_dollars();

  // @@protoc_insertion_point(class_scope:CMsgDOTADPCLeagueResults)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCLeagueResults_Result > results_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > points_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > dollars_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCTeamResults_Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTADPCTeamResults.Result) */ {
 public:
  inline CMsgDOTADPCTeamResults_Result() : CMsgDOTADPCTeamResults_Result(nullptr) {}
  ~CMsgDOTADPCTeamResults_Result() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTADPCTeamResults_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTADPCTeamResults_Result(const CMsgDOTADPCTeamResults_Result& from);
  CMsgDOTADPCTeamResults_Result(CMsgDOTADPCTeamResults_Result&& from) noexcept
    : CMsgDOTADPCTeamResults_Result() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCTeamResults_Result& operator=(const CMsgDOTADPCTeamResults_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTADPCTeamResults_Result& operator=(CMsgDOTADPCTeamResults_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTADPCTeamResults_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTADPCTeamResults_Result* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCTeamResults_Result*>(
               &_CMsgDOTADPCTeamResults_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CMsgDOTADPCTeamResults_Result& a, CMsgDOTADPCTeamResults_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTADPCTeamResults_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTADPCTeamResults_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTADPCTeamResults_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTADPCTeamResults_Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTADPCTeamResults_Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTADPCTeamResults_Result& from) {
    CMsgDOTADPCTeamResults_Result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCTeamResults_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTADPCTeamResults.Result";
  }
  protected:
  explicit CMsgDOTADPCTeamResults_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeagueIdFieldNumber = 1,
    kStandingFieldNumber = 2,
    kPointsFieldNumber = 3,
    kEarningsFieldNumber = 4,
    kTimestampFieldNumber = 5,
  };
  // optional uint32 league_id = 1;
  bool has_league_id() const;
  private:
  bool _internal_has_league_id() const;
  public:
  void clear_league_id();
  uint32_t league_id() const;
  void set_league_id(uint32_t value);
  private:
  uint32_t _internal_league_id() const;
  void _internal_set_league_id(uint32_t value);
  public:

  // optional uint32 standing = 2;
  bool has_standing() const;
  private:
  bool _internal_has_standing() const;
  public:
  void clear_standing();
  uint32_t standing() const;
  void set_standing(uint32_t value);
  private:
  uint32_t _internal_standing() const;
  void _internal_set_standing(uint32_t value);
  public:

  // optional uint32 points = 3;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  uint32_t points() const;
  void set_points(uint32_t value);
  private:
  uint32_t _internal_points() const;
  void _internal_set_points(uint32_t value);
  public:

  // optional uint32 earnings = 4;
  bool has_earnings() const;
  private:
  bool _internal_has_earnings() const;
  public:
  void clear_earnings();
  uint32_t earnings() const;
  void set_earnings(uint32_t value);
  private:
  uint32_t _internal_earnings() const;
  void _internal_set_earnings(uint32_t value);
  public:

  // optional uint32 timestamp = 5;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTADPCTeamResults.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t league_id_;
    uint32_t standing_;
    uint32_t points_;
    uint32_t earnings_;
    uint32_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCTeamResults final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTADPCTeamResults) */ {
 public:
  inline CMsgDOTADPCTeamResults() : CMsgDOTADPCTeamResults(nullptr) {}
  ~CMsgDOTADPCTeamResults() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTADPCTeamResults(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTADPCTeamResults(const CMsgDOTADPCTeamResults& from);
  CMsgDOTADPCTeamResults(CMsgDOTADPCTeamResults&& from) noexcept
    : CMsgDOTADPCTeamResults() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCTeamResults& operator=(const CMsgDOTADPCTeamResults& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTADPCTeamResults& operator=(CMsgDOTADPCTeamResults&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTADPCTeamResults& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTADPCTeamResults* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCTeamResults*>(
               &_CMsgDOTADPCTeamResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CMsgDOTADPCTeamResults& a, CMsgDOTADPCTeamResults& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTADPCTeamResults* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTADPCTeamResults* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTADPCTeamResults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTADPCTeamResults>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTADPCTeamResults& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTADPCTeamResults& from) {
    CMsgDOTADPCTeamResults::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCTeamResults* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTADPCTeamResults";
  }
  protected:
  explicit CMsgDOTADPCTeamResults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTADPCTeamResults_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .CMsgDOTADPCTeamResults.Result results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::CMsgDOTADPCTeamResults_Result* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCTeamResults_Result >*
      mutable_results();
  private:
  const ::CMsgDOTADPCTeamResults_Result& _internal_results(int index) const;
  ::CMsgDOTADPCTeamResults_Result* _internal_add_results();
  public:
  const ::CMsgDOTADPCTeamResults_Result& results(int index) const;
  ::CMsgDOTADPCTeamResults_Result* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCTeamResults_Result >&
      results() const;

  // @@protoc_insertion_point(class_scope:CMsgDOTADPCTeamResults)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCTeamResults_Result > results_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCSeasonResults_TeamLeagueResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTADPCSeasonResults.TeamLeagueResult) */ {
 public:
  inline CMsgDOTADPCSeasonResults_TeamLeagueResult() : CMsgDOTADPCSeasonResults_TeamLeagueResult(nullptr) {}
  ~CMsgDOTADPCSeasonResults_TeamLeagueResult() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults_TeamLeagueResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTADPCSeasonResults_TeamLeagueResult(const CMsgDOTADPCSeasonResults_TeamLeagueResult& from);
  CMsgDOTADPCSeasonResults_TeamLeagueResult(CMsgDOTADPCSeasonResults_TeamLeagueResult&& from) noexcept
    : CMsgDOTADPCSeasonResults_TeamLeagueResult() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCSeasonResults_TeamLeagueResult& operator=(const CMsgDOTADPCSeasonResults_TeamLeagueResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTADPCSeasonResults_TeamLeagueResult& operator=(CMsgDOTADPCSeasonResults_TeamLeagueResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTADPCSeasonResults_TeamLeagueResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTADPCSeasonResults_TeamLeagueResult* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCSeasonResults_TeamLeagueResult*>(
               &_CMsgDOTADPCSeasonResults_TeamLeagueResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CMsgDOTADPCSeasonResults_TeamLeagueResult& a, CMsgDOTADPCSeasonResults_TeamLeagueResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTADPCSeasonResults_TeamLeagueResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTADPCSeasonResults_TeamLeagueResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTADPCSeasonResults_TeamLeagueResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTADPCSeasonResults_TeamLeagueResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTADPCSeasonResults_TeamLeagueResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTADPCSeasonResults_TeamLeagueResult& from) {
    CMsgDOTADPCSeasonResults_TeamLeagueResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCSeasonResults_TeamLeagueResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTADPCSeasonResults.TeamLeagueResult";
  }
  protected:
  explicit CMsgDOTADPCSeasonResults_TeamLeagueResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kLeagueIdFieldNumber = 2,
    kStandingFieldNumber = 3,
    kPointsFieldNumber = 4,
    kEarningsFieldNumber = 5,
    kAuditActionFieldNumber = 6,
    kAuditDataFieldNumber = 7,
  };
  // optional uint32 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // optional uint32 league_id = 2;
  bool has_league_id() const;
  private:
  bool _internal_has_league_id() const;
  public:
  void clear_league_id();
  uint32_t league_id() const;
  void set_league_id(uint32_t value);
  private:
  uint32_t _internal_league_id() const;
  void _internal_set_league_id(uint32_t value);
  public:

  // optional uint32 standing = 3;
  bool has_standing() const;
  private:
  bool _internal_has_standing() const;
  public:
  void clear_standing();
  uint32_t standing() const;
  void set_standing(uint32_t value);
  private:
  uint32_t _internal_standing() const;
  void _internal_set_standing(uint32_t value);
  public:

  // optional uint32 points = 4;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  uint32_t points() const;
  void set_points(uint32_t value);
  private:
  uint32_t _internal_points() const;
  void _internal_set_points(uint32_t value);
  public:

  // optional uint32 earnings = 5;
  bool has_earnings() const;
  private:
  bool _internal_has_earnings() const;
  public:
  void clear_earnings();
  uint32_t earnings() const;
  void set_earnings(uint32_t value);
  private:
  uint32_t _internal_earnings() const;
  void _internal_set_earnings(uint32_t value);
  public:

  // optional uint32 audit_action = 6;
  bool has_audit_action() const;
  private:
  bool _internal_has_audit_action() const;
  public:
  void clear_audit_action();
  uint32_t audit_action() const;
  void set_audit_action(uint32_t value);
  private:
  uint32_t _internal_audit_action() const;
  void _internal_set_audit_action(uint32_t value);
  public:

  // optional uint32 audit_data = 7;
  bool has_audit_data() const;
  private:
  bool _internal_has_audit_data() const;
  public:
  void clear_audit_data();
  uint32_t audit_data() const;
  void set_audit_data(uint32_t value);
  private:
  uint32_t _internal_audit_data() const;
  void _internal_set_audit_data(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTADPCSeasonResults.TeamLeagueResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t timestamp_;
    uint32_t league_id_;
    uint32_t standing_;
    uint32_t points_;
    uint32_t earnings_;
    uint32_t audit_action_;
    uint32_t audit_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCSeasonResults_TeamResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTADPCSeasonResults.TeamResult) */ {
 public:
  inline CMsgDOTADPCSeasonResults_TeamResult() : CMsgDOTADPCSeasonResults_TeamResult(nullptr) {}
  ~CMsgDOTADPCSeasonResults_TeamResult() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults_TeamResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTADPCSeasonResults_TeamResult(const CMsgDOTADPCSeasonResults_TeamResult& from);
  CMsgDOTADPCSeasonResults_TeamResult(CMsgDOTADPCSeasonResults_TeamResult&& from) noexcept
    : CMsgDOTADPCSeasonResults_TeamResult() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCSeasonResults_TeamResult& operator=(const CMsgDOTADPCSeasonResults_TeamResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTADPCSeasonResults_TeamResult& operator=(CMsgDOTADPCSeasonResults_TeamResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTADPCSeasonResults_TeamResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTADPCSeasonResults_TeamResult* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCSeasonResults_TeamResult*>(
               &_CMsgDOTADPCSeasonResults_TeamResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CMsgDOTADPCSeasonResults_TeamResult& a, CMsgDOTADPCSeasonResults_TeamResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTADPCSeasonResults_TeamResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTADPCSeasonResults_TeamResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTADPCSeasonResults_TeamResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTADPCSeasonResults_TeamResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTADPCSeasonResults_TeamResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTADPCSeasonResults_TeamResult& from) {
    CMsgDOTADPCSeasonResults_TeamResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCSeasonResults_TeamResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTADPCSeasonResults.TeamResult";
  }
  protected:
  explicit CMsgDOTADPCSeasonResults_TeamResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeagueResultsFieldNumber = 7,
    kTeamNameFieldNumber = 2,
    kTeamLogoUrlFieldNumber = 4,
    kTeamAbbreviationFieldNumber = 8,
    kTeamLogoFieldNumber = 3,
    kTeamIdFieldNumber = 1,
    kTotalPointsFieldNumber = 5,
    kTotalEarningsFieldNumber = 6,
  };
  // repeated .CMsgDOTADPCSeasonResults.TeamLeagueResult league_results = 7;
  int league_results_size() const;
  private:
  int _internal_league_results_size() const;
  public:
  void clear_league_results();
  ::CMsgDOTADPCSeasonResults_TeamLeagueResult* mutable_league_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_TeamLeagueResult >*
      mutable_league_results();
  private:
  const ::CMsgDOTADPCSeasonResults_TeamLeagueResult& _internal_league_results(int index) const;
  ::CMsgDOTADPCSeasonResults_TeamLeagueResult* _internal_add_league_results();
  public:
  const ::CMsgDOTADPCSeasonResults_TeamLeagueResult& league_results(int index) const;
  ::CMsgDOTADPCSeasonResults_TeamLeagueResult* add_league_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_TeamLeagueResult >&
      league_results() const;

  // optional string team_name = 2;
  bool has_team_name() const;
  private:
  bool _internal_has_team_name() const;
  public:
  void clear_team_name();
  const std::string& team_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_name();
  PROTOBUF_NODISCARD std::string* release_team_name();
  void set_allocated_team_name(std::string* team_name);
  private:
  const std::string& _internal_team_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_name(const std::string& value);
  std::string* _internal_mutable_team_name();
  public:

  // optional string team_logo_url = 4;
  bool has_team_logo_url() const;
  private:
  bool _internal_has_team_logo_url() const;
  public:
  void clear_team_logo_url();
  const std::string& team_logo_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_logo_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_logo_url();
  PROTOBUF_NODISCARD std::string* release_team_logo_url();
  void set_allocated_team_logo_url(std::string* team_logo_url);
  private:
  const std::string& _internal_team_logo_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_logo_url(const std::string& value);
  std::string* _internal_mutable_team_logo_url();
  public:

  // optional string team_abbreviation = 8;
  bool has_team_abbreviation() const;
  private:
  bool _internal_has_team_abbreviation() const;
  public:
  void clear_team_abbreviation();
  const std::string& team_abbreviation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_abbreviation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_abbreviation();
  PROTOBUF_NODISCARD std::string* release_team_abbreviation();
  void set_allocated_team_abbreviation(std::string* team_abbreviation);
  private:
  const std::string& _internal_team_abbreviation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_abbreviation(const std::string& value);
  std::string* _internal_mutable_team_abbreviation();
  public:

  // optional uint64 team_logo = 3;
  bool has_team_logo() const;
  private:
  bool _internal_has_team_logo() const;
  public:
  void clear_team_logo();
  uint64_t team_logo() const;
  void set_team_logo(uint64_t value);
  private:
  uint64_t _internal_team_logo() const;
  void _internal_set_team_logo(uint64_t value);
  public:

  // optional uint32 team_id = 1;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  uint32_t team_id() const;
  void set_team_id(uint32_t value);
  private:
  uint32_t _internal_team_id() const;
  void _internal_set_team_id(uint32_t value);
  public:

  // optional uint32 total_points = 5;
  bool has_total_points() const;
  private:
  bool _internal_has_total_points() const;
  public:
  void clear_total_points();
  uint32_t total_points() const;
  void set_total_points(uint32_t value);
  private:
  uint32_t _internal_total_points() const;
  void _internal_set_total_points(uint32_t value);
  public:

  // optional uint32 total_earnings = 6;
  bool has_total_earnings() const;
  private:
  bool _internal_has_total_earnings() const;
  public:
  void clear_total_earnings();
  uint32_t total_earnings() const;
  void set_total_earnings(uint32_t value);
  private:
  uint32_t _internal_total_earnings() const;
  void _internal_set_total_earnings(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTADPCSeasonResults.TeamResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_TeamLeagueResult > league_results_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_logo_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_abbreviation_;
    uint64_t team_logo_;
    uint32_t team_id_;
    uint32_t total_points_;
    uint32_t total_earnings_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCSeasonResults_StandingEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTADPCSeasonResults.StandingEntry) */ {
 public:
  inline CMsgDOTADPCSeasonResults_StandingEntry() : CMsgDOTADPCSeasonResults_StandingEntry(nullptr) {}
  ~CMsgDOTADPCSeasonResults_StandingEntry() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults_StandingEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTADPCSeasonResults_StandingEntry(const CMsgDOTADPCSeasonResults_StandingEntry& from);
  CMsgDOTADPCSeasonResults_StandingEntry(CMsgDOTADPCSeasonResults_StandingEntry&& from) noexcept
    : CMsgDOTADPCSeasonResults_StandingEntry() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCSeasonResults_StandingEntry& operator=(const CMsgDOTADPCSeasonResults_StandingEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTADPCSeasonResults_StandingEntry& operator=(CMsgDOTADPCSeasonResults_StandingEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTADPCSeasonResults_StandingEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTADPCSeasonResults_StandingEntry* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCSeasonResults_StandingEntry*>(
               &_CMsgDOTADPCSeasonResults_StandingEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CMsgDOTADPCSeasonResults_StandingEntry& a, CMsgDOTADPCSeasonResults_StandingEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTADPCSeasonResults_StandingEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTADPCSeasonResults_StandingEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTADPCSeasonResults_StandingEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTADPCSeasonResults_StandingEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTADPCSeasonResults_StandingEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTADPCSeasonResults_StandingEntry& from) {
    CMsgDOTADPCSeasonResults_StandingEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCSeasonResults_StandingEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTADPCSeasonResults.StandingEntry";
  }
  protected:
  explicit CMsgDOTADPCSeasonResults_StandingEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamUrlFieldNumber = 4,
    kTeamNameFieldNumber = 5,
    kTeamAbbreviationFieldNumber = 6,
    kTeamIdFieldNumber = 1,
    kWinsFieldNumber = 2,
    kLossesFieldNumber = 3,
  };
  // optional string team_url = 4;
  bool has_team_url() const;
  private:
  bool _internal_has_team_url() const;
  public:
  void clear_team_url();
  const std::string& team_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_url();
  PROTOBUF_NODISCARD std::string* release_team_url();
  void set_allocated_team_url(std::string* team_url);
  private:
  const std::string& _internal_team_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_url(const std::string& value);
  std::string* _internal_mutable_team_url();
  public:

  // optional string team_name = 5;
  bool has_team_name() const;
  private:
  bool _internal_has_team_name() const;
  public:
  void clear_team_name();
  const std::string& team_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_name();
  PROTOBUF_NODISCARD std::string* release_team_name();
  void set_allocated_team_name(std::string* team_name);
  private:
  const std::string& _internal_team_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_name(const std::string& value);
  std::string* _internal_mutable_team_name();
  public:

  // optional string team_abbreviation = 6;
  bool has_team_abbreviation() const;
  private:
  bool _internal_has_team_abbreviation() const;
  public:
  void clear_team_abbreviation();
  const std::string& team_abbreviation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_abbreviation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_abbreviation();
  PROTOBUF_NODISCARD std::string* release_team_abbreviation();
  void set_allocated_team_abbreviation(std::string* team_abbreviation);
  private:
  const std::string& _internal_team_abbreviation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_abbreviation(const std::string& value);
  std::string* _internal_mutable_team_abbreviation();
  public:

  // optional uint32 team_id = 1;
  bool has_team_id() const;
  private:
  bool _internal_has_team_id() const;
  public:
  void clear_team_id();
  uint32_t team_id() const;
  void set_team_id(uint32_t value);
  private:
  uint32_t _internal_team_id() const;
  void _internal_set_team_id(uint32_t value);
  public:

  // optional uint32 wins = 2;
  bool has_wins() const;
  private:
  bool _internal_has_wins() const;
  public:
  void clear_wins();
  uint32_t wins() const;
  void set_wins(uint32_t value);
  private:
  uint32_t _internal_wins() const;
  void _internal_set_wins(uint32_t value);
  public:

  // optional uint32 losses = 3;
  bool has_losses() const;
  private:
  bool _internal_has_losses() const;
  public:
  void clear_losses();
  uint32_t losses() const;
  void set_losses(uint32_t value);
  private:
  uint32_t _internal_losses() const;
  void _internal_set_losses(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTADPCSeasonResults.StandingEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_abbreviation_;
    uint32_t team_id_;
    uint32_t wins_;
    uint32_t losses_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCSeasonResults_Standing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTADPCSeasonResults.Standing) */ {
 public:
  inline CMsgDOTADPCSeasonResults_Standing() : CMsgDOTADPCSeasonResults_Standing(nullptr) {}
  ~CMsgDOTADPCSeasonResults_Standing() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults_Standing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTADPCSeasonResults_Standing(const CMsgDOTADPCSeasonResults_Standing& from);
  CMsgDOTADPCSeasonResults_Standing(CMsgDOTADPCSeasonResults_Standing&& from) noexcept
    : CMsgDOTADPCSeasonResults_Standing() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCSeasonResults_Standing& operator=(const CMsgDOTADPCSeasonResults_Standing& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTADPCSeasonResults_Standing& operator=(CMsgDOTADPCSeasonResults_Standing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTADPCSeasonResults_Standing& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTADPCSeasonResults_Standing* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCSeasonResults_Standing*>(
               &_CMsgDOTADPCSeasonResults_Standing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CMsgDOTADPCSeasonResults_Standing& a, CMsgDOTADPCSeasonResults_Standing& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTADPCSeasonResults_Standing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTADPCSeasonResults_Standing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTADPCSeasonResults_Standing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTADPCSeasonResults_Standing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTADPCSeasonResults_Standing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTADPCSeasonResults_Standing& from) {
    CMsgDOTADPCSeasonResults_Standing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCSeasonResults_Standing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTADPCSeasonResults.Standing";
  }
  protected:
  explicit CMsgDOTADPCSeasonResults_Standing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 3,
    kRegionFieldNumber = 1,
    kDivisionFieldNumber = 2,
  };
  // repeated .CMsgDOTADPCSeasonResults.StandingEntry entries = 3;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::CMsgDOTADPCSeasonResults_StandingEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >*
      mutable_entries();
  private:
  const ::CMsgDOTADPCSeasonResults_StandingEntry& _internal_entries(int index) const;
  ::CMsgDOTADPCSeasonResults_StandingEntry* _internal_add_entries();
  public:
  const ::CMsgDOTADPCSeasonResults_StandingEntry& entries(int index) const;
  ::CMsgDOTADPCSeasonResults_StandingEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >&
      entries() const;

  // optional .ELeagueRegion region = 1 [default = LEAGUE_REGION_UNSET];
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  ::ELeagueRegion region() const;
  void set_region(::ELeagueRegion value);
  private:
  ::ELeagueRegion _internal_region() const;
  void _internal_set_region(::ELeagueRegion value);
  public:

  // optional .ELeagueDivision division = 2 [default = LEAGUE_DIVISION_UNSET];
  bool has_division() const;
  private:
  bool _internal_has_division() const;
  public:
  void clear_division();
  ::ELeagueDivision division() const;
  void set_division(::ELeagueDivision value);
  private:
  ::ELeagueDivision _internal_division() const;
  void _internal_set_division(::ELeagueDivision value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTADPCSeasonResults.Standing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry > entries_;
    int region_;
    int division_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCSeasonResults final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTADPCSeasonResults) */ {
 public:
  inline CMsgDOTADPCSeasonResults() : CMsgDOTADPCSeasonResults(nullptr) {}
  ~CMsgDOTADPCSeasonResults() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonResults(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTADPCSeasonResults(const CMsgDOTADPCSeasonResults& from);
  CMsgDOTADPCSeasonResults(CMsgDOTADPCSeasonResults&& from) noexcept
    : CMsgDOTADPCSeasonResults() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCSeasonResults& operator=(const CMsgDOTADPCSeasonResults& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTADPCSeasonResults& operator=(CMsgDOTADPCSeasonResults&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTADPCSeasonResults& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTADPCSeasonResults* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCSeasonResults*>(
               &_CMsgDOTADPCSeasonResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CMsgDOTADPCSeasonResults& a, CMsgDOTADPCSeasonResults& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTADPCSeasonResults* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTADPCSeasonResults* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTADPCSeasonResults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTADPCSeasonResults>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTADPCSeasonResults& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTADPCSeasonResults& from) {
    CMsgDOTADPCSeasonResults::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCSeasonResults* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTADPCSeasonResults";
  }
  protected:
  explicit CMsgDOTADPCSeasonResults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTADPCSeasonResults_TeamLeagueResult TeamLeagueResult;
  typedef CMsgDOTADPCSeasonResults_TeamResult TeamResult;
  typedef CMsgDOTADPCSeasonResults_StandingEntry StandingEntry;
  typedef CMsgDOTADPCSeasonResults_Standing Standing;

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
    kStandingsFieldNumber = 2,
    kMajorWildcardStandingsFieldNumber = 3,
    kMajorGroupStandingsFieldNumber = 4,
    kMajorPlayoffStandingsFieldNumber = 5,
  };
  // repeated .CMsgDOTADPCSeasonResults.TeamResult results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::CMsgDOTADPCSeasonResults_TeamResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_TeamResult >*
      mutable_results();
  private:
  const ::CMsgDOTADPCSeasonResults_TeamResult& _internal_results(int index) const;
  ::CMsgDOTADPCSeasonResults_TeamResult* _internal_add_results();
  public:
  const ::CMsgDOTADPCSeasonResults_TeamResult& results(int index) const;
  ::CMsgDOTADPCSeasonResults_TeamResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_TeamResult >&
      results() const;

  // repeated .CMsgDOTADPCSeasonResults.Standing standings = 2;
  int standings_size() const;
  private:
  int _internal_standings_size() const;
  public:
  void clear_standings();
  ::CMsgDOTADPCSeasonResults_Standing* mutable_standings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_Standing >*
      mutable_standings();
  private:
  const ::CMsgDOTADPCSeasonResults_Standing& _internal_standings(int index) const;
  ::CMsgDOTADPCSeasonResults_Standing* _internal_add_standings();
  public:
  const ::CMsgDOTADPCSeasonResults_Standing& standings(int index) const;
  ::CMsgDOTADPCSeasonResults_Standing* add_standings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_Standing >&
      standings() const;

  // repeated .CMsgDOTADPCSeasonResults.StandingEntry major_wildcard_standings = 3;
  int major_wildcard_standings_size() const;
  private:
  int _internal_major_wildcard_standings_size() const;
  public:
  void clear_major_wildcard_standings();
  ::CMsgDOTADPCSeasonResults_StandingEntry* mutable_major_wildcard_standings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >*
      mutable_major_wildcard_standings();
  private:
  const ::CMsgDOTADPCSeasonResults_StandingEntry& _internal_major_wildcard_standings(int index) const;
  ::CMsgDOTADPCSeasonResults_StandingEntry* _internal_add_major_wildcard_standings();
  public:
  const ::CMsgDOTADPCSeasonResults_StandingEntry& major_wildcard_standings(int index) const;
  ::CMsgDOTADPCSeasonResults_StandingEntry* add_major_wildcard_standings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >&
      major_wildcard_standings() const;

  // repeated .CMsgDOTADPCSeasonResults.StandingEntry major_group_standings = 4;
  int major_group_standings_size() const;
  private:
  int _internal_major_group_standings_size() const;
  public:
  void clear_major_group_standings();
  ::CMsgDOTADPCSeasonResults_StandingEntry* mutable_major_group_standings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >*
      mutable_major_group_standings();
  private:
  const ::CMsgDOTADPCSeasonResults_StandingEntry& _internal_major_group_standings(int index) const;
  ::CMsgDOTADPCSeasonResults_StandingEntry* _internal_add_major_group_standings();
  public:
  const ::CMsgDOTADPCSeasonResults_StandingEntry& major_group_standings(int index) const;
  ::CMsgDOTADPCSeasonResults_StandingEntry* add_major_group_standings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >&
      major_group_standings() const;

  // repeated .CMsgDOTADPCSeasonResults.StandingEntry major_playoff_standings = 5;
  int major_playoff_standings_size() const;
  private:
  int _internal_major_playoff_standings_size() const;
  public:
  void clear_major_playoff_standings();
  ::CMsgDOTADPCSeasonResults_StandingEntry* mutable_major_playoff_standings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >*
      mutable_major_playoff_standings();
  private:
  const ::CMsgDOTADPCSeasonResults_StandingEntry& _internal_major_playoff_standings(int index) const;
  ::CMsgDOTADPCSeasonResults_StandingEntry* _internal_add_major_playoff_standings();
  public:
  const ::CMsgDOTADPCSeasonResults_StandingEntry& major_playoff_standings(int index) const;
  ::CMsgDOTADPCSeasonResults_StandingEntry* add_major_playoff_standings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >&
      major_playoff_standings() const;

  // @@protoc_insertion_point(class_scope:CMsgDOTADPCSeasonResults)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_TeamResult > results_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_Standing > standings_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry > major_wildcard_standings_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry > major_group_standings_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry > major_playoff_standings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCSeasonSpoilerResults final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTADPCSeasonSpoilerResults) */ {
 public:
  inline CMsgDOTADPCSeasonSpoilerResults() : CMsgDOTADPCSeasonSpoilerResults(nullptr) {}
  ~CMsgDOTADPCSeasonSpoilerResults() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTADPCSeasonSpoilerResults(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTADPCSeasonSpoilerResults(const CMsgDOTADPCSeasonSpoilerResults& from);
  CMsgDOTADPCSeasonSpoilerResults(CMsgDOTADPCSeasonSpoilerResults&& from) noexcept
    : CMsgDOTADPCSeasonSpoilerResults() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCSeasonSpoilerResults& operator=(const CMsgDOTADPCSeasonSpoilerResults& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTADPCSeasonSpoilerResults& operator=(CMsgDOTADPCSeasonSpoilerResults&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTADPCSeasonSpoilerResults& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTADPCSeasonSpoilerResults* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCSeasonSpoilerResults*>(
               &_CMsgDOTADPCSeasonSpoilerResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CMsgDOTADPCSeasonSpoilerResults& a, CMsgDOTADPCSeasonSpoilerResults& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTADPCSeasonSpoilerResults* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTADPCSeasonSpoilerResults* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTADPCSeasonSpoilerResults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTADPCSeasonSpoilerResults>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTADPCSeasonSpoilerResults& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTADPCSeasonSpoilerResults& from) {
    CMsgDOTADPCSeasonSpoilerResults::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCSeasonSpoilerResults* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTADPCSeasonSpoilerResults";
  }
  protected:
  explicit CMsgDOTADPCSeasonSpoilerResults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSavedResultsFieldNumber = 2,
    kTimeLastUpdatedFieldNumber = 1,
  };
  // optional .CMsgDOTADPCSeasonResults saved_results = 2;
  bool has_saved_results() const;
  private:
  bool _internal_has_saved_results() const;
  public:
  void clear_saved_results();
  const ::CMsgDOTADPCSeasonResults& saved_results() const;
  PROTOBUF_NODISCARD ::CMsgDOTADPCSeasonResults* release_saved_results();
  ::CMsgDOTADPCSeasonResults* mutable_saved_results();
  void set_allocated_saved_results(::CMsgDOTADPCSeasonResults* saved_results);
  private:
  const ::CMsgDOTADPCSeasonResults& _internal_saved_results() const;
  ::CMsgDOTADPCSeasonResults* _internal_mutable_saved_results();
  public:
  void unsafe_arena_set_allocated_saved_results(
      ::CMsgDOTADPCSeasonResults* saved_results);
  ::CMsgDOTADPCSeasonResults* unsafe_arena_release_saved_results();

  // optional uint32 time_last_updated = 1;
  bool has_time_last_updated() const;
  private:
  bool _internal_has_time_last_updated() const;
  public:
  void clear_time_last_updated();
  uint32_t time_last_updated() const;
  void set_time_last_updated(uint32_t value);
  private:
  uint32_t _internal_time_last_updated() const;
  void _internal_set_time_last_updated(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTADPCSeasonSpoilerResults)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgDOTADPCSeasonResults* saved_results_;
    uint32_t time_last_updated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgDOTALeagueNode_MatchDetails

// optional uint64 match_id = 1;
inline bool CMsgDOTALeagueNode_MatchDetails::_internal_has_match_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode_MatchDetails::has_match_id() const {
  return _internal_has_match_id();
}
inline void CMsgDOTALeagueNode_MatchDetails::clear_match_id() {
  _impl_.match_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgDOTALeagueNode_MatchDetails::_internal_match_id() const {
  return _impl_.match_id_;
}
inline uint64_t CMsgDOTALeagueNode_MatchDetails::match_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.MatchDetails.match_id)
  return _internal_match_id();
}
inline void CMsgDOTALeagueNode_MatchDetails::_internal_set_match_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.match_id_ = value;
}
inline void CMsgDOTALeagueNode_MatchDetails::set_match_id(uint64_t value) {
  _internal_set_match_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.MatchDetails.match_id)
}

// optional uint32 winning_team_id = 2;
inline bool CMsgDOTALeagueNode_MatchDetails::_internal_has_winning_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode_MatchDetails::has_winning_team_id() const {
  return _internal_has_winning_team_id();
}
inline void CMsgDOTALeagueNode_MatchDetails::clear_winning_team_id() {
  _impl_.winning_team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTALeagueNode_MatchDetails::_internal_winning_team_id() const {
  return _impl_.winning_team_id_;
}
inline uint32_t CMsgDOTALeagueNode_MatchDetails::winning_team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.MatchDetails.winning_team_id)
  return _internal_winning_team_id();
}
inline void CMsgDOTALeagueNode_MatchDetails::_internal_set_winning_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.winning_team_id_ = value;
}
inline void CMsgDOTALeagueNode_MatchDetails::set_winning_team_id(uint32_t value) {
  _internal_set_winning_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.MatchDetails.winning_team_id)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueNode_VOD

// optional uint32 series_game = 1;
inline bool CMsgDOTALeagueNode_VOD::_internal_has_series_game() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode_VOD::has_series_game() const {
  return _internal_has_series_game();
}
inline void CMsgDOTALeagueNode_VOD::clear_series_game() {
  _impl_.series_game_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTALeagueNode_VOD::_internal_series_game() const {
  return _impl_.series_game_;
}
inline uint32_t CMsgDOTALeagueNode_VOD::series_game() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.VOD.series_game)
  return _internal_series_game();
}
inline void CMsgDOTALeagueNode_VOD::_internal_set_series_game(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.series_game_ = value;
}
inline void CMsgDOTALeagueNode_VOD::set_series_game(uint32_t value) {
  _internal_set_series_game(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.VOD.series_game)
}

// optional uint32 stream_id = 2;
inline bool CMsgDOTALeagueNode_VOD::_internal_has_stream_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode_VOD::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void CMsgDOTALeagueNode_VOD::clear_stream_id() {
  _impl_.stream_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTALeagueNode_VOD::_internal_stream_id() const {
  return _impl_.stream_id_;
}
inline uint32_t CMsgDOTALeagueNode_VOD::stream_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.VOD.stream_id)
  return _internal_stream_id();
}
inline void CMsgDOTALeagueNode_VOD::_internal_set_stream_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stream_id_ = value;
}
inline void CMsgDOTALeagueNode_VOD::set_stream_id(uint32_t value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.VOD.stream_id)
}

// optional string url = 3;
inline bool CMsgDOTALeagueNode_VOD::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode_VOD::has_url() const {
  return _internal_has_url();
}
inline void CMsgDOTALeagueNode_VOD::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeagueNode_VOD::url() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.VOD.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueNode_VOD::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.VOD.url)
}
inline std::string* CMsgDOTALeagueNode_VOD::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNode.VOD.url)
  return _s;
}
inline const std::string& CMsgDOTALeagueNode_VOD::_internal_url() const {
  return _impl_.url_.Get();
}
inline void CMsgDOTALeagueNode_VOD::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNode_VOD::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNode_VOD::release_url() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueNode.VOD.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueNode_VOD::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueNode.VOD.url)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueNode

// optional string name = 1;
inline bool CMsgDOTALeagueNode::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_name() const {
  return _internal_has_name();
}
inline void CMsgDOTALeagueNode::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeagueNode::name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueNode::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.name)
}
inline std::string* CMsgDOTALeagueNode::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNode.name)
  return _s;
}
inline const std::string& CMsgDOTALeagueNode::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDOTALeagueNode::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNode::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNode::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueNode.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueNode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueNode.name)
}

// optional uint32 node_id = 2;
inline bool CMsgDOTALeagueNode::_internal_has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_node_id() const {
  return _internal_has_node_id();
}
inline void CMsgDOTALeagueNode::clear_node_id() {
  _impl_.node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_node_id() const {
  return _impl_.node_id_;
}
inline uint32_t CMsgDOTALeagueNode::node_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.node_id)
  return _internal_node_id();
}
inline void CMsgDOTALeagueNode::_internal_set_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.node_id_ = value;
}
inline void CMsgDOTALeagueNode::set_node_id(uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.node_id)
}

// optional uint32 node_group_id = 3;
inline bool CMsgDOTALeagueNode::_internal_has_node_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_node_group_id() const {
  return _internal_has_node_group_id();
}
inline void CMsgDOTALeagueNode::clear_node_group_id() {
  _impl_.node_group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_node_group_id() const {
  return _impl_.node_group_id_;
}
inline uint32_t CMsgDOTALeagueNode::node_group_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.node_group_id)
  return _internal_node_group_id();
}
inline void CMsgDOTALeagueNode::_internal_set_node_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.node_group_id_ = value;
}
inline void CMsgDOTALeagueNode::set_node_group_id(uint32_t value) {
  _internal_set_node_group_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.node_group_id)
}

// optional uint32 winning_node_id = 4;
inline bool CMsgDOTALeagueNode::_internal_has_winning_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_winning_node_id() const {
  return _internal_has_winning_node_id();
}
inline void CMsgDOTALeagueNode::clear_winning_node_id() {
  _impl_.winning_node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_winning_node_id() const {
  return _impl_.winning_node_id_;
}
inline uint32_t CMsgDOTALeagueNode::winning_node_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.winning_node_id)
  return _internal_winning_node_id();
}
inline void CMsgDOTALeagueNode::_internal_set_winning_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.winning_node_id_ = value;
}
inline void CMsgDOTALeagueNode::set_winning_node_id(uint32_t value) {
  _internal_set_winning_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.winning_node_id)
}

// optional uint32 losing_node_id = 5;
inline bool CMsgDOTALeagueNode::_internal_has_losing_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_losing_node_id() const {
  return _internal_has_losing_node_id();
}
inline void CMsgDOTALeagueNode::clear_losing_node_id() {
  _impl_.losing_node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_losing_node_id() const {
  return _impl_.losing_node_id_;
}
inline uint32_t CMsgDOTALeagueNode::losing_node_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.losing_node_id)
  return _internal_losing_node_id();
}
inline void CMsgDOTALeagueNode::_internal_set_losing_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.losing_node_id_ = value;
}
inline void CMsgDOTALeagueNode::set_losing_node_id(uint32_t value) {
  _internal_set_losing_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.losing_node_id)
}

// optional uint32 incoming_node_id_1 = 6;
inline bool CMsgDOTALeagueNode::_internal_has_incoming_node_id_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_incoming_node_id_1() const {
  return _internal_has_incoming_node_id_1();
}
inline void CMsgDOTALeagueNode::clear_incoming_node_id_1() {
  _impl_.incoming_node_id_1_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_incoming_node_id_1() const {
  return _impl_.incoming_node_id_1_;
}
inline uint32_t CMsgDOTALeagueNode::incoming_node_id_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.incoming_node_id_1)
  return _internal_incoming_node_id_1();
}
inline void CMsgDOTALeagueNode::_internal_set_incoming_node_id_1(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.incoming_node_id_1_ = value;
}
inline void CMsgDOTALeagueNode::set_incoming_node_id_1(uint32_t value) {
  _internal_set_incoming_node_id_1(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.incoming_node_id_1)
}

// optional uint32 incoming_node_id_2 = 7;
inline bool CMsgDOTALeagueNode::_internal_has_incoming_node_id_2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_incoming_node_id_2() const {
  return _internal_has_incoming_node_id_2();
}
inline void CMsgDOTALeagueNode::clear_incoming_node_id_2() {
  _impl_.incoming_node_id_2_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_incoming_node_id_2() const {
  return _impl_.incoming_node_id_2_;
}
inline uint32_t CMsgDOTALeagueNode::incoming_node_id_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.incoming_node_id_2)
  return _internal_incoming_node_id_2();
}
inline void CMsgDOTALeagueNode::_internal_set_incoming_node_id_2(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.incoming_node_id_2_ = value;
}
inline void CMsgDOTALeagueNode::set_incoming_node_id_2(uint32_t value) {
  _internal_set_incoming_node_id_2(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.incoming_node_id_2)
}

// optional .ELeagueNodeType node_type = 8 [default = INVALID_NODE_TYPE];
inline bool CMsgDOTALeagueNode::_internal_has_node_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_node_type() const {
  return _internal_has_node_type();
}
inline void CMsgDOTALeagueNode::clear_node_type() {
  _impl_.node_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::ELeagueNodeType CMsgDOTALeagueNode::_internal_node_type() const {
  return static_cast< ::ELeagueNodeType >(_impl_.node_type_);
}
inline ::ELeagueNodeType CMsgDOTALeagueNode::node_type() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.node_type)
  return _internal_node_type();
}
inline void CMsgDOTALeagueNode::_internal_set_node_type(::ELeagueNodeType value) {
  assert(::ELeagueNodeType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.node_type_ = value;
}
inline void CMsgDOTALeagueNode::set_node_type(::ELeagueNodeType value) {
  _internal_set_node_type(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.node_type)
}

// optional uint32 scheduled_time = 9;
inline bool CMsgDOTALeagueNode::_internal_has_scheduled_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_scheduled_time() const {
  return _internal_has_scheduled_time();
}
inline void CMsgDOTALeagueNode::clear_scheduled_time() {
  _impl_.scheduled_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_scheduled_time() const {
  return _impl_.scheduled_time_;
}
inline uint32_t CMsgDOTALeagueNode::scheduled_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.scheduled_time)
  return _internal_scheduled_time();
}
inline void CMsgDOTALeagueNode::_internal_set_scheduled_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.scheduled_time_ = value;
}
inline void CMsgDOTALeagueNode::set_scheduled_time(uint32_t value) {
  _internal_set_scheduled_time(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.scheduled_time)
}

// optional uint32 actual_time = 19;
inline bool CMsgDOTALeagueNode::_internal_has_actual_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_actual_time() const {
  return _internal_has_actual_time();
}
inline void CMsgDOTALeagueNode::clear_actual_time() {
  _impl_.actual_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_actual_time() const {
  return _impl_.actual_time_;
}
inline uint32_t CMsgDOTALeagueNode::actual_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.actual_time)
  return _internal_actual_time();
}
inline void CMsgDOTALeagueNode::_internal_set_actual_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.actual_time_ = value;
}
inline void CMsgDOTALeagueNode::set_actual_time(uint32_t value) {
  _internal_set_actual_time(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.actual_time)
}

// optional uint32 series_id = 10;
inline bool CMsgDOTALeagueNode::_internal_has_series_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_series_id() const {
  return _internal_has_series_id();
}
inline void CMsgDOTALeagueNode::clear_series_id() {
  _impl_.series_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_series_id() const {
  return _impl_.series_id_;
}
inline uint32_t CMsgDOTALeagueNode::series_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.series_id)
  return _internal_series_id();
}
inline void CMsgDOTALeagueNode::_internal_set_series_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.series_id_ = value;
}
inline void CMsgDOTALeagueNode::set_series_id(uint32_t value) {
  _internal_set_series_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.series_id)
}

// optional uint32 team_id_1 = 11;
inline bool CMsgDOTALeagueNode::_internal_has_team_id_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_team_id_1() const {
  return _internal_has_team_id_1();
}
inline void CMsgDOTALeagueNode::clear_team_id_1() {
  _impl_.team_id_1_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_team_id_1() const {
  return _impl_.team_id_1_;
}
inline uint32_t CMsgDOTALeagueNode::team_id_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.team_id_1)
  return _internal_team_id_1();
}
inline void CMsgDOTALeagueNode::_internal_set_team_id_1(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.team_id_1_ = value;
}
inline void CMsgDOTALeagueNode::set_team_id_1(uint32_t value) {
  _internal_set_team_id_1(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.team_id_1)
}

// optional uint32 team_id_2 = 12;
inline bool CMsgDOTALeagueNode::_internal_has_team_id_2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_team_id_2() const {
  return _internal_has_team_id_2();
}
inline void CMsgDOTALeagueNode::clear_team_id_2() {
  _impl_.team_id_2_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_team_id_2() const {
  return _impl_.team_id_2_;
}
inline uint32_t CMsgDOTALeagueNode::team_id_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.team_id_2)
  return _internal_team_id_2();
}
inline void CMsgDOTALeagueNode::_internal_set_team_id_2(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.team_id_2_ = value;
}
inline void CMsgDOTALeagueNode::set_team_id_2(uint32_t value) {
  _internal_set_team_id_2(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.team_id_2)
}

// repeated .CMsgDOTALeagueNode.MatchDetails matches = 13;
inline int CMsgDOTALeagueNode::_internal_matches_size() const {
  return _impl_.matches_.size();
}
inline int CMsgDOTALeagueNode::matches_size() const {
  return _internal_matches_size();
}
inline void CMsgDOTALeagueNode::clear_matches() {
  _impl_.matches_.Clear();
}
inline ::CMsgDOTALeagueNode_MatchDetails* CMsgDOTALeagueNode::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNode.matches)
  return _impl_.matches_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode_MatchDetails >*
CMsgDOTALeagueNode::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueNode.matches)
  return &_impl_.matches_;
}
inline const ::CMsgDOTALeagueNode_MatchDetails& CMsgDOTALeagueNode::_internal_matches(int index) const {
  return _impl_.matches_.Get(index);
}
inline const ::CMsgDOTALeagueNode_MatchDetails& CMsgDOTALeagueNode::matches(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.matches)
  return _internal_matches(index);
}
inline ::CMsgDOTALeagueNode_MatchDetails* CMsgDOTALeagueNode::_internal_add_matches() {
  return _impl_.matches_.Add();
}
inline ::CMsgDOTALeagueNode_MatchDetails* CMsgDOTALeagueNode::add_matches() {
  ::CMsgDOTALeagueNode_MatchDetails* _add = _internal_add_matches();
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueNode.matches)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode_MatchDetails >&
CMsgDOTALeagueNode::matches() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueNode.matches)
  return _impl_.matches_;
}

// optional uint32 team_1_wins = 14;
inline bool CMsgDOTALeagueNode::_internal_has_team_1_wins() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_team_1_wins() const {
  return _internal_has_team_1_wins();
}
inline void CMsgDOTALeagueNode::clear_team_1_wins() {
  _impl_.team_1_wins_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_team_1_wins() const {
  return _impl_.team_1_wins_;
}
inline uint32_t CMsgDOTALeagueNode::team_1_wins() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.team_1_wins)
  return _internal_team_1_wins();
}
inline void CMsgDOTALeagueNode::_internal_set_team_1_wins(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.team_1_wins_ = value;
}
inline void CMsgDOTALeagueNode::set_team_1_wins(uint32_t value) {
  _internal_set_team_1_wins(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.team_1_wins)
}

// optional uint32 team_2_wins = 15;
inline bool CMsgDOTALeagueNode::_internal_has_team_2_wins() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_team_2_wins() const {
  return _internal_has_team_2_wins();
}
inline void CMsgDOTALeagueNode::clear_team_2_wins() {
  _impl_.team_2_wins_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t CMsgDOTALeagueNode::_internal_team_2_wins() const {
  return _impl_.team_2_wins_;
}
inline uint32_t CMsgDOTALeagueNode::team_2_wins() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.team_2_wins)
  return _internal_team_2_wins();
}
inline void CMsgDOTALeagueNode::_internal_set_team_2_wins(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.team_2_wins_ = value;
}
inline void CMsgDOTALeagueNode::set_team_2_wins(uint32_t value) {
  _internal_set_team_2_wins(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.team_2_wins)
}

// optional bool has_started = 16;
inline bool CMsgDOTALeagueNode::_internal_has_has_started() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_has_started() const {
  return _internal_has_has_started();
}
inline void CMsgDOTALeagueNode::clear_has_started() {
  _impl_.has_started_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool CMsgDOTALeagueNode::_internal_has_started() const {
  return _impl_.has_started_;
}
inline bool CMsgDOTALeagueNode::has_started() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.has_started)
  return _internal_has_started();
}
inline void CMsgDOTALeagueNode::_internal_set_has_started(bool value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.has_started_ = value;
}
inline void CMsgDOTALeagueNode::set_has_started(bool value) {
  _internal_set_has_started(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.has_started)
}

// optional bool is_completed = 17;
inline bool CMsgDOTALeagueNode::_internal_has_is_completed() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNode::has_is_completed() const {
  return _internal_has_is_completed();
}
inline void CMsgDOTALeagueNode::clear_is_completed() {
  _impl_.is_completed_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool CMsgDOTALeagueNode::_internal_is_completed() const {
  return _impl_.is_completed_;
}
inline bool CMsgDOTALeagueNode::is_completed() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.is_completed)
  return _internal_is_completed();
}
inline void CMsgDOTALeagueNode::_internal_set_is_completed(bool value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.is_completed_ = value;
}
inline void CMsgDOTALeagueNode::set_is_completed(bool value) {
  _internal_set_is_completed(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.is_completed)
}

// repeated uint32 stream_ids = 18;
inline int CMsgDOTALeagueNode::_internal_stream_ids_size() const {
  return _impl_.stream_ids_.size();
}
inline int CMsgDOTALeagueNode::stream_ids_size() const {
  return _internal_stream_ids_size();
}
inline void CMsgDOTALeagueNode::clear_stream_ids() {
  _impl_.stream_ids_.Clear();
}
inline uint32_t CMsgDOTALeagueNode::_internal_stream_ids(int index) const {
  return _impl_.stream_ids_.Get(index);
}
inline uint32_t CMsgDOTALeagueNode::stream_ids(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.stream_ids)
  return _internal_stream_ids(index);
}
inline void CMsgDOTALeagueNode::set_stream_ids(int index, uint32_t value) {
  _impl_.stream_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNode.stream_ids)
}
inline void CMsgDOTALeagueNode::_internal_add_stream_ids(uint32_t value) {
  _impl_.stream_ids_.Add(value);
}
inline void CMsgDOTALeagueNode::add_stream_ids(uint32_t value) {
  _internal_add_stream_ids(value);
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueNode.stream_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgDOTALeagueNode::_internal_stream_ids() const {
  return _impl_.stream_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgDOTALeagueNode::stream_ids() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueNode.stream_ids)
  return _internal_stream_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgDOTALeagueNode::_internal_mutable_stream_ids() {
  return &_impl_.stream_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgDOTALeagueNode::mutable_stream_ids() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueNode.stream_ids)
  return _internal_mutable_stream_ids();
}

// repeated .CMsgDOTALeagueNode.VOD vods = 20;
inline int CMsgDOTALeagueNode::_internal_vods_size() const {
  return _impl_.vods_.size();
}
inline int CMsgDOTALeagueNode::vods_size() const {
  return _internal_vods_size();
}
inline void CMsgDOTALeagueNode::clear_vods() {
  _impl_.vods_.Clear();
}
inline ::CMsgDOTALeagueNode_VOD* CMsgDOTALeagueNode::mutable_vods(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNode.vods)
  return _impl_.vods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode_VOD >*
CMsgDOTALeagueNode::mutable_vods() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueNode.vods)
  return &_impl_.vods_;
}
inline const ::CMsgDOTALeagueNode_VOD& CMsgDOTALeagueNode::_internal_vods(int index) const {
  return _impl_.vods_.Get(index);
}
inline const ::CMsgDOTALeagueNode_VOD& CMsgDOTALeagueNode::vods(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNode.vods)
  return _internal_vods(index);
}
inline ::CMsgDOTALeagueNode_VOD* CMsgDOTALeagueNode::_internal_add_vods() {
  return _impl_.vods_.Add();
}
inline ::CMsgDOTALeagueNode_VOD* CMsgDOTALeagueNode::add_vods() {
  ::CMsgDOTALeagueNode_VOD* _add = _internal_add_vods();
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueNode.vods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode_VOD >&
CMsgDOTALeagueNode::vods() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueNode.vods)
  return _impl_.vods_;
}

// -------------------------------------------------------------------

// CMsgDOTALeagueNodeGroup_TeamStanding

// optional uint32 standing = 1;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_standing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_standing() const {
  return _internal_has_standing();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_standing() {
  _impl_.standing_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTALeagueNodeGroup_TeamStanding::_internal_standing() const {
  return _impl_.standing_;
}
inline uint32_t CMsgDOTALeagueNodeGroup_TeamStanding::standing() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.standing)
  return _internal_standing();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_standing(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.standing_ = value;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_standing(uint32_t value) {
  _internal_set_standing(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.standing)
}

// optional uint32 team_id = 2;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_team_id() {
  _impl_.team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgDOTALeagueNodeGroup_TeamStanding::_internal_team_id() const {
  return _impl_.team_id_;
}
inline uint32_t CMsgDOTALeagueNodeGroup_TeamStanding::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.team_id)
  return _internal_team_id();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.team_id_ = value;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_id(uint32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.team_id)
}

// optional string team_name = 3;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_team_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_team_name() const {
  return _internal_has_team_name();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_team_name() {
  _impl_.team_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeagueNodeGroup_TeamStanding::team_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
  return _internal_team_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.team_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
}
inline std::string* CMsgDOTALeagueNodeGroup_TeamStanding::mutable_team_name() {
  std::string* _s = _internal_mutable_team_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
  return _s;
}
inline const std::string& CMsgDOTALeagueNodeGroup_TeamStanding::_internal_team_name() const {
  return _impl_.team_name_.Get();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_team_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.team_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeGroup_TeamStanding::_internal_mutable_team_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.team_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeGroup_TeamStanding::release_team_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
  if (!_internal_has_team_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.team_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_name_.IsDefault()) {
    _impl_.team_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_allocated_team_name(std::string* team_name) {
  if (team_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.team_name_.SetAllocated(team_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_name_.IsDefault()) {
    _impl_.team_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
}

// optional string team_tag = 4;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_team_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_team_tag() const {
  return _internal_has_team_tag();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_team_tag() {
  _impl_.team_tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTALeagueNodeGroup_TeamStanding::team_tag() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
  return _internal_team_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_tag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.team_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
}
inline std::string* CMsgDOTALeagueNodeGroup_TeamStanding::mutable_team_tag() {
  std::string* _s = _internal_mutable_team_tag();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
  return _s;
}
inline const std::string& CMsgDOTALeagueNodeGroup_TeamStanding::_internal_team_tag() const {
  return _impl_.team_tag_.Get();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_team_tag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.team_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeGroup_TeamStanding::_internal_mutable_team_tag() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.team_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeGroup_TeamStanding::release_team_tag() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
  if (!_internal_has_team_tag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.team_tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_tag_.IsDefault()) {
    _impl_.team_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_allocated_team_tag(std::string* team_tag) {
  if (team_tag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.team_tag_.SetAllocated(team_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_tag_.IsDefault()) {
    _impl_.team_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
}

// optional uint64 team_logo = 5;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_team_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_team_logo() const {
  return _internal_has_team_logo();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_team_logo() {
  _impl_.team_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t CMsgDOTALeagueNodeGroup_TeamStanding::_internal_team_logo() const {
  return _impl_.team_logo_;
}
inline uint64_t CMsgDOTALeagueNodeGroup_TeamStanding::team_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.team_logo)
  return _internal_team_logo();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_team_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.team_logo_ = value;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_logo(uint64_t value) {
  _internal_set_team_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.team_logo)
}

// optional string team_logo_url = 6;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_team_logo_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_team_logo_url() const {
  return _internal_has_team_logo_url();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_team_logo_url() {
  _impl_.team_logo_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgDOTALeagueNodeGroup_TeamStanding::team_logo_url() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
  return _internal_team_logo_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_logo_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.team_logo_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
}
inline std::string* CMsgDOTALeagueNodeGroup_TeamStanding::mutable_team_logo_url() {
  std::string* _s = _internal_mutable_team_logo_url();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
  return _s;
}
inline const std::string& CMsgDOTALeagueNodeGroup_TeamStanding::_internal_team_logo_url() const {
  return _impl_.team_logo_url_.Get();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_team_logo_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.team_logo_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeGroup_TeamStanding::_internal_mutable_team_logo_url() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.team_logo_url_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeGroup_TeamStanding::release_team_logo_url() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
  if (!_internal_has_team_logo_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.team_logo_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_logo_url_.IsDefault()) {
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_allocated_team_logo_url(std::string* team_logo_url) {
  if (team_logo_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.team_logo_url_.SetAllocated(team_logo_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_logo_url_.IsDefault()) {
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
}

// optional uint32 wins = 7;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_wins() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_wins() const {
  return _internal_has_wins();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_wins() {
  _impl_.wins_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CMsgDOTALeagueNodeGroup_TeamStanding::_internal_wins() const {
  return _impl_.wins_;
}
inline uint32_t CMsgDOTALeagueNodeGroup_TeamStanding::wins() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.wins)
  return _internal_wins();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_wins(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.wins_ = value;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_wins(uint32_t value) {
  _internal_set_wins(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.wins)
}

// optional uint32 losses = 8;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_losses() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_losses() const {
  return _internal_has_losses();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_losses() {
  _impl_.losses_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CMsgDOTALeagueNodeGroup_TeamStanding::_internal_losses() const {
  return _impl_.losses_;
}
inline uint32_t CMsgDOTALeagueNodeGroup_TeamStanding::losses() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.losses)
  return _internal_losses();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_losses(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.losses_ = value;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_losses(uint32_t value) {
  _internal_set_losses(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.losses)
}

// optional int64 score = 9;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_score() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_score() const {
  return _internal_has_score();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_score() {
  _impl_.score_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t CMsgDOTALeagueNodeGroup_TeamStanding::_internal_score() const {
  return _impl_.score_;
}
inline int64_t CMsgDOTALeagueNodeGroup_TeamStanding::score() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.score)
  return _internal_score();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_score(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.score_ = value;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_score(int64_t value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.score)
}

// optional string team_abbreviation = 10;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_team_abbreviation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_team_abbreviation() const {
  return _internal_has_team_abbreviation();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_team_abbreviation() {
  _impl_.team_abbreviation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CMsgDOTALeagueNodeGroup_TeamStanding::team_abbreviation() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.team_abbreviation)
  return _internal_team_abbreviation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_abbreviation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.team_abbreviation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.team_abbreviation)
}
inline std::string* CMsgDOTALeagueNodeGroup_TeamStanding::mutable_team_abbreviation() {
  std::string* _s = _internal_mutable_team_abbreviation();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNodeGroup.TeamStanding.team_abbreviation)
  return _s;
}
inline const std::string& CMsgDOTALeagueNodeGroup_TeamStanding::_internal_team_abbreviation() const {
  return _impl_.team_abbreviation_.Get();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_team_abbreviation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.team_abbreviation_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeGroup_TeamStanding::_internal_mutable_team_abbreviation() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.team_abbreviation_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeGroup_TeamStanding::release_team_abbreviation() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueNodeGroup.TeamStanding.team_abbreviation)
  if (!_internal_has_team_abbreviation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.team_abbreviation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_abbreviation_.IsDefault()) {
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_allocated_team_abbreviation(std::string* team_abbreviation) {
  if (team_abbreviation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.team_abbreviation_.SetAllocated(team_abbreviation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_abbreviation_.IsDefault()) {
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueNodeGroup.TeamStanding.team_abbreviation)
}

// optional int64 score_tiebreak_group = 11;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_score_tiebreak_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_score_tiebreak_group() const {
  return _internal_has_score_tiebreak_group();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_score_tiebreak_group() {
  _impl_.score_tiebreak_group_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t CMsgDOTALeagueNodeGroup_TeamStanding::_internal_score_tiebreak_group() const {
  return _impl_.score_tiebreak_group_;
}
inline int64_t CMsgDOTALeagueNodeGroup_TeamStanding::score_tiebreak_group() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.score_tiebreak_group)
  return _internal_score_tiebreak_group();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_score_tiebreak_group(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.score_tiebreak_group_ = value;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_score_tiebreak_group(int64_t value) {
  _internal_set_score_tiebreak_group(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.score_tiebreak_group)
}

// optional int64 score_tiebreak_below = 12;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_score_tiebreak_below() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_score_tiebreak_below() const {
  return _internal_has_score_tiebreak_below();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_score_tiebreak_below() {
  _impl_.score_tiebreak_below_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int64_t CMsgDOTALeagueNodeGroup_TeamStanding::_internal_score_tiebreak_below() const {
  return _impl_.score_tiebreak_below_;
}
inline int64_t CMsgDOTALeagueNodeGroup_TeamStanding::score_tiebreak_below() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.score_tiebreak_below)
  return _internal_score_tiebreak_below();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_score_tiebreak_below(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.score_tiebreak_below_ = value;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_score_tiebreak_below(int64_t value) {
  _internal_set_score_tiebreak_below(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.score_tiebreak_below)
}

// optional int64 score_tiebreak_random = 13;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_score_tiebreak_random() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_score_tiebreak_random() const {
  return _internal_has_score_tiebreak_random();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_score_tiebreak_random() {
  _impl_.score_tiebreak_random_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int64_t CMsgDOTALeagueNodeGroup_TeamStanding::_internal_score_tiebreak_random() const {
  return _impl_.score_tiebreak_random_;
}
inline int64_t CMsgDOTALeagueNodeGroup_TeamStanding::score_tiebreak_random() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.score_tiebreak_random)
  return _internal_score_tiebreak_random();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_score_tiebreak_random(int64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.score_tiebreak_random_ = value;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_score_tiebreak_random(int64_t value) {
  _internal_set_score_tiebreak_random(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.score_tiebreak_random)
}

// optional bool is_pro = 14;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_has_is_pro() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_is_pro() const {
  return _internal_has_is_pro();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_is_pro() {
  _impl_.is_pro_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::_internal_is_pro() const {
  return _impl_.is_pro_;
}
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::is_pro() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.TeamStanding.is_pro)
  return _internal_is_pro();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::_internal_set_is_pro(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.is_pro_ = value;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_is_pro(bool value) {
  _internal_set_is_pro(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.TeamStanding.is_pro)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueNodeGroup

// optional string name = 1;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_name() const {
  return _internal_has_name();
}
inline void CMsgDOTALeagueNodeGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeagueNodeGroup::name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueNodeGroup::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.name)
}
inline std::string* CMsgDOTALeagueNodeGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNodeGroup.name)
  return _s;
}
inline const std::string& CMsgDOTALeagueNodeGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeGroup::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeGroup::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueNodeGroup.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueNodeGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueNodeGroup.name)
}

// optional uint32 node_group_id = 2;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_node_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_node_group_id() const {
  return _internal_has_node_group_id();
}
inline void CMsgDOTALeagueNodeGroup::clear_node_group_id() {
  _impl_.node_group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_node_group_id() const {
  return _impl_.node_group_id_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::node_group_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.node_group_id)
  return _internal_node_group_id();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_node_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.node_group_id_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_node_group_id(uint32_t value) {
  _internal_set_node_group_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.node_group_id)
}

// optional uint32 parent_node_group_id = 3;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_parent_node_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_parent_node_group_id() const {
  return _internal_has_parent_node_group_id();
}
inline void CMsgDOTALeagueNodeGroup::clear_parent_node_group_id() {
  _impl_.parent_node_group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_parent_node_group_id() const {
  return _impl_.parent_node_group_id_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::parent_node_group_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.parent_node_group_id)
  return _internal_parent_node_group_id();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_parent_node_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parent_node_group_id_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_parent_node_group_id(uint32_t value) {
  _internal_set_parent_node_group_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.parent_node_group_id)
}

// repeated uint32 incoming_node_group_ids = 4;
inline int CMsgDOTALeagueNodeGroup::_internal_incoming_node_group_ids_size() const {
  return _impl_.incoming_node_group_ids_.size();
}
inline int CMsgDOTALeagueNodeGroup::incoming_node_group_ids_size() const {
  return _internal_incoming_node_group_ids_size();
}
inline void CMsgDOTALeagueNodeGroup::clear_incoming_node_group_ids() {
  _impl_.incoming_node_group_ids_.Clear();
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_incoming_node_group_ids(int index) const {
  return _impl_.incoming_node_group_ids_.Get(index);
}
inline uint32_t CMsgDOTALeagueNodeGroup::incoming_node_group_ids(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.incoming_node_group_ids)
  return _internal_incoming_node_group_ids(index);
}
inline void CMsgDOTALeagueNodeGroup::set_incoming_node_group_ids(int index, uint32_t value) {
  _impl_.incoming_node_group_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.incoming_node_group_ids)
}
inline void CMsgDOTALeagueNodeGroup::_internal_add_incoming_node_group_ids(uint32_t value) {
  _impl_.incoming_node_group_ids_.Add(value);
}
inline void CMsgDOTALeagueNodeGroup::add_incoming_node_group_ids(uint32_t value) {
  _internal_add_incoming_node_group_ids(value);
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueNodeGroup.incoming_node_group_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgDOTALeagueNodeGroup::_internal_incoming_node_group_ids() const {
  return _impl_.incoming_node_group_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgDOTALeagueNodeGroup::incoming_node_group_ids() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueNodeGroup.incoming_node_group_ids)
  return _internal_incoming_node_group_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgDOTALeagueNodeGroup::_internal_mutable_incoming_node_group_ids() {
  return &_impl_.incoming_node_group_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgDOTALeagueNodeGroup::mutable_incoming_node_group_ids() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueNodeGroup.incoming_node_group_ids)
  return _internal_mutable_incoming_node_group_ids();
}

// optional uint32 advancing_node_group_id = 5;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_advancing_node_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_advancing_node_group_id() const {
  return _internal_has_advancing_node_group_id();
}
inline void CMsgDOTALeagueNodeGroup::clear_advancing_node_group_id() {
  _impl_.advancing_node_group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_advancing_node_group_id() const {
  return _impl_.advancing_node_group_id_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::advancing_node_group_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.advancing_node_group_id)
  return _internal_advancing_node_group_id();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_advancing_node_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.advancing_node_group_id_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_advancing_node_group_id(uint32_t value) {
  _internal_set_advancing_node_group_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.advancing_node_group_id)
}

// optional uint32 advancing_team_count = 6;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_advancing_team_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_advancing_team_count() const {
  return _internal_has_advancing_team_count();
}
inline void CMsgDOTALeagueNodeGroup::clear_advancing_team_count() {
  _impl_.advancing_team_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_advancing_team_count() const {
  return _impl_.advancing_team_count_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::advancing_team_count() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.advancing_team_count)
  return _internal_advancing_team_count();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_advancing_team_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.advancing_team_count_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_advancing_team_count(uint32_t value) {
  _internal_set_advancing_team_count(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.advancing_team_count)
}

// optional uint32 team_count = 7;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_team_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_team_count() const {
  return _internal_has_team_count();
}
inline void CMsgDOTALeagueNodeGroup::clear_team_count() {
  _impl_.team_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_team_count() const {
  return _impl_.team_count_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::team_count() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.team_count)
  return _internal_team_count();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_team_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.team_count_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_team_count(uint32_t value) {
  _internal_set_team_count(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.team_count)
}

// optional .ELeagueNodeGroupType node_group_type = 8 [default = INVALID_GROUP_TYPE];
inline bool CMsgDOTALeagueNodeGroup::_internal_has_node_group_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_node_group_type() const {
  return _internal_has_node_group_type();
}
inline void CMsgDOTALeagueNodeGroup::clear_node_group_type() {
  _impl_.node_group_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::ELeagueNodeGroupType CMsgDOTALeagueNodeGroup::_internal_node_group_type() const {
  return static_cast< ::ELeagueNodeGroupType >(_impl_.node_group_type_);
}
inline ::ELeagueNodeGroupType CMsgDOTALeagueNodeGroup::node_group_type() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.node_group_type)
  return _internal_node_group_type();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_node_group_type(::ELeagueNodeGroupType value) {
  assert(::ELeagueNodeGroupType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.node_group_type_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_node_group_type(::ELeagueNodeGroupType value) {
  _internal_set_node_group_type(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.node_group_type)
}

// optional .ELeagueNodeType default_node_type = 9 [default = INVALID_NODE_TYPE];
inline bool CMsgDOTALeagueNodeGroup::_internal_has_default_node_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_default_node_type() const {
  return _internal_has_default_node_type();
}
inline void CMsgDOTALeagueNodeGroup::clear_default_node_type() {
  _impl_.default_node_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::ELeagueNodeType CMsgDOTALeagueNodeGroup::_internal_default_node_type() const {
  return static_cast< ::ELeagueNodeType >(_impl_.default_node_type_);
}
inline ::ELeagueNodeType CMsgDOTALeagueNodeGroup::default_node_type() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.default_node_type)
  return _internal_default_node_type();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_default_node_type(::ELeagueNodeType value) {
  assert(::ELeagueNodeType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.default_node_type_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_default_node_type(::ELeagueNodeType value) {
  _internal_set_default_node_type(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.default_node_type)
}

// optional uint32 round = 10;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_round() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_round() const {
  return _internal_has_round();
}
inline void CMsgDOTALeagueNodeGroup::clear_round() {
  _impl_.round_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_round() const {
  return _impl_.round_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::round() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.round)
  return _internal_round();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_round(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.round_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_round(uint32_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.round)
}

// optional uint32 max_rounds = 11;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_max_rounds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_max_rounds() const {
  return _internal_has_max_rounds();
}
inline void CMsgDOTALeagueNodeGroup::clear_max_rounds() {
  _impl_.max_rounds_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_max_rounds() const {
  return _impl_.max_rounds_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::max_rounds() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.max_rounds)
  return _internal_max_rounds();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_max_rounds(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.max_rounds_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_max_rounds(uint32_t value) {
  _internal_set_max_rounds(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.max_rounds)
}

// optional bool is_tiebreaker = 12;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_is_tiebreaker() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_is_tiebreaker() const {
  return _internal_has_is_tiebreaker();
}
inline void CMsgDOTALeagueNodeGroup::clear_is_tiebreaker() {
  _impl_.is_tiebreaker_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool CMsgDOTALeagueNodeGroup::_internal_is_tiebreaker() const {
  return _impl_.is_tiebreaker_;
}
inline bool CMsgDOTALeagueNodeGroup::is_tiebreaker() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.is_tiebreaker)
  return _internal_is_tiebreaker();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_is_tiebreaker(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.is_tiebreaker_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_is_tiebreaker(bool value) {
  _internal_set_is_tiebreaker(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.is_tiebreaker)
}

// optional bool is_final_group = 13;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_is_final_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_is_final_group() const {
  return _internal_has_is_final_group();
}
inline void CMsgDOTALeagueNodeGroup::clear_is_final_group() {
  _impl_.is_final_group_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool CMsgDOTALeagueNodeGroup::_internal_is_final_group() const {
  return _impl_.is_final_group_;
}
inline bool CMsgDOTALeagueNodeGroup::is_final_group() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.is_final_group)
  return _internal_is_final_group();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_is_final_group(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.is_final_group_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_is_final_group(bool value) {
  _internal_set_is_final_group(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.is_final_group)
}

// optional bool is_completed = 14;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_is_completed() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_is_completed() const {
  return _internal_has_is_completed();
}
inline void CMsgDOTALeagueNodeGroup::clear_is_completed() {
  _impl_.is_completed_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool CMsgDOTALeagueNodeGroup::_internal_is_completed() const {
  return _impl_.is_completed_;
}
inline bool CMsgDOTALeagueNodeGroup::is_completed() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.is_completed)
  return _internal_is_completed();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_is_completed(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.is_completed_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_is_completed(bool value) {
  _internal_set_is_completed(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.is_completed)
}

// optional .ELeaguePhase phase = 18 [default = LEAGUE_PHASE_UNSET];
inline bool CMsgDOTALeagueNodeGroup::_internal_has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_phase() const {
  return _internal_has_phase();
}
inline void CMsgDOTALeagueNodeGroup::clear_phase() {
  _impl_.phase_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::ELeaguePhase CMsgDOTALeagueNodeGroup::_internal_phase() const {
  return static_cast< ::ELeaguePhase >(_impl_.phase_);
}
inline ::ELeaguePhase CMsgDOTALeagueNodeGroup::phase() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.phase)
  return _internal_phase();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_phase(::ELeaguePhase value) {
  assert(::ELeaguePhase_IsValid(value));
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.phase_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_phase(::ELeaguePhase value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.phase)
}

// optional .ELeagueRegion region = 19 [default = LEAGUE_REGION_UNSET];
inline bool CMsgDOTALeagueNodeGroup::_internal_has_region() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_region() const {
  return _internal_has_region();
}
inline void CMsgDOTALeagueNodeGroup::clear_region() {
  _impl_.region_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::ELeagueRegion CMsgDOTALeagueNodeGroup::_internal_region() const {
  return static_cast< ::ELeagueRegion >(_impl_.region_);
}
inline ::ELeagueRegion CMsgDOTALeagueNodeGroup::region() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.region)
  return _internal_region();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_region(::ELeagueRegion value) {
  assert(::ELeagueRegion_IsValid(value));
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.region_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_region(::ELeagueRegion value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.region)
}

// optional uint32 start_time = 20;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_start_time() const {
  return _internal_has_start_time();
}
inline void CMsgDOTALeagueNodeGroup::clear_start_time() {
  _impl_.start_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_start_time() const {
  return _impl_.start_time_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::start_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.start_time)
  return _internal_start_time();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_start_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.start_time_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_start_time(uint32_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.start_time)
}

// optional uint32 end_time = 21;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_end_time() const {
  return _internal_has_end_time();
}
inline void CMsgDOTALeagueNodeGroup::clear_end_time() {
  _impl_.end_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_end_time() const {
  return _impl_.end_time_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::end_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.end_time)
  return _internal_end_time();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_end_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.end_time_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_end_time(uint32_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.end_time)
}

// optional uint32 secondary_advancing_node_group_id = 22;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_secondary_advancing_node_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_secondary_advancing_node_group_id() const {
  return _internal_has_secondary_advancing_node_group_id();
}
inline void CMsgDOTALeagueNodeGroup::clear_secondary_advancing_node_group_id() {
  _impl_.secondary_advancing_node_group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_secondary_advancing_node_group_id() const {
  return _impl_.secondary_advancing_node_group_id_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::secondary_advancing_node_group_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.secondary_advancing_node_group_id)
  return _internal_secondary_advancing_node_group_id();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_secondary_advancing_node_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.secondary_advancing_node_group_id_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_secondary_advancing_node_group_id(uint32_t value) {
  _internal_set_secondary_advancing_node_group_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.secondary_advancing_node_group_id)
}

// optional uint32 secondary_advancing_team_count = 23;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_secondary_advancing_team_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_secondary_advancing_team_count() const {
  return _internal_has_secondary_advancing_team_count();
}
inline void CMsgDOTALeagueNodeGroup::clear_secondary_advancing_team_count() {
  _impl_.secondary_advancing_team_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_secondary_advancing_team_count() const {
  return _impl_.secondary_advancing_team_count_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::secondary_advancing_team_count() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.secondary_advancing_team_count)
  return _internal_secondary_advancing_team_count();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_secondary_advancing_team_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.secondary_advancing_team_count_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_secondary_advancing_team_count(uint32_t value) {
  _internal_set_secondary_advancing_team_count(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.secondary_advancing_team_count)
}

// optional uint32 tertiary_advancing_node_group_id = 24;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_tertiary_advancing_node_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_tertiary_advancing_node_group_id() const {
  return _internal_has_tertiary_advancing_node_group_id();
}
inline void CMsgDOTALeagueNodeGroup::clear_tertiary_advancing_node_group_id() {
  _impl_.tertiary_advancing_node_group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_tertiary_advancing_node_group_id() const {
  return _impl_.tertiary_advancing_node_group_id_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::tertiary_advancing_node_group_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.tertiary_advancing_node_group_id)
  return _internal_tertiary_advancing_node_group_id();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_tertiary_advancing_node_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.tertiary_advancing_node_group_id_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_tertiary_advancing_node_group_id(uint32_t value) {
  _internal_set_tertiary_advancing_node_group_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.tertiary_advancing_node_group_id)
}

// optional uint32 tertiary_advancing_team_count = 25;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_tertiary_advancing_team_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_tertiary_advancing_team_count() const {
  return _internal_has_tertiary_advancing_team_count();
}
inline void CMsgDOTALeagueNodeGroup::clear_tertiary_advancing_team_count() {
  _impl_.tertiary_advancing_team_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_tertiary_advancing_team_count() const {
  return _impl_.tertiary_advancing_team_count_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::tertiary_advancing_team_count() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.tertiary_advancing_team_count)
  return _internal_tertiary_advancing_team_count();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_tertiary_advancing_team_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.tertiary_advancing_team_count_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_tertiary_advancing_team_count(uint32_t value) {
  _internal_set_tertiary_advancing_team_count(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.tertiary_advancing_team_count)
}

// optional uint32 elimination_dpc_points = 26;
inline bool CMsgDOTALeagueNodeGroup::_internal_has_elimination_dpc_points() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeGroup::has_elimination_dpc_points() const {
  return _internal_has_elimination_dpc_points();
}
inline void CMsgDOTALeagueNodeGroup::clear_elimination_dpc_points() {
  _impl_.elimination_dpc_points_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline uint32_t CMsgDOTALeagueNodeGroup::_internal_elimination_dpc_points() const {
  return _impl_.elimination_dpc_points_;
}
inline uint32_t CMsgDOTALeagueNodeGroup::elimination_dpc_points() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.elimination_dpc_points)
  return _internal_elimination_dpc_points();
}
inline void CMsgDOTALeagueNodeGroup::_internal_set_elimination_dpc_points(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.elimination_dpc_points_ = value;
}
inline void CMsgDOTALeagueNodeGroup::set_elimination_dpc_points(uint32_t value) {
  _internal_set_elimination_dpc_points(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeGroup.elimination_dpc_points)
}

// repeated .CMsgDOTALeagueNodeGroup.TeamStanding team_standings = 15;
inline int CMsgDOTALeagueNodeGroup::_internal_team_standings_size() const {
  return _impl_.team_standings_.size();
}
inline int CMsgDOTALeagueNodeGroup::team_standings_size() const {
  return _internal_team_standings_size();
}
inline void CMsgDOTALeagueNodeGroup::clear_team_standings() {
  _impl_.team_standings_.Clear();
}
inline ::CMsgDOTALeagueNodeGroup_TeamStanding* CMsgDOTALeagueNodeGroup::mutable_team_standings(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNodeGroup.team_standings)
  return _impl_.team_standings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup_TeamStanding >*
CMsgDOTALeagueNodeGroup::mutable_team_standings() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueNodeGroup.team_standings)
  return &_impl_.team_standings_;
}
inline const ::CMsgDOTALeagueNodeGroup_TeamStanding& CMsgDOTALeagueNodeGroup::_internal_team_standings(int index) const {
  return _impl_.team_standings_.Get(index);
}
inline const ::CMsgDOTALeagueNodeGroup_TeamStanding& CMsgDOTALeagueNodeGroup::team_standings(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.team_standings)
  return _internal_team_standings(index);
}
inline ::CMsgDOTALeagueNodeGroup_TeamStanding* CMsgDOTALeagueNodeGroup::_internal_add_team_standings() {
  return _impl_.team_standings_.Add();
}
inline ::CMsgDOTALeagueNodeGroup_TeamStanding* CMsgDOTALeagueNodeGroup::add_team_standings() {
  ::CMsgDOTALeagueNodeGroup_TeamStanding* _add = _internal_add_team_standings();
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueNodeGroup.team_standings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup_TeamStanding >&
CMsgDOTALeagueNodeGroup::team_standings() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueNodeGroup.team_standings)
  return _impl_.team_standings_;
}

// repeated .CMsgDOTALeagueNode nodes = 16;
inline int CMsgDOTALeagueNodeGroup::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int CMsgDOTALeagueNodeGroup::nodes_size() const {
  return _internal_nodes_size();
}
inline void CMsgDOTALeagueNodeGroup::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::CMsgDOTALeagueNode* CMsgDOTALeagueNodeGroup::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNodeGroup.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode >*
CMsgDOTALeagueNodeGroup::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueNodeGroup.nodes)
  return &_impl_.nodes_;
}
inline const ::CMsgDOTALeagueNode& CMsgDOTALeagueNodeGroup::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::CMsgDOTALeagueNode& CMsgDOTALeagueNodeGroup::nodes(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.nodes)
  return _internal_nodes(index);
}
inline ::CMsgDOTALeagueNode* CMsgDOTALeagueNodeGroup::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::CMsgDOTALeagueNode* CMsgDOTALeagueNodeGroup::add_nodes() {
  ::CMsgDOTALeagueNode* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueNodeGroup.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNode >&
CMsgDOTALeagueNodeGroup::nodes() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueNodeGroup.nodes)
  return _impl_.nodes_;
}

// repeated .CMsgDOTALeagueNodeGroup node_groups = 17;
inline int CMsgDOTALeagueNodeGroup::_internal_node_groups_size() const {
  return _impl_.node_groups_.size();
}
inline int CMsgDOTALeagueNodeGroup::node_groups_size() const {
  return _internal_node_groups_size();
}
inline void CMsgDOTALeagueNodeGroup::clear_node_groups() {
  _impl_.node_groups_.Clear();
}
inline ::CMsgDOTALeagueNodeGroup* CMsgDOTALeagueNodeGroup::mutable_node_groups(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNodeGroup.node_groups)
  return _impl_.node_groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup >*
CMsgDOTALeagueNodeGroup::mutable_node_groups() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueNodeGroup.node_groups)
  return &_impl_.node_groups_;
}
inline const ::CMsgDOTALeagueNodeGroup& CMsgDOTALeagueNodeGroup::_internal_node_groups(int index) const {
  return _impl_.node_groups_.Get(index);
}
inline const ::CMsgDOTALeagueNodeGroup& CMsgDOTALeagueNodeGroup::node_groups(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeGroup.node_groups)
  return _internal_node_groups(index);
}
inline ::CMsgDOTALeagueNodeGroup* CMsgDOTALeagueNodeGroup::_internal_add_node_groups() {
  return _impl_.node_groups_.Add();
}
inline ::CMsgDOTALeagueNodeGroup* CMsgDOTALeagueNodeGroup::add_node_groups() {
  ::CMsgDOTALeagueNodeGroup* _add = _internal_add_node_groups();
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueNodeGroup.node_groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup >&
CMsgDOTALeagueNodeGroup::node_groups() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueNodeGroup.node_groups)
  return _impl_.node_groups_;
}

// -------------------------------------------------------------------

// CMsgDOTALeague_Info

// optional uint32 league_id = 1;
inline bool CMsgDOTALeague_Info::_internal_has_league_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_league_id() const {
  return _internal_has_league_id();
}
inline void CMsgDOTALeague_Info::clear_league_id() {
  _impl_.league_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTALeague_Info::_internal_league_id() const {
  return _impl_.league_id_;
}
inline uint32_t CMsgDOTALeague_Info::league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.league_id)
  return _internal_league_id();
}
inline void CMsgDOTALeague_Info::_internal_set_league_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.league_id_ = value;
}
inline void CMsgDOTALeague_Info::set_league_id(uint32_t value) {
  _internal_set_league_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.league_id)
}

// optional string name = 2;
inline bool CMsgDOTALeague_Info::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_name() const {
  return _internal_has_name();
}
inline void CMsgDOTALeague_Info::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeague_Info::name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeague_Info::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.name)
}
inline std::string* CMsgDOTALeague_Info::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.Info.name)
  return _s;
}
inline const std::string& CMsgDOTALeague_Info::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDOTALeague_Info::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Info::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Info::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeague.Info.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeague_Info::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeague.Info.name)
}

// optional .ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
inline bool CMsgDOTALeague_Info::_internal_has_tier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_tier() const {
  return _internal_has_tier();
}
inline void CMsgDOTALeague_Info::clear_tier() {
  _impl_.tier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::ELeagueTier CMsgDOTALeague_Info::_internal_tier() const {
  return static_cast< ::ELeagueTier >(_impl_.tier_);
}
inline ::ELeagueTier CMsgDOTALeague_Info::tier() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.tier)
  return _internal_tier();
}
inline void CMsgDOTALeague_Info::_internal_set_tier(::ELeagueTier value) {
  assert(::ELeagueTier_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tier_ = value;
}
inline void CMsgDOTALeague_Info::set_tier(::ELeagueTier value) {
  _internal_set_tier(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.tier)
}

// optional .ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
inline bool CMsgDOTALeague_Info::_internal_has_region() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_region() const {
  return _internal_has_region();
}
inline void CMsgDOTALeague_Info::clear_region() {
  _impl_.region_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::ELeagueRegion CMsgDOTALeague_Info::_internal_region() const {
  return static_cast< ::ELeagueRegion >(_impl_.region_);
}
inline ::ELeagueRegion CMsgDOTALeague_Info::region() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.region)
  return _internal_region();
}
inline void CMsgDOTALeague_Info::_internal_set_region(::ELeagueRegion value) {
  assert(::ELeagueRegion_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.region_ = value;
}
inline void CMsgDOTALeague_Info::set_region(::ELeagueRegion value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.region)
}

// optional string url = 5;
inline bool CMsgDOTALeague_Info::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_url() const {
  return _internal_has_url();
}
inline void CMsgDOTALeague_Info::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTALeague_Info::url() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeague_Info::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.url)
}
inline std::string* CMsgDOTALeague_Info::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.Info.url)
  return _s;
}
inline const std::string& CMsgDOTALeague_Info::_internal_url() const {
  return _impl_.url_.Get();
}
inline void CMsgDOTALeague_Info::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Info::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Info::release_url() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeague.Info.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeague_Info::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeague.Info.url)
}

// optional string description = 6;
inline bool CMsgDOTALeague_Info::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_description() const {
  return _internal_has_description();
}
inline void CMsgDOTALeague_Info::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgDOTALeague_Info::description() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeague_Info::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.description)
}
inline std::string* CMsgDOTALeague_Info::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.Info.description)
  return _s;
}
inline const std::string& CMsgDOTALeague_Info::_internal_description() const {
  return _impl_.description_.Get();
}
inline void CMsgDOTALeague_Info::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Info::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Info::release_description() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeague.Info.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeague_Info::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeague.Info.description)
}

// optional string notes = 7;
inline bool CMsgDOTALeague_Info::_internal_has_notes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_notes() const {
  return _internal_has_notes();
}
inline void CMsgDOTALeague_Info::clear_notes() {
  _impl_.notes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CMsgDOTALeague_Info::notes() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeague_Info::set_notes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.notes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.notes)
}
inline std::string* CMsgDOTALeague_Info::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.Info.notes)
  return _s;
}
inline const std::string& CMsgDOTALeague_Info::_internal_notes() const {
  return _impl_.notes_.Get();
}
inline void CMsgDOTALeague_Info::_internal_set_notes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.notes_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Info::_internal_mutable_notes() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.notes_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Info::release_notes() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeague.Info.notes)
  if (!_internal_has_notes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.notes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notes_.IsDefault()) {
    _impl_.notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeague_Info::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.notes_.SetAllocated(notes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notes_.IsDefault()) {
    _impl_.notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeague.Info.notes)
}

// optional uint32 start_timestamp = 8;
inline bool CMsgDOTALeague_Info::_internal_has_start_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_start_timestamp() const {
  return _internal_has_start_timestamp();
}
inline void CMsgDOTALeague_Info::clear_start_timestamp() {
  _impl_.start_timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CMsgDOTALeague_Info::_internal_start_timestamp() const {
  return _impl_.start_timestamp_;
}
inline uint32_t CMsgDOTALeague_Info::start_timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.start_timestamp)
  return _internal_start_timestamp();
}
inline void CMsgDOTALeague_Info::_internal_set_start_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.start_timestamp_ = value;
}
inline void CMsgDOTALeague_Info::set_start_timestamp(uint32_t value) {
  _internal_set_start_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.start_timestamp)
}

// optional uint32 end_timestamp = 9;
inline bool CMsgDOTALeague_Info::_internal_has_end_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_end_timestamp() const {
  return _internal_has_end_timestamp();
}
inline void CMsgDOTALeague_Info::clear_end_timestamp() {
  _impl_.end_timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CMsgDOTALeague_Info::_internal_end_timestamp() const {
  return _impl_.end_timestamp_;
}
inline uint32_t CMsgDOTALeague_Info::end_timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.end_timestamp)
  return _internal_end_timestamp();
}
inline void CMsgDOTALeague_Info::_internal_set_end_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.end_timestamp_ = value;
}
inline void CMsgDOTALeague_Info::set_end_timestamp(uint32_t value) {
  _internal_set_end_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.end_timestamp)
}

// optional uint32 pro_circuit_points = 10;
inline bool CMsgDOTALeague_Info::_internal_has_pro_circuit_points() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_pro_circuit_points() const {
  return _internal_has_pro_circuit_points();
}
inline void CMsgDOTALeague_Info::clear_pro_circuit_points() {
  _impl_.pro_circuit_points_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t CMsgDOTALeague_Info::_internal_pro_circuit_points() const {
  return _impl_.pro_circuit_points_;
}
inline uint32_t CMsgDOTALeague_Info::pro_circuit_points() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.pro_circuit_points)
  return _internal_pro_circuit_points();
}
inline void CMsgDOTALeague_Info::_internal_set_pro_circuit_points(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.pro_circuit_points_ = value;
}
inline void CMsgDOTALeague_Info::set_pro_circuit_points(uint32_t value) {
  _internal_set_pro_circuit_points(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.pro_circuit_points)
}

// optional uint32 image_bits = 11;
inline bool CMsgDOTALeague_Info::_internal_has_image_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_image_bits() const {
  return _internal_has_image_bits();
}
inline void CMsgDOTALeague_Info::clear_image_bits() {
  _impl_.image_bits_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t CMsgDOTALeague_Info::_internal_image_bits() const {
  return _impl_.image_bits_;
}
inline uint32_t CMsgDOTALeague_Info::image_bits() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.image_bits)
  return _internal_image_bits();
}
inline void CMsgDOTALeague_Info::_internal_set_image_bits(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.image_bits_ = value;
}
inline void CMsgDOTALeague_Info::set_image_bits(uint32_t value) {
  _internal_set_image_bits(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.image_bits)
}

// optional .ELeagueStatus status = 12 [default = LEAGUE_STATUS_UNSET];
inline bool CMsgDOTALeague_Info::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_status() const {
  return _internal_has_status();
}
inline void CMsgDOTALeague_Info::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::ELeagueStatus CMsgDOTALeague_Info::_internal_status() const {
  return static_cast< ::ELeagueStatus >(_impl_.status_);
}
inline ::ELeagueStatus CMsgDOTALeague_Info::status() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.status)
  return _internal_status();
}
inline void CMsgDOTALeague_Info::_internal_set_status(::ELeagueStatus value) {
  assert(::ELeagueStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.status_ = value;
}
inline void CMsgDOTALeague_Info::set_status(::ELeagueStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.status)
}

// optional uint32 most_recent_activity = 13;
inline bool CMsgDOTALeague_Info::_internal_has_most_recent_activity() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_most_recent_activity() const {
  return _internal_has_most_recent_activity();
}
inline void CMsgDOTALeague_Info::clear_most_recent_activity() {
  _impl_.most_recent_activity_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint32_t CMsgDOTALeague_Info::_internal_most_recent_activity() const {
  return _impl_.most_recent_activity_;
}
inline uint32_t CMsgDOTALeague_Info::most_recent_activity() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.most_recent_activity)
  return _internal_most_recent_activity();
}
inline void CMsgDOTALeague_Info::_internal_set_most_recent_activity(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.most_recent_activity_ = value;
}
inline void CMsgDOTALeague_Info::set_most_recent_activity(uint32_t value) {
  _internal_set_most_recent_activity(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.most_recent_activity)
}

// optional uint32 registration_period = 14;
inline bool CMsgDOTALeague_Info::_internal_has_registration_period() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Info::has_registration_period() const {
  return _internal_has_registration_period();
}
inline void CMsgDOTALeague_Info::clear_registration_period() {
  _impl_.registration_period_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t CMsgDOTALeague_Info::_internal_registration_period() const {
  return _impl_.registration_period_;
}
inline uint32_t CMsgDOTALeague_Info::registration_period() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Info.registration_period)
  return _internal_registration_period();
}
inline void CMsgDOTALeague_Info::_internal_set_registration_period(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.registration_period_ = value;
}
inline void CMsgDOTALeague_Info::set_registration_period(uint32_t value) {
  _internal_set_registration_period(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Info.registration_period)
}

// -------------------------------------------------------------------

// CMsgDOTALeague_Admin

// optional uint32 account_id = 1;
inline bool CMsgDOTALeague_Admin::_internal_has_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Admin::has_account_id() const {
  return _internal_has_account_id();
}
inline void CMsgDOTALeague_Admin::clear_account_id() {
  _impl_.account_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTALeague_Admin::_internal_account_id() const {
  return _impl_.account_id_;
}
inline uint32_t CMsgDOTALeague_Admin::account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Admin.account_id)
  return _internal_account_id();
}
inline void CMsgDOTALeague_Admin::_internal_set_account_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.account_id_ = value;
}
inline void CMsgDOTALeague_Admin::set_account_id(uint32_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Admin.account_id)
}

// optional bool is_primary = 2;
inline bool CMsgDOTALeague_Admin::_internal_has_is_primary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Admin::has_is_primary() const {
  return _internal_has_is_primary();
}
inline void CMsgDOTALeague_Admin::clear_is_primary() {
  _impl_.is_primary_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CMsgDOTALeague_Admin::_internal_is_primary() const {
  return _impl_.is_primary_;
}
inline bool CMsgDOTALeague_Admin::is_primary() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Admin.is_primary)
  return _internal_is_primary();
}
inline void CMsgDOTALeague_Admin::_internal_set_is_primary(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_primary_ = value;
}
inline void CMsgDOTALeague_Admin::set_is_primary(bool value) {
  _internal_set_is_primary(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Admin.is_primary)
}

// optional string email_address = 3;
inline bool CMsgDOTALeague_Admin::_internal_has_email_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Admin::has_email_address() const {
  return _internal_has_email_address();
}
inline void CMsgDOTALeague_Admin::clear_email_address() {
  _impl_.email_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeague_Admin::email_address() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Admin.email_address)
  return _internal_email_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeague_Admin::set_email_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.email_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Admin.email_address)
}
inline std::string* CMsgDOTALeague_Admin::mutable_email_address() {
  std::string* _s = _internal_mutable_email_address();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.Admin.email_address)
  return _s;
}
inline const std::string& CMsgDOTALeague_Admin::_internal_email_address() const {
  return _impl_.email_address_.Get();
}
inline void CMsgDOTALeague_Admin::_internal_set_email_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.email_address_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Admin::_internal_mutable_email_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.email_address_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Admin::release_email_address() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeague.Admin.email_address)
  if (!_internal_has_email_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.email_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_address_.IsDefault()) {
    _impl_.email_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeague_Admin::set_allocated_email_address(std::string* email_address) {
  if (email_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.email_address_.SetAllocated(email_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_address_.IsDefault()) {
    _impl_.email_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeague.Admin.email_address)
}

// -------------------------------------------------------------------

// CMsgDOTALeague_PrizePoolItem

// optional uint32 item_def = 1;
inline bool CMsgDOTALeague_PrizePoolItem::_internal_has_item_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeague_PrizePoolItem::has_item_def() const {
  return _internal_has_item_def();
}
inline void CMsgDOTALeague_PrizePoolItem::clear_item_def() {
  _impl_.item_def_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTALeague_PrizePoolItem::_internal_item_def() const {
  return _impl_.item_def_;
}
inline uint32_t CMsgDOTALeague_PrizePoolItem::item_def() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.PrizePoolItem.item_def)
  return _internal_item_def();
}
inline void CMsgDOTALeague_PrizePoolItem::_internal_set_item_def(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.item_def_ = value;
}
inline void CMsgDOTALeague_PrizePoolItem::set_item_def(uint32_t value) {
  _internal_set_item_def(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.PrizePoolItem.item_def)
}

// optional uint32 sales_stop_timestamp = 2;
inline bool CMsgDOTALeague_PrizePoolItem::_internal_has_sales_stop_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeague_PrizePoolItem::has_sales_stop_timestamp() const {
  return _internal_has_sales_stop_timestamp();
}
inline void CMsgDOTALeague_PrizePoolItem::clear_sales_stop_timestamp() {
  _impl_.sales_stop_timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTALeague_PrizePoolItem::_internal_sales_stop_timestamp() const {
  return _impl_.sales_stop_timestamp_;
}
inline uint32_t CMsgDOTALeague_PrizePoolItem::sales_stop_timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.PrizePoolItem.sales_stop_timestamp)
  return _internal_sales_stop_timestamp();
}
inline void CMsgDOTALeague_PrizePoolItem::_internal_set_sales_stop_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sales_stop_timestamp_ = value;
}
inline void CMsgDOTALeague_PrizePoolItem::set_sales_stop_timestamp(uint32_t value) {
  _internal_set_sales_stop_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.PrizePoolItem.sales_stop_timestamp)
}

// optional uint32 revenue_pct = 3;
inline bool CMsgDOTALeague_PrizePoolItem::_internal_has_revenue_pct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeague_PrizePoolItem::has_revenue_pct() const {
  return _internal_has_revenue_pct();
}
inline void CMsgDOTALeague_PrizePoolItem::clear_revenue_pct() {
  _impl_.revenue_pct_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTALeague_PrizePoolItem::_internal_revenue_pct() const {
  return _impl_.revenue_pct_;
}
inline uint32_t CMsgDOTALeague_PrizePoolItem::revenue_pct() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.PrizePoolItem.revenue_pct)
  return _internal_revenue_pct();
}
inline void CMsgDOTALeague_PrizePoolItem::_internal_set_revenue_pct(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.revenue_pct_ = value;
}
inline void CMsgDOTALeague_PrizePoolItem::set_revenue_pct(uint32_t value) {
  _internal_set_revenue_pct(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.PrizePoolItem.revenue_pct)
}

// optional uint32 revenue_cents_per_sale = 4;
inline bool CMsgDOTALeague_PrizePoolItem::_internal_has_revenue_cents_per_sale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTALeague_PrizePoolItem::has_revenue_cents_per_sale() const {
  return _internal_has_revenue_cents_per_sale();
}
inline void CMsgDOTALeague_PrizePoolItem::clear_revenue_cents_per_sale() {
  _impl_.revenue_cents_per_sale_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTALeague_PrizePoolItem::_internal_revenue_cents_per_sale() const {
  return _impl_.revenue_cents_per_sale_;
}
inline uint32_t CMsgDOTALeague_PrizePoolItem::revenue_cents_per_sale() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.PrizePoolItem.revenue_cents_per_sale)
  return _internal_revenue_cents_per_sale();
}
inline void CMsgDOTALeague_PrizePoolItem::_internal_set_revenue_cents_per_sale(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.revenue_cents_per_sale_ = value;
}
inline void CMsgDOTALeague_PrizePoolItem::set_revenue_cents_per_sale(uint32_t value) {
  _internal_set_revenue_cents_per_sale(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.PrizePoolItem.revenue_cents_per_sale)
}

// -------------------------------------------------------------------

// CMsgDOTALeague_PrizePool

// optional uint32 base_prize_pool = 1;
inline bool CMsgDOTALeague_PrizePool::_internal_has_base_prize_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeague_PrizePool::has_base_prize_pool() const {
  return _internal_has_base_prize_pool();
}
inline void CMsgDOTALeague_PrizePool::clear_base_prize_pool() {
  _impl_.base_prize_pool_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTALeague_PrizePool::_internal_base_prize_pool() const {
  return _impl_.base_prize_pool_;
}
inline uint32_t CMsgDOTALeague_PrizePool::base_prize_pool() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.PrizePool.base_prize_pool)
  return _internal_base_prize_pool();
}
inline void CMsgDOTALeague_PrizePool::_internal_set_base_prize_pool(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.base_prize_pool_ = value;
}
inline void CMsgDOTALeague_PrizePool::set_base_prize_pool(uint32_t value) {
  _internal_set_base_prize_pool(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.PrizePool.base_prize_pool)
}

// optional uint32 total_prize_pool = 2;
inline bool CMsgDOTALeague_PrizePool::_internal_has_total_prize_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeague_PrizePool::has_total_prize_pool() const {
  return _internal_has_total_prize_pool();
}
inline void CMsgDOTALeague_PrizePool::clear_total_prize_pool() {
  _impl_.total_prize_pool_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTALeague_PrizePool::_internal_total_prize_pool() const {
  return _impl_.total_prize_pool_;
}
inline uint32_t CMsgDOTALeague_PrizePool::total_prize_pool() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.PrizePool.total_prize_pool)
  return _internal_total_prize_pool();
}
inline void CMsgDOTALeague_PrizePool::_internal_set_total_prize_pool(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.total_prize_pool_ = value;
}
inline void CMsgDOTALeague_PrizePool::set_total_prize_pool(uint32_t value) {
  _internal_set_total_prize_pool(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.PrizePool.total_prize_pool)
}

// repeated uint32 prize_split_pct_x100 = 3;
inline int CMsgDOTALeague_PrizePool::_internal_prize_split_pct_x100_size() const {
  return _impl_.prize_split_pct_x100_.size();
}
inline int CMsgDOTALeague_PrizePool::prize_split_pct_x100_size() const {
  return _internal_prize_split_pct_x100_size();
}
inline void CMsgDOTALeague_PrizePool::clear_prize_split_pct_x100() {
  _impl_.prize_split_pct_x100_.Clear();
}
inline uint32_t CMsgDOTALeague_PrizePool::_internal_prize_split_pct_x100(int index) const {
  return _impl_.prize_split_pct_x100_.Get(index);
}
inline uint32_t CMsgDOTALeague_PrizePool::prize_split_pct_x100(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.PrizePool.prize_split_pct_x100)
  return _internal_prize_split_pct_x100(index);
}
inline void CMsgDOTALeague_PrizePool::set_prize_split_pct_x100(int index, uint32_t value) {
  _impl_.prize_split_pct_x100_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.PrizePool.prize_split_pct_x100)
}
inline void CMsgDOTALeague_PrizePool::_internal_add_prize_split_pct_x100(uint32_t value) {
  _impl_.prize_split_pct_x100_.Add(value);
}
inline void CMsgDOTALeague_PrizePool::add_prize_split_pct_x100(uint32_t value) {
  _internal_add_prize_split_pct_x100(value);
  // @@protoc_insertion_point(field_add:CMsgDOTALeague.PrizePool.prize_split_pct_x100)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgDOTALeague_PrizePool::_internal_prize_split_pct_x100() const {
  return _impl_.prize_split_pct_x100_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgDOTALeague_PrizePool::prize_split_pct_x100() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeague.PrizePool.prize_split_pct_x100)
  return _internal_prize_split_pct_x100();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgDOTALeague_PrizePool::_internal_mutable_prize_split_pct_x100() {
  return &_impl_.prize_split_pct_x100_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgDOTALeague_PrizePool::mutable_prize_split_pct_x100() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeague.PrizePool.prize_split_pct_x100)
  return _internal_mutable_prize_split_pct_x100();
}

// repeated .CMsgDOTALeague.PrizePoolItem prize_pool_items = 4;
inline int CMsgDOTALeague_PrizePool::_internal_prize_pool_items_size() const {
  return _impl_.prize_pool_items_.size();
}
inline int CMsgDOTALeague_PrizePool::prize_pool_items_size() const {
  return _internal_prize_pool_items_size();
}
inline void CMsgDOTALeague_PrizePool::clear_prize_pool_items() {
  _impl_.prize_pool_items_.Clear();
}
inline ::CMsgDOTALeague_PrizePoolItem* CMsgDOTALeague_PrizePool::mutable_prize_pool_items(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.PrizePool.prize_pool_items)
  return _impl_.prize_pool_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_PrizePoolItem >*
CMsgDOTALeague_PrizePool::mutable_prize_pool_items() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeague.PrizePool.prize_pool_items)
  return &_impl_.prize_pool_items_;
}
inline const ::CMsgDOTALeague_PrizePoolItem& CMsgDOTALeague_PrizePool::_internal_prize_pool_items(int index) const {
  return _impl_.prize_pool_items_.Get(index);
}
inline const ::CMsgDOTALeague_PrizePoolItem& CMsgDOTALeague_PrizePool::prize_pool_items(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.PrizePool.prize_pool_items)
  return _internal_prize_pool_items(index);
}
inline ::CMsgDOTALeague_PrizePoolItem* CMsgDOTALeague_PrizePool::_internal_add_prize_pool_items() {
  return _impl_.prize_pool_items_.Add();
}
inline ::CMsgDOTALeague_PrizePoolItem* CMsgDOTALeague_PrizePool::add_prize_pool_items() {
  ::CMsgDOTALeague_PrizePoolItem* _add = _internal_add_prize_pool_items();
  // @@protoc_insertion_point(field_add:CMsgDOTALeague.PrizePool.prize_pool_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_PrizePoolItem >&
CMsgDOTALeague_PrizePool::prize_pool_items() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeague.PrizePool.prize_pool_items)
  return _impl_.prize_pool_items_;
}

// -------------------------------------------------------------------

// CMsgDOTALeague_Stream

// optional uint32 stream_id = 1;
inline bool CMsgDOTALeague_Stream::_internal_has_stream_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Stream::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void CMsgDOTALeague_Stream::clear_stream_id() {
  _impl_.stream_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTALeague_Stream::_internal_stream_id() const {
  return _impl_.stream_id_;
}
inline uint32_t CMsgDOTALeague_Stream::stream_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Stream.stream_id)
  return _internal_stream_id();
}
inline void CMsgDOTALeague_Stream::_internal_set_stream_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stream_id_ = value;
}
inline void CMsgDOTALeague_Stream::set_stream_id(uint32_t value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Stream.stream_id)
}

// optional uint32 language = 2;
inline bool CMsgDOTALeague_Stream::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Stream::has_language() const {
  return _internal_has_language();
}
inline void CMsgDOTALeague_Stream::clear_language() {
  _impl_.language_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTALeague_Stream::_internal_language() const {
  return _impl_.language_;
}
inline uint32_t CMsgDOTALeague_Stream::language() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Stream.language)
  return _internal_language();
}
inline void CMsgDOTALeague_Stream::_internal_set_language(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.language_ = value;
}
inline void CMsgDOTALeague_Stream::set_language(uint32_t value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Stream.language)
}

// optional string name = 3;
inline bool CMsgDOTALeague_Stream::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Stream::has_name() const {
  return _internal_has_name();
}
inline void CMsgDOTALeague_Stream::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeague_Stream::name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Stream.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeague_Stream::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Stream.name)
}
inline std::string* CMsgDOTALeague_Stream::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.Stream.name)
  return _s;
}
inline const std::string& CMsgDOTALeague_Stream::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDOTALeague_Stream::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Stream::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Stream::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeague.Stream.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeague_Stream::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeague.Stream.name)
}

// optional .ELeagueBroadcastProvider broadcast_provider = 4 [default = LEAGUE_BROADCAST_UNKNOWN];
inline bool CMsgDOTALeague_Stream::_internal_has_broadcast_provider() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Stream::has_broadcast_provider() const {
  return _internal_has_broadcast_provider();
}
inline void CMsgDOTALeague_Stream::clear_broadcast_provider() {
  _impl_.broadcast_provider_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::ELeagueBroadcastProvider CMsgDOTALeague_Stream::_internal_broadcast_provider() const {
  return static_cast< ::ELeagueBroadcastProvider >(_impl_.broadcast_provider_);
}
inline ::ELeagueBroadcastProvider CMsgDOTALeague_Stream::broadcast_provider() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Stream.broadcast_provider)
  return _internal_broadcast_provider();
}
inline void CMsgDOTALeague_Stream::_internal_set_broadcast_provider(::ELeagueBroadcastProvider value) {
  assert(::ELeagueBroadcastProvider_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.broadcast_provider_ = value;
}
inline void CMsgDOTALeague_Stream::set_broadcast_provider(::ELeagueBroadcastProvider value) {
  _internal_set_broadcast_provider(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Stream.broadcast_provider)
}

// optional string stream_url = 5;
inline bool CMsgDOTALeague_Stream::_internal_has_stream_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Stream::has_stream_url() const {
  return _internal_has_stream_url();
}
inline void CMsgDOTALeague_Stream::clear_stream_url() {
  _impl_.stream_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTALeague_Stream::stream_url() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Stream.stream_url)
  return _internal_stream_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeague_Stream::set_stream_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.stream_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Stream.stream_url)
}
inline std::string* CMsgDOTALeague_Stream::mutable_stream_url() {
  std::string* _s = _internal_mutable_stream_url();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.Stream.stream_url)
  return _s;
}
inline const std::string& CMsgDOTALeague_Stream::_internal_stream_url() const {
  return _impl_.stream_url_.Get();
}
inline void CMsgDOTALeague_Stream::_internal_set_stream_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stream_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Stream::_internal_mutable_stream_url() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.stream_url_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Stream::release_stream_url() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeague.Stream.stream_url)
  if (!_internal_has_stream_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.stream_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_url_.IsDefault()) {
    _impl_.stream_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeague_Stream::set_allocated_stream_url(std::string* stream_url) {
  if (stream_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_url_.SetAllocated(stream_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_url_.IsDefault()) {
    _impl_.stream_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeague.Stream.stream_url)
}

// optional string vod_url = 6;
inline bool CMsgDOTALeague_Stream::_internal_has_vod_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Stream::has_vod_url() const {
  return _internal_has_vod_url();
}
inline void CMsgDOTALeague_Stream::clear_vod_url() {
  _impl_.vod_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgDOTALeague_Stream::vod_url() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Stream.vod_url)
  return _internal_vod_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeague_Stream::set_vod_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.vod_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Stream.vod_url)
}
inline std::string* CMsgDOTALeague_Stream::mutable_vod_url() {
  std::string* _s = _internal_mutable_vod_url();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.Stream.vod_url)
  return _s;
}
inline const std::string& CMsgDOTALeague_Stream::_internal_vod_url() const {
  return _impl_.vod_url_.Get();
}
inline void CMsgDOTALeague_Stream::_internal_set_vod_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.vod_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Stream::_internal_mutable_vod_url() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.vod_url_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Stream::release_vod_url() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeague.Stream.vod_url)
  if (!_internal_has_vod_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.vod_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vod_url_.IsDefault()) {
    _impl_.vod_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeague_Stream::set_allocated_vod_url(std::string* vod_url) {
  if (vod_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.vod_url_.SetAllocated(vod_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vod_url_.IsDefault()) {
    _impl_.vod_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeague.Stream.vod_url)
}

// -------------------------------------------------------------------

// CMsgDOTALeague_SeriesInfo

// optional uint32 series_id = 1;
inline bool CMsgDOTALeague_SeriesInfo::_internal_has_series_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeague_SeriesInfo::has_series_id() const {
  return _internal_has_series_id();
}
inline void CMsgDOTALeague_SeriesInfo::clear_series_id() {
  _impl_.series_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTALeague_SeriesInfo::_internal_series_id() const {
  return _impl_.series_id_;
}
inline uint32_t CMsgDOTALeague_SeriesInfo::series_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.SeriesInfo.series_id)
  return _internal_series_id();
}
inline void CMsgDOTALeague_SeriesInfo::_internal_set_series_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.series_id_ = value;
}
inline void CMsgDOTALeague_SeriesInfo::set_series_id(uint32_t value) {
  _internal_set_series_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.SeriesInfo.series_id)
}

// optional uint32 series_type = 2;
inline bool CMsgDOTALeague_SeriesInfo::_internal_has_series_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeague_SeriesInfo::has_series_type() const {
  return _internal_has_series_type();
}
inline void CMsgDOTALeague_SeriesInfo::clear_series_type() {
  _impl_.series_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTALeague_SeriesInfo::_internal_series_type() const {
  return _impl_.series_type_;
}
inline uint32_t CMsgDOTALeague_SeriesInfo::series_type() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.SeriesInfo.series_type)
  return _internal_series_type();
}
inline void CMsgDOTALeague_SeriesInfo::_internal_set_series_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.series_type_ = value;
}
inline void CMsgDOTALeague_SeriesInfo::set_series_type(uint32_t value) {
  _internal_set_series_type(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.SeriesInfo.series_type)
}

// optional uint32 start_time = 3;
inline bool CMsgDOTALeague_SeriesInfo::_internal_has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeague_SeriesInfo::has_start_time() const {
  return _internal_has_start_time();
}
inline void CMsgDOTALeague_SeriesInfo::clear_start_time() {
  _impl_.start_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTALeague_SeriesInfo::_internal_start_time() const {
  return _impl_.start_time_;
}
inline uint32_t CMsgDOTALeague_SeriesInfo::start_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.SeriesInfo.start_time)
  return _internal_start_time();
}
inline void CMsgDOTALeague_SeriesInfo::_internal_set_start_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_time_ = value;
}
inline void CMsgDOTALeague_SeriesInfo::set_start_time(uint32_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.SeriesInfo.start_time)
}

// repeated uint64 match_ids = 4;
inline int CMsgDOTALeague_SeriesInfo::_internal_match_ids_size() const {
  return _impl_.match_ids_.size();
}
inline int CMsgDOTALeague_SeriesInfo::match_ids_size() const {
  return _internal_match_ids_size();
}
inline void CMsgDOTALeague_SeriesInfo::clear_match_ids() {
  _impl_.match_ids_.Clear();
}
inline uint64_t CMsgDOTALeague_SeriesInfo::_internal_match_ids(int index) const {
  return _impl_.match_ids_.Get(index);
}
inline uint64_t CMsgDOTALeague_SeriesInfo::match_ids(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.SeriesInfo.match_ids)
  return _internal_match_ids(index);
}
inline void CMsgDOTALeague_SeriesInfo::set_match_ids(int index, uint64_t value) {
  _impl_.match_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.SeriesInfo.match_ids)
}
inline void CMsgDOTALeague_SeriesInfo::_internal_add_match_ids(uint64_t value) {
  _impl_.match_ids_.Add(value);
}
inline void CMsgDOTALeague_SeriesInfo::add_match_ids(uint64_t value) {
  _internal_add_match_ids(value);
  // @@protoc_insertion_point(field_add:CMsgDOTALeague.SeriesInfo.match_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CMsgDOTALeague_SeriesInfo::_internal_match_ids() const {
  return _impl_.match_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CMsgDOTALeague_SeriesInfo::match_ids() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeague.SeriesInfo.match_ids)
  return _internal_match_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CMsgDOTALeague_SeriesInfo::_internal_mutable_match_ids() {
  return &_impl_.match_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CMsgDOTALeague_SeriesInfo::mutable_match_ids() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeague.SeriesInfo.match_ids)
  return _internal_mutable_match_ids();
}

// optional uint32 team_id_1 = 5;
inline bool CMsgDOTALeague_SeriesInfo::_internal_has_team_id_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTALeague_SeriesInfo::has_team_id_1() const {
  return _internal_has_team_id_1();
}
inline void CMsgDOTALeague_SeriesInfo::clear_team_id_1() {
  _impl_.team_id_1_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTALeague_SeriesInfo::_internal_team_id_1() const {
  return _impl_.team_id_1_;
}
inline uint32_t CMsgDOTALeague_SeriesInfo::team_id_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.SeriesInfo.team_id_1)
  return _internal_team_id_1();
}
inline void CMsgDOTALeague_SeriesInfo::_internal_set_team_id_1(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.team_id_1_ = value;
}
inline void CMsgDOTALeague_SeriesInfo::set_team_id_1(uint32_t value) {
  _internal_set_team_id_1(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.SeriesInfo.team_id_1)
}

// optional uint32 team_id_2 = 6;
inline bool CMsgDOTALeague_SeriesInfo::_internal_has_team_id_2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTALeague_SeriesInfo::has_team_id_2() const {
  return _internal_has_team_id_2();
}
inline void CMsgDOTALeague_SeriesInfo::clear_team_id_2() {
  _impl_.team_id_2_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTALeague_SeriesInfo::_internal_team_id_2() const {
  return _impl_.team_id_2_;
}
inline uint32_t CMsgDOTALeague_SeriesInfo::team_id_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.SeriesInfo.team_id_2)
  return _internal_team_id_2();
}
inline void CMsgDOTALeague_SeriesInfo::_internal_set_team_id_2(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.team_id_2_ = value;
}
inline void CMsgDOTALeague_SeriesInfo::set_team_id_2(uint32_t value) {
  _internal_set_team_id_2(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.SeriesInfo.team_id_2)
}

// -------------------------------------------------------------------

// CMsgDOTALeague_Player

// optional uint32 account_id = 1;
inline bool CMsgDOTALeague_Player::_internal_has_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Player::has_account_id() const {
  return _internal_has_account_id();
}
inline void CMsgDOTALeague_Player::clear_account_id() {
  _impl_.account_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTALeague_Player::_internal_account_id() const {
  return _impl_.account_id_;
}
inline uint32_t CMsgDOTALeague_Player::account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Player.account_id)
  return _internal_account_id();
}
inline void CMsgDOTALeague_Player::_internal_set_account_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.account_id_ = value;
}
inline void CMsgDOTALeague_Player::set_account_id(uint32_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Player.account_id)
}

// optional string name = 2;
inline bool CMsgDOTALeague_Player::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Player::has_name() const {
  return _internal_has_name();
}
inline void CMsgDOTALeague_Player::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeague_Player::name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Player.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeague_Player::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Player.name)
}
inline std::string* CMsgDOTALeague_Player::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.Player.name)
  return _s;
}
inline const std::string& CMsgDOTALeague_Player::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDOTALeague_Player::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Player::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeague_Player::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeague.Player.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeague_Player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeague.Player.name)
}

// optional uint32 team_id = 3;
inline bool CMsgDOTALeague_Player::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeague_Player::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDOTALeague_Player::clear_team_id() {
  _impl_.team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTALeague_Player::_internal_team_id() const {
  return _impl_.team_id_;
}
inline uint32_t CMsgDOTALeague_Player::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.Player.team_id)
  return _internal_team_id();
}
inline void CMsgDOTALeague_Player::_internal_set_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.team_id_ = value;
}
inline void CMsgDOTALeague_Player::set_team_id(uint32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeague.Player.team_id)
}

// -------------------------------------------------------------------

// CMsgDOTALeague

// optional .CMsgDOTALeague.Info info = 1;
inline bool CMsgDOTALeague::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool CMsgDOTALeague::has_info() const {
  return _internal_has_info();
}
inline void CMsgDOTALeague::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgDOTALeague_Info& CMsgDOTALeague::_internal_info() const {
  const ::CMsgDOTALeague_Info* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgDOTALeague_Info&>(
      ::_CMsgDOTALeague_Info_default_instance_);
}
inline const ::CMsgDOTALeague_Info& CMsgDOTALeague::info() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.info)
  return _internal_info();
}
inline void CMsgDOTALeague::unsafe_arena_set_allocated_info(
    ::CMsgDOTALeague_Info* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDOTALeague.info)
}
inline ::CMsgDOTALeague_Info* CMsgDOTALeague::release_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgDOTALeague_Info* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgDOTALeague_Info* CMsgDOTALeague::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeague.info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgDOTALeague_Info* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::CMsgDOTALeague_Info* CMsgDOTALeague::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgDOTALeague_Info>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::CMsgDOTALeague_Info* CMsgDOTALeague::mutable_info() {
  ::CMsgDOTALeague_Info* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.info)
  return _msg;
}
inline void CMsgDOTALeague::set_allocated_info(::CMsgDOTALeague_Info* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeague.info)
}

// optional .CMsgDOTALeague.PrizePool prize_pool = 2;
inline bool CMsgDOTALeague::_internal_has_prize_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.prize_pool_ != nullptr);
  return value;
}
inline bool CMsgDOTALeague::has_prize_pool() const {
  return _internal_has_prize_pool();
}
inline void CMsgDOTALeague::clear_prize_pool() {
  if (_impl_.prize_pool_ != nullptr) _impl_.prize_pool_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CMsgDOTALeague_PrizePool& CMsgDOTALeague::_internal_prize_pool() const {
  const ::CMsgDOTALeague_PrizePool* p = _impl_.prize_pool_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgDOTALeague_PrizePool&>(
      ::_CMsgDOTALeague_PrizePool_default_instance_);
}
inline const ::CMsgDOTALeague_PrizePool& CMsgDOTALeague::prize_pool() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.prize_pool)
  return _internal_prize_pool();
}
inline void CMsgDOTALeague::unsafe_arena_set_allocated_prize_pool(
    ::CMsgDOTALeague_PrizePool* prize_pool) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prize_pool_);
  }
  _impl_.prize_pool_ = prize_pool;
  if (prize_pool) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDOTALeague.prize_pool)
}
inline ::CMsgDOTALeague_PrizePool* CMsgDOTALeague::release_prize_pool() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgDOTALeague_PrizePool* temp = _impl_.prize_pool_;
  _impl_.prize_pool_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgDOTALeague_PrizePool* CMsgDOTALeague::unsafe_arena_release_prize_pool() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeague.prize_pool)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgDOTALeague_PrizePool* temp = _impl_.prize_pool_;
  _impl_.prize_pool_ = nullptr;
  return temp;
}
inline ::CMsgDOTALeague_PrizePool* CMsgDOTALeague::_internal_mutable_prize_pool() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.prize_pool_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgDOTALeague_PrizePool>(GetArenaForAllocation());
    _impl_.prize_pool_ = p;
  }
  return _impl_.prize_pool_;
}
inline ::CMsgDOTALeague_PrizePool* CMsgDOTALeague::mutable_prize_pool() {
  ::CMsgDOTALeague_PrizePool* _msg = _internal_mutable_prize_pool();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.prize_pool)
  return _msg;
}
inline void CMsgDOTALeague::set_allocated_prize_pool(::CMsgDOTALeague_PrizePool* prize_pool) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.prize_pool_;
  }
  if (prize_pool) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prize_pool);
    if (message_arena != submessage_arena) {
      prize_pool = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prize_pool, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.prize_pool_ = prize_pool;
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeague.prize_pool)
}

// repeated .CMsgDOTALeague.Admin admins = 3;
inline int CMsgDOTALeague::_internal_admins_size() const {
  return _impl_.admins_.size();
}
inline int CMsgDOTALeague::admins_size() const {
  return _internal_admins_size();
}
inline void CMsgDOTALeague::clear_admins() {
  _impl_.admins_.Clear();
}
inline ::CMsgDOTALeague_Admin* CMsgDOTALeague::mutable_admins(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.admins)
  return _impl_.admins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Admin >*
CMsgDOTALeague::mutable_admins() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeague.admins)
  return &_impl_.admins_;
}
inline const ::CMsgDOTALeague_Admin& CMsgDOTALeague::_internal_admins(int index) const {
  return _impl_.admins_.Get(index);
}
inline const ::CMsgDOTALeague_Admin& CMsgDOTALeague::admins(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.admins)
  return _internal_admins(index);
}
inline ::CMsgDOTALeague_Admin* CMsgDOTALeague::_internal_add_admins() {
  return _impl_.admins_.Add();
}
inline ::CMsgDOTALeague_Admin* CMsgDOTALeague::add_admins() {
  ::CMsgDOTALeague_Admin* _add = _internal_add_admins();
  // @@protoc_insertion_point(field_add:CMsgDOTALeague.admins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Admin >&
CMsgDOTALeague::admins() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeague.admins)
  return _impl_.admins_;
}

// repeated .CMsgDOTALeague.Stream streams = 4;
inline int CMsgDOTALeague::_internal_streams_size() const {
  return _impl_.streams_.size();
}
inline int CMsgDOTALeague::streams_size() const {
  return _internal_streams_size();
}
inline void CMsgDOTALeague::clear_streams() {
  _impl_.streams_.Clear();
}
inline ::CMsgDOTALeague_Stream* CMsgDOTALeague::mutable_streams(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.streams)
  return _impl_.streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Stream >*
CMsgDOTALeague::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeague.streams)
  return &_impl_.streams_;
}
inline const ::CMsgDOTALeague_Stream& CMsgDOTALeague::_internal_streams(int index) const {
  return _impl_.streams_.Get(index);
}
inline const ::CMsgDOTALeague_Stream& CMsgDOTALeague::streams(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.streams)
  return _internal_streams(index);
}
inline ::CMsgDOTALeague_Stream* CMsgDOTALeague::_internal_add_streams() {
  return _impl_.streams_.Add();
}
inline ::CMsgDOTALeague_Stream* CMsgDOTALeague::add_streams() {
  ::CMsgDOTALeague_Stream* _add = _internal_add_streams();
  // @@protoc_insertion_point(field_add:CMsgDOTALeague.streams)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Stream >&
CMsgDOTALeague::streams() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeague.streams)
  return _impl_.streams_;
}

// repeated .CMsgDOTALeagueNodeGroup node_groups = 5;
inline int CMsgDOTALeague::_internal_node_groups_size() const {
  return _impl_.node_groups_.size();
}
inline int CMsgDOTALeague::node_groups_size() const {
  return _internal_node_groups_size();
}
inline void CMsgDOTALeague::clear_node_groups() {
  _impl_.node_groups_.Clear();
}
inline ::CMsgDOTALeagueNodeGroup* CMsgDOTALeague::mutable_node_groups(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.node_groups)
  return _impl_.node_groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup >*
CMsgDOTALeague::mutable_node_groups() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeague.node_groups)
  return &_impl_.node_groups_;
}
inline const ::CMsgDOTALeagueNodeGroup& CMsgDOTALeague::_internal_node_groups(int index) const {
  return _impl_.node_groups_.Get(index);
}
inline const ::CMsgDOTALeagueNodeGroup& CMsgDOTALeague::node_groups(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.node_groups)
  return _internal_node_groups(index);
}
inline ::CMsgDOTALeagueNodeGroup* CMsgDOTALeague::_internal_add_node_groups() {
  return _impl_.node_groups_.Add();
}
inline ::CMsgDOTALeagueNodeGroup* CMsgDOTALeague::add_node_groups() {
  ::CMsgDOTALeagueNodeGroup* _add = _internal_add_node_groups();
  // @@protoc_insertion_point(field_add:CMsgDOTALeague.node_groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeGroup >&
CMsgDOTALeague::node_groups() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeague.node_groups)
  return _impl_.node_groups_;
}

// repeated .CMsgDOTALeague.SeriesInfo series_infos = 6;
inline int CMsgDOTALeague::_internal_series_infos_size() const {
  return _impl_.series_infos_.size();
}
inline int CMsgDOTALeague::series_infos_size() const {
  return _internal_series_infos_size();
}
inline void CMsgDOTALeague::clear_series_infos() {
  _impl_.series_infos_.Clear();
}
inline ::CMsgDOTALeague_SeriesInfo* CMsgDOTALeague::mutable_series_infos(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.series_infos)
  return _impl_.series_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_SeriesInfo >*
CMsgDOTALeague::mutable_series_infos() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeague.series_infos)
  return &_impl_.series_infos_;
}
inline const ::CMsgDOTALeague_SeriesInfo& CMsgDOTALeague::_internal_series_infos(int index) const {
  return _impl_.series_infos_.Get(index);
}
inline const ::CMsgDOTALeague_SeriesInfo& CMsgDOTALeague::series_infos(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.series_infos)
  return _internal_series_infos(index);
}
inline ::CMsgDOTALeague_SeriesInfo* CMsgDOTALeague::_internal_add_series_infos() {
  return _impl_.series_infos_.Add();
}
inline ::CMsgDOTALeague_SeriesInfo* CMsgDOTALeague::add_series_infos() {
  ::CMsgDOTALeague_SeriesInfo* _add = _internal_add_series_infos();
  // @@protoc_insertion_point(field_add:CMsgDOTALeague.series_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_SeriesInfo >&
CMsgDOTALeague::series_infos() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeague.series_infos)
  return _impl_.series_infos_;
}

// repeated .CMsgDOTALeague.Player registered_players = 7;
inline int CMsgDOTALeague::_internal_registered_players_size() const {
  return _impl_.registered_players_.size();
}
inline int CMsgDOTALeague::registered_players_size() const {
  return _internal_registered_players_size();
}
inline void CMsgDOTALeague::clear_registered_players() {
  _impl_.registered_players_.Clear();
}
inline ::CMsgDOTALeague_Player* CMsgDOTALeague::mutable_registered_players(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeague.registered_players)
  return _impl_.registered_players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Player >*
CMsgDOTALeague::mutable_registered_players() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeague.registered_players)
  return &_impl_.registered_players_;
}
inline const ::CMsgDOTALeague_Player& CMsgDOTALeague::_internal_registered_players(int index) const {
  return _impl_.registered_players_.Get(index);
}
inline const ::CMsgDOTALeague_Player& CMsgDOTALeague::registered_players(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeague.registered_players)
  return _internal_registered_players(index);
}
inline ::CMsgDOTALeague_Player* CMsgDOTALeague::_internal_add_registered_players() {
  return _impl_.registered_players_.Add();
}
inline ::CMsgDOTALeague_Player* CMsgDOTALeague::add_registered_players() {
  ::CMsgDOTALeague_Player* _add = _internal_add_registered_players();
  // @@protoc_insertion_point(field_add:CMsgDOTALeague.registered_players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague_Player >&
CMsgDOTALeague::registered_players() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeague.registered_players)
  return _impl_.registered_players_;
}

// -------------------------------------------------------------------

// CMsgDOTALeagueList

// repeated .CMsgDOTALeague leagues = 1;
inline int CMsgDOTALeagueList::_internal_leagues_size() const {
  return _impl_.leagues_.size();
}
inline int CMsgDOTALeagueList::leagues_size() const {
  return _internal_leagues_size();
}
inline void CMsgDOTALeagueList::clear_leagues() {
  _impl_.leagues_.Clear();
}
inline ::CMsgDOTALeague* CMsgDOTALeagueList::mutable_leagues(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueList.leagues)
  return _impl_.leagues_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague >*
CMsgDOTALeagueList::mutable_leagues() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueList.leagues)
  return &_impl_.leagues_;
}
inline const ::CMsgDOTALeague& CMsgDOTALeagueList::_internal_leagues(int index) const {
  return _impl_.leagues_.Get(index);
}
inline const ::CMsgDOTALeague& CMsgDOTALeagueList::leagues(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueList.leagues)
  return _internal_leagues(index);
}
inline ::CMsgDOTALeague* CMsgDOTALeagueList::_internal_add_leagues() {
  return _impl_.leagues_.Add();
}
inline ::CMsgDOTALeague* CMsgDOTALeagueList::add_leagues() {
  ::CMsgDOTALeague* _add = _internal_add_leagues();
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueList.leagues)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeague >&
CMsgDOTALeagueList::leagues() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueList.leagues)
  return _impl_.leagues_;
}

// -------------------------------------------------------------------

// CMsgDOTALeagueInfo

// optional uint32 league_id = 1;
inline bool CMsgDOTALeagueInfo::_internal_has_league_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeagueInfo::has_league_id() const {
  return _internal_has_league_id();
}
inline void CMsgDOTALeagueInfo::clear_league_id() {
  _impl_.league_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTALeagueInfo::_internal_league_id() const {
  return _impl_.league_id_;
}
inline uint32_t CMsgDOTALeagueInfo::league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueInfo.league_id)
  return _internal_league_id();
}
inline void CMsgDOTALeagueInfo::_internal_set_league_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.league_id_ = value;
}
inline void CMsgDOTALeagueInfo::set_league_id(uint32_t value) {
  _internal_set_league_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueInfo.league_id)
}

// optional string name = 2;
inline bool CMsgDOTALeagueInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeagueInfo::has_name() const {
  return _internal_has_name();
}
inline void CMsgDOTALeagueInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeagueInfo::name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueInfo.name)
}
inline std::string* CMsgDOTALeagueInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueInfo.name)
  return _s;
}
inline const std::string& CMsgDOTALeagueInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CMsgDOTALeagueInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueInfo::release_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueInfo.name)
}

// optional .ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
inline bool CMsgDOTALeagueInfo::_internal_has_tier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeagueInfo::has_tier() const {
  return _internal_has_tier();
}
inline void CMsgDOTALeagueInfo::clear_tier() {
  _impl_.tier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::ELeagueTier CMsgDOTALeagueInfo::_internal_tier() const {
  return static_cast< ::ELeagueTier >(_impl_.tier_);
}
inline ::ELeagueTier CMsgDOTALeagueInfo::tier() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueInfo.tier)
  return _internal_tier();
}
inline void CMsgDOTALeagueInfo::_internal_set_tier(::ELeagueTier value) {
  assert(::ELeagueTier_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tier_ = value;
}
inline void CMsgDOTALeagueInfo::set_tier(::ELeagueTier value) {
  _internal_set_tier(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueInfo.tier)
}

// optional .ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
inline bool CMsgDOTALeagueInfo::_internal_has_region() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTALeagueInfo::has_region() const {
  return _internal_has_region();
}
inline void CMsgDOTALeagueInfo::clear_region() {
  _impl_.region_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::ELeagueRegion CMsgDOTALeagueInfo::_internal_region() const {
  return static_cast< ::ELeagueRegion >(_impl_.region_);
}
inline ::ELeagueRegion CMsgDOTALeagueInfo::region() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueInfo.region)
  return _internal_region();
}
inline void CMsgDOTALeagueInfo::_internal_set_region(::ELeagueRegion value) {
  assert(::ELeagueRegion_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.region_ = value;
}
inline void CMsgDOTALeagueInfo::set_region(::ELeagueRegion value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueInfo.region)
}

// optional uint32 most_recent_activity = 5;
inline bool CMsgDOTALeagueInfo::_internal_has_most_recent_activity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTALeagueInfo::has_most_recent_activity() const {
  return _internal_has_most_recent_activity();
}
inline void CMsgDOTALeagueInfo::clear_most_recent_activity() {
  _impl_.most_recent_activity_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTALeagueInfo::_internal_most_recent_activity() const {
  return _impl_.most_recent_activity_;
}
inline uint32_t CMsgDOTALeagueInfo::most_recent_activity() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueInfo.most_recent_activity)
  return _internal_most_recent_activity();
}
inline void CMsgDOTALeagueInfo::_internal_set_most_recent_activity(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.most_recent_activity_ = value;
}
inline void CMsgDOTALeagueInfo::set_most_recent_activity(uint32_t value) {
  _internal_set_most_recent_activity(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueInfo.most_recent_activity)
}

// optional uint32 total_prize_pool = 6;
inline bool CMsgDOTALeagueInfo::_internal_has_total_prize_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTALeagueInfo::has_total_prize_pool() const {
  return _internal_has_total_prize_pool();
}
inline void CMsgDOTALeagueInfo::clear_total_prize_pool() {
  _impl_.total_prize_pool_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgDOTALeagueInfo::_internal_total_prize_pool() const {
  return _impl_.total_prize_pool_;
}
inline uint32_t CMsgDOTALeagueInfo::total_prize_pool() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueInfo.total_prize_pool)
  return _internal_total_prize_pool();
}
inline void CMsgDOTALeagueInfo::_internal_set_total_prize_pool(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.total_prize_pool_ = value;
}
inline void CMsgDOTALeagueInfo::set_total_prize_pool(uint32_t value) {
  _internal_set_total_prize_pool(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueInfo.total_prize_pool)
}

// optional uint32 start_timestamp = 7;
inline bool CMsgDOTALeagueInfo::_internal_has_start_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTALeagueInfo::has_start_timestamp() const {
  return _internal_has_start_timestamp();
}
inline void CMsgDOTALeagueInfo::clear_start_timestamp() {
  _impl_.start_timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CMsgDOTALeagueInfo::_internal_start_timestamp() const {
  return _impl_.start_timestamp_;
}
inline uint32_t CMsgDOTALeagueInfo::start_timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueInfo.start_timestamp)
  return _internal_start_timestamp();
}
inline void CMsgDOTALeagueInfo::_internal_set_start_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.start_timestamp_ = value;
}
inline void CMsgDOTALeagueInfo::set_start_timestamp(uint32_t value) {
  _internal_set_start_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueInfo.start_timestamp)
}

// optional uint32 end_timestamp = 8;
inline bool CMsgDOTALeagueInfo::_internal_has_end_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTALeagueInfo::has_end_timestamp() const {
  return _internal_has_end_timestamp();
}
inline void CMsgDOTALeagueInfo::clear_end_timestamp() {
  _impl_.end_timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CMsgDOTALeagueInfo::_internal_end_timestamp() const {
  return _impl_.end_timestamp_;
}
inline uint32_t CMsgDOTALeagueInfo::end_timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueInfo.end_timestamp)
  return _internal_end_timestamp();
}
inline void CMsgDOTALeagueInfo::_internal_set_end_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.end_timestamp_ = value;
}
inline void CMsgDOTALeagueInfo::set_end_timestamp(uint32_t value) {
  _internal_set_end_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueInfo.end_timestamp)
}

// optional uint32 status = 9;
inline bool CMsgDOTALeagueInfo::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTALeagueInfo::has_status() const {
  return _internal_has_status();
}
inline void CMsgDOTALeagueInfo::clear_status() {
  _impl_.status_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CMsgDOTALeagueInfo::_internal_status() const {
  return _impl_.status_;
}
inline uint32_t CMsgDOTALeagueInfo::status() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueInfo.status)
  return _internal_status();
}
inline void CMsgDOTALeagueInfo::_internal_set_status(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.status_ = value;
}
inline void CMsgDOTALeagueInfo::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueInfo.status)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueInfoList

// repeated .CMsgDOTALeagueInfo infos = 1;
inline int CMsgDOTALeagueInfoList::_internal_infos_size() const {
  return _impl_.infos_.size();
}
inline int CMsgDOTALeagueInfoList::infos_size() const {
  return _internal_infos_size();
}
inline void CMsgDOTALeagueInfoList::clear_infos() {
  _impl_.infos_.Clear();
}
inline ::CMsgDOTALeagueInfo* CMsgDOTALeagueInfoList::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueInfoList.infos)
  return _impl_.infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueInfo >*
CMsgDOTALeagueInfoList::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueInfoList.infos)
  return &_impl_.infos_;
}
inline const ::CMsgDOTALeagueInfo& CMsgDOTALeagueInfoList::_internal_infos(int index) const {
  return _impl_.infos_.Get(index);
}
inline const ::CMsgDOTALeagueInfo& CMsgDOTALeagueInfoList::infos(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueInfoList.infos)
  return _internal_infos(index);
}
inline ::CMsgDOTALeagueInfo* CMsgDOTALeagueInfoList::_internal_add_infos() {
  return _impl_.infos_.Add();
}
inline ::CMsgDOTALeagueInfo* CMsgDOTALeagueInfoList::add_infos() {
  ::CMsgDOTALeagueInfo* _add = _internal_add_infos();
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueInfoList.infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueInfo >&
CMsgDOTALeagueInfoList::infos() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueInfoList.infos)
  return _impl_.infos_;
}

// -------------------------------------------------------------------

// CMsgDOTALeagueLiveGames_LiveGame

// optional uint32 league_id = 1;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_league_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_league_id() const {
  return _internal_has_league_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_league_id() {
  _impl_.league_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::_internal_league_id() const {
  return _impl_.league_id_;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.league_id)
  return _internal_league_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_league_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.league_id_ = value;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_league_id(uint32_t value) {
  _internal_set_league_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.league_id)
}

// optional uint64 server_steam_id = 2;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_server_steam_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_server_steam_id() const {
  return _internal_has_server_steam_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_server_steam_id() {
  _impl_.server_steam_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CMsgDOTALeagueLiveGames_LiveGame::_internal_server_steam_id() const {
  return _impl_.server_steam_id_;
}
inline uint64_t CMsgDOTALeagueLiveGames_LiveGame::server_steam_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.server_steam_id)
  return _internal_server_steam_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_server_steam_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.server_steam_id_ = value;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_server_steam_id(uint64_t value) {
  _internal_set_server_steam_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.server_steam_id)
}

// optional string radiant_name = 3;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_radiant_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_radiant_name() const {
  return _internal_has_radiant_name();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_radiant_name() {
  _impl_.radiant_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeagueLiveGames_LiveGame::radiant_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
  return _internal_radiant_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueLiveGames_LiveGame::set_radiant_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.radiant_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
}
inline std::string* CMsgDOTALeagueLiveGames_LiveGame::mutable_radiant_name() {
  std::string* _s = _internal_mutable_radiant_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
  return _s;
}
inline const std::string& CMsgDOTALeagueLiveGames_LiveGame::_internal_radiant_name() const {
  return _impl_.radiant_name_.Get();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_radiant_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.radiant_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueLiveGames_LiveGame::_internal_mutable_radiant_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.radiant_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueLiveGames_LiveGame::release_radiant_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
  if (!_internal_has_radiant_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.radiant_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.radiant_name_.IsDefault()) {
    _impl_.radiant_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_allocated_radiant_name(std::string* radiant_name) {
  if (radiant_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.radiant_name_.SetAllocated(radiant_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.radiant_name_.IsDefault()) {
    _impl_.radiant_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
}

// optional uint64 radiant_logo = 4;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_radiant_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_radiant_logo() const {
  return _internal_has_radiant_logo();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_radiant_logo() {
  _impl_.radiant_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CMsgDOTALeagueLiveGames_LiveGame::_internal_radiant_logo() const {
  return _impl_.radiant_logo_;
}
inline uint64_t CMsgDOTALeagueLiveGames_LiveGame::radiant_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.radiant_logo)
  return _internal_radiant_logo();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_radiant_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.radiant_logo_ = value;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_radiant_logo(uint64_t value) {
  _internal_set_radiant_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.radiant_logo)
}

// optional uint32 radiant_team_id = 9;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_radiant_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_radiant_team_id() const {
  return _internal_has_radiant_team_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_radiant_team_id() {
  _impl_.radiant_team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::_internal_radiant_team_id() const {
  return _impl_.radiant_team_id_;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::radiant_team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.radiant_team_id)
  return _internal_radiant_team_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_radiant_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.radiant_team_id_ = value;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_radiant_team_id(uint32_t value) {
  _internal_set_radiant_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.radiant_team_id)
}

// optional string dire_name = 5;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_dire_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_dire_name() const {
  return _internal_has_dire_name();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_dire_name() {
  _impl_.dire_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTALeagueLiveGames_LiveGame::dire_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.dire_name)
  return _internal_dire_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueLiveGames_LiveGame::set_dire_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.dire_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.dire_name)
}
inline std::string* CMsgDOTALeagueLiveGames_LiveGame::mutable_dire_name() {
  std::string* _s = _internal_mutable_dire_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueLiveGames.LiveGame.dire_name)
  return _s;
}
inline const std::string& CMsgDOTALeagueLiveGames_LiveGame::_internal_dire_name() const {
  return _impl_.dire_name_.Get();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_dire_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dire_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueLiveGames_LiveGame::_internal_mutable_dire_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dire_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueLiveGames_LiveGame::release_dire_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueLiveGames.LiveGame.dire_name)
  if (!_internal_has_dire_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.dire_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dire_name_.IsDefault()) {
    _impl_.dire_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_allocated_dire_name(std::string* dire_name) {
  if (dire_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dire_name_.SetAllocated(dire_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dire_name_.IsDefault()) {
    _impl_.dire_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueLiveGames.LiveGame.dire_name)
}

// optional uint64 dire_logo = 6;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_dire_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_dire_logo() const {
  return _internal_has_dire_logo();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_dire_logo() {
  _impl_.dire_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t CMsgDOTALeagueLiveGames_LiveGame::_internal_dire_logo() const {
  return _impl_.dire_logo_;
}
inline uint64_t CMsgDOTALeagueLiveGames_LiveGame::dire_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.dire_logo)
  return _internal_dire_logo();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_dire_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.dire_logo_ = value;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_dire_logo(uint64_t value) {
  _internal_set_dire_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.dire_logo)
}

// optional uint32 dire_team_id = 10;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_dire_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_dire_team_id() const {
  return _internal_has_dire_team_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_dire_team_id() {
  _impl_.dire_team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::_internal_dire_team_id() const {
  return _impl_.dire_team_id_;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::dire_team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.dire_team_id)
  return _internal_dire_team_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_dire_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.dire_team_id_ = value;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_dire_team_id(uint32_t value) {
  _internal_set_dire_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.dire_team_id)
}

// optional uint32 time = 7;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_time() const {
  return _internal_has_time();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_time() {
  _impl_.time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::_internal_time() const {
  return _impl_.time_;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.time)
  return _internal_time();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.time_ = value;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.time)
}

// optional uint32 spectators = 8;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_spectators() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_spectators() const {
  return _internal_has_spectators();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_spectators() {
  _impl_.spectators_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::_internal_spectators() const {
  return _impl_.spectators_;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::spectators() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.spectators)
  return _internal_spectators();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_spectators(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.spectators_ = value;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_spectators(uint32_t value) {
  _internal_set_spectators(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.spectators)
}

// optional uint32 league_node_id = 11;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_league_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_league_node_id() const {
  return _internal_has_league_node_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_league_node_id() {
  _impl_.league_node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::_internal_league_node_id() const {
  return _impl_.league_node_id_;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::league_node_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.league_node_id)
  return _internal_league_node_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_league_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.league_node_id_ = value;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_league_node_id(uint32_t value) {
  _internal_set_league_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.league_node_id)
}

// optional uint32 series_id = 12;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_series_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_series_id() const {
  return _internal_has_series_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_series_id() {
  _impl_.series_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::_internal_series_id() const {
  return _impl_.series_id_;
}
inline uint32_t CMsgDOTALeagueLiveGames_LiveGame::series_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.series_id)
  return _internal_series_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_series_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.series_id_ = value;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_series_id(uint32_t value) {
  _internal_set_series_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.series_id)
}

// optional uint64 match_id = 13;
inline bool CMsgDOTALeagueLiveGames_LiveGame::_internal_has_match_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_match_id() const {
  return _internal_has_match_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_match_id() {
  _impl_.match_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint64_t CMsgDOTALeagueLiveGames_LiveGame::_internal_match_id() const {
  return _impl_.match_id_;
}
inline uint64_t CMsgDOTALeagueLiveGames_LiveGame::match_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.LiveGame.match_id)
  return _internal_match_id();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::_internal_set_match_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.match_id_ = value;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_match_id(uint64_t value) {
  _internal_set_match_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueLiveGames.LiveGame.match_id)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueLiveGames

// repeated .CMsgDOTALeagueLiveGames.LiveGame games = 1;
inline int CMsgDOTALeagueLiveGames::_internal_games_size() const {
  return _impl_.games_.size();
}
inline int CMsgDOTALeagueLiveGames::games_size() const {
  return _internal_games_size();
}
inline void CMsgDOTALeagueLiveGames::clear_games() {
  _impl_.games_.Clear();
}
inline ::CMsgDOTALeagueLiveGames_LiveGame* CMsgDOTALeagueLiveGames::mutable_games(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueLiveGames.games)
  return _impl_.games_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueLiveGames_LiveGame >*
CMsgDOTALeagueLiveGames::mutable_games() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueLiveGames.games)
  return &_impl_.games_;
}
inline const ::CMsgDOTALeagueLiveGames_LiveGame& CMsgDOTALeagueLiveGames::_internal_games(int index) const {
  return _impl_.games_.Get(index);
}
inline const ::CMsgDOTALeagueLiveGames_LiveGame& CMsgDOTALeagueLiveGames::games(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueLiveGames.games)
  return _internal_games(index);
}
inline ::CMsgDOTALeagueLiveGames_LiveGame* CMsgDOTALeagueLiveGames::_internal_add_games() {
  return _impl_.games_.Add();
}
inline ::CMsgDOTALeagueLiveGames_LiveGame* CMsgDOTALeagueLiveGames::add_games() {
  ::CMsgDOTALeagueLiveGames_LiveGame* _add = _internal_add_games();
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueLiveGames.games)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueLiveGames_LiveGame >&
CMsgDOTALeagueLiveGames::games() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueLiveGames.games)
  return _impl_.games_;
}

// -------------------------------------------------------------------

// CMsgDOTALeagueMessages_Message

// optional uint32 author_account_id = 1;
inline bool CMsgDOTALeagueMessages_Message::_internal_has_author_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeagueMessages_Message::has_author_account_id() const {
  return _internal_has_author_account_id();
}
inline void CMsgDOTALeagueMessages_Message::clear_author_account_id() {
  _impl_.author_account_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTALeagueMessages_Message::_internal_author_account_id() const {
  return _impl_.author_account_id_;
}
inline uint32_t CMsgDOTALeagueMessages_Message::author_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueMessages.Message.author_account_id)
  return _internal_author_account_id();
}
inline void CMsgDOTALeagueMessages_Message::_internal_set_author_account_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.author_account_id_ = value;
}
inline void CMsgDOTALeagueMessages_Message::set_author_account_id(uint32_t value) {
  _internal_set_author_account_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueMessages.Message.author_account_id)
}

// optional uint32 timestamp = 2;
inline bool CMsgDOTALeagueMessages_Message::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeagueMessages_Message::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CMsgDOTALeagueMessages_Message::clear_timestamp() {
  _impl_.timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTALeagueMessages_Message::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint32_t CMsgDOTALeagueMessages_Message::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueMessages.Message.timestamp)
  return _internal_timestamp();
}
inline void CMsgDOTALeagueMessages_Message::_internal_set_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_ = value;
}
inline void CMsgDOTALeagueMessages_Message::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueMessages.Message.timestamp)
}

// optional string message = 3;
inline bool CMsgDOTALeagueMessages_Message::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeagueMessages_Message::has_message() const {
  return _internal_has_message();
}
inline void CMsgDOTALeagueMessages_Message::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeagueMessages_Message::message() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueMessages.Message.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueMessages_Message::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueMessages.Message.message)
}
inline std::string* CMsgDOTALeagueMessages_Message::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueMessages.Message.message)
  return _s;
}
inline const std::string& CMsgDOTALeagueMessages_Message::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CMsgDOTALeagueMessages_Message::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueMessages_Message::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueMessages_Message::release_message() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueMessages.Message.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueMessages_Message::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueMessages.Message.message)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueMessages

// repeated .CMsgDOTALeagueMessages.Message messages = 1;
inline int CMsgDOTALeagueMessages::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int CMsgDOTALeagueMessages::messages_size() const {
  return _internal_messages_size();
}
inline void CMsgDOTALeagueMessages::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::CMsgDOTALeagueMessages_Message* CMsgDOTALeagueMessages::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueMessages.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueMessages_Message >*
CMsgDOTALeagueMessages::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueMessages.messages)
  return &_impl_.messages_;
}
inline const ::CMsgDOTALeagueMessages_Message& CMsgDOTALeagueMessages::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::CMsgDOTALeagueMessages_Message& CMsgDOTALeagueMessages::messages(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueMessages.messages)
  return _internal_messages(index);
}
inline ::CMsgDOTALeagueMessages_Message* CMsgDOTALeagueMessages::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::CMsgDOTALeagueMessages_Message* CMsgDOTALeagueMessages::add_messages() {
  ::CMsgDOTALeagueMessages_Message* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueMessages.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueMessages_Message >&
CMsgDOTALeagueMessages::messages() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueMessages.messages)
  return _impl_.messages_;
}

// -------------------------------------------------------------------

// CMsgDOTALeaguePrizePool

// optional uint32 prize_pool = 1;
inline bool CMsgDOTALeaguePrizePool::_internal_has_prize_pool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeaguePrizePool::has_prize_pool() const {
  return _internal_has_prize_pool();
}
inline void CMsgDOTALeaguePrizePool::clear_prize_pool() {
  _impl_.prize_pool_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTALeaguePrizePool::_internal_prize_pool() const {
  return _impl_.prize_pool_;
}
inline uint32_t CMsgDOTALeaguePrizePool::prize_pool() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeaguePrizePool.prize_pool)
  return _internal_prize_pool();
}
inline void CMsgDOTALeaguePrizePool::_internal_set_prize_pool(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prize_pool_ = value;
}
inline void CMsgDOTALeaguePrizePool::set_prize_pool(uint32_t value) {
  _internal_set_prize_pool(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeaguePrizePool.prize_pool)
}

// optional float increment_per_second = 2;
inline bool CMsgDOTALeaguePrizePool::_internal_has_increment_per_second() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeaguePrizePool::has_increment_per_second() const {
  return _internal_has_increment_per_second();
}
inline void CMsgDOTALeaguePrizePool::clear_increment_per_second() {
  _impl_.increment_per_second_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float CMsgDOTALeaguePrizePool::_internal_increment_per_second() const {
  return _impl_.increment_per_second_;
}
inline float CMsgDOTALeaguePrizePool::increment_per_second() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeaguePrizePool.increment_per_second)
  return _internal_increment_per_second();
}
inline void CMsgDOTALeaguePrizePool::_internal_set_increment_per_second(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.increment_per_second_ = value;
}
inline void CMsgDOTALeaguePrizePool::set_increment_per_second(float value) {
  _internal_set_increment_per_second(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeaguePrizePool.increment_per_second)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueInfoListAdminsRequest

// -------------------------------------------------------------------

// CMsgDOTALeagueAvailableLobbyNodesRequest

// optional uint32 league_id = 1;
inline bool CMsgDOTALeagueAvailableLobbyNodesRequest::_internal_has_league_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeagueAvailableLobbyNodesRequest::has_league_id() const {
  return _internal_has_league_id();
}
inline void CMsgDOTALeagueAvailableLobbyNodesRequest::clear_league_id() {
  _impl_.league_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTALeagueAvailableLobbyNodesRequest::_internal_league_id() const {
  return _impl_.league_id_;
}
inline uint32_t CMsgDOTALeagueAvailableLobbyNodesRequest::league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueAvailableLobbyNodesRequest.league_id)
  return _internal_league_id();
}
inline void CMsgDOTALeagueAvailableLobbyNodesRequest::_internal_set_league_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.league_id_ = value;
}
inline void CMsgDOTALeagueAvailableLobbyNodesRequest::set_league_id(uint32_t value) {
  _internal_set_league_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueAvailableLobbyNodesRequest.league_id)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueAvailableLobbyNodes_NodeInfo

// optional uint32 node_id = 1;
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::has_node_id() const {
  return _internal_has_node_id();
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::clear_node_id() {
  _impl_.node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_node_id() const {
  return _impl_.node_id_;
}
inline uint32_t CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::node_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_id)
  return _internal_node_id();
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_set_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.node_id_ = value;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_node_id(uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_id)
}

// optional string node_name = 2;
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_has_node_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::has_node_name() const {
  return _internal_has_node_name();
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::clear_node_name() {
  _impl_.node_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::node_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
  return _internal_node_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_node_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.node_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
}
inline std::string* CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::mutable_node_name() {
  std::string* _s = _internal_mutable_node_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
  return _s;
}
inline const std::string& CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_node_name() const {
  return _impl_.node_name_.Get();
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_set_node_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_mutable_node_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::release_node_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
  if (!_internal_has_node_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.node_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_name_.IsDefault()) {
    _impl_.node_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_allocated_node_name(std::string* node_name) {
  if (node_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_name_.SetAllocated(node_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_name_.IsDefault()) {
    _impl_.node_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
}

// optional string node_group_name = 3;
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_has_node_group_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::has_node_group_name() const {
  return _internal_has_node_group_name();
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::clear_node_group_name() {
  _impl_.node_group_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::node_group_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
  return _internal_node_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_node_group_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.node_group_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
}
inline std::string* CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::mutable_node_group_name() {
  std::string* _s = _internal_mutable_node_group_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
  return _s;
}
inline const std::string& CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_node_group_name() const {
  return _impl_.node_group_name_.Get();
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_set_node_group_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.node_group_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_mutable_node_group_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.node_group_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::release_node_group_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
  if (!_internal_has_node_group_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.node_group_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_group_name_.IsDefault()) {
    _impl_.node_group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_allocated_node_group_name(std::string* node_group_name) {
  if (node_group_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.node_group_name_.SetAllocated(node_group_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_group_name_.IsDefault()) {
    _impl_.node_group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
}

// optional uint32 team_id_1 = 4;
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_has_team_id_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::has_team_id_1() const {
  return _internal_has_team_id_1();
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::clear_team_id_1() {
  _impl_.team_id_1_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_team_id_1() const {
  return _impl_.team_id_1_;
}
inline uint32_t CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::team_id_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.team_id_1)
  return _internal_team_id_1();
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_set_team_id_1(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.team_id_1_ = value;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_team_id_1(uint32_t value) {
  _internal_set_team_id_1(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.team_id_1)
}

// optional uint32 team_id_2 = 5;
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_has_team_id_2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::has_team_id_2() const {
  return _internal_has_team_id_2();
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::clear_team_id_2() {
  _impl_.team_id_2_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_team_id_2() const {
  return _impl_.team_id_2_;
}
inline uint32_t CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::team_id_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.team_id_2)
  return _internal_team_id_2();
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::_internal_set_team_id_2(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.team_id_2_ = value;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_team_id_2(uint32_t value) {
  _internal_set_team_id_2(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.team_id_2)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueAvailableLobbyNodes

// repeated .CMsgDOTALeagueAvailableLobbyNodes.NodeInfo node_infos = 1;
inline int CMsgDOTALeagueAvailableLobbyNodes::_internal_node_infos_size() const {
  return _impl_.node_infos_.size();
}
inline int CMsgDOTALeagueAvailableLobbyNodes::node_infos_size() const {
  return _internal_node_infos_size();
}
inline void CMsgDOTALeagueAvailableLobbyNodes::clear_node_infos() {
  _impl_.node_infos_.Clear();
}
inline ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* CMsgDOTALeagueAvailableLobbyNodes::mutable_node_infos(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueAvailableLobbyNodes.node_infos)
  return _impl_.node_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo >*
CMsgDOTALeagueAvailableLobbyNodes::mutable_node_infos() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueAvailableLobbyNodes.node_infos)
  return &_impl_.node_infos_;
}
inline const ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& CMsgDOTALeagueAvailableLobbyNodes::_internal_node_infos(int index) const {
  return _impl_.node_infos_.Get(index);
}
inline const ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& CMsgDOTALeagueAvailableLobbyNodes::node_infos(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueAvailableLobbyNodes.node_infos)
  return _internal_node_infos(index);
}
inline ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* CMsgDOTALeagueAvailableLobbyNodes::_internal_add_node_infos() {
  return _impl_.node_infos_.Add();
}
inline ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* CMsgDOTALeagueAvailableLobbyNodes::add_node_infos() {
  ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* _add = _internal_add_node_infos();
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueAvailableLobbyNodes.node_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo >&
CMsgDOTALeagueAvailableLobbyNodes::node_infos() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueAvailableLobbyNodes.node_infos)
  return _impl_.node_infos_;
}

// -------------------------------------------------------------------

// CMsgDOTALeagueNodeResults_Result

// optional uint32 node_id = 1;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_node_id() const {
  return _internal_has_node_id();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_node_id() {
  _impl_.node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::_internal_node_id() const {
  return _impl_.node_id_;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::node_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.node_id)
  return _internal_node_id();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.node_id_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_node_id(uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.node_id)
}

// optional uint32 winning_node_id = 2;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_winning_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_winning_node_id() const {
  return _internal_has_winning_node_id();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_winning_node_id() {
  _impl_.winning_node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::_internal_winning_node_id() const {
  return _impl_.winning_node_id_;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::winning_node_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.winning_node_id)
  return _internal_winning_node_id();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_winning_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.winning_node_id_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_winning_node_id(uint32_t value) {
  _internal_set_winning_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.winning_node_id)
}

// optional uint32 losing_node_id = 3;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_losing_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_losing_node_id() const {
  return _internal_has_losing_node_id();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_losing_node_id() {
  _impl_.losing_node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::_internal_losing_node_id() const {
  return _impl_.losing_node_id_;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::losing_node_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.losing_node_id)
  return _internal_losing_node_id();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_losing_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.losing_node_id_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_losing_node_id(uint32_t value) {
  _internal_set_losing_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.losing_node_id)
}

// optional uint32 incoming_node_id_1 = 4;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_incoming_node_id_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_incoming_node_id_1() const {
  return _internal_has_incoming_node_id_1();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_incoming_node_id_1() {
  _impl_.incoming_node_id_1_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::_internal_incoming_node_id_1() const {
  return _impl_.incoming_node_id_1_;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::incoming_node_id_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.incoming_node_id_1)
  return _internal_incoming_node_id_1();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_incoming_node_id_1(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.incoming_node_id_1_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_incoming_node_id_1(uint32_t value) {
  _internal_set_incoming_node_id_1(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.incoming_node_id_1)
}

// optional uint32 incoming_node_id_2 = 5;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_incoming_node_id_2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_incoming_node_id_2() const {
  return _internal_has_incoming_node_id_2();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_incoming_node_id_2() {
  _impl_.incoming_node_id_2_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::_internal_incoming_node_id_2() const {
  return _impl_.incoming_node_id_2_;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::incoming_node_id_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.incoming_node_id_2)
  return _internal_incoming_node_id_2();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_incoming_node_id_2(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.incoming_node_id_2_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_incoming_node_id_2(uint32_t value) {
  _internal_set_incoming_node_id_2(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.incoming_node_id_2)
}

// optional uint32 team_id_1 = 6;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_team_id_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_team_id_1() const {
  return _internal_has_team_id_1();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_team_id_1() {
  _impl_.team_id_1_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::_internal_team_id_1() const {
  return _impl_.team_id_1_;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::team_id_1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.team_id_1)
  return _internal_team_id_1();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_team_id_1(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.team_id_1_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_team_id_1(uint32_t value) {
  _internal_set_team_id_1(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.team_id_1)
}

// optional uint32 team_id_2 = 7;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_team_id_2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_team_id_2() const {
  return _internal_has_team_id_2();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_team_id_2() {
  _impl_.team_id_2_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::_internal_team_id_2() const {
  return _impl_.team_id_2_;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::team_id_2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.team_id_2)
  return _internal_team_id_2();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_team_id_2(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.team_id_2_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_team_id_2(uint32_t value) {
  _internal_set_team_id_2(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.team_id_2)
}

// optional string team_1_name = 8;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_team_1_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_team_1_name() const {
  return _internal_has_team_1_name();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_team_1_name() {
  _impl_.team_1_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTALeagueNodeResults_Result::team_1_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.team_1_name)
  return _internal_team_1_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueNodeResults_Result::set_team_1_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.team_1_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.team_1_name)
}
inline std::string* CMsgDOTALeagueNodeResults_Result::mutable_team_1_name() {
  std::string* _s = _internal_mutable_team_1_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNodeResults.Result.team_1_name)
  return _s;
}
inline const std::string& CMsgDOTALeagueNodeResults_Result::_internal_team_1_name() const {
  return _impl_.team_1_name_.Get();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_team_1_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.team_1_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeResults_Result::_internal_mutable_team_1_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.team_1_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeResults_Result::release_team_1_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueNodeResults.Result.team_1_name)
  if (!_internal_has_team_1_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.team_1_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_1_name_.IsDefault()) {
    _impl_.team_1_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueNodeResults_Result::set_allocated_team_1_name(std::string* team_1_name) {
  if (team_1_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.team_1_name_.SetAllocated(team_1_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_1_name_.IsDefault()) {
    _impl_.team_1_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueNodeResults.Result.team_1_name)
}

// optional string team_2_name = 9;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_team_2_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_team_2_name() const {
  return _internal_has_team_2_name();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_team_2_name() {
  _impl_.team_2_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTALeagueNodeResults_Result::team_2_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.team_2_name)
  return _internal_team_2_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTALeagueNodeResults_Result::set_team_2_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.team_2_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.team_2_name)
}
inline std::string* CMsgDOTALeagueNodeResults_Result::mutable_team_2_name() {
  std::string* _s = _internal_mutable_team_2_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNodeResults.Result.team_2_name)
  return _s;
}
inline const std::string& CMsgDOTALeagueNodeResults_Result::_internal_team_2_name() const {
  return _impl_.team_2_name_.Get();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_team_2_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.team_2_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeResults_Result::_internal_mutable_team_2_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.team_2_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTALeagueNodeResults_Result::release_team_2_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTALeagueNodeResults.Result.team_2_name)
  if (!_internal_has_team_2_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.team_2_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_2_name_.IsDefault()) {
    _impl_.team_2_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTALeagueNodeResults_Result::set_allocated_team_2_name(std::string* team_2_name) {
  if (team_2_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.team_2_name_.SetAllocated(team_2_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_2_name_.IsDefault()) {
    _impl_.team_2_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTALeagueNodeResults.Result.team_2_name)
}

// optional uint32 team_1_wins = 10;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_team_1_wins() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_team_1_wins() const {
  return _internal_has_team_1_wins();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_team_1_wins() {
  _impl_.team_1_wins_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::_internal_team_1_wins() const {
  return _impl_.team_1_wins_;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::team_1_wins() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.team_1_wins)
  return _internal_team_1_wins();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_team_1_wins(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.team_1_wins_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_team_1_wins(uint32_t value) {
  _internal_set_team_1_wins(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.team_1_wins)
}

// optional uint32 team_2_wins = 11;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_team_2_wins() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_team_2_wins() const {
  return _internal_has_team_2_wins();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_team_2_wins() {
  _impl_.team_2_wins_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::_internal_team_2_wins() const {
  return _impl_.team_2_wins_;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::team_2_wins() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.team_2_wins)
  return _internal_team_2_wins();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_team_2_wins(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.team_2_wins_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_team_2_wins(uint32_t value) {
  _internal_set_team_2_wins(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.team_2_wins)
}

// optional uint32 winning_team_id = 12;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_winning_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_winning_team_id() const {
  return _internal_has_winning_team_id();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_winning_team_id() {
  _impl_.winning_team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::_internal_winning_team_id() const {
  return _impl_.winning_team_id_;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::winning_team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.winning_team_id)
  return _internal_winning_team_id();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_winning_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.winning_team_id_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_winning_team_id(uint32_t value) {
  _internal_set_winning_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.winning_team_id)
}

// optional uint32 losing_team_id = 13;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_losing_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_losing_team_id() const {
  return _internal_has_losing_team_id();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_losing_team_id() {
  _impl_.losing_team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::_internal_losing_team_id() const {
  return _impl_.losing_team_id_;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::losing_team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.losing_team_id)
  return _internal_losing_team_id();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_losing_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.losing_team_id_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_losing_team_id(uint32_t value) {
  _internal_set_losing_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.losing_team_id)
}

// optional bool has_started = 14;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_has_started() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_has_started() const {
  return _internal_has_has_started();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_has_started() {
  _impl_.has_started_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_started() const {
  return _impl_.has_started_;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_started() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.has_started)
  return _internal_has_started();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_has_started(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.has_started_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_has_started(bool value) {
  _internal_set_has_started(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.has_started)
}

// optional bool is_completed = 15;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_is_completed() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_is_completed() const {
  return _internal_has_is_completed();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_is_completed() {
  _impl_.is_completed_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool CMsgDOTALeagueNodeResults_Result::_internal_is_completed() const {
  return _impl_.is_completed_;
}
inline bool CMsgDOTALeagueNodeResults_Result::is_completed() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.is_completed)
  return _internal_is_completed();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_is_completed(bool value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.is_completed_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_is_completed(bool value) {
  _internal_set_is_completed(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.is_completed)
}

// optional uint32 scheduled_time = 16;
inline bool CMsgDOTALeagueNodeResults_Result::_internal_has_scheduled_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_scheduled_time() const {
  return _internal_has_scheduled_time();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_scheduled_time() {
  _impl_.scheduled_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::_internal_scheduled_time() const {
  return _impl_.scheduled_time_;
}
inline uint32_t CMsgDOTALeagueNodeResults_Result::scheduled_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.scheduled_time)
  return _internal_scheduled_time();
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_set_scheduled_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.scheduled_time_ = value;
}
inline void CMsgDOTALeagueNodeResults_Result::set_scheduled_time(uint32_t value) {
  _internal_set_scheduled_time(value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.scheduled_time)
}

// repeated uint64 match_ids = 17;
inline int CMsgDOTALeagueNodeResults_Result::_internal_match_ids_size() const {
  return _impl_.match_ids_.size();
}
inline int CMsgDOTALeagueNodeResults_Result::match_ids_size() const {
  return _internal_match_ids_size();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_match_ids() {
  _impl_.match_ids_.Clear();
}
inline uint64_t CMsgDOTALeagueNodeResults_Result::_internal_match_ids(int index) const {
  return _impl_.match_ids_.Get(index);
}
inline uint64_t CMsgDOTALeagueNodeResults_Result::match_ids(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.Result.match_ids)
  return _internal_match_ids(index);
}
inline void CMsgDOTALeagueNodeResults_Result::set_match_ids(int index, uint64_t value) {
  _impl_.match_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTALeagueNodeResults.Result.match_ids)
}
inline void CMsgDOTALeagueNodeResults_Result::_internal_add_match_ids(uint64_t value) {
  _impl_.match_ids_.Add(value);
}
inline void CMsgDOTALeagueNodeResults_Result::add_match_ids(uint64_t value) {
  _internal_add_match_ids(value);
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueNodeResults.Result.match_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CMsgDOTALeagueNodeResults_Result::_internal_match_ids() const {
  return _impl_.match_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CMsgDOTALeagueNodeResults_Result::match_ids() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueNodeResults.Result.match_ids)
  return _internal_match_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CMsgDOTALeagueNodeResults_Result::_internal_mutable_match_ids() {
  return &_impl_.match_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CMsgDOTALeagueNodeResults_Result::mutable_match_ids() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueNodeResults.Result.match_ids)
  return _internal_mutable_match_ids();
}

// -------------------------------------------------------------------

// CMsgDOTALeagueNodeResults

// repeated .CMsgDOTALeagueNodeResults.Result node_results = 1;
inline int CMsgDOTALeagueNodeResults::_internal_node_results_size() const {
  return _impl_.node_results_.size();
}
inline int CMsgDOTALeagueNodeResults::node_results_size() const {
  return _internal_node_results_size();
}
inline void CMsgDOTALeagueNodeResults::clear_node_results() {
  _impl_.node_results_.Clear();
}
inline ::CMsgDOTALeagueNodeResults_Result* CMsgDOTALeagueNodeResults::mutable_node_results(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTALeagueNodeResults.node_results)
  return _impl_.node_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeResults_Result >*
CMsgDOTALeagueNodeResults::mutable_node_results() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTALeagueNodeResults.node_results)
  return &_impl_.node_results_;
}
inline const ::CMsgDOTALeagueNodeResults_Result& CMsgDOTALeagueNodeResults::_internal_node_results(int index) const {
  return _impl_.node_results_.Get(index);
}
inline const ::CMsgDOTALeagueNodeResults_Result& CMsgDOTALeagueNodeResults::node_results(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTALeagueNodeResults.node_results)
  return _internal_node_results(index);
}
inline ::CMsgDOTALeagueNodeResults_Result* CMsgDOTALeagueNodeResults::_internal_add_node_results() {
  return _impl_.node_results_.Add();
}
inline ::CMsgDOTALeagueNodeResults_Result* CMsgDOTALeagueNodeResults::add_node_results() {
  ::CMsgDOTALeagueNodeResults_Result* _add = _internal_add_node_results();
  // @@protoc_insertion_point(field_add:CMsgDOTALeagueNodeResults.node_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTALeagueNodeResults_Result >&
CMsgDOTALeagueNodeResults::node_results() const {
  // @@protoc_insertion_point(field_list:CMsgDOTALeagueNodeResults.node_results)
  return _impl_.node_results_;
}

// -------------------------------------------------------------------

// CMsgDOTADPCLeagueResults_Result

// optional uint32 standing = 1;
inline bool CMsgDOTADPCLeagueResults_Result::_internal_has_standing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTADPCLeagueResults_Result::has_standing() const {
  return _internal_has_standing();
}
inline void CMsgDOTADPCLeagueResults_Result::clear_standing() {
  _impl_.standing_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTADPCLeagueResults_Result::_internal_standing() const {
  return _impl_.standing_;
}
inline uint32_t CMsgDOTADPCLeagueResults_Result::standing() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.Result.standing)
  return _internal_standing();
}
inline void CMsgDOTADPCLeagueResults_Result::_internal_set_standing(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.standing_ = value;
}
inline void CMsgDOTADPCLeagueResults_Result::set_standing(uint32_t value) {
  _internal_set_standing(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCLeagueResults.Result.standing)
}

// optional uint32 team_id = 2;
inline bool CMsgDOTADPCLeagueResults_Result::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTADPCLeagueResults_Result::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDOTADPCLeagueResults_Result::clear_team_id() {
  _impl_.team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTADPCLeagueResults_Result::_internal_team_id() const {
  return _impl_.team_id_;
}
inline uint32_t CMsgDOTADPCLeagueResults_Result::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.Result.team_id)
  return _internal_team_id();
}
inline void CMsgDOTADPCLeagueResults_Result::_internal_set_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.team_id_ = value;
}
inline void CMsgDOTADPCLeagueResults_Result::set_team_id(uint32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCLeagueResults.Result.team_id)
}

// optional string team_name = 3;
inline bool CMsgDOTADPCLeagueResults_Result::_internal_has_team_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTADPCLeagueResults_Result::has_team_name() const {
  return _internal_has_team_name();
}
inline void CMsgDOTADPCLeagueResults_Result::clear_team_name() {
  _impl_.team_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTADPCLeagueResults_Result::team_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.Result.team_name)
  return _internal_team_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTADPCLeagueResults_Result::set_team_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.team_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTADPCLeagueResults.Result.team_name)
}
inline std::string* CMsgDOTADPCLeagueResults_Result::mutable_team_name() {
  std::string* _s = _internal_mutable_team_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCLeagueResults.Result.team_name)
  return _s;
}
inline const std::string& CMsgDOTADPCLeagueResults_Result::_internal_team_name() const {
  return _impl_.team_name_.Get();
}
inline void CMsgDOTADPCLeagueResults_Result::_internal_set_team_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.team_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCLeagueResults_Result::_internal_mutable_team_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.team_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCLeagueResults_Result::release_team_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTADPCLeagueResults.Result.team_name)
  if (!_internal_has_team_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.team_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_name_.IsDefault()) {
    _impl_.team_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTADPCLeagueResults_Result::set_allocated_team_name(std::string* team_name) {
  if (team_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.team_name_.SetAllocated(team_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_name_.IsDefault()) {
    _impl_.team_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTADPCLeagueResults.Result.team_name)
}

// optional uint64 team_logo = 4;
inline bool CMsgDOTADPCLeagueResults_Result::_internal_has_team_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTADPCLeagueResults_Result::has_team_logo() const {
  return _internal_has_team_logo();
}
inline void CMsgDOTADPCLeagueResults_Result::clear_team_logo() {
  _impl_.team_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t CMsgDOTADPCLeagueResults_Result::_internal_team_logo() const {
  return _impl_.team_logo_;
}
inline uint64_t CMsgDOTADPCLeagueResults_Result::team_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.Result.team_logo)
  return _internal_team_logo();
}
inline void CMsgDOTADPCLeagueResults_Result::_internal_set_team_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.team_logo_ = value;
}
inline void CMsgDOTADPCLeagueResults_Result::set_team_logo(uint64_t value) {
  _internal_set_team_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCLeagueResults.Result.team_logo)
}

// optional string team_logo_url = 5;
inline bool CMsgDOTADPCLeagueResults_Result::_internal_has_team_logo_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTADPCLeagueResults_Result::has_team_logo_url() const {
  return _internal_has_team_logo_url();
}
inline void CMsgDOTADPCLeagueResults_Result::clear_team_logo_url() {
  _impl_.team_logo_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTADPCLeagueResults_Result::team_logo_url() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.Result.team_logo_url)
  return _internal_team_logo_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTADPCLeagueResults_Result::set_team_logo_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.team_logo_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTADPCLeagueResults.Result.team_logo_url)
}
inline std::string* CMsgDOTADPCLeagueResults_Result::mutable_team_logo_url() {
  std::string* _s = _internal_mutable_team_logo_url();
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCLeagueResults.Result.team_logo_url)
  return _s;
}
inline const std::string& CMsgDOTADPCLeagueResults_Result::_internal_team_logo_url() const {
  return _impl_.team_logo_url_.Get();
}
inline void CMsgDOTADPCLeagueResults_Result::_internal_set_team_logo_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.team_logo_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCLeagueResults_Result::_internal_mutable_team_logo_url() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.team_logo_url_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCLeagueResults_Result::release_team_logo_url() {
  // @@protoc_insertion_point(field_release:CMsgDOTADPCLeagueResults.Result.team_logo_url)
  if (!_internal_has_team_logo_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.team_logo_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_logo_url_.IsDefault()) {
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTADPCLeagueResults_Result::set_allocated_team_logo_url(std::string* team_logo_url) {
  if (team_logo_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.team_logo_url_.SetAllocated(team_logo_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_logo_url_.IsDefault()) {
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTADPCLeagueResults.Result.team_logo_url)
}

// optional uint32 points = 6;
inline bool CMsgDOTADPCLeagueResults_Result::_internal_has_points() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTADPCLeagueResults_Result::has_points() const {
  return _internal_has_points();
}
inline void CMsgDOTADPCLeagueResults_Result::clear_points() {
  _impl_.points_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CMsgDOTADPCLeagueResults_Result::_internal_points() const {
  return _impl_.points_;
}
inline uint32_t CMsgDOTADPCLeagueResults_Result::points() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.Result.points)
  return _internal_points();
}
inline void CMsgDOTADPCLeagueResults_Result::_internal_set_points(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.points_ = value;
}
inline void CMsgDOTADPCLeagueResults_Result::set_points(uint32_t value) {
  _internal_set_points(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCLeagueResults.Result.points)
}

// optional uint32 earnings = 7;
inline bool CMsgDOTADPCLeagueResults_Result::_internal_has_earnings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTADPCLeagueResults_Result::has_earnings() const {
  return _internal_has_earnings();
}
inline void CMsgDOTADPCLeagueResults_Result::clear_earnings() {
  _impl_.earnings_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CMsgDOTADPCLeagueResults_Result::_internal_earnings() const {
  return _impl_.earnings_;
}
inline uint32_t CMsgDOTADPCLeagueResults_Result::earnings() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.Result.earnings)
  return _internal_earnings();
}
inline void CMsgDOTADPCLeagueResults_Result::_internal_set_earnings(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.earnings_ = value;
}
inline void CMsgDOTADPCLeagueResults_Result::set_earnings(uint32_t value) {
  _internal_set_earnings(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCLeagueResults.Result.earnings)
}

// optional uint32 timestamp = 8;
inline bool CMsgDOTADPCLeagueResults_Result::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTADPCLeagueResults_Result::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CMsgDOTADPCLeagueResults_Result::clear_timestamp() {
  _impl_.timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CMsgDOTADPCLeagueResults_Result::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint32_t CMsgDOTADPCLeagueResults_Result::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.Result.timestamp)
  return _internal_timestamp();
}
inline void CMsgDOTADPCLeagueResults_Result::_internal_set_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.timestamp_ = value;
}
inline void CMsgDOTADPCLeagueResults_Result::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCLeagueResults.Result.timestamp)
}

// optional .ELeaguePhase phase = 9 [default = LEAGUE_PHASE_UNSET];
inline bool CMsgDOTADPCLeagueResults_Result::_internal_has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTADPCLeagueResults_Result::has_phase() const {
  return _internal_has_phase();
}
inline void CMsgDOTADPCLeagueResults_Result::clear_phase() {
  _impl_.phase_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::ELeaguePhase CMsgDOTADPCLeagueResults_Result::_internal_phase() const {
  return static_cast< ::ELeaguePhase >(_impl_.phase_);
}
inline ::ELeaguePhase CMsgDOTADPCLeagueResults_Result::phase() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.Result.phase)
  return _internal_phase();
}
inline void CMsgDOTADPCLeagueResults_Result::_internal_set_phase(::ELeaguePhase value) {
  assert(::ELeaguePhase_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.phase_ = value;
}
inline void CMsgDOTADPCLeagueResults_Result::set_phase(::ELeaguePhase value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCLeagueResults.Result.phase)
}

// optional string team_abbreviation = 10;
inline bool CMsgDOTADPCLeagueResults_Result::_internal_has_team_abbreviation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTADPCLeagueResults_Result::has_team_abbreviation() const {
  return _internal_has_team_abbreviation();
}
inline void CMsgDOTADPCLeagueResults_Result::clear_team_abbreviation() {
  _impl_.team_abbreviation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgDOTADPCLeagueResults_Result::team_abbreviation() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.Result.team_abbreviation)
  return _internal_team_abbreviation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTADPCLeagueResults_Result::set_team_abbreviation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.team_abbreviation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTADPCLeagueResults.Result.team_abbreviation)
}
inline std::string* CMsgDOTADPCLeagueResults_Result::mutable_team_abbreviation() {
  std::string* _s = _internal_mutable_team_abbreviation();
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCLeagueResults.Result.team_abbreviation)
  return _s;
}
inline const std::string& CMsgDOTADPCLeagueResults_Result::_internal_team_abbreviation() const {
  return _impl_.team_abbreviation_.Get();
}
inline void CMsgDOTADPCLeagueResults_Result::_internal_set_team_abbreviation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.team_abbreviation_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCLeagueResults_Result::_internal_mutable_team_abbreviation() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.team_abbreviation_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCLeagueResults_Result::release_team_abbreviation() {
  // @@protoc_insertion_point(field_release:CMsgDOTADPCLeagueResults.Result.team_abbreviation)
  if (!_internal_has_team_abbreviation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.team_abbreviation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_abbreviation_.IsDefault()) {
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTADPCLeagueResults_Result::set_allocated_team_abbreviation(std::string* team_abbreviation) {
  if (team_abbreviation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.team_abbreviation_.SetAllocated(team_abbreviation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_abbreviation_.IsDefault()) {
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTADPCLeagueResults.Result.team_abbreviation)
}

// -------------------------------------------------------------------

// CMsgDOTADPCLeagueResults

// repeated .CMsgDOTADPCLeagueResults.Result results = 1;
inline int CMsgDOTADPCLeagueResults::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int CMsgDOTADPCLeagueResults::results_size() const {
  return _internal_results_size();
}
inline void CMsgDOTADPCLeagueResults::clear_results() {
  _impl_.results_.Clear();
}
inline ::CMsgDOTADPCLeagueResults_Result* CMsgDOTADPCLeagueResults::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCLeagueResults.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCLeagueResults_Result >*
CMsgDOTADPCLeagueResults::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTADPCLeagueResults.results)
  return &_impl_.results_;
}
inline const ::CMsgDOTADPCLeagueResults_Result& CMsgDOTADPCLeagueResults::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::CMsgDOTADPCLeagueResults_Result& CMsgDOTADPCLeagueResults::results(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.results)
  return _internal_results(index);
}
inline ::CMsgDOTADPCLeagueResults_Result* CMsgDOTADPCLeagueResults::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::CMsgDOTADPCLeagueResults_Result* CMsgDOTADPCLeagueResults::add_results() {
  ::CMsgDOTADPCLeagueResults_Result* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:CMsgDOTADPCLeagueResults.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCLeagueResults_Result >&
CMsgDOTADPCLeagueResults::results() const {
  // @@protoc_insertion_point(field_list:CMsgDOTADPCLeagueResults.results)
  return _impl_.results_;
}

// repeated uint32 points = 2;
inline int CMsgDOTADPCLeagueResults::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int CMsgDOTADPCLeagueResults::points_size() const {
  return _internal_points_size();
}
inline void CMsgDOTADPCLeagueResults::clear_points() {
  _impl_.points_.Clear();
}
inline uint32_t CMsgDOTADPCLeagueResults::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline uint32_t CMsgDOTADPCLeagueResults::points(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.points)
  return _internal_points(index);
}
inline void CMsgDOTADPCLeagueResults::set_points(int index, uint32_t value) {
  _impl_.points_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCLeagueResults.points)
}
inline void CMsgDOTADPCLeagueResults::_internal_add_points(uint32_t value) {
  _impl_.points_.Add(value);
}
inline void CMsgDOTADPCLeagueResults::add_points(uint32_t value) {
  _internal_add_points(value);
  // @@protoc_insertion_point(field_add:CMsgDOTADPCLeagueResults.points)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgDOTADPCLeagueResults::_internal_points() const {
  return _impl_.points_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgDOTADPCLeagueResults::points() const {
  // @@protoc_insertion_point(field_list:CMsgDOTADPCLeagueResults.points)
  return _internal_points();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgDOTADPCLeagueResults::_internal_mutable_points() {
  return &_impl_.points_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgDOTADPCLeagueResults::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTADPCLeagueResults.points)
  return _internal_mutable_points();
}

// repeated uint32 dollars = 3;
inline int CMsgDOTADPCLeagueResults::_internal_dollars_size() const {
  return _impl_.dollars_.size();
}
inline int CMsgDOTADPCLeagueResults::dollars_size() const {
  return _internal_dollars_size();
}
inline void CMsgDOTADPCLeagueResults::clear_dollars() {
  _impl_.dollars_.Clear();
}
inline uint32_t CMsgDOTADPCLeagueResults::_internal_dollars(int index) const {
  return _impl_.dollars_.Get(index);
}
inline uint32_t CMsgDOTADPCLeagueResults::dollars(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCLeagueResults.dollars)
  return _internal_dollars(index);
}
inline void CMsgDOTADPCLeagueResults::set_dollars(int index, uint32_t value) {
  _impl_.dollars_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCLeagueResults.dollars)
}
inline void CMsgDOTADPCLeagueResults::_internal_add_dollars(uint32_t value) {
  _impl_.dollars_.Add(value);
}
inline void CMsgDOTADPCLeagueResults::add_dollars(uint32_t value) {
  _internal_add_dollars(value);
  // @@protoc_insertion_point(field_add:CMsgDOTADPCLeagueResults.dollars)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgDOTADPCLeagueResults::_internal_dollars() const {
  return _impl_.dollars_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CMsgDOTADPCLeagueResults::dollars() const {
  // @@protoc_insertion_point(field_list:CMsgDOTADPCLeagueResults.dollars)
  return _internal_dollars();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgDOTADPCLeagueResults::_internal_mutable_dollars() {
  return &_impl_.dollars_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CMsgDOTADPCLeagueResults::mutable_dollars() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTADPCLeagueResults.dollars)
  return _internal_mutable_dollars();
}

// -------------------------------------------------------------------

// CMsgDOTADPCTeamResults_Result

// optional uint32 league_id = 1;
inline bool CMsgDOTADPCTeamResults_Result::_internal_has_league_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTADPCTeamResults_Result::has_league_id() const {
  return _internal_has_league_id();
}
inline void CMsgDOTADPCTeamResults_Result::clear_league_id() {
  _impl_.league_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTADPCTeamResults_Result::_internal_league_id() const {
  return _impl_.league_id_;
}
inline uint32_t CMsgDOTADPCTeamResults_Result::league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCTeamResults.Result.league_id)
  return _internal_league_id();
}
inline void CMsgDOTADPCTeamResults_Result::_internal_set_league_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.league_id_ = value;
}
inline void CMsgDOTADPCTeamResults_Result::set_league_id(uint32_t value) {
  _internal_set_league_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCTeamResults.Result.league_id)
}

// optional uint32 standing = 2;
inline bool CMsgDOTADPCTeamResults_Result::_internal_has_standing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTADPCTeamResults_Result::has_standing() const {
  return _internal_has_standing();
}
inline void CMsgDOTADPCTeamResults_Result::clear_standing() {
  _impl_.standing_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTADPCTeamResults_Result::_internal_standing() const {
  return _impl_.standing_;
}
inline uint32_t CMsgDOTADPCTeamResults_Result::standing() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCTeamResults.Result.standing)
  return _internal_standing();
}
inline void CMsgDOTADPCTeamResults_Result::_internal_set_standing(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.standing_ = value;
}
inline void CMsgDOTADPCTeamResults_Result::set_standing(uint32_t value) {
  _internal_set_standing(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCTeamResults.Result.standing)
}

// optional uint32 points = 3;
inline bool CMsgDOTADPCTeamResults_Result::_internal_has_points() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTADPCTeamResults_Result::has_points() const {
  return _internal_has_points();
}
inline void CMsgDOTADPCTeamResults_Result::clear_points() {
  _impl_.points_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTADPCTeamResults_Result::_internal_points() const {
  return _impl_.points_;
}
inline uint32_t CMsgDOTADPCTeamResults_Result::points() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCTeamResults.Result.points)
  return _internal_points();
}
inline void CMsgDOTADPCTeamResults_Result::_internal_set_points(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.points_ = value;
}
inline void CMsgDOTADPCTeamResults_Result::set_points(uint32_t value) {
  _internal_set_points(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCTeamResults.Result.points)
}

// optional uint32 earnings = 4;
inline bool CMsgDOTADPCTeamResults_Result::_internal_has_earnings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTADPCTeamResults_Result::has_earnings() const {
  return _internal_has_earnings();
}
inline void CMsgDOTADPCTeamResults_Result::clear_earnings() {
  _impl_.earnings_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTADPCTeamResults_Result::_internal_earnings() const {
  return _impl_.earnings_;
}
inline uint32_t CMsgDOTADPCTeamResults_Result::earnings() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCTeamResults.Result.earnings)
  return _internal_earnings();
}
inline void CMsgDOTADPCTeamResults_Result::_internal_set_earnings(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.earnings_ = value;
}
inline void CMsgDOTADPCTeamResults_Result::set_earnings(uint32_t value) {
  _internal_set_earnings(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCTeamResults.Result.earnings)
}

// optional uint32 timestamp = 5;
inline bool CMsgDOTADPCTeamResults_Result::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTADPCTeamResults_Result::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CMsgDOTADPCTeamResults_Result::clear_timestamp() {
  _impl_.timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTADPCTeamResults_Result::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint32_t CMsgDOTADPCTeamResults_Result::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCTeamResults.Result.timestamp)
  return _internal_timestamp();
}
inline void CMsgDOTADPCTeamResults_Result::_internal_set_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.timestamp_ = value;
}
inline void CMsgDOTADPCTeamResults_Result::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCTeamResults.Result.timestamp)
}

// -------------------------------------------------------------------

// CMsgDOTADPCTeamResults

// repeated .CMsgDOTADPCTeamResults.Result results = 1;
inline int CMsgDOTADPCTeamResults::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int CMsgDOTADPCTeamResults::results_size() const {
  return _internal_results_size();
}
inline void CMsgDOTADPCTeamResults::clear_results() {
  _impl_.results_.Clear();
}
inline ::CMsgDOTADPCTeamResults_Result* CMsgDOTADPCTeamResults::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCTeamResults.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCTeamResults_Result >*
CMsgDOTADPCTeamResults::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTADPCTeamResults.results)
  return &_impl_.results_;
}
inline const ::CMsgDOTADPCTeamResults_Result& CMsgDOTADPCTeamResults::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::CMsgDOTADPCTeamResults_Result& CMsgDOTADPCTeamResults::results(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCTeamResults.results)
  return _internal_results(index);
}
inline ::CMsgDOTADPCTeamResults_Result* CMsgDOTADPCTeamResults::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::CMsgDOTADPCTeamResults_Result* CMsgDOTADPCTeamResults::add_results() {
  ::CMsgDOTADPCTeamResults_Result* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:CMsgDOTADPCTeamResults.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCTeamResults_Result >&
CMsgDOTADPCTeamResults::results() const {
  // @@protoc_insertion_point(field_list:CMsgDOTADPCTeamResults.results)
  return _impl_.results_;
}

// -------------------------------------------------------------------

// CMsgDOTADPCSeasonResults_TeamLeagueResult

// optional uint32 timestamp = 1;
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::clear_timestamp() {
  _impl_.timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamLeagueResult.timestamp)
  return _internal_timestamp();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_set_timestamp(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ = value;
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamLeagueResult.timestamp)
}

// optional uint32 league_id = 2;
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_has_league_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::has_league_id() const {
  return _internal_has_league_id();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::clear_league_id() {
  _impl_.league_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_league_id() const {
  return _impl_.league_id_;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::league_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamLeagueResult.league_id)
  return _internal_league_id();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_set_league_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.league_id_ = value;
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::set_league_id(uint32_t value) {
  _internal_set_league_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamLeagueResult.league_id)
}

// optional uint32 standing = 3;
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_has_standing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::has_standing() const {
  return _internal_has_standing();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::clear_standing() {
  _impl_.standing_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_standing() const {
  return _impl_.standing_;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::standing() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamLeagueResult.standing)
  return _internal_standing();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_set_standing(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.standing_ = value;
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::set_standing(uint32_t value) {
  _internal_set_standing(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamLeagueResult.standing)
}

// optional uint32 points = 4;
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_has_points() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::has_points() const {
  return _internal_has_points();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::clear_points() {
  _impl_.points_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_points() const {
  return _impl_.points_;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::points() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamLeagueResult.points)
  return _internal_points();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_set_points(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.points_ = value;
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::set_points(uint32_t value) {
  _internal_set_points(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamLeagueResult.points)
}

// optional uint32 earnings = 5;
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_has_earnings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::has_earnings() const {
  return _internal_has_earnings();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::clear_earnings() {
  _impl_.earnings_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_earnings() const {
  return _impl_.earnings_;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::earnings() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamLeagueResult.earnings)
  return _internal_earnings();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_set_earnings(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.earnings_ = value;
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::set_earnings(uint32_t value) {
  _internal_set_earnings(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamLeagueResult.earnings)
}

// optional uint32 audit_action = 6;
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_has_audit_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::has_audit_action() const {
  return _internal_has_audit_action();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::clear_audit_action() {
  _impl_.audit_action_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_audit_action() const {
  return _impl_.audit_action_;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::audit_action() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamLeagueResult.audit_action)
  return _internal_audit_action();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_set_audit_action(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.audit_action_ = value;
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::set_audit_action(uint32_t value) {
  _internal_set_audit_action(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamLeagueResult.audit_action)
}

// optional uint32 audit_data = 7;
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_has_audit_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamLeagueResult::has_audit_data() const {
  return _internal_has_audit_data();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::clear_audit_data() {
  _impl_.audit_data_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_audit_data() const {
  return _impl_.audit_data_;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamLeagueResult::audit_data() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamLeagueResult.audit_data)
  return _internal_audit_data();
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::_internal_set_audit_data(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.audit_data_ = value;
}
inline void CMsgDOTADPCSeasonResults_TeamLeagueResult::set_audit_data(uint32_t value) {
  _internal_set_audit_data(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamLeagueResult.audit_data)
}

// -------------------------------------------------------------------

// CMsgDOTADPCSeasonResults_TeamResult

// optional uint32 team_id = 1;
inline bool CMsgDOTADPCSeasonResults_TeamResult::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamResult::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::clear_team_id() {
  _impl_.team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamResult::_internal_team_id() const {
  return _impl_.team_id_;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamResult::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamResult.team_id)
  return _internal_team_id();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::_internal_set_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.team_id_ = value;
}
inline void CMsgDOTADPCSeasonResults_TeamResult::set_team_id(uint32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamResult.team_id)
}

// optional string team_name = 2;
inline bool CMsgDOTADPCSeasonResults_TeamResult::_internal_has_team_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamResult::has_team_name() const {
  return _internal_has_team_name();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::clear_team_name() {
  _impl_.team_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTADPCSeasonResults_TeamResult::team_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamResult.team_name)
  return _internal_team_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTADPCSeasonResults_TeamResult::set_team_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.team_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamResult.team_name)
}
inline std::string* CMsgDOTADPCSeasonResults_TeamResult::mutable_team_name() {
  std::string* _s = _internal_mutable_team_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.TeamResult.team_name)
  return _s;
}
inline const std::string& CMsgDOTADPCSeasonResults_TeamResult::_internal_team_name() const {
  return _impl_.team_name_.Get();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::_internal_set_team_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.team_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCSeasonResults_TeamResult::_internal_mutable_team_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.team_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCSeasonResults_TeamResult::release_team_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTADPCSeasonResults.TeamResult.team_name)
  if (!_internal_has_team_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.team_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_name_.IsDefault()) {
    _impl_.team_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTADPCSeasonResults_TeamResult::set_allocated_team_name(std::string* team_name) {
  if (team_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.team_name_.SetAllocated(team_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_name_.IsDefault()) {
    _impl_.team_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTADPCSeasonResults.TeamResult.team_name)
}

// optional string team_abbreviation = 8;
inline bool CMsgDOTADPCSeasonResults_TeamResult::_internal_has_team_abbreviation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamResult::has_team_abbreviation() const {
  return _internal_has_team_abbreviation();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::clear_team_abbreviation() {
  _impl_.team_abbreviation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgDOTADPCSeasonResults_TeamResult::team_abbreviation() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamResult.team_abbreviation)
  return _internal_team_abbreviation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTADPCSeasonResults_TeamResult::set_team_abbreviation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.team_abbreviation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamResult.team_abbreviation)
}
inline std::string* CMsgDOTADPCSeasonResults_TeamResult::mutable_team_abbreviation() {
  std::string* _s = _internal_mutable_team_abbreviation();
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.TeamResult.team_abbreviation)
  return _s;
}
inline const std::string& CMsgDOTADPCSeasonResults_TeamResult::_internal_team_abbreviation() const {
  return _impl_.team_abbreviation_.Get();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::_internal_set_team_abbreviation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.team_abbreviation_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCSeasonResults_TeamResult::_internal_mutable_team_abbreviation() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.team_abbreviation_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCSeasonResults_TeamResult::release_team_abbreviation() {
  // @@protoc_insertion_point(field_release:CMsgDOTADPCSeasonResults.TeamResult.team_abbreviation)
  if (!_internal_has_team_abbreviation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.team_abbreviation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_abbreviation_.IsDefault()) {
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTADPCSeasonResults_TeamResult::set_allocated_team_abbreviation(std::string* team_abbreviation) {
  if (team_abbreviation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.team_abbreviation_.SetAllocated(team_abbreviation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_abbreviation_.IsDefault()) {
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTADPCSeasonResults.TeamResult.team_abbreviation)
}

// optional uint64 team_logo = 3;
inline bool CMsgDOTADPCSeasonResults_TeamResult::_internal_has_team_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamResult::has_team_logo() const {
  return _internal_has_team_logo();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::clear_team_logo() {
  _impl_.team_logo_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CMsgDOTADPCSeasonResults_TeamResult::_internal_team_logo() const {
  return _impl_.team_logo_;
}
inline uint64_t CMsgDOTADPCSeasonResults_TeamResult::team_logo() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamResult.team_logo)
  return _internal_team_logo();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::_internal_set_team_logo(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.team_logo_ = value;
}
inline void CMsgDOTADPCSeasonResults_TeamResult::set_team_logo(uint64_t value) {
  _internal_set_team_logo(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamResult.team_logo)
}

// optional string team_logo_url = 4;
inline bool CMsgDOTADPCSeasonResults_TeamResult::_internal_has_team_logo_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamResult::has_team_logo_url() const {
  return _internal_has_team_logo_url();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::clear_team_logo_url() {
  _impl_.team_logo_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTADPCSeasonResults_TeamResult::team_logo_url() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamResult.team_logo_url)
  return _internal_team_logo_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTADPCSeasonResults_TeamResult::set_team_logo_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.team_logo_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamResult.team_logo_url)
}
inline std::string* CMsgDOTADPCSeasonResults_TeamResult::mutable_team_logo_url() {
  std::string* _s = _internal_mutable_team_logo_url();
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.TeamResult.team_logo_url)
  return _s;
}
inline const std::string& CMsgDOTADPCSeasonResults_TeamResult::_internal_team_logo_url() const {
  return _impl_.team_logo_url_.Get();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::_internal_set_team_logo_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.team_logo_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCSeasonResults_TeamResult::_internal_mutable_team_logo_url() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.team_logo_url_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCSeasonResults_TeamResult::release_team_logo_url() {
  // @@protoc_insertion_point(field_release:CMsgDOTADPCSeasonResults.TeamResult.team_logo_url)
  if (!_internal_has_team_logo_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.team_logo_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_logo_url_.IsDefault()) {
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTADPCSeasonResults_TeamResult::set_allocated_team_logo_url(std::string* team_logo_url) {
  if (team_logo_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.team_logo_url_.SetAllocated(team_logo_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_logo_url_.IsDefault()) {
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTADPCSeasonResults.TeamResult.team_logo_url)
}

// optional uint32 total_points = 5;
inline bool CMsgDOTADPCSeasonResults_TeamResult::_internal_has_total_points() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamResult::has_total_points() const {
  return _internal_has_total_points();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::clear_total_points() {
  _impl_.total_points_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamResult::_internal_total_points() const {
  return _impl_.total_points_;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamResult::total_points() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamResult.total_points)
  return _internal_total_points();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::_internal_set_total_points(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.total_points_ = value;
}
inline void CMsgDOTADPCSeasonResults_TeamResult::set_total_points(uint32_t value) {
  _internal_set_total_points(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamResult.total_points)
}

// optional uint32 total_earnings = 6;
inline bool CMsgDOTADPCSeasonResults_TeamResult::_internal_has_total_earnings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_TeamResult::has_total_earnings() const {
  return _internal_has_total_earnings();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::clear_total_earnings() {
  _impl_.total_earnings_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamResult::_internal_total_earnings() const {
  return _impl_.total_earnings_;
}
inline uint32_t CMsgDOTADPCSeasonResults_TeamResult::total_earnings() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamResult.total_earnings)
  return _internal_total_earnings();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::_internal_set_total_earnings(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.total_earnings_ = value;
}
inline void CMsgDOTADPCSeasonResults_TeamResult::set_total_earnings(uint32_t value) {
  _internal_set_total_earnings(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.TeamResult.total_earnings)
}

// repeated .CMsgDOTADPCSeasonResults.TeamLeagueResult league_results = 7;
inline int CMsgDOTADPCSeasonResults_TeamResult::_internal_league_results_size() const {
  return _impl_.league_results_.size();
}
inline int CMsgDOTADPCSeasonResults_TeamResult::league_results_size() const {
  return _internal_league_results_size();
}
inline void CMsgDOTADPCSeasonResults_TeamResult::clear_league_results() {
  _impl_.league_results_.Clear();
}
inline ::CMsgDOTADPCSeasonResults_TeamLeagueResult* CMsgDOTADPCSeasonResults_TeamResult::mutable_league_results(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.TeamResult.league_results)
  return _impl_.league_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_TeamLeagueResult >*
CMsgDOTADPCSeasonResults_TeamResult::mutable_league_results() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTADPCSeasonResults.TeamResult.league_results)
  return &_impl_.league_results_;
}
inline const ::CMsgDOTADPCSeasonResults_TeamLeagueResult& CMsgDOTADPCSeasonResults_TeamResult::_internal_league_results(int index) const {
  return _impl_.league_results_.Get(index);
}
inline const ::CMsgDOTADPCSeasonResults_TeamLeagueResult& CMsgDOTADPCSeasonResults_TeamResult::league_results(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.TeamResult.league_results)
  return _internal_league_results(index);
}
inline ::CMsgDOTADPCSeasonResults_TeamLeagueResult* CMsgDOTADPCSeasonResults_TeamResult::_internal_add_league_results() {
  return _impl_.league_results_.Add();
}
inline ::CMsgDOTADPCSeasonResults_TeamLeagueResult* CMsgDOTADPCSeasonResults_TeamResult::add_league_results() {
  ::CMsgDOTADPCSeasonResults_TeamLeagueResult* _add = _internal_add_league_results();
  // @@protoc_insertion_point(field_add:CMsgDOTADPCSeasonResults.TeamResult.league_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_TeamLeagueResult >&
CMsgDOTADPCSeasonResults_TeamResult::league_results() const {
  // @@protoc_insertion_point(field_list:CMsgDOTADPCSeasonResults.TeamResult.league_results)
  return _impl_.league_results_;
}

// -------------------------------------------------------------------

// CMsgDOTADPCSeasonResults_StandingEntry

// optional uint32 team_id = 1;
inline bool CMsgDOTADPCSeasonResults_StandingEntry::_internal_has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_StandingEntry::has_team_id() const {
  return _internal_has_team_id();
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::clear_team_id() {
  _impl_.team_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTADPCSeasonResults_StandingEntry::_internal_team_id() const {
  return _impl_.team_id_;
}
inline uint32_t CMsgDOTADPCSeasonResults_StandingEntry::team_id() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.StandingEntry.team_id)
  return _internal_team_id();
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::_internal_set_team_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.team_id_ = value;
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::set_team_id(uint32_t value) {
  _internal_set_team_id(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.StandingEntry.team_id)
}

// optional uint32 wins = 2;
inline bool CMsgDOTADPCSeasonResults_StandingEntry::_internal_has_wins() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_StandingEntry::has_wins() const {
  return _internal_has_wins();
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::clear_wins() {
  _impl_.wins_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTADPCSeasonResults_StandingEntry::_internal_wins() const {
  return _impl_.wins_;
}
inline uint32_t CMsgDOTADPCSeasonResults_StandingEntry::wins() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.StandingEntry.wins)
  return _internal_wins();
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::_internal_set_wins(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.wins_ = value;
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::set_wins(uint32_t value) {
  _internal_set_wins(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.StandingEntry.wins)
}

// optional uint32 losses = 3;
inline bool CMsgDOTADPCSeasonResults_StandingEntry::_internal_has_losses() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_StandingEntry::has_losses() const {
  return _internal_has_losses();
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::clear_losses() {
  _impl_.losses_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgDOTADPCSeasonResults_StandingEntry::_internal_losses() const {
  return _impl_.losses_;
}
inline uint32_t CMsgDOTADPCSeasonResults_StandingEntry::losses() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.StandingEntry.losses)
  return _internal_losses();
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::_internal_set_losses(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.losses_ = value;
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::set_losses(uint32_t value) {
  _internal_set_losses(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.StandingEntry.losses)
}

// optional string team_url = 4;
inline bool CMsgDOTADPCSeasonResults_StandingEntry::_internal_has_team_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_StandingEntry::has_team_url() const {
  return _internal_has_team_url();
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::clear_team_url() {
  _impl_.team_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgDOTADPCSeasonResults_StandingEntry::team_url() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.StandingEntry.team_url)
  return _internal_team_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTADPCSeasonResults_StandingEntry::set_team_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.team_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.StandingEntry.team_url)
}
inline std::string* CMsgDOTADPCSeasonResults_StandingEntry::mutable_team_url() {
  std::string* _s = _internal_mutable_team_url();
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.StandingEntry.team_url)
  return _s;
}
inline const std::string& CMsgDOTADPCSeasonResults_StandingEntry::_internal_team_url() const {
  return _impl_.team_url_.Get();
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::_internal_set_team_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.team_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCSeasonResults_StandingEntry::_internal_mutable_team_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.team_url_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCSeasonResults_StandingEntry::release_team_url() {
  // @@protoc_insertion_point(field_release:CMsgDOTADPCSeasonResults.StandingEntry.team_url)
  if (!_internal_has_team_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.team_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_url_.IsDefault()) {
    _impl_.team_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::set_allocated_team_url(std::string* team_url) {
  if (team_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.team_url_.SetAllocated(team_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_url_.IsDefault()) {
    _impl_.team_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTADPCSeasonResults.StandingEntry.team_url)
}

// optional string team_name = 5;
inline bool CMsgDOTADPCSeasonResults_StandingEntry::_internal_has_team_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_StandingEntry::has_team_name() const {
  return _internal_has_team_name();
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::clear_team_name() {
  _impl_.team_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgDOTADPCSeasonResults_StandingEntry::team_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.StandingEntry.team_name)
  return _internal_team_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTADPCSeasonResults_StandingEntry::set_team_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.team_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.StandingEntry.team_name)
}
inline std::string* CMsgDOTADPCSeasonResults_StandingEntry::mutable_team_name() {
  std::string* _s = _internal_mutable_team_name();
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.StandingEntry.team_name)
  return _s;
}
inline const std::string& CMsgDOTADPCSeasonResults_StandingEntry::_internal_team_name() const {
  return _impl_.team_name_.Get();
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::_internal_set_team_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.team_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCSeasonResults_StandingEntry::_internal_mutable_team_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.team_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCSeasonResults_StandingEntry::release_team_name() {
  // @@protoc_insertion_point(field_release:CMsgDOTADPCSeasonResults.StandingEntry.team_name)
  if (!_internal_has_team_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.team_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_name_.IsDefault()) {
    _impl_.team_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::set_allocated_team_name(std::string* team_name) {
  if (team_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.team_name_.SetAllocated(team_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_name_.IsDefault()) {
    _impl_.team_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTADPCSeasonResults.StandingEntry.team_name)
}

// optional string team_abbreviation = 6;
inline bool CMsgDOTADPCSeasonResults_StandingEntry::_internal_has_team_abbreviation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_StandingEntry::has_team_abbreviation() const {
  return _internal_has_team_abbreviation();
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::clear_team_abbreviation() {
  _impl_.team_abbreviation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgDOTADPCSeasonResults_StandingEntry::team_abbreviation() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.StandingEntry.team_abbreviation)
  return _internal_team_abbreviation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgDOTADPCSeasonResults_StandingEntry::set_team_abbreviation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.team_abbreviation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.StandingEntry.team_abbreviation)
}
inline std::string* CMsgDOTADPCSeasonResults_StandingEntry::mutable_team_abbreviation() {
  std::string* _s = _internal_mutable_team_abbreviation();
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.StandingEntry.team_abbreviation)
  return _s;
}
inline const std::string& CMsgDOTADPCSeasonResults_StandingEntry::_internal_team_abbreviation() const {
  return _impl_.team_abbreviation_.Get();
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::_internal_set_team_abbreviation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.team_abbreviation_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCSeasonResults_StandingEntry::_internal_mutable_team_abbreviation() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.team_abbreviation_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgDOTADPCSeasonResults_StandingEntry::release_team_abbreviation() {
  // @@protoc_insertion_point(field_release:CMsgDOTADPCSeasonResults.StandingEntry.team_abbreviation)
  if (!_internal_has_team_abbreviation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.team_abbreviation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_abbreviation_.IsDefault()) {
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgDOTADPCSeasonResults_StandingEntry::set_allocated_team_abbreviation(std::string* team_abbreviation) {
  if (team_abbreviation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.team_abbreviation_.SetAllocated(team_abbreviation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_abbreviation_.IsDefault()) {
    _impl_.team_abbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTADPCSeasonResults.StandingEntry.team_abbreviation)
}

// -------------------------------------------------------------------

// CMsgDOTADPCSeasonResults_Standing

// optional .ELeagueRegion region = 1 [default = LEAGUE_REGION_UNSET];
inline bool CMsgDOTADPCSeasonResults_Standing::_internal_has_region() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_Standing::has_region() const {
  return _internal_has_region();
}
inline void CMsgDOTADPCSeasonResults_Standing::clear_region() {
  _impl_.region_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::ELeagueRegion CMsgDOTADPCSeasonResults_Standing::_internal_region() const {
  return static_cast< ::ELeagueRegion >(_impl_.region_);
}
inline ::ELeagueRegion CMsgDOTADPCSeasonResults_Standing::region() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.Standing.region)
  return _internal_region();
}
inline void CMsgDOTADPCSeasonResults_Standing::_internal_set_region(::ELeagueRegion value) {
  assert(::ELeagueRegion_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.region_ = value;
}
inline void CMsgDOTADPCSeasonResults_Standing::set_region(::ELeagueRegion value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.Standing.region)
}

// optional .ELeagueDivision division = 2 [default = LEAGUE_DIVISION_UNSET];
inline bool CMsgDOTADPCSeasonResults_Standing::_internal_has_division() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonResults_Standing::has_division() const {
  return _internal_has_division();
}
inline void CMsgDOTADPCSeasonResults_Standing::clear_division() {
  _impl_.division_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::ELeagueDivision CMsgDOTADPCSeasonResults_Standing::_internal_division() const {
  return static_cast< ::ELeagueDivision >(_impl_.division_);
}
inline ::ELeagueDivision CMsgDOTADPCSeasonResults_Standing::division() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.Standing.division)
  return _internal_division();
}
inline void CMsgDOTADPCSeasonResults_Standing::_internal_set_division(::ELeagueDivision value) {
  assert(::ELeagueDivision_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.division_ = value;
}
inline void CMsgDOTADPCSeasonResults_Standing::set_division(::ELeagueDivision value) {
  _internal_set_division(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonResults.Standing.division)
}

// repeated .CMsgDOTADPCSeasonResults.StandingEntry entries = 3;
inline int CMsgDOTADPCSeasonResults_Standing::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int CMsgDOTADPCSeasonResults_Standing::entries_size() const {
  return _internal_entries_size();
}
inline void CMsgDOTADPCSeasonResults_Standing::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::CMsgDOTADPCSeasonResults_StandingEntry* CMsgDOTADPCSeasonResults_Standing::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.Standing.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >*
CMsgDOTADPCSeasonResults_Standing::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTADPCSeasonResults.Standing.entries)
  return &_impl_.entries_;
}
inline const ::CMsgDOTADPCSeasonResults_StandingEntry& CMsgDOTADPCSeasonResults_Standing::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::CMsgDOTADPCSeasonResults_StandingEntry& CMsgDOTADPCSeasonResults_Standing::entries(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.Standing.entries)
  return _internal_entries(index);
}
inline ::CMsgDOTADPCSeasonResults_StandingEntry* CMsgDOTADPCSeasonResults_Standing::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::CMsgDOTADPCSeasonResults_StandingEntry* CMsgDOTADPCSeasonResults_Standing::add_entries() {
  ::CMsgDOTADPCSeasonResults_StandingEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:CMsgDOTADPCSeasonResults.Standing.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >&
CMsgDOTADPCSeasonResults_Standing::entries() const {
  // @@protoc_insertion_point(field_list:CMsgDOTADPCSeasonResults.Standing.entries)
  return _impl_.entries_;
}

// -------------------------------------------------------------------

// CMsgDOTADPCSeasonResults

// repeated .CMsgDOTADPCSeasonResults.TeamResult results = 1;
inline int CMsgDOTADPCSeasonResults::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int CMsgDOTADPCSeasonResults::results_size() const {
  return _internal_results_size();
}
inline void CMsgDOTADPCSeasonResults::clear_results() {
  _impl_.results_.Clear();
}
inline ::CMsgDOTADPCSeasonResults_TeamResult* CMsgDOTADPCSeasonResults::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_TeamResult >*
CMsgDOTADPCSeasonResults::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTADPCSeasonResults.results)
  return &_impl_.results_;
}
inline const ::CMsgDOTADPCSeasonResults_TeamResult& CMsgDOTADPCSeasonResults::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::CMsgDOTADPCSeasonResults_TeamResult& CMsgDOTADPCSeasonResults::results(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.results)
  return _internal_results(index);
}
inline ::CMsgDOTADPCSeasonResults_TeamResult* CMsgDOTADPCSeasonResults::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::CMsgDOTADPCSeasonResults_TeamResult* CMsgDOTADPCSeasonResults::add_results() {
  ::CMsgDOTADPCSeasonResults_TeamResult* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:CMsgDOTADPCSeasonResults.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_TeamResult >&
CMsgDOTADPCSeasonResults::results() const {
  // @@protoc_insertion_point(field_list:CMsgDOTADPCSeasonResults.results)
  return _impl_.results_;
}

// repeated .CMsgDOTADPCSeasonResults.Standing standings = 2;
inline int CMsgDOTADPCSeasonResults::_internal_standings_size() const {
  return _impl_.standings_.size();
}
inline int CMsgDOTADPCSeasonResults::standings_size() const {
  return _internal_standings_size();
}
inline void CMsgDOTADPCSeasonResults::clear_standings() {
  _impl_.standings_.Clear();
}
inline ::CMsgDOTADPCSeasonResults_Standing* CMsgDOTADPCSeasonResults::mutable_standings(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.standings)
  return _impl_.standings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_Standing >*
CMsgDOTADPCSeasonResults::mutable_standings() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTADPCSeasonResults.standings)
  return &_impl_.standings_;
}
inline const ::CMsgDOTADPCSeasonResults_Standing& CMsgDOTADPCSeasonResults::_internal_standings(int index) const {
  return _impl_.standings_.Get(index);
}
inline const ::CMsgDOTADPCSeasonResults_Standing& CMsgDOTADPCSeasonResults::standings(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.standings)
  return _internal_standings(index);
}
inline ::CMsgDOTADPCSeasonResults_Standing* CMsgDOTADPCSeasonResults::_internal_add_standings() {
  return _impl_.standings_.Add();
}
inline ::CMsgDOTADPCSeasonResults_Standing* CMsgDOTADPCSeasonResults::add_standings() {
  ::CMsgDOTADPCSeasonResults_Standing* _add = _internal_add_standings();
  // @@protoc_insertion_point(field_add:CMsgDOTADPCSeasonResults.standings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_Standing >&
CMsgDOTADPCSeasonResults::standings() const {
  // @@protoc_insertion_point(field_list:CMsgDOTADPCSeasonResults.standings)
  return _impl_.standings_;
}

// repeated .CMsgDOTADPCSeasonResults.StandingEntry major_wildcard_standings = 3;
inline int CMsgDOTADPCSeasonResults::_internal_major_wildcard_standings_size() const {
  return _impl_.major_wildcard_standings_.size();
}
inline int CMsgDOTADPCSeasonResults::major_wildcard_standings_size() const {
  return _internal_major_wildcard_standings_size();
}
inline void CMsgDOTADPCSeasonResults::clear_major_wildcard_standings() {
  _impl_.major_wildcard_standings_.Clear();
}
inline ::CMsgDOTADPCSeasonResults_StandingEntry* CMsgDOTADPCSeasonResults::mutable_major_wildcard_standings(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.major_wildcard_standings)
  return _impl_.major_wildcard_standings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >*
CMsgDOTADPCSeasonResults::mutable_major_wildcard_standings() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTADPCSeasonResults.major_wildcard_standings)
  return &_impl_.major_wildcard_standings_;
}
inline const ::CMsgDOTADPCSeasonResults_StandingEntry& CMsgDOTADPCSeasonResults::_internal_major_wildcard_standings(int index) const {
  return _impl_.major_wildcard_standings_.Get(index);
}
inline const ::CMsgDOTADPCSeasonResults_StandingEntry& CMsgDOTADPCSeasonResults::major_wildcard_standings(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.major_wildcard_standings)
  return _internal_major_wildcard_standings(index);
}
inline ::CMsgDOTADPCSeasonResults_StandingEntry* CMsgDOTADPCSeasonResults::_internal_add_major_wildcard_standings() {
  return _impl_.major_wildcard_standings_.Add();
}
inline ::CMsgDOTADPCSeasonResults_StandingEntry* CMsgDOTADPCSeasonResults::add_major_wildcard_standings() {
  ::CMsgDOTADPCSeasonResults_StandingEntry* _add = _internal_add_major_wildcard_standings();
  // @@protoc_insertion_point(field_add:CMsgDOTADPCSeasonResults.major_wildcard_standings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >&
CMsgDOTADPCSeasonResults::major_wildcard_standings() const {
  // @@protoc_insertion_point(field_list:CMsgDOTADPCSeasonResults.major_wildcard_standings)
  return _impl_.major_wildcard_standings_;
}

// repeated .CMsgDOTADPCSeasonResults.StandingEntry major_group_standings = 4;
inline int CMsgDOTADPCSeasonResults::_internal_major_group_standings_size() const {
  return _impl_.major_group_standings_.size();
}
inline int CMsgDOTADPCSeasonResults::major_group_standings_size() const {
  return _internal_major_group_standings_size();
}
inline void CMsgDOTADPCSeasonResults::clear_major_group_standings() {
  _impl_.major_group_standings_.Clear();
}
inline ::CMsgDOTADPCSeasonResults_StandingEntry* CMsgDOTADPCSeasonResults::mutable_major_group_standings(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.major_group_standings)
  return _impl_.major_group_standings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >*
CMsgDOTADPCSeasonResults::mutable_major_group_standings() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTADPCSeasonResults.major_group_standings)
  return &_impl_.major_group_standings_;
}
inline const ::CMsgDOTADPCSeasonResults_StandingEntry& CMsgDOTADPCSeasonResults::_internal_major_group_standings(int index) const {
  return _impl_.major_group_standings_.Get(index);
}
inline const ::CMsgDOTADPCSeasonResults_StandingEntry& CMsgDOTADPCSeasonResults::major_group_standings(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.major_group_standings)
  return _internal_major_group_standings(index);
}
inline ::CMsgDOTADPCSeasonResults_StandingEntry* CMsgDOTADPCSeasonResults::_internal_add_major_group_standings() {
  return _impl_.major_group_standings_.Add();
}
inline ::CMsgDOTADPCSeasonResults_StandingEntry* CMsgDOTADPCSeasonResults::add_major_group_standings() {
  ::CMsgDOTADPCSeasonResults_StandingEntry* _add = _internal_add_major_group_standings();
  // @@protoc_insertion_point(field_add:CMsgDOTADPCSeasonResults.major_group_standings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >&
CMsgDOTADPCSeasonResults::major_group_standings() const {
  // @@protoc_insertion_point(field_list:CMsgDOTADPCSeasonResults.major_group_standings)
  return _impl_.major_group_standings_;
}

// repeated .CMsgDOTADPCSeasonResults.StandingEntry major_playoff_standings = 5;
inline int CMsgDOTADPCSeasonResults::_internal_major_playoff_standings_size() const {
  return _impl_.major_playoff_standings_.size();
}
inline int CMsgDOTADPCSeasonResults::major_playoff_standings_size() const {
  return _internal_major_playoff_standings_size();
}
inline void CMsgDOTADPCSeasonResults::clear_major_playoff_standings() {
  _impl_.major_playoff_standings_.Clear();
}
inline ::CMsgDOTADPCSeasonResults_StandingEntry* CMsgDOTADPCSeasonResults::mutable_major_playoff_standings(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonResults.major_playoff_standings)
  return _impl_.major_playoff_standings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >*
CMsgDOTADPCSeasonResults::mutable_major_playoff_standings() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTADPCSeasonResults.major_playoff_standings)
  return &_impl_.major_playoff_standings_;
}
inline const ::CMsgDOTADPCSeasonResults_StandingEntry& CMsgDOTADPCSeasonResults::_internal_major_playoff_standings(int index) const {
  return _impl_.major_playoff_standings_.Get(index);
}
inline const ::CMsgDOTADPCSeasonResults_StandingEntry& CMsgDOTADPCSeasonResults::major_playoff_standings(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonResults.major_playoff_standings)
  return _internal_major_playoff_standings(index);
}
inline ::CMsgDOTADPCSeasonResults_StandingEntry* CMsgDOTADPCSeasonResults::_internal_add_major_playoff_standings() {
  return _impl_.major_playoff_standings_.Add();
}
inline ::CMsgDOTADPCSeasonResults_StandingEntry* CMsgDOTADPCSeasonResults::add_major_playoff_standings() {
  ::CMsgDOTADPCSeasonResults_StandingEntry* _add = _internal_add_major_playoff_standings();
  // @@protoc_insertion_point(field_add:CMsgDOTADPCSeasonResults.major_playoff_standings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgDOTADPCSeasonResults_StandingEntry >&
CMsgDOTADPCSeasonResults::major_playoff_standings() const {
  // @@protoc_insertion_point(field_list:CMsgDOTADPCSeasonResults.major_playoff_standings)
  return _impl_.major_playoff_standings_;
}

// -------------------------------------------------------------------

// CMsgDOTADPCSeasonSpoilerResults

// optional uint32 time_last_updated = 1;
inline bool CMsgDOTADPCSeasonSpoilerResults::_internal_has_time_last_updated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTADPCSeasonSpoilerResults::has_time_last_updated() const {
  return _internal_has_time_last_updated();
}
inline void CMsgDOTADPCSeasonSpoilerResults::clear_time_last_updated() {
  _impl_.time_last_updated_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTADPCSeasonSpoilerResults::_internal_time_last_updated() const {
  return _impl_.time_last_updated_;
}
inline uint32_t CMsgDOTADPCSeasonSpoilerResults::time_last_updated() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonSpoilerResults.time_last_updated)
  return _internal_time_last_updated();
}
inline void CMsgDOTADPCSeasonSpoilerResults::_internal_set_time_last_updated(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.time_last_updated_ = value;
}
inline void CMsgDOTADPCSeasonSpoilerResults::set_time_last_updated(uint32_t value) {
  _internal_set_time_last_updated(value);
  // @@protoc_insertion_point(field_set:CMsgDOTADPCSeasonSpoilerResults.time_last_updated)
}

// optional .CMsgDOTADPCSeasonResults saved_results = 2;
inline bool CMsgDOTADPCSeasonSpoilerResults::_internal_has_saved_results() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.saved_results_ != nullptr);
  return value;
}
inline bool CMsgDOTADPCSeasonSpoilerResults::has_saved_results() const {
  return _internal_has_saved_results();
}
inline void CMsgDOTADPCSeasonSpoilerResults::clear_saved_results() {
  if (_impl_.saved_results_ != nullptr) _impl_.saved_results_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgDOTADPCSeasonResults& CMsgDOTADPCSeasonSpoilerResults::_internal_saved_results() const {
  const ::CMsgDOTADPCSeasonResults* p = _impl_.saved_results_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgDOTADPCSeasonResults&>(
      ::_CMsgDOTADPCSeasonResults_default_instance_);
}
inline const ::CMsgDOTADPCSeasonResults& CMsgDOTADPCSeasonSpoilerResults::saved_results() const {
  // @@protoc_insertion_point(field_get:CMsgDOTADPCSeasonSpoilerResults.saved_results)
  return _internal_saved_results();
}
inline void CMsgDOTADPCSeasonSpoilerResults::unsafe_arena_set_allocated_saved_results(
    ::CMsgDOTADPCSeasonResults* saved_results) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.saved_results_);
  }
  _impl_.saved_results_ = saved_results;
  if (saved_results) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgDOTADPCSeasonSpoilerResults.saved_results)
}
inline ::CMsgDOTADPCSeasonResults* CMsgDOTADPCSeasonSpoilerResults::release_saved_results() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgDOTADPCSeasonResults* temp = _impl_.saved_results_;
  _impl_.saved_results_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgDOTADPCSeasonResults* CMsgDOTADPCSeasonSpoilerResults::unsafe_arena_release_saved_results() {
  // @@protoc_insertion_point(field_release:CMsgDOTADPCSeasonSpoilerResults.saved_results)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgDOTADPCSeasonResults* temp = _impl_.saved_results_;
  _impl_.saved_results_ = nullptr;
  return temp;
}
inline ::CMsgDOTADPCSeasonResults* CMsgDOTADPCSeasonSpoilerResults::_internal_mutable_saved_results() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.saved_results_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgDOTADPCSeasonResults>(GetArenaForAllocation());
    _impl_.saved_results_ = p;
  }
  return _impl_.saved_results_;
}
inline ::CMsgDOTADPCSeasonResults* CMsgDOTADPCSeasonSpoilerResults::mutable_saved_results() {
  ::CMsgDOTADPCSeasonResults* _msg = _internal_mutable_saved_results();
  // @@protoc_insertion_point(field_mutable:CMsgDOTADPCSeasonSpoilerResults.saved_results)
  return _msg;
}
inline void CMsgDOTADPCSeasonSpoilerResults::set_allocated_saved_results(::CMsgDOTADPCSeasonResults* saved_results) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.saved_results_;
  }
  if (saved_results) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(saved_results);
    if (message_arena != submessage_arena) {
      saved_results = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, saved_results, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.saved_results_ = saved_results;
  // @@protoc_insertion_point(field_set_allocated:CMsgDOTADPCSeasonSpoilerResults.saved_results)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ELeagueNodeGroupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELeagueNodeGroupType>() {
  return ::ELeagueNodeGroupType_descriptor();
}
template <> struct is_proto_enum< ::ELeagueNodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELeagueNodeType>() {
  return ::ELeagueNodeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dota_5fgcmessages_5fcommon_5fleague_2eproto
