// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gcsdk_gcmessages.proto

#include "gcsdk_gcmessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CExtraMsgBlock::CExtraMsgBlock(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.contents_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_type_)*/0u
  , /*decltype(_impl_.is_compressed_)*/false
  , /*decltype(_impl_.msg_key_)*/uint64_t{0u}} {}
struct CExtraMsgBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CExtraMsgBlockDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CExtraMsgBlockDefaultTypeInternal() {}
  union {
    CExtraMsgBlock _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CExtraMsgBlockDefaultTypeInternal _CExtraMsgBlock_default_instance_;
PROTOBUF_CONSTEXPR CMsgSteamLearnServerInfo::CMsgSteamLearnServerInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hmac_keys_)*/nullptr
  , /*decltype(_impl_.enable_data_submission_)*/false
  , /*decltype(_impl_.enable_inferencing_)*/false} {}
struct CMsgSteamLearnServerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSteamLearnServerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSteamLearnServerInfoDefaultTypeInternal() {}
  union {
    CMsgSteamLearnServerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSteamLearnServerInfoDefaultTypeInternal _CMsgSteamLearnServerInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCAssertJobData::CMsgGCAssertJobData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgGCAssertJobDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCAssertJobDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCAssertJobDataDefaultTypeInternal() {}
  union {
    CMsgGCAssertJobData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCAssertJobDataDefaultTypeInternal _CMsgGCAssertJobData_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCConCommand::CMsgGCConCommand(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.command_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgGCConCommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCConCommandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCConCommandDefaultTypeInternal() {}
  union {
    CMsgGCConCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCConCommandDefaultTypeInternal _CMsgGCConCommand_default_instance_;
PROTOBUF_CONSTEXPR CMsgSDOAssert_Request::CMsgSDOAssert_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/{}
  , /*decltype(_impl_.requesting_job_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgSDOAssert_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSDOAssert_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSDOAssert_RequestDefaultTypeInternal() {}
  union {
    CMsgSDOAssert_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSDOAssert_RequestDefaultTypeInternal _CMsgSDOAssert_Request_default_instance_;
PROTOBUF_CONSTEXPR CMsgSDOAssert::CMsgSDOAssert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.requests_)*/{}
  , /*decltype(_impl_.sdo_type_)*/0} {}
struct CMsgSDOAssertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSDOAssertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSDOAssertDefaultTypeInternal() {}
  union {
    CMsgSDOAssert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSDOAssertDefaultTypeInternal _CMsgSDOAssert_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOIDOwner::CMsgSOIDOwner(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0u} {}
struct CMsgSOIDOwnerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOIDOwnerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOIDOwnerDefaultTypeInternal() {}
  union {
    CMsgSOIDOwner _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOIDOwnerDefaultTypeInternal _CMsgSOIDOwner_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOSingleObject::CMsgSOSingleObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owner_soid_)*/nullptr
  , /*decltype(_impl_.version_)*/uint64_t{0u}
  , /*decltype(_impl_.type_id_)*/0
  , /*decltype(_impl_.service_id_)*/0u} {}
struct CMsgSOSingleObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOSingleObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOSingleObjectDefaultTypeInternal() {}
  union {
    CMsgSOSingleObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOSingleObjectDefaultTypeInternal _CMsgSOSingleObject_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOMultipleObjects_SingleObject::CMsgSOMultipleObjects_SingleObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_id_)*/0} {}
struct CMsgSOMultipleObjects_SingleObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOMultipleObjects_SingleObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOMultipleObjects_SingleObjectDefaultTypeInternal() {}
  union {
    CMsgSOMultipleObjects_SingleObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOMultipleObjects_SingleObjectDefaultTypeInternal _CMsgSOMultipleObjects_SingleObject_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOMultipleObjects::CMsgSOMultipleObjects(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.objects_modified_)*/{}
  , /*decltype(_impl_.objects_added_)*/{}
  , /*decltype(_impl_.objects_removed_)*/{}
  , /*decltype(_impl_.owner_soid_)*/nullptr
  , /*decltype(_impl_.version_)*/uint64_t{0u}
  , /*decltype(_impl_.service_id_)*/0u} {}
struct CMsgSOMultipleObjectsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOMultipleObjectsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOMultipleObjectsDefaultTypeInternal() {}
  union {
    CMsgSOMultipleObjects _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOMultipleObjectsDefaultTypeInternal _CMsgSOMultipleObjects_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheSubscribed_SubscribedType::CMsgSOCacheSubscribed_SubscribedType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_data_)*/{}
  , /*decltype(_impl_.type_id_)*/0} {}
struct CMsgSOCacheSubscribed_SubscribedTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheSubscribed_SubscribedTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheSubscribed_SubscribedTypeDefaultTypeInternal() {}
  union {
    CMsgSOCacheSubscribed_SubscribedType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheSubscribed_SubscribedTypeDefaultTypeInternal _CMsgSOCacheSubscribed_SubscribedType_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheSubscribed::CMsgSOCacheSubscribed(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.objects_)*/{}
  , /*decltype(_impl_.service_list_)*/{}
  , /*decltype(_impl_.owner_soid_)*/nullptr
  , /*decltype(_impl_.version_)*/uint64_t{0u}
  , /*decltype(_impl_.sync_version_)*/uint64_t{0u}
  , /*decltype(_impl_.service_id_)*/0u} {}
struct CMsgSOCacheSubscribedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheSubscribedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheSubscribedDefaultTypeInternal() {}
  union {
    CMsgSOCacheSubscribed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheSubscribedDefaultTypeInternal _CMsgSOCacheSubscribed_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheSubscribedUpToDate::CMsgSOCacheSubscribedUpToDate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.service_list_)*/{}
  , /*decltype(_impl_.owner_soid_)*/nullptr
  , /*decltype(_impl_.version_)*/uint64_t{0u}
  , /*decltype(_impl_.sync_version_)*/uint64_t{0u}
  , /*decltype(_impl_.service_id_)*/0u} {}
struct CMsgSOCacheSubscribedUpToDateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheSubscribedUpToDateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheSubscribedUpToDateDefaultTypeInternal() {}
  union {
    CMsgSOCacheSubscribedUpToDate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheSubscribedUpToDateDefaultTypeInternal _CMsgSOCacheSubscribedUpToDate_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheUnsubscribed::CMsgSOCacheUnsubscribed(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.owner_soid_)*/nullptr} {}
struct CMsgSOCacheUnsubscribedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheUnsubscribedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheUnsubscribedDefaultTypeInternal() {}
  union {
    CMsgSOCacheUnsubscribed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheUnsubscribedDefaultTypeInternal _CMsgSOCacheUnsubscribed_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheSubscriptionCheck::CMsgSOCacheSubscriptionCheck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.service_list_)*/{}
  , /*decltype(_impl_.owner_soid_)*/nullptr
  , /*decltype(_impl_.version_)*/uint64_t{0u}
  , /*decltype(_impl_.sync_version_)*/uint64_t{0u}
  , /*decltype(_impl_.service_id_)*/0u} {}
struct CMsgSOCacheSubscriptionCheckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheSubscriptionCheckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheSubscriptionCheckDefaultTypeInternal() {}
  union {
    CMsgSOCacheSubscriptionCheck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheSubscriptionCheckDefaultTypeInternal _CMsgSOCacheSubscriptionCheck_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheSubscriptionRefresh::CMsgSOCacheSubscriptionRefresh(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.owner_soid_)*/nullptr} {}
struct CMsgSOCacheSubscriptionRefreshDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheSubscriptionRefreshDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheSubscriptionRefreshDefaultTypeInternal() {}
  union {
    CMsgSOCacheSubscriptionRefresh _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheSubscriptionRefreshDefaultTypeInternal _CMsgSOCacheSubscriptionRefresh_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheVersion::CMsgSOCacheVersion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.version_)*/uint64_t{0u}} {}
struct CMsgSOCacheVersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheVersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheVersionDefaultTypeInternal() {}
  union {
    CMsgSOCacheVersion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheVersionDefaultTypeInternal _CMsgSOCacheVersion_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCMultiplexMessage::CMsgGCMultiplexMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steamids_)*/{}
  , /*decltype(_impl_.payload_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msgtype_)*/0u} {}
struct CMsgGCMultiplexMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCMultiplexMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCMultiplexMessageDefaultTypeInternal() {}
  union {
    CMsgGCMultiplexMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCMultiplexMessageDefaultTypeInternal _CMsgGCMultiplexMessage_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCSubGCStarting::CMsgGCToGCSubGCStarting(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dir_index_)*/-1} {}
struct CMsgGCToGCSubGCStartingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCSubGCStartingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCSubGCStartingDefaultTypeInternal() {}
  union {
    CMsgGCToGCSubGCStarting _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCSubGCStartingDefaultTypeInternal _CMsgGCToGCSubGCStarting_default_instance_;
PROTOBUF_CONSTEXPR CGCToGCMsgMasterAck_Process::CGCToGCMsgMasterAck_Process(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_instances_)*/{}
  , /*decltype(_impl_.dir_index_)*/-1} {}
struct CGCToGCMsgMasterAck_ProcessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCToGCMsgMasterAck_ProcessDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCToGCMsgMasterAck_ProcessDefaultTypeInternal() {}
  union {
    CGCToGCMsgMasterAck_Process _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCToGCMsgMasterAck_ProcessDefaultTypeInternal _CGCToGCMsgMasterAck_Process_default_instance_;
PROTOBUF_CONSTEXPR CGCToGCMsgMasterAck::CGCToGCMsgMasterAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.directory_)*/{}
  , /*decltype(_impl_.machine_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.process_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dir_index_)*/-1} {}
struct CGCToGCMsgMasterAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCToGCMsgMasterAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCToGCMsgMasterAckDefaultTypeInternal() {}
  union {
    CGCToGCMsgMasterAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCToGCMsgMasterAckDefaultTypeInternal _CGCToGCMsgMasterAck_default_instance_;
PROTOBUF_CONSTEXPR CGCToGCMsgMasterAck_Response::CGCToGCMsgMasterAck_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.eresult_)*/2} {}
struct CGCToGCMsgMasterAck_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCToGCMsgMasterAck_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCToGCMsgMasterAck_ResponseDefaultTypeInternal() {}
  union {
    CGCToGCMsgMasterAck_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCToGCMsgMasterAck_ResponseDefaultTypeInternal _CGCToGCMsgMasterAck_Response_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCUniverseStartup::CMsgGCToGCUniverseStartup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.is_initial_startup_)*/false} {}
struct CMsgGCToGCUniverseStartupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCUniverseStartupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCUniverseStartupDefaultTypeInternal() {}
  union {
    CMsgGCToGCUniverseStartup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCUniverseStartupDefaultTypeInternal _CMsgGCToGCUniverseStartup_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCUniverseStartupResponse::CMsgGCToGCUniverseStartupResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.eresult_)*/0} {}
struct CMsgGCToGCUniverseStartupResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCUniverseStartupResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCUniverseStartupResponseDefaultTypeInternal() {}
  union {
    CMsgGCToGCUniverseStartupResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCUniverseStartupResponseDefaultTypeInternal _CMsgGCToGCUniverseStartupResponse_default_instance_;
PROTOBUF_CONSTEXPR CGCToGCMsgMasterStartupComplete_GCInfo::CGCToGCMsgMasterStartupComplete_GCInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.machine_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dir_index_)*/-1} {}
struct CGCToGCMsgMasterStartupComplete_GCInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCToGCMsgMasterStartupComplete_GCInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCToGCMsgMasterStartupComplete_GCInfoDefaultTypeInternal() {}
  union {
    CGCToGCMsgMasterStartupComplete_GCInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCToGCMsgMasterStartupComplete_GCInfoDefaultTypeInternal _CGCToGCMsgMasterStartupComplete_GCInfo_default_instance_;
PROTOBUF_CONSTEXPR CGCToGCMsgMasterStartupComplete::CGCToGCMsgMasterStartupComplete(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.gc_info_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CGCToGCMsgMasterStartupCompleteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCToGCMsgMasterStartupCompleteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCToGCMsgMasterStartupCompleteDefaultTypeInternal() {}
  union {
    CGCToGCMsgMasterStartupComplete _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCToGCMsgMasterStartupCompleteDefaultTypeInternal _CGCToGCMsgMasterStartupComplete_default_instance_;
PROTOBUF_CONSTEXPR CGCToGCMsgRouted::CGCToGCMsgRouted(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.net_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sender_id_)*/uint64_t{0u}
  , /*decltype(_impl_.msg_type_)*/0u} {}
struct CGCToGCMsgRoutedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCToGCMsgRoutedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCToGCMsgRoutedDefaultTypeInternal() {}
  union {
    CGCToGCMsgRouted _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCToGCMsgRoutedDefaultTypeInternal _CGCToGCMsgRouted_default_instance_;
PROTOBUF_CONSTEXPR CGCToGCMsgRoutedReply::CGCToGCMsgRoutedReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.net_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_type_)*/0u} {}
struct CGCToGCMsgRoutedReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCToGCMsgRoutedReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCToGCMsgRoutedReplyDefaultTypeInternal() {}
  union {
    CGCToGCMsgRoutedReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCToGCMsgRoutedReplyDefaultTypeInternal _CGCToGCMsgRoutedReply_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::CMsgGCUpdateSubGCSessionInfo_CMsgUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.ip_)*/0u
  , /*decltype(_impl_.trusted_)*/false} {}
struct CMsgGCUpdateSubGCSessionInfo_CMsgUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCUpdateSubGCSessionInfo_CMsgUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCUpdateSubGCSessionInfo_CMsgUpdateDefaultTypeInternal() {}
  union {
    CMsgGCUpdateSubGCSessionInfo_CMsgUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCUpdateSubGCSessionInfo_CMsgUpdateDefaultTypeInternal _CMsgGCUpdateSubGCSessionInfo_CMsgUpdate_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCUpdateSubGCSessionInfo::CMsgGCUpdateSubGCSessionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.updates_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGCUpdateSubGCSessionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCUpdateSubGCSessionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCUpdateSubGCSessionInfoDefaultTypeInternal() {}
  union {
    CMsgGCUpdateSubGCSessionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCUpdateSubGCSessionInfoDefaultTypeInternal _CMsgGCUpdateSubGCSessionInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCRequestSubGCSessionInfo::CMsgGCRequestSubGCSessionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}} {}
struct CMsgGCRequestSubGCSessionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCRequestSubGCSessionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCRequestSubGCSessionInfoDefaultTypeInternal() {}
  union {
    CMsgGCRequestSubGCSessionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCRequestSubGCSessionInfoDefaultTypeInternal _CMsgGCRequestSubGCSessionInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCRequestSubGCSessionInfoResponse::CMsgGCRequestSubGCSessionInfoResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ip_)*/0u
  , /*decltype(_impl_.port_)*/0u
  , /*decltype(_impl_.trusted_)*/false
  , /*decltype(_impl_.success_)*/false} {}
struct CMsgGCRequestSubGCSessionInfoResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCRequestSubGCSessionInfoResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCRequestSubGCSessionInfoResponseDefaultTypeInternal() {}
  union {
    CMsgGCRequestSubGCSessionInfoResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCRequestSubGCSessionInfoResponseDefaultTypeInternal _CMsgGCRequestSubGCSessionInfoResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgSOCacheHaveVersion::CMsgSOCacheHaveVersion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.soid_)*/nullptr
  , /*decltype(_impl_.version_)*/uint64_t{0u}
  , /*decltype(_impl_.service_id_)*/0u
  , /*decltype(_impl_.cached_file_version_)*/0u} {}
struct CMsgSOCacheHaveVersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSOCacheHaveVersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSOCacheHaveVersionDefaultTypeInternal() {}
  union {
    CMsgSOCacheHaveVersion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSOCacheHaveVersionDefaultTypeInternal _CMsgSOCacheHaveVersion_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientHello::CMsgClientHello(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.socache_have_versions_)*/{}
  , /*decltype(_impl_.secret_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.steamdatagram_login_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.game_msg_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.platform_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.client_session_need_)*/0u
  , /*decltype(_impl_.client_launcher_)*/0
  , /*decltype(_impl_.client_language_)*/0u
  , /*decltype(_impl_.engine_)*/0
  , /*decltype(_impl_.platform_id_)*/0u
  , /*decltype(_impl_.os_type_)*/0
  , /*decltype(_impl_.render_system_)*/0u
  , /*decltype(_impl_.render_system_req_)*/0u
  , /*decltype(_impl_.screen_width_)*/0u
  , /*decltype(_impl_.screen_height_)*/0u
  , /*decltype(_impl_.screen_refresh_)*/0u
  , /*decltype(_impl_.render_width_)*/0u
  , /*decltype(_impl_.render_height_)*/0u
  , /*decltype(_impl_.swap_width_)*/0u
  , /*decltype(_impl_.swap_height_)*/0u
  , /*decltype(_impl_.is_steam_china_)*/false
  , /*decltype(_impl_.is_steam_china_client_)*/false} {}
struct CMsgClientHelloDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientHelloDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientHelloDefaultTypeInternal() {}
  union {
    CMsgClientHello _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientHelloDefaultTypeInternal _CMsgClientHello_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientWelcome_Location::CMsgClientWelcome_Location(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.country_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.latitude_)*/0
  , /*decltype(_impl_.longitude_)*/0} {}
struct CMsgClientWelcome_LocationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientWelcome_LocationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientWelcome_LocationDefaultTypeInternal() {}
  union {
    CMsgClientWelcome_Location _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientWelcome_LocationDefaultTypeInternal _CMsgClientWelcome_Location_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientWelcome::CMsgClientWelcome(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.outofdate_subscribed_caches_)*/{}
  , /*decltype(_impl_.uptodate_subscribed_caches_)*/{}
  , /*decltype(_impl_.game_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.save_game_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.txn_country_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.game_data2_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.balance_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.location_)*/nullptr
  , /*decltype(_impl_.additional_welcome_msgs_)*/nullptr
  , /*decltype(_impl_.steam_learn_server_info_)*/nullptr
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.gc_socache_file_version_)*/0u
  , /*decltype(_impl_.rtime32_gc_welcome_timestamp_)*/0u
  , /*decltype(_impl_.currency_)*/0u
  , /*decltype(_impl_.balance_)*/0u
  , /*decltype(_impl_.has_accepted_china_ssa_)*/false
  , /*decltype(_impl_.is_banned_steam_china_)*/false} {}
struct CMsgClientWelcomeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientWelcomeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientWelcomeDefaultTypeInternal() {}
  union {
    CMsgClientWelcome _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientWelcomeDefaultTypeInternal _CMsgClientWelcome_default_instance_;
PROTOBUF_CONSTEXPR CMsgConnectionStatus::CMsgConnectionStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.client_session_need_)*/0u
  , /*decltype(_impl_.queue_position_)*/0
  , /*decltype(_impl_.queue_size_)*/0
  , /*decltype(_impl_.wait_seconds_)*/0
  , /*decltype(_impl_.estimated_wait_seconds_remaining_)*/0} {}
struct CMsgConnectionStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgConnectionStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgConnectionStatusDefaultTypeInternal() {}
  union {
    CMsgConnectionStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgConnectionStatusDefaultTypeInternal _CMsgConnectionStatus_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.version_)*/uint64_t{0u}
  , /*decltype(_impl_.service_id_)*/0u} {}
struct CMsgGCToGCSOCacheSubscribe_CMsgHaveVersionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCSOCacheSubscribe_CMsgHaveVersionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCSOCacheSubscribe_CMsgHaveVersionsDefaultTypeInternal() {}
  union {
    CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCSOCacheSubscribe_CMsgHaveVersionsDefaultTypeInternal _CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCSOCacheSubscribe::CMsgGCToGCSOCacheSubscribe(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.have_versions_)*/{}
  , /*decltype(_impl_.subscriber_)*/uint64_t{0u}
  , /*decltype(_impl_.subscribe_to_id_)*/uint64_t{0u}
  , /*decltype(_impl_.sync_version_)*/uint64_t{0u}
  , /*decltype(_impl_.subscribe_to_type_)*/0u} {}
struct CMsgGCToGCSOCacheSubscribeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCSOCacheSubscribeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCSOCacheSubscribeDefaultTypeInternal() {}
  union {
    CMsgGCToGCSOCacheSubscribe _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCSOCacheSubscribeDefaultTypeInternal _CMsgGCToGCSOCacheSubscribe_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCSOCacheUnsubscribe::CMsgGCToGCSOCacheUnsubscribe(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subscriber_)*/uint64_t{0u}
  , /*decltype(_impl_.unsubscribe_from_id_)*/uint64_t{0u}
  , /*decltype(_impl_.unsubscribe_from_type_)*/0u} {}
struct CMsgGCToGCSOCacheUnsubscribeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCSOCacheUnsubscribeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCSOCacheUnsubscribeDefaultTypeInternal() {}
  union {
    CMsgGCToGCSOCacheUnsubscribe _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCSOCacheUnsubscribeDefaultTypeInternal _CMsgGCToGCSOCacheUnsubscribe_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCClientPing::CMsgGCClientPing(
    ::_pbi::ConstantInitialized) {}
struct CMsgGCClientPingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCClientPingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCClientPingDefaultTypeInternal() {}
  union {
    CMsgGCClientPing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCClientPingDefaultTypeInternal _CMsgGCClientPing_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCForwardAccountDetails::CMsgGCToGCForwardAccountDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_details_)*/nullptr
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.age_seconds_)*/0u} {}
struct CMsgGCToGCForwardAccountDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCForwardAccountDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCForwardAccountDetailsDefaultTypeInternal() {}
  union {
    CMsgGCToGCForwardAccountDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCForwardAccountDetailsDefaultTypeInternal _CMsgGCToGCForwardAccountDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCLoadSessionSOCache::CMsgGCToGCLoadSessionSOCache(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.forward_account_details_)*/nullptr
  , /*decltype(_impl_.account_id_)*/0u} {}
struct CMsgGCToGCLoadSessionSOCacheDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCLoadSessionSOCacheDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCLoadSessionSOCacheDefaultTypeInternal() {}
  union {
    CMsgGCToGCLoadSessionSOCache _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCLoadSessionSOCacheDefaultTypeInternal _CMsgGCToGCLoadSessionSOCache_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCLoadSessionSOCacheResponse::CMsgGCToGCLoadSessionSOCacheResponse(
    ::_pbi::ConstantInitialized) {}
struct CMsgGCToGCLoadSessionSOCacheResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCLoadSessionSOCacheResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCLoadSessionSOCacheResponseDefaultTypeInternal() {}
  union {
    CMsgGCToGCLoadSessionSOCacheResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCLoadSessionSOCacheResponseDefaultTypeInternal _CMsgGCToGCLoadSessionSOCacheResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCUpdateSessionStats::CMsgGCToGCUpdateSessionStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_sessions_)*/0u
  , /*decltype(_impl_.server_sessions_)*/0u
  , /*decltype(_impl_.in_logon_surge_)*/false} {}
struct CMsgGCToGCUpdateSessionStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCUpdateSessionStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCUpdateSessionStatsDefaultTypeInternal() {}
  union {
    CMsgGCToGCUpdateSessionStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCUpdateSessionStatsDefaultTypeInternal _CMsgGCToGCUpdateSessionStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToClientRequestDropped::CMsgGCToClientRequestDropped(
    ::_pbi::ConstantInitialized) {}
struct CMsgGCToClientRequestDroppedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToClientRequestDroppedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToClientRequestDroppedDefaultTypeInternal() {}
  union {
    CMsgGCToClientRequestDropped _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToClientRequestDroppedDefaultTypeInternal _CMsgGCToClientRequestDropped_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gameitemid_)*/0u} {}
struct CWorkshop_PopulateItemDescriptions_Request_SingleItemDescriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_PopulateItemDescriptions_Request_SingleItemDescriptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_PopulateItemDescriptions_Request_SingleItemDescriptionDefaultTypeInternal() {}
  union {
    CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_PopulateItemDescriptions_Request_SingleItemDescriptionDefaultTypeInternal _CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.descriptions_)*/{}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlockDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlockDefaultTypeInternal() {}
  union {
    CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlockDefaultTypeInternal _CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_PopulateItemDescriptions_Request::CWorkshop_PopulateItemDescriptions_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.languages_)*/{}
  , /*decltype(_impl_.appid_)*/0u} {}
struct CWorkshop_PopulateItemDescriptions_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_PopulateItemDescriptions_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_PopulateItemDescriptions_RequestDefaultTypeInternal() {}
  union {
    CWorkshop_PopulateItemDescriptions_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_PopulateItemDescriptions_RequestDefaultTypeInternal _CWorkshop_PopulateItemDescriptions_Request_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_GetContributors_Request::CWorkshop_GetContributors_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_.gameitemid_)*/0u} {}
struct CWorkshop_GetContributors_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_GetContributors_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_GetContributors_RequestDefaultTypeInternal() {}
  union {
    CWorkshop_GetContributors_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_GetContributors_RequestDefaultTypeInternal _CWorkshop_GetContributors_Request_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_GetContributors_Response::CWorkshop_GetContributors_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contributors_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CWorkshop_GetContributors_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_GetContributors_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_GetContributors_ResponseDefaultTypeInternal() {}
  union {
    CWorkshop_GetContributors_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_GetContributors_ResponseDefaultTypeInternal _CWorkshop_GetContributors_Response_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rule_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.workshop_file_id_)*/uint64_t{0u}
  , /*decltype(_impl_.revenue_percentage_)*/0
  , /*decltype(_impl_.rule_type_)*/1u} {}
struct CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRuleDefaultTypeInternal() {}
  union {
    CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRuleDefaultTypeInternal _CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rule_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.workshop_file_id_)*/uint64_t{0u}} {}
struct CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRuleDefaultTypeInternal() {}
  union {
    CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRuleDefaultTypeInternal _CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rule_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.revenue_percentage_)*/0} {}
struct CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRuleDefaultTypeInternal() {}
  union {
    CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRuleDefaultTypeInternal _CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Request::CWorkshop_SetItemPaymentRules_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.associated_workshop_files_)*/{}
  , /*decltype(_impl_.partner_accounts_)*/{}
  , /*decltype(_impl_.associated_workshop_file_for_direct_payments_)*/nullptr
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_.gameitemid_)*/0u
  , /*decltype(_impl_.validate_only_)*/false
  , /*decltype(_impl_.make_workshop_files_subscribable_)*/false} {}
struct CWorkshop_SetItemPaymentRules_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_SetItemPaymentRules_RequestDefaultTypeInternal() {}
  union {
    CWorkshop_SetItemPaymentRules_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_SetItemPaymentRules_RequestDefaultTypeInternal _CWorkshop_SetItemPaymentRules_Request_default_instance_;
PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_Response::CWorkshop_SetItemPaymentRules_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.validation_errors_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CWorkshop_SetItemPaymentRules_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CWorkshop_SetItemPaymentRules_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CWorkshop_SetItemPaymentRules_ResponseDefaultTypeInternal() {}
  union {
    CWorkshop_SetItemPaymentRules_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CWorkshop_SetItemPaymentRules_ResponseDefaultTypeInternal _CWorkshop_SetItemPaymentRules_Response_default_instance_;
PROTOBUF_CONSTEXPR CCommunity_ClanAnnouncementInfo::CCommunity_ClanAnnouncementInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tags_)*/{}
  , /*decltype(_impl_.headline_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gid_)*/uint64_t{0u}
  , /*decltype(_impl_.clanid_)*/uint64_t{0u}
  , /*decltype(_impl_.posterid_)*/uint64_t{0u}
  , /*decltype(_impl_.posttime_)*/0u
  , /*decltype(_impl_.updatetime_)*/0u
  , /*decltype(_impl_.commentcount_)*/0
  , /*decltype(_impl_.language_)*/0
  , /*decltype(_impl_.forum_topic_id_)*/uint64_t{0u}
  , /*decltype(_impl_.hidden_)*/false} {}
struct CCommunity_ClanAnnouncementInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCommunity_ClanAnnouncementInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCommunity_ClanAnnouncementInfoDefaultTypeInternal() {}
  union {
    CCommunity_ClanAnnouncementInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCommunity_ClanAnnouncementInfoDefaultTypeInternal _CCommunity_ClanAnnouncementInfo_default_instance_;
PROTOBUF_CONSTEXPR CCommunity_GetClanAnnouncements_Request::CCommunity_GetClanAnnouncements_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.required_tags_)*/{}
  , /*decltype(_impl_.language_preference_)*/{}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.offset_)*/0u
  , /*decltype(_impl_.count_)*/0u
  , /*decltype(_impl_.maxchars_)*/0u
  , /*decltype(_impl_.strip_html_)*/false
  , /*decltype(_impl_.require_no_tags_)*/false
  , /*decltype(_impl_.hidden_only_)*/false
  , /*decltype(_impl_.only_gid_)*/false
  , /*decltype(_impl_.rtime_oldest_date_)*/0u
  , /*decltype(_impl_.include_hidden_)*/false
  , /*decltype(_impl_.include_partner_events_)*/false} {}
struct CCommunity_GetClanAnnouncements_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCommunity_GetClanAnnouncements_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCommunity_GetClanAnnouncements_RequestDefaultTypeInternal() {}
  union {
    CCommunity_GetClanAnnouncements_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCommunity_GetClanAnnouncements_RequestDefaultTypeInternal _CCommunity_GetClanAnnouncements_Request_default_instance_;
PROTOBUF_CONSTEXPR CCommunity_GetClanAnnouncements_Response::CCommunity_GetClanAnnouncements_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.announcements_)*/{}
  , /*decltype(_impl_.maxchars_)*/0u
  , /*decltype(_impl_.strip_html_)*/false} {}
struct CCommunity_GetClanAnnouncements_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCommunity_GetClanAnnouncements_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCommunity_GetClanAnnouncements_ResponseDefaultTypeInternal() {}
  union {
    CCommunity_GetClanAnnouncements_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCommunity_GetClanAnnouncements_ResponseDefaultTypeInternal _CCommunity_GetClanAnnouncements_Response_default_instance_;
PROTOBUF_CONSTEXPR CBroadcast_PostGameDataFrame_Request::CBroadcast_PostGameDataFrame_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.frame_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.broadcast_id_)*/uint64_t{0u}
  , /*decltype(_impl_.appid_)*/0u} {}
struct CBroadcast_PostGameDataFrame_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CBroadcast_PostGameDataFrame_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CBroadcast_PostGameDataFrame_RequestDefaultTypeInternal() {}
  union {
    CBroadcast_PostGameDataFrame_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CBroadcast_PostGameDataFrame_RequestDefaultTypeInternal _CBroadcast_PostGameDataFrame_Request_default_instance_;
PROTOBUF_CONSTEXPR CMsgSerializedSOCache_TypeCache::CMsgSerializedSOCache_TypeCache(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.objects_)*/{}
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.service_id_)*/0u} {}
struct CMsgSerializedSOCache_TypeCacheDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSerializedSOCache_TypeCacheDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSerializedSOCache_TypeCacheDefaultTypeInternal() {}
  union {
    CMsgSerializedSOCache_TypeCache _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSerializedSOCache_TypeCacheDefaultTypeInternal _CMsgSerializedSOCache_TypeCache_default_instance_;
PROTOBUF_CONSTEXPR CMsgSerializedSOCache_Cache_Version::CMsgSerializedSOCache_Cache_Version(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.version_)*/uint64_t{0u}
  , /*decltype(_impl_.service_)*/0u} {}
struct CMsgSerializedSOCache_Cache_VersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSerializedSOCache_Cache_VersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSerializedSOCache_Cache_VersionDefaultTypeInternal() {}
  union {
    CMsgSerializedSOCache_Cache_Version _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSerializedSOCache_Cache_VersionDefaultTypeInternal _CMsgSerializedSOCache_Cache_Version_default_instance_;
PROTOBUF_CONSTEXPR CMsgSerializedSOCache_Cache::CMsgSerializedSOCache_Cache(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.versions_)*/{}
  , /*decltype(_impl_.type_caches_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0u} {}
struct CMsgSerializedSOCache_CacheDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSerializedSOCache_CacheDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSerializedSOCache_CacheDefaultTypeInternal() {}
  union {
    CMsgSerializedSOCache_Cache _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSerializedSOCache_CacheDefaultTypeInternal _CMsgSerializedSOCache_Cache_default_instance_;
PROTOBUF_CONSTEXPR CMsgSerializedSOCache::CMsgSerializedSOCache(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.caches_)*/{}
  , /*decltype(_impl_.file_version_)*/0u
  , /*decltype(_impl_.gc_socache_file_version_)*/0u} {}
struct CMsgSerializedSOCacheDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSerializedSOCacheDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSerializedSOCacheDefaultTypeInternal() {}
  union {
    CMsgSerializedSOCache _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSerializedSOCacheDefaultTypeInternal _CMsgSerializedSOCache_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToClientPollConvarRequest::CMsgGCToClientPollConvarRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.convar_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.poll_id_)*/0u} {}
struct CMsgGCToClientPollConvarRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToClientPollConvarRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToClientPollConvarRequestDefaultTypeInternal() {}
  union {
    CMsgGCToClientPollConvarRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToClientPollConvarRequestDefaultTypeInternal _CMsgGCToClientPollConvarRequest_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToClientPollConvarResponse::CMsgGCToClientPollConvarResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.convar_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.poll_id_)*/0u} {}
struct CMsgGCToClientPollConvarResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToClientPollConvarResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToClientPollConvarResponseDefaultTypeInternal() {}
  union {
    CMsgGCToClientPollConvarResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToClientPollConvarResponseDefaultTypeInternal _CMsgGCToClientPollConvarResponse_default_instance_;
PROTOBUF_CONSTEXPR CGCMsgCompressedMsgToClient::CGCMsgCompressedMsgToClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.compressed_msg_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_id_)*/0u} {}
struct CGCMsgCompressedMsgToClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CGCMsgCompressedMsgToClientDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CGCMsgCompressedMsgToClientDefaultTypeInternal() {}
  union {
    CGCMsgCompressedMsgToClient _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CGCMsgCompressedMsgToClientDefaultTypeInternal _CGCMsgCompressedMsgToClient_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCMasterBroadcastMessage::CMsgGCToGCMasterBroadcastMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.msg_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.users_per_second_)*/0u
  , /*decltype(_impl_.send_to_users_)*/false
  , /*decltype(_impl_.send_to_servers_)*/false
  , /*decltype(_impl_.msg_id_)*/0u} {}
struct CMsgGCToGCMasterBroadcastMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCMasterBroadcastMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCMasterBroadcastMessageDefaultTypeInternal() {}
  union {
    CMsgGCToGCMasterBroadcastMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCMasterBroadcastMessageDefaultTypeInternal _CMsgGCToGCMasterBroadcastMessage_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCMasterSubscribeToCache::CMsgGCToGCMasterSubscribeToCache(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_ids_)*/{}
  , /*decltype(_impl_.steam_ids_)*/{}
  , /*decltype(_impl_.soid_id_)*/uint64_t{0u}
  , /*decltype(_impl_.soid_type_)*/0u} {}
struct CMsgGCToGCMasterSubscribeToCacheDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCMasterSubscribeToCacheDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCMasterSubscribeToCacheDefaultTypeInternal() {}
  union {
    CMsgGCToGCMasterSubscribeToCache _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCMasterSubscribeToCacheDefaultTypeInternal _CMsgGCToGCMasterSubscribeToCache_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCMasterSubscribeToCacheResponse::CMsgGCToGCMasterSubscribeToCacheResponse(
    ::_pbi::ConstantInitialized) {}
struct CMsgGCToGCMasterSubscribeToCacheResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCMasterSubscribeToCacheResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCMasterSubscribeToCacheResponseDefaultTypeInternal() {}
  union {
    CMsgGCToGCMasterSubscribeToCacheResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCMasterSubscribeToCacheResponseDefaultTypeInternal _CMsgGCToGCMasterSubscribeToCacheResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCMasterSubscribeToCacheAsync::CMsgGCToGCMasterSubscribeToCacheAsync(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subscribe_msg_)*/nullptr} {}
struct CMsgGCToGCMasterSubscribeToCacheAsyncDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCMasterSubscribeToCacheAsyncDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCMasterSubscribeToCacheAsyncDefaultTypeInternal() {}
  union {
    CMsgGCToGCMasterSubscribeToCacheAsync _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCMasterSubscribeToCacheAsyncDefaultTypeInternal _CMsgGCToGCMasterSubscribeToCacheAsync_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCMasterUnsubscribeFromCache::CMsgGCToGCMasterUnsubscribeFromCache(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_ids_)*/{}
  , /*decltype(_impl_.steam_ids_)*/{}
  , /*decltype(_impl_.soid_id_)*/uint64_t{0u}
  , /*decltype(_impl_.soid_type_)*/0u} {}
struct CMsgGCToGCMasterUnsubscribeFromCacheDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCMasterUnsubscribeFromCacheDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCMasterUnsubscribeFromCacheDefaultTypeInternal() {}
  union {
    CMsgGCToGCMasterUnsubscribeFromCache _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCMasterUnsubscribeFromCacheDefaultTypeInternal _CMsgGCToGCMasterUnsubscribeFromCache_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToGCMasterDestroyCache::CMsgGCToGCMasterDestroyCache(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.soid_id_)*/uint64_t{0u}
  , /*decltype(_impl_.soid_type_)*/0u} {}
struct CMsgGCToGCMasterDestroyCacheDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToGCMasterDestroyCacheDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToGCMasterDestroyCacheDefaultTypeInternal() {}
  union {
    CMsgGCToGCMasterDestroyCache _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToGCMasterDestroyCacheDefaultTypeInternal _CMsgGCToGCMasterDestroyCache_default_instance_;
static ::_pb::Metadata file_level_metadata_gcsdk_5fgcmessages_2eproto[73];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_gcsdk_5fgcmessages_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_gcsdk_5fgcmessages_2eproto = nullptr;

const uint32_t TableStruct_gcsdk_5fgcmessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CExtraMsgBlock, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CExtraMsgBlock, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CExtraMsgBlock, _impl_.msg_type_),
  PROTOBUF_FIELD_OFFSET(::CExtraMsgBlock, _impl_.contents_),
  PROTOBUF_FIELD_OFFSET(::CExtraMsgBlock, _impl_.msg_key_),
  PROTOBUF_FIELD_OFFSET(::CExtraMsgBlock, _impl_.is_compressed_),
  1,
  0,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSteamLearnServerInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamLearnServerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSteamLearnServerInfo, _impl_.enable_data_submission_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamLearnServerInfo, _impl_.enable_inferencing_),
  PROTOBUF_FIELD_OFFSET(::CMsgSteamLearnServerInfo, _impl_.hmac_keys_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCAssertJobData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCAssertJobData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCAssertJobData, _impl_.message_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCAssertJobData, _impl_.message_data_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgGCConCommand, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCConCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCConCommand, _impl_.command_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSDOAssert_Request, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSDOAssert_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSDOAssert_Request, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::CMsgSDOAssert_Request, _impl_.requesting_job_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSDOAssert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSDOAssert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSDOAssert, _impl_.sdo_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgSDOAssert, _impl_.requests_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgSOIDOwner, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOIDOwner, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSOIDOwner, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOIDOwner, _impl_.id_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSOSingleObject, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOSingleObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSOSingleObject, _impl_.type_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOSingleObject, _impl_.object_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOSingleObject, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOSingleObject, _impl_.owner_soid_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOSingleObject, _impl_.service_id_),
  3,
  0,
  2,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgSOMultipleObjects_SingleObject, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOMultipleObjects_SingleObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSOMultipleObjects_SingleObject, _impl_.type_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOMultipleObjects_SingleObject, _impl_.object_data_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSOMultipleObjects, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOMultipleObjects, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSOMultipleObjects, _impl_.objects_modified_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOMultipleObjects, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOMultipleObjects, _impl_.objects_added_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOMultipleObjects, _impl_.objects_removed_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOMultipleObjects, _impl_.owner_soid_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOMultipleObjects, _impl_.service_id_),
  ~0u,
  1,
  ~0u,
  ~0u,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribed_SubscribedType, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribed_SubscribedType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribed_SubscribedType, _impl_.type_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribed_SubscribedType, _impl_.object_data_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribed, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribed, _impl_.objects_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribed, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribed, _impl_.owner_soid_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribed, _impl_.service_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribed, _impl_.service_list_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribed, _impl_.sync_version_),
  ~0u,
  1,
  0,
  3,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribedUpToDate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribedUpToDate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribedUpToDate, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribedUpToDate, _impl_.owner_soid_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribedUpToDate, _impl_.service_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribedUpToDate, _impl_.service_list_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscribedUpToDate, _impl_.sync_version_),
  1,
  0,
  3,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheUnsubscribed, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheUnsubscribed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheUnsubscribed, _impl_.owner_soid_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscriptionCheck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscriptionCheck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscriptionCheck, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscriptionCheck, _impl_.owner_soid_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscriptionCheck, _impl_.service_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscriptionCheck, _impl_.service_list_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscriptionCheck, _impl_.sync_version_),
  1,
  0,
  3,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscriptionRefresh, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscriptionRefresh, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheSubscriptionRefresh, _impl_.owner_soid_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheVersion, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheVersion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheVersion, _impl_.version_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCMultiplexMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCMultiplexMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCMultiplexMessage, _impl_.msgtype_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCMultiplexMessage, _impl_.payload_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCMultiplexMessage, _impl_.steamids_),
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSubGCStarting, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSubGCStarting, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSubGCStarting, _impl_.dir_index_),
  0,
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck_Process, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck_Process, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck_Process, _impl_.dir_index_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck_Process, _impl_.type_instances_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck, _impl_.dir_index_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck, _impl_.machine_name_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck, _impl_.process_name_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck, _impl_.directory_),
  2,
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck_Response, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterAck_Response, _impl_.eresult_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUniverseStartup, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUniverseStartup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUniverseStartup, _impl_.is_initial_startup_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUniverseStartupResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUniverseStartupResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUniverseStartupResponse, _impl_.eresult_),
  0,
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterStartupComplete_GCInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterStartupComplete_GCInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterStartupComplete_GCInfo, _impl_.dir_index_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterStartupComplete_GCInfo, _impl_.machine_name_),
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterStartupComplete, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgMasterStartupComplete, _impl_.gc_info_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgRouted, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgRouted, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgRouted, _impl_.msg_type_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgRouted, _impl_.sender_id_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgRouted, _impl_.net_message_),
  2,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgRoutedReply, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgRoutedReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgRoutedReply, _impl_.msg_type_),
  PROTOBUF_FIELD_OFFSET(::CGCToGCMsgRoutedReply, _impl_.net_message_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCUpdateSubGCSessionInfo_CMsgUpdate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCUpdateSubGCSessionInfo_CMsgUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCUpdateSubGCSessionInfo_CMsgUpdate, _impl_.steamid_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCUpdateSubGCSessionInfo_CMsgUpdate, _impl_.ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCUpdateSubGCSessionInfo_CMsgUpdate, _impl_.trusted_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGCUpdateSubGCSessionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCUpdateSubGCSessionInfo, _impl_.updates_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestSubGCSessionInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestSubGCSessionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestSubGCSessionInfo, _impl_.steamid_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestSubGCSessionInfoResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestSubGCSessionInfoResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestSubGCSessionInfoResponse, _impl_.ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestSubGCSessionInfoResponse, _impl_.trusted_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestSubGCSessionInfoResponse, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRequestSubGCSessionInfoResponse, _impl_.success_),
  0,
  2,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheHaveVersion, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheHaveVersion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheHaveVersion, _impl_.soid_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheHaveVersion, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheHaveVersion, _impl_.service_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSOCacheHaveVersion, _impl_.cached_file_version_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.socache_have_versions_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.client_session_need_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.client_launcher_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.secret_key_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.client_language_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.engine_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.steamdatagram_login_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.platform_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.game_msg_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.os_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.render_system_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.render_system_req_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.screen_width_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.screen_height_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.screen_refresh_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.render_width_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.render_height_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.swap_width_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.swap_height_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.is_steam_china_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.is_steam_china_client_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientHello, _impl_.platform_name_),
  4,
  ~0u,
  5,
  6,
  0,
  7,
  8,
  1,
  9,
  2,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome_Location, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome_Location, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome_Location, _impl_.latitude_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome_Location, _impl_.longitude_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome_Location, _impl_.country_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.game_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.outofdate_subscribed_caches_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.uptodate_subscribed_caches_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.location_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.save_game_key_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.gc_socache_file_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.txn_country_code_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.game_data2_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.rtime32_gc_welcome_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.currency_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.balance_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.balance_url_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.has_accepted_china_ssa_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.is_banned_steam_china_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.additional_welcome_msgs_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientWelcome, _impl_.steam_learn_server_info_),
  8,
  0,
  ~0u,
  ~0u,
  5,
  1,
  9,
  2,
  3,
  10,
  11,
  12,
  4,
  13,
  14,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgConnectionStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgConnectionStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgConnectionStatus, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::CMsgConnectionStatus, _impl_.client_session_need_),
  PROTOBUF_FIELD_OFFSET(::CMsgConnectionStatus, _impl_.queue_position_),
  PROTOBUF_FIELD_OFFSET(::CMsgConnectionStatus, _impl_.queue_size_),
  PROTOBUF_FIELD_OFFSET(::CMsgConnectionStatus, _impl_.wait_seconds_),
  PROTOBUF_FIELD_OFFSET(::CMsgConnectionStatus, _impl_.estimated_wait_seconds_remaining_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions, _impl_.service_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions, _impl_.version_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheSubscribe, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheSubscribe, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheSubscribe, _impl_.subscriber_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheSubscribe, _impl_.subscribe_to_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheSubscribe, _impl_.sync_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheSubscribe, _impl_.have_versions_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheSubscribe, _impl_.subscribe_to_type_),
  0,
  1,
  2,
  ~0u,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheUnsubscribe, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheUnsubscribe, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheUnsubscribe, _impl_.subscriber_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheUnsubscribe, _impl_.unsubscribe_from_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCSOCacheUnsubscribe, _impl_.unsubscribe_from_type_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGCClientPing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCForwardAccountDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCForwardAccountDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCForwardAccountDetails, _impl_.steamid_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCForwardAccountDetails, _impl_.account_details_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCForwardAccountDetails, _impl_.age_seconds_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCLoadSessionSOCache, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCLoadSessionSOCache, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCLoadSessionSOCache, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCLoadSessionSOCache, _impl_.forward_account_details_),
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCLoadSessionSOCacheResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUpdateSessionStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUpdateSessionStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUpdateSessionStats, _impl_.user_sessions_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUpdateSessionStats, _impl_.server_sessions_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCUpdateSessionStats, _impl_.in_logon_surge_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientRequestDropped, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription, _impl_.gameitemid_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription, _impl_.item_description_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock, _impl_.descriptions_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CWorkshop_PopulateItemDescriptions_Request, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_PopulateItemDescriptions_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_PopulateItemDescriptions_Request, _impl_.appid_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_PopulateItemDescriptions_Request, _impl_.languages_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CWorkshop_GetContributors_Request, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_GetContributors_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_GetContributors_Request, _impl_.appid_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_GetContributors_Request, _impl_.gameitemid_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_GetContributors_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_GetContributors_Response, _impl_.contributors_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule, _impl_.workshop_file_id_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule, _impl_.revenue_percentage_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule, _impl_.rule_description_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule, _impl_.rule_type_),
  1,
  2,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule, _impl_.workshop_file_id_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule, _impl_.rule_description_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule, _impl_.revenue_percentage_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule, _impl_.rule_description_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request, _impl_.appid_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request, _impl_.gameitemid_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request, _impl_.associated_workshop_files_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request, _impl_.partner_accounts_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request, _impl_.validate_only_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request, _impl_.make_workshop_files_subscribable_),
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Request, _impl_.associated_workshop_file_for_direct_payments_),
  1,
  2,
  ~0u,
  ~0u,
  3,
  4,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CWorkshop_SetItemPaymentRules_Response, _impl_.validation_errors_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.gid_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.clanid_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.posterid_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.headline_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.posttime_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.updatetime_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.commentcount_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.tags_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.hidden_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.forum_topic_id_),
  2,
  3,
  4,
  0,
  5,
  6,
  1,
  7,
  ~0u,
  8,
  10,
  9,
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.steamid_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.maxchars_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.strip_html_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.required_tags_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.require_no_tags_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.language_preference_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.hidden_only_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.only_gid_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.rtime_oldest_date_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.include_hidden_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Request, _impl_.include_partner_events_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  5,
  ~0u,
  6,
  7,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Response, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Response, _impl_.maxchars_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Response, _impl_.strip_html_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_GetClanAnnouncements_Response, _impl_.announcements_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CBroadcast_PostGameDataFrame_Request, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CBroadcast_PostGameDataFrame_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CBroadcast_PostGameDataFrame_Request, _impl_.appid_),
  PROTOBUF_FIELD_OFFSET(::CBroadcast_PostGameDataFrame_Request, _impl_.steamid_),
  PROTOBUF_FIELD_OFFSET(::CBroadcast_PostGameDataFrame_Request, _impl_.broadcast_id_),
  PROTOBUF_FIELD_OFFSET(::CBroadcast_PostGameDataFrame_Request, _impl_.frame_data_),
  3,
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_TypeCache, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_TypeCache, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_TypeCache, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_TypeCache, _impl_.objects_),
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_TypeCache, _impl_.service_id_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_Cache_Version, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_Cache_Version, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_Cache_Version, _impl_.service_),
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_Cache_Version, _impl_.version_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_Cache, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_Cache, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_Cache, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_Cache, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_Cache, _impl_.versions_),
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache_Cache, _impl_.type_caches_),
  1,
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache, _impl_.file_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache, _impl_.caches_),
  PROTOBUF_FIELD_OFFSET(::CMsgSerializedSOCache, _impl_.gc_socache_file_version_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientPollConvarRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientPollConvarRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientPollConvarRequest, _impl_.convar_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientPollConvarRequest, _impl_.poll_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientPollConvarResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientPollConvarResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientPollConvarResponse, _impl_.poll_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientPollConvarResponse, _impl_.convar_value_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CGCMsgCompressedMsgToClient, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGCMsgCompressedMsgToClient, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGCMsgCompressedMsgToClient, _impl_.msg_id_),
  PROTOBUF_FIELD_OFFSET(::CGCMsgCompressedMsgToClient, _impl_.compressed_msg_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterBroadcastMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterBroadcastMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterBroadcastMessage, _impl_.users_per_second_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterBroadcastMessage, _impl_.send_to_users_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterBroadcastMessage, _impl_.send_to_servers_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterBroadcastMessage, _impl_.msg_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterBroadcastMessage, _impl_.msg_data_),
  1,
  2,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterSubscribeToCache, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterSubscribeToCache, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterSubscribeToCache, _impl_.soid_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterSubscribeToCache, _impl_.soid_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterSubscribeToCache, _impl_.account_ids_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterSubscribeToCache, _impl_.steam_ids_),
  1,
  0,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterSubscribeToCacheResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterSubscribeToCacheAsync, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterSubscribeToCacheAsync, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterSubscribeToCacheAsync, _impl_.subscribe_msg_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterUnsubscribeFromCache, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterUnsubscribeFromCache, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterUnsubscribeFromCache, _impl_.soid_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterUnsubscribeFromCache, _impl_.soid_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterUnsubscribeFromCache, _impl_.account_ids_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterUnsubscribeFromCache, _impl_.steam_ids_),
  1,
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterDestroyCache, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterDestroyCache, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterDestroyCache, _impl_.soid_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToGCMasterDestroyCache, _impl_.soid_id_),
  1,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, -1, sizeof(::CExtraMsgBlock)},
  { 14, 23, -1, sizeof(::CMsgSteamLearnServerInfo)},
  { 26, 34, -1, sizeof(::CMsgGCAssertJobData)},
  { 36, 43, -1, sizeof(::CMsgGCConCommand)},
  { 44, 52, -1, sizeof(::CMsgSDOAssert_Request)},
  { 54, 62, -1, sizeof(::CMsgSDOAssert)},
  { 64, 72, -1, sizeof(::CMsgSOIDOwner)},
  { 74, 85, -1, sizeof(::CMsgSOSingleObject)},
  { 90, 98, -1, sizeof(::CMsgSOMultipleObjects_SingleObject)},
  { 100, 112, -1, sizeof(::CMsgSOMultipleObjects)},
  { 118, 126, -1, sizeof(::CMsgSOCacheSubscribed_SubscribedType)},
  { 128, 140, -1, sizeof(::CMsgSOCacheSubscribed)},
  { 146, 157, -1, sizeof(::CMsgSOCacheSubscribedUpToDate)},
  { 162, 169, -1, sizeof(::CMsgSOCacheUnsubscribed)},
  { 170, 181, -1, sizeof(::CMsgSOCacheSubscriptionCheck)},
  { 186, 193, -1, sizeof(::CMsgSOCacheSubscriptionRefresh)},
  { 194, 201, -1, sizeof(::CMsgSOCacheVersion)},
  { 202, 211, -1, sizeof(::CMsgGCMultiplexMessage)},
  { 214, 221, -1, sizeof(::CMsgGCToGCSubGCStarting)},
  { 222, 230, -1, sizeof(::CGCToGCMsgMasterAck_Process)},
  { 232, 242, -1, sizeof(::CGCToGCMsgMasterAck)},
  { 246, 253, -1, sizeof(::CGCToGCMsgMasterAck_Response)},
  { 254, 261, -1, sizeof(::CMsgGCToGCUniverseStartup)},
  { 262, 269, -1, sizeof(::CMsgGCToGCUniverseStartupResponse)},
  { 270, 278, -1, sizeof(::CGCToGCMsgMasterStartupComplete_GCInfo)},
  { 280, -1, -1, sizeof(::CGCToGCMsgMasterStartupComplete)},
  { 287, 296, -1, sizeof(::CGCToGCMsgRouted)},
  { 299, 307, -1, sizeof(::CGCToGCMsgRoutedReply)},
  { 309, 318, -1, sizeof(::CMsgGCUpdateSubGCSessionInfo_CMsgUpdate)},
  { 321, -1, -1, sizeof(::CMsgGCUpdateSubGCSessionInfo)},
  { 328, 335, -1, sizeof(::CMsgGCRequestSubGCSessionInfo)},
  { 336, 346, -1, sizeof(::CMsgGCRequestSubGCSessionInfoResponse)},
  { 350, 360, -1, sizeof(::CMsgSOCacheHaveVersion)},
  { 364, 393, -1, sizeof(::CMsgClientHello)},
  { 416, 425, -1, sizeof(::CMsgClientWelcome_Location)},
  { 428, 451, -1, sizeof(::CMsgClientWelcome)},
  { 468, 480, -1, sizeof(::CMsgConnectionStatus)},
  { 486, 494, -1, sizeof(::CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions)},
  { 496, 507, -1, sizeof(::CMsgGCToGCSOCacheSubscribe)},
  { 512, 521, -1, sizeof(::CMsgGCToGCSOCacheUnsubscribe)},
  { 524, -1, -1, sizeof(::CMsgGCClientPing)},
  { 530, 539, -1, sizeof(::CMsgGCToGCForwardAccountDetails)},
  { 542, 550, -1, sizeof(::CMsgGCToGCLoadSessionSOCache)},
  { 552, -1, -1, sizeof(::CMsgGCToGCLoadSessionSOCacheResponse)},
  { 558, 567, -1, sizeof(::CMsgGCToGCUpdateSessionStats)},
  { 570, -1, -1, sizeof(::CMsgGCToClientRequestDropped)},
  { 576, 584, -1, sizeof(::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription)},
  { 586, 594, -1, sizeof(::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock)},
  { 596, 604, -1, sizeof(::CWorkshop_PopulateItemDescriptions_Request)},
  { 606, 614, -1, sizeof(::CWorkshop_GetContributors_Request)},
  { 616, -1, -1, sizeof(::CWorkshop_GetContributors_Response)},
  { 623, 633, -1, sizeof(::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule)},
  { 637, 645, -1, sizeof(::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule)},
  { 647, 656, -1, sizeof(::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule)},
  { 659, 672, -1, sizeof(::CWorkshop_SetItemPaymentRules_Request)},
  { 679, -1, -1, sizeof(::CWorkshop_SetItemPaymentRules_Response)},
  { 686, 704, -1, sizeof(::CCommunity_ClanAnnouncementInfo)},
  { 716, 735, -1, sizeof(::CCommunity_GetClanAnnouncements_Request)},
  { 748, 757, -1, sizeof(::CCommunity_GetClanAnnouncements_Response)},
  { 760, 770, -1, sizeof(::CBroadcast_PostGameDataFrame_Request)},
  { 774, 783, -1, sizeof(::CMsgSerializedSOCache_TypeCache)},
  { 786, 794, -1, sizeof(::CMsgSerializedSOCache_Cache_Version)},
  { 796, 806, -1, sizeof(::CMsgSerializedSOCache_Cache)},
  { 810, 819, -1, sizeof(::CMsgSerializedSOCache)},
  { 822, 830, -1, sizeof(::CMsgGCToClientPollConvarRequest)},
  { 832, 840, -1, sizeof(::CMsgGCToClientPollConvarResponse)},
  { 842, 850, -1, sizeof(::CGCMsgCompressedMsgToClient)},
  { 852, 863, -1, sizeof(::CMsgGCToGCMasterBroadcastMessage)},
  { 868, 878, -1, sizeof(::CMsgGCToGCMasterSubscribeToCache)},
  { 882, -1, -1, sizeof(::CMsgGCToGCMasterSubscribeToCacheResponse)},
  { 888, 895, -1, sizeof(::CMsgGCToGCMasterSubscribeToCacheAsync)},
  { 896, 906, -1, sizeof(::CMsgGCToGCMasterUnsubscribeFromCache)},
  { 910, 918, -1, sizeof(::CMsgGCToGCMasterDestroyCache)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CExtraMsgBlock_default_instance_._instance,
  &::_CMsgSteamLearnServerInfo_default_instance_._instance,
  &::_CMsgGCAssertJobData_default_instance_._instance,
  &::_CMsgGCConCommand_default_instance_._instance,
  &::_CMsgSDOAssert_Request_default_instance_._instance,
  &::_CMsgSDOAssert_default_instance_._instance,
  &::_CMsgSOIDOwner_default_instance_._instance,
  &::_CMsgSOSingleObject_default_instance_._instance,
  &::_CMsgSOMultipleObjects_SingleObject_default_instance_._instance,
  &::_CMsgSOMultipleObjects_default_instance_._instance,
  &::_CMsgSOCacheSubscribed_SubscribedType_default_instance_._instance,
  &::_CMsgSOCacheSubscribed_default_instance_._instance,
  &::_CMsgSOCacheSubscribedUpToDate_default_instance_._instance,
  &::_CMsgSOCacheUnsubscribed_default_instance_._instance,
  &::_CMsgSOCacheSubscriptionCheck_default_instance_._instance,
  &::_CMsgSOCacheSubscriptionRefresh_default_instance_._instance,
  &::_CMsgSOCacheVersion_default_instance_._instance,
  &::_CMsgGCMultiplexMessage_default_instance_._instance,
  &::_CMsgGCToGCSubGCStarting_default_instance_._instance,
  &::_CGCToGCMsgMasterAck_Process_default_instance_._instance,
  &::_CGCToGCMsgMasterAck_default_instance_._instance,
  &::_CGCToGCMsgMasterAck_Response_default_instance_._instance,
  &::_CMsgGCToGCUniverseStartup_default_instance_._instance,
  &::_CMsgGCToGCUniverseStartupResponse_default_instance_._instance,
  &::_CGCToGCMsgMasterStartupComplete_GCInfo_default_instance_._instance,
  &::_CGCToGCMsgMasterStartupComplete_default_instance_._instance,
  &::_CGCToGCMsgRouted_default_instance_._instance,
  &::_CGCToGCMsgRoutedReply_default_instance_._instance,
  &::_CMsgGCUpdateSubGCSessionInfo_CMsgUpdate_default_instance_._instance,
  &::_CMsgGCUpdateSubGCSessionInfo_default_instance_._instance,
  &::_CMsgGCRequestSubGCSessionInfo_default_instance_._instance,
  &::_CMsgGCRequestSubGCSessionInfoResponse_default_instance_._instance,
  &::_CMsgSOCacheHaveVersion_default_instance_._instance,
  &::_CMsgClientHello_default_instance_._instance,
  &::_CMsgClientWelcome_Location_default_instance_._instance,
  &::_CMsgClientWelcome_default_instance_._instance,
  &::_CMsgConnectionStatus_default_instance_._instance,
  &::_CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions_default_instance_._instance,
  &::_CMsgGCToGCSOCacheSubscribe_default_instance_._instance,
  &::_CMsgGCToGCSOCacheUnsubscribe_default_instance_._instance,
  &::_CMsgGCClientPing_default_instance_._instance,
  &::_CMsgGCToGCForwardAccountDetails_default_instance_._instance,
  &::_CMsgGCToGCLoadSessionSOCache_default_instance_._instance,
  &::_CMsgGCToGCLoadSessionSOCacheResponse_default_instance_._instance,
  &::_CMsgGCToGCUpdateSessionStats_default_instance_._instance,
  &::_CMsgGCToClientRequestDropped_default_instance_._instance,
  &::_CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription_default_instance_._instance,
  &::_CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock_default_instance_._instance,
  &::_CWorkshop_PopulateItemDescriptions_Request_default_instance_._instance,
  &::_CWorkshop_GetContributors_Request_default_instance_._instance,
  &::_CWorkshop_GetContributors_Response_default_instance_._instance,
  &::_CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule_default_instance_._instance,
  &::_CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule_default_instance_._instance,
  &::_CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule_default_instance_._instance,
  &::_CWorkshop_SetItemPaymentRules_Request_default_instance_._instance,
  &::_CWorkshop_SetItemPaymentRules_Response_default_instance_._instance,
  &::_CCommunity_ClanAnnouncementInfo_default_instance_._instance,
  &::_CCommunity_GetClanAnnouncements_Request_default_instance_._instance,
  &::_CCommunity_GetClanAnnouncements_Response_default_instance_._instance,
  &::_CBroadcast_PostGameDataFrame_Request_default_instance_._instance,
  &::_CMsgSerializedSOCache_TypeCache_default_instance_._instance,
  &::_CMsgSerializedSOCache_Cache_Version_default_instance_._instance,
  &::_CMsgSerializedSOCache_Cache_default_instance_._instance,
  &::_CMsgSerializedSOCache_default_instance_._instance,
  &::_CMsgGCToClientPollConvarRequest_default_instance_._instance,
  &::_CMsgGCToClientPollConvarResponse_default_instance_._instance,
  &::_CGCMsgCompressedMsgToClient_default_instance_._instance,
  &::_CMsgGCToGCMasterBroadcastMessage_default_instance_._instance,
  &::_CMsgGCToGCMasterSubscribeToCache_default_instance_._instance,
  &::_CMsgGCToGCMasterSubscribeToCacheResponse_default_instance_._instance,
  &::_CMsgGCToGCMasterSubscribeToCacheAsync_default_instance_._instance,
  &::_CMsgGCToGCMasterUnsubscribeFromCache_default_instance_._instance,
  &::_CMsgGCToGCMasterDestroyCache_default_instance_._instance,
};

const char descriptor_table_protodef_gcsdk_5fgcmessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\026gcsdk_gcmessages.proto\032\023steammessages."
  "proto\032,steammessages_steamlearn.steamwor"
  "kssdk.proto\"\\\n\016CExtraMsgBlock\022\020\n\010msg_typ"
  "e\030\001 \001(\r\022\020\n\010contents\030\002 \001(\014\022\017\n\007msg_key\030\003 \001"
  "(\004\022\025\n\ris_compressed\030\004 \001(\010\"\202\001\n\030CMsgSteamL"
  "earnServerInfo\022\036\n\026enable_data_submission"
  "\030\001 \001(\010\022\032\n\022enable_inferencing\030\002 \001(\010\022*\n\thm"
  "ac_keys\030\003 \001(\0132\027.CMsgSteamLearnHMACKeys\"A"
  "\n\023CMsgGCAssertJobData\022\024\n\014message_type\030\001 "
  "\001(\t\022\024\n\014message_data\030\002 \001(\014\"#\n\020CMsgGCConCo"
  "mmand\022\017\n\007command\030\001 \001(\t\"{\n\rCMsgSDOAssert\022"
  "\020\n\010sdo_type\030\001 \001(\005\022(\n\010requests\030\002 \003(\0132\026.CM"
  "sgSDOAssert.Request\032.\n\007Request\022\013\n\003key\030\001 "
  "\003(\004\022\026\n\016requesting_job\030\002 \001(\t\")\n\rCMsgSOIDO"
  "wner\022\014\n\004type\030\001 \001(\r\022\n\n\002id\030\002 \001(\004\"\203\001\n\022CMsgS"
  "OSingleObject\022\017\n\007type_id\030\002 \001(\005\022\023\n\013object"
  "_data\030\003 \001(\014\022\017\n\007version\030\004 \001(\006\022\"\n\nowner_so"
  "id\030\005 \001(\0132\016.CMsgSOIDOwner\022\022\n\nservice_id\030\006"
  " \001(\r\"\333\002\n\025CMsgSOMultipleObjects\022=\n\020object"
  "s_modified\030\002 \003(\0132#.CMsgSOMultipleObjects"
  ".SingleObject\022\017\n\007version\030\003 \001(\006\022:\n\robject"
  "s_added\030\004 \003(\0132#.CMsgSOMultipleObjects.Si"
  "ngleObject\022<\n\017objects_removed\030\005 \003(\0132#.CM"
  "sgSOMultipleObjects.SingleObject\022\"\n\nowne"
  "r_soid\030\006 \001(\0132\016.CMsgSOIDOwner\022\022\n\nservice_"
  "id\030\007 \001(\r\032@\n\014SingleObject\022\017\n\007type_id\030\001 \001("
  "\005\022\023\n\013object_data\030\002 \001(\014:\n\200\246\035\200\002\210\246\035\200\010\"\374\001\n\025C"
  "MsgSOCacheSubscribed\0226\n\007objects\030\002 \003(\0132%."
  "CMsgSOCacheSubscribed.SubscribedType\022\017\n\007"
  "version\030\003 \001(\006\022\"\n\nowner_soid\030\004 \001(\0132\016.CMsg"
  "SOIDOwner\022\022\n\nservice_id\030\005 \001(\r\022\024\n\014service"
  "_list\030\006 \003(\r\022\024\n\014sync_version\030\007 \001(\006\0326\n\016Sub"
  "scribedType\022\017\n\007type_id\030\001 \001(\005\022\023\n\013object_d"
  "ata\030\002 \003(\014\"\224\001\n\035CMsgSOCacheSubscribedUpToD"
  "ate\022\017\n\007version\030\001 \001(\006\022\"\n\nowner_soid\030\002 \001(\013"
  "2\016.CMsgSOIDOwner\022\022\n\nservice_id\030\003 \001(\r\022\024\n\014"
  "service_list\030\004 \003(\r\022\024\n\014sync_version\030\005 \001(\006"
  "\"=\n\027CMsgSOCacheUnsubscribed\022\"\n\nowner_soi"
  "d\030\002 \001(\0132\016.CMsgSOIDOwner\"\223\001\n\034CMsgSOCacheS"
  "ubscriptionCheck\022\017\n\007version\030\002 \001(\006\022\"\n\nown"
  "er_soid\030\003 \001(\0132\016.CMsgSOIDOwner\022\022\n\nservice"
  "_id\030\004 \001(\r\022\024\n\014service_list\030\005 \003(\r\022\024\n\014sync_"
  "version\030\006 \001(\006\"D\n\036CMsgSOCacheSubscription"
  "Refresh\022\"\n\nowner_soid\030\002 \001(\0132\016.CMsgSOIDOw"
  "ner\"%\n\022CMsgSOCacheVersion\022\017\n\007version\030\001 \001"
  "(\006\"L\n\026CMsgGCMultiplexMessage\022\017\n\007msgtype\030"
  "\001 \001(\r\022\017\n\007payload\030\002 \001(\014\022\020\n\010steamids\030\003 \003(\006"
  "\"0\n\027CMsgGCToGCSubGCStarting\022\025\n\tdir_index"
  "\030\001 \001(\005:\002-1\"\303\001\n\023CGCToGCMsgMasterAck\022\025\n\tdi"
  "r_index\030\001 \001(\005:\002-1\022\024\n\014machine_name\030\003 \001(\t\022"
  "\024\n\014process_name\030\004 \001(\t\022/\n\tdirectory\030\006 \003(\013"
  "2\034.CGCToGCMsgMasterAck.Process\0328\n\007Proces"
  "s\022\025\n\tdir_index\030\001 \001(\005:\002-1\022\026\n\016type_instanc"
  "es\030\002 \003(\r\"2\n\034CGCToGCMsgMasterAck_Response"
  "\022\022\n\007eresult\030\001 \001(\005:\0012\"7\n\031CMsgGCToGCUniver"
  "seStartup\022\032\n\022is_initial_startup\030\001 \001(\010\"4\n"
  "!CMsgGCToGCUniverseStartupResponse\022\017\n\007er"
  "esult\030\001 \001(\005\"\222\001\n\037CGCToGCMsgMasterStartupC"
  "omplete\0228\n\007gc_info\030\001 \003(\0132\'.CGCToGCMsgMas"
  "terStartupComplete.GCInfo\0325\n\006GCInfo\022\025\n\td"
  "ir_index\030\001 \001(\005:\002-1\022\024\n\014machine_name\030\002 \001(\t"
  "\"L\n\020CGCToGCMsgRouted\022\020\n\010msg_type\030\001 \001(\r\022\021"
  "\n\tsender_id\030\002 \001(\006\022\023\n\013net_message\030\003 \001(\014\">"
  "\n\025CGCToGCMsgRoutedReply\022\020\n\010msg_type\030\001 \001("
  "\r\022\023\n\013net_message\030\002 \001(\014\"\225\001\n\034CMsgGCUpdateS"
  "ubGCSessionInfo\0229\n\007updates\030\001 \003(\0132(.CMsgG"
  "CUpdateSubGCSessionInfo.CMsgUpdate\032:\n\nCM"
  "sgUpdate\022\017\n\007steamid\030\001 \001(\006\022\n\n\002ip\030\002 \001(\007\022\017\n"
  "\007trusted\030\003 \001(\010\"0\n\035CMsgGCRequestSubGCSess"
  "ionInfo\022\017\n\007steamid\030\001 \001(\006\"c\n%CMsgGCReques"
  "tSubGCSessionInfoResponse\022\n\n\002ip\030\001 \001(\007\022\017\n"
  "\007trusted\030\002 \001(\010\022\014\n\004port\030\003 \001(\r\022\017\n\007success\030"
  "\004 \001(\010\"x\n\026CMsgSOCacheHaveVersion\022\034\n\004soid\030"
  "\001 \001(\0132\016.CMsgSOIDOwner\022\017\n\007version\030\002 \001(\006\022\022"
  "\n\nservice_id\030\003 \001(\r\022\033\n\023cached_file_versio"
  "n\030\004 \001(\r\"\377\004\n\017CMsgClientHello\022\017\n\007version\030\001"
  " \001(\r\0226\n\025socache_have_versions\030\002 \003(\0132\027.CM"
  "sgSOCacheHaveVersion\022\033\n\023client_session_n"
  "eed\030\003 \001(\r\022:\n\017client_launcher\030\004 \001(\0162\023.Par"
  "tnerAccountType:\014PARTNER_NONE\022\022\n\nsecret_"
  "key\030\005 \001(\t\022\027\n\017client_language\030\006 \001(\r\022-\n\006en"
  "gine\030\007 \001(\0162\016.ESourceEngine:\rk_ESE_Source"
  "1\022\033\n\023steamdatagram_login\030\010 \001(\014\022\023\n\013platfo"
  "rm_id\030\t \001(\r\022\020\n\010game_msg\030\n \001(\014\022\017\n\007os_type"
  "\030\013 \001(\005\022\025\n\rrender_system\030\014 \001(\r\022\031\n\021render_"
  "system_req\030\r \001(\r\022\024\n\014screen_width\030\016 \001(\r\022\025"
  "\n\rscreen_height\030\017 \001(\r\022\026\n\016screen_refresh\030"
  "\020 \001(\r\022\024\n\014render_width\030\021 \001(\r\022\025\n\rrender_he"
  "ight\030\022 \001(\r\022\022\n\nswap_width\030\023 \001(\r\022\023\n\013swap_h"
  "eight\030\024 \001(\r\022\026\n\016is_steam_china\030\026 \001(\010\022\035\n\025i"
  "s_steam_china_client\030\030 \001(\010\022\025\n\rplatform_n"
  "ame\030\027 \001(\t\"\231\005\n\021CMsgClientWelcome\022\017\n\007versi"
  "on\030\001 \001(\r\022\021\n\tgame_data\030\002 \001(\014\022;\n\033outofdate"
  "_subscribed_caches\030\003 \003(\0132\026.CMsgSOCacheSu"
  "bscribed\022A\n\032uptodate_subscribed_caches\030\004"
  " \003(\0132\035.CMsgSOCacheSubscriptionCheck\022-\n\010l"
  "ocation\030\005 \001(\0132\033.CMsgClientWelcome.Locati"
  "on\022\025\n\rsave_game_key\030\006 \001(\014\022\037\n\027gc_socache_"
  "file_version\030\t \001(\r\022\030\n\020txn_country_code\030\n"
  " \001(\t\022\022\n\ngame_data2\030\013 \001(\014\022$\n\034rtime32_gc_w"
  "elcome_timestamp\030\014 \001(\r\022\020\n\010currency\030\r \001(\r"
  "\022\017\n\007balance\030\016 \001(\r\022\023\n\013balance_url\030\017 \001(\t\022\036"
  "\n\026has_accepted_china_ssa\030\020 \001(\010\022\035\n\025is_ban"
  "ned_steam_china\030\021 \001(\010\0220\n\027additional_welc"
  "ome_msgs\030\022 \001(\0132\017.CExtraMsgBlock\022:\n\027steam"
  "_learn_server_info\030\024 \001(\0132\031.CMsgSteamLear"
  "nServerInfo\032@\n\010Location\022\020\n\010latitude\030\001 \001("
  "\002\022\021\n\tlongitude\030\002 \001(\002\022\017\n\007country\030\003 \001(\t\"\345\001"
  "\n\024CMsgConnectionStatus\022D\n\006status\030\001 \001(\0162\023"
  ".GCConnectionStatus:\037GCConnectionStatus_"
  "HAVE_SESSION\022\033\n\023client_session_need\030\002 \001("
  "\r\022\026\n\016queue_position\030\003 \001(\005\022\022\n\nqueue_size\030"
  "\004 \001(\005\022\024\n\014wait_seconds\030\005 \001(\005\022(\n estimated"
  "_wait_seconds_remaining\030\006 \001(\005\"\370\001\n\032CMsgGC"
  "ToGCSOCacheSubscribe\022\022\n\nsubscriber\030\001 \001(\006"
  "\022\027\n\017subscribe_to_id\030\002 \001(\006\022\024\n\014sync_versio"
  "n\030\003 \001(\006\022C\n\rhave_versions\030\004 \003(\0132,.CMsgGCT"
  "oGCSOCacheSubscribe.CMsgHaveVersions\022\031\n\021"
  "subscribe_to_type\030\005 \001(\r\0327\n\020CMsgHaveVersi"
  "ons\022\022\n\nservice_id\030\001 \001(\r\022\017\n\007version\030\002 \001(\004"
  "\"n\n\034CMsgGCToGCSOCacheUnsubscribe\022\022\n\nsubs"
  "criber\030\001 \001(\006\022\033\n\023unsubscribe_from_id\030\002 \001("
  "\006\022\035\n\025unsubscribe_from_type\030\003 \001(\r\"\022\n\020CMsg"
  "GCClientPing\"\212\001\n\037CMsgGCToGCForwardAccoun"
  "tDetails\022\017\n\007steamid\030\001 \001(\006\022A\n\017account_det"
  "ails\030\002 \001(\0132(.CGCSystemMsg_GetAccountDeta"
  "ils_Response\022\023\n\013age_seconds\030\003 \001(\r\"u\n\034CMs"
  "gGCToGCLoadSessionSOCache\022\022\n\naccount_id\030"
  "\001 \001(\r\022A\n\027forward_account_details\030\002 \001(\0132 "
  ".CMsgGCToGCForwardAccountDetails\"&\n$CMsg"
  "GCToGCLoadSessionSOCacheResponse\"f\n\034CMsg"
  "GCToGCUpdateSessionStats\022\025\n\ruser_session"
  "s\030\001 \001(\r\022\027\n\017server_sessions\030\002 \001(\r\022\026\n\016in_l"
  "ogon_surge\030\003 \001(\010\"\036\n\034CMsgGCToClientReques"
  "tDropped\"\355\002\n*CWorkshop_PopulateItemDescr"
  "iptions_Request\022\r\n\005appid\030\001 \001(\r\022\\\n\tlangua"
  "ges\030\002 \003(\0132I.CWorkshop_PopulateItemDescri"
  "ptions_Request.ItemDescriptionsLanguageB"
  "lock\032E\n\025SingleItemDescription\022\022\n\ngameite"
  "mid\030\001 \001(\r\022\030\n\020item_description\030\002 \001(\t\032\212\001\n\035"
  "ItemDescriptionsLanguageBlock\022\020\n\010languag"
  "e\030\001 \001(\t\022W\n\014descriptions\030\002 \003(\0132A.CWorksho"
  "p_PopulateItemDescriptions_Request.Singl"
  "eItemDescription\"F\n!CWorkshop_GetContrib"
  "utors_Request\022\r\n\005appid\030\001 \001(\r\022\022\n\ngameitem"
  "id\030\002 \001(\r\":\n\"CWorkshop_GetContributors_Re"
  "sponse\022\024\n\014contributors\030\001 \003(\006\"\365\005\n%CWorksh"
  "op_SetItemPaymentRules_Request\022\r\n\005appid\030"
  "\001 \001(\r\022\022\n\ngameitemid\030\002 \001(\r\022a\n\031associated_"
  "workshop_files\030\003 \003(\0132>.CWorkshop_SetItem"
  "PaymentRules_Request.WorkshopItemPayment"
  "Rule\022W\n\020partner_accounts\030\004 \003(\0132=.CWorksh"
  "op_SetItemPaymentRules_Request.PartnerIt"
  "emPaymentRule\022\025\n\rvalidate_only\030\005 \001(\010\022(\n "
  "make_workshop_files_subscribable\030\006 \001(\010\022v"
  "\n,associated_workshop_file_for_direct_pa"
  "yments\030\007 \001(\0132@.CWorkshop_SetItemPaymentR"
  "ules_Request.WorkshopDirectPaymentRule\032\177"
  "\n\027WorkshopItemPaymentRule\022\030\n\020workshop_fi"
  "le_id\030\001 \001(\004\022\032\n\022revenue_percentage\030\002 \001(\002\022"
  "\030\n\020rule_description\030\003 \001(\t\022\024\n\trule_type\030\004"
  " \001(\r:\0011\032O\n\031WorkshopDirectPaymentRule\022\030\n\020"
  "workshop_file_id\030\001 \001(\004\022\030\n\020rule_descripti"
  "on\030\002 \001(\t\032b\n\026PartnerItemPaymentRule\022\022\n\nac"
  "count_id\030\001 \001(\r\022\032\n\022revenue_percentage\030\002 \001"
  "(\002\022\030\n\020rule_description\030\003 \001(\t\"C\n&CWorksho"
  "p_SetItemPaymentRules_Response\022\031\n\021valida"
  "tion_errors\030\001 \003(\t\"\364\001\n\037CCommunity_ClanAnn"
  "ouncementInfo\022\013\n\003gid\030\001 \001(\004\022\016\n\006clanid\030\002 \001"
  "(\004\022\020\n\010posterid\030\003 \001(\004\022\020\n\010headline\030\004 \001(\t\022\020"
  "\n\010posttime\030\005 \001(\r\022\022\n\nupdatetime\030\006 \001(\r\022\014\n\004"
  "body\030\007 \001(\t\022\024\n\014commentcount\030\010 \001(\005\022\014\n\004tags"
  "\030\t \003(\t\022\020\n\010language\030\n \001(\005\022\016\n\006hidden\030\013 \001(\010"
  "\022\026\n\016forum_topic_id\030\014 \001(\006\"\306\002\n\'CCommunity_"
  "GetClanAnnouncements_Request\022\017\n\007steamid\030"
  "\001 \001(\004\022\016\n\006offset\030\002 \001(\r\022\r\n\005count\030\003 \001(\r\022\020\n\010"
  "maxchars\030\004 \001(\r\022\022\n\nstrip_html\030\005 \001(\010\022\025\n\rre"
  "quired_tags\030\006 \003(\t\022\027\n\017require_no_tags\030\007 \001"
  "(\010\022\033\n\023language_preference\030\010 \003(\r\022\023\n\013hidde"
  "n_only\030\t \001(\010\022\020\n\010only_gid\030\n \001(\010\022\031\n\021rtime_"
  "oldest_date\030\013 \001(\r\022\026\n\016include_hidden\030\014 \001("
  "\010\022\036\n\026include_partner_events\030\r \001(\010\"\211\001\n(CC"
  "ommunity_GetClanAnnouncements_Response\022\020"
  "\n\010maxchars\030\001 \001(\r\022\022\n\nstrip_html\030\002 \001(\010\0227\n\r"
  "announcements\030\003 \003(\0132 .CCommunity_ClanAnn"
  "ouncementInfo\"p\n$CBroadcast_PostGameData"
  "Frame_Request\022\r\n\005appid\030\001 \001(\r\022\017\n\007steamid\030"
  "\002 \001(\006\022\024\n\014broadcast_id\030\003 \001(\006\022\022\n\nframe_dat"
  "a\030\004 \001(\014\"\374\002\n\025CMsgSerializedSOCache\022\024\n\014fil"
  "e_version\030\001 \001(\r\022,\n\006caches\030\002 \003(\0132\034.CMsgSe"
  "rializedSOCache.Cache\022\037\n\027gc_socache_file"
  "_version\030\003 \001(\r\032>\n\tTypeCache\022\014\n\004type\030\001 \001("
  "\r\022\017\n\007objects\030\002 \003(\014\022\022\n\nservice_id\030\003 \001(\r\032\275"
  "\001\n\005Cache\022\014\n\004type\030\001 \001(\r\022\n\n\002id\030\002 \001(\004\0226\n\010ve"
  "rsions\030\003 \003(\0132$.CMsgSerializedSOCache.Cac"
  "he.Version\0225\n\013type_caches\030\004 \003(\0132 .CMsgSe"
  "rializedSOCache.TypeCache\032+\n\007Version\022\017\n\007"
  "service\030\001 \001(\r\022\017\n\007version\030\002 \001(\004\"G\n\037CMsgGC"
  "ToClientPollConvarRequest\022\023\n\013convar_name"
  "\030\001 \001(\t\022\017\n\007poll_id\030\002 \001(\r\"I\n CMsgGCToClien"
  "tPollConvarResponse\022\017\n\007poll_id\030\001 \001(\r\022\024\n\014"
  "convar_value\030\002 \001(\t\"E\n\033CGCMsgCompressedMs"
  "gToClient\022\016\n\006msg_id\030\001 \001(\r\022\026\n\016compressed_"
  "msg\030\002 \001(\014\"\216\001\n CMsgGCToGCMasterBroadcastM"
  "essage\022\030\n\020users_per_second\030\001 \001(\r\022\025\n\rsend"
  "_to_users\030\002 \001(\010\022\027\n\017send_to_servers\030\003 \001(\010"
  "\022\016\n\006msg_id\030\004 \001(\r\022\020\n\010msg_data\030\005 \001(\014\"n\n CM"
  "sgGCToGCMasterSubscribeToCache\022\021\n\tsoid_t"
  "ype\030\001 \001(\r\022\017\n\007soid_id\030\002 \001(\006\022\023\n\013account_id"
  "s\030\003 \003(\r\022\021\n\tsteam_ids\030\004 \003(\006\"*\n(CMsgGCToGC"
  "MasterSubscribeToCacheResponse\"a\n%CMsgGC"
  "ToGCMasterSubscribeToCacheAsync\0228\n\rsubsc"
  "ribe_msg\030\001 \001(\0132!.CMsgGCToGCMasterSubscri"
  "beToCache\"r\n$CMsgGCToGCMasterUnsubscribe"
  "FromCache\022\021\n\tsoid_type\030\001 \001(\r\022\017\n\007soid_id\030"
  "\002 \001(\006\022\023\n\013account_ids\030\003 \003(\r\022\021\n\tsteam_ids\030"
  "\004 \003(\006\"B\n\034CMsgGCToGCMasterDestroyCache\022\021\n"
  "\tsoid_type\030\001 \001(\r\022\017\n\007soid_id\030\002 \001(\006*5\n\rESo"
  "urceEngine\022\021\n\rk_ESE_Source1\020\000\022\021\n\rk_ESE_S"
  "ource2\020\001*V\n\022PartnerAccountType\022\020\n\014PARTNE"
  "R_NONE\020\000\022\031\n\025PARTNER_PERFECT_WORLD\020\001\022\023\n\017P"
  "ARTNER_INVALID\020\003*\240\002\n\022GCConnectionStatus\022"
  "#\n\037GCConnectionStatus_HAVE_SESSION\020\000\022$\n "
  "GCConnectionStatus_GC_GOING_DOWN\020\001\022!\n\035GC"
  "ConnectionStatus_NO_SESSION\020\002\0220\n,GCConne"
  "ctionStatus_NO_SESSION_IN_LOGON_QUEUE\020\003\022"
  "\037\n\033GCConnectionStatus_NO_STEAM\020\004\022 \n\034GCCo"
  "nnectionStatus_SUSPENDED\020\005\022\'\n#GCConnecti"
  "onStatus_STEAM_GOING_DOWN\020\006"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_gcsdk_5fgcmessages_2eproto_deps[2] = {
  &::descriptor_table_steammessages_2eproto,
  &::descriptor_table_steammessages_5fsteamlearn_2esteamworkssdk_2eproto,
};
static ::_pbi::once_flag descriptor_table_gcsdk_5fgcmessages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_gcsdk_5fgcmessages_2eproto = {
    false, false, 9147, descriptor_table_protodef_gcsdk_5fgcmessages_2eproto,
    "gcsdk_gcmessages.proto",
    &descriptor_table_gcsdk_5fgcmessages_2eproto_once, descriptor_table_gcsdk_5fgcmessages_2eproto_deps, 2, 73,
    schemas, file_default_instances, TableStruct_gcsdk_5fgcmessages_2eproto::offsets,
    file_level_metadata_gcsdk_5fgcmessages_2eproto, file_level_enum_descriptors_gcsdk_5fgcmessages_2eproto,
    file_level_service_descriptors_gcsdk_5fgcmessages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_gcsdk_5fgcmessages_2eproto_getter() {
  return &descriptor_table_gcsdk_5fgcmessages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_gcsdk_5fgcmessages_2eproto(&descriptor_table_gcsdk_5fgcmessages_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESourceEngine_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gcsdk_5fgcmessages_2eproto);
  return file_level_enum_descriptors_gcsdk_5fgcmessages_2eproto[0];
}
bool ESourceEngine_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartnerAccountType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gcsdk_5fgcmessages_2eproto);
  return file_level_enum_descriptors_gcsdk_5fgcmessages_2eproto[1];
}
bool PartnerAccountType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GCConnectionStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gcsdk_5fgcmessages_2eproto);
  return file_level_enum_descriptors_gcsdk_5fgcmessages_2eproto[2];
}
bool GCConnectionStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CExtraMsgBlock::_Internal {
 public:
  using HasBits = decltype(std::declval<CExtraMsgBlock>()._impl_._has_bits_);
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_contents(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_msg_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_compressed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CExtraMsgBlock::CExtraMsgBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CExtraMsgBlock)
}
CExtraMsgBlock::CExtraMsgBlock(const CExtraMsgBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CExtraMsgBlock* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contents_){}
    , decltype(_impl_.msg_type_){}
    , decltype(_impl_.is_compressed_){}
    , decltype(_impl_.msg_key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.contents_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contents_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contents()) {
    _this->_impl_.contents_.Set(from._internal_contents(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.msg_type_, &from._impl_.msg_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.msg_key_) -
    reinterpret_cast<char*>(&_impl_.msg_type_)) + sizeof(_impl_.msg_key_));
  // @@protoc_insertion_point(copy_constructor:CExtraMsgBlock)
}

inline void CExtraMsgBlock::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contents_){}
    , decltype(_impl_.msg_type_){0u}
    , decltype(_impl_.is_compressed_){false}
    , decltype(_impl_.msg_key_){uint64_t{0u}}
  };
  _impl_.contents_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contents_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CExtraMsgBlock::~CExtraMsgBlock() {
  // @@protoc_insertion_point(destructor:CExtraMsgBlock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CExtraMsgBlock::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contents_.Destroy();
}

void CExtraMsgBlock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CExtraMsgBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:CExtraMsgBlock)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.contents_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.msg_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.msg_key_) -
        reinterpret_cast<char*>(&_impl_.msg_type_)) + sizeof(_impl_.msg_key_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CExtraMsgBlock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 msg_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_type(&has_bits);
          _impl_.msg_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes contents = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contents();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 msg_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_msg_key(&has_bits);
          _impl_.msg_key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_compressed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_compressed(&has_bits);
          _impl_.is_compressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CExtraMsgBlock::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CExtraMsgBlock)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 msg_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msg_type(), target);
  }

  // optional bytes contents = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_contents(), target);
  }

  // optional uint64 msg_key = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_msg_key(), target);
  }

  // optional bool is_compressed = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_compressed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CExtraMsgBlock)
  return target;
}

size_t CExtraMsgBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CExtraMsgBlock)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes contents = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_contents());
    }

    // optional uint32 msg_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_type());
    }

    // optional bool is_compressed = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint64 msg_key = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_msg_key());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CExtraMsgBlock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CExtraMsgBlock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CExtraMsgBlock::GetClassData() const { return &_class_data_; }


void CExtraMsgBlock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CExtraMsgBlock*>(&to_msg);
  auto& from = static_cast<const CExtraMsgBlock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CExtraMsgBlock)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_contents(from._internal_contents());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_compressed_ = from._impl_.is_compressed_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.msg_key_ = from._impl_.msg_key_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CExtraMsgBlock::CopyFrom(const CExtraMsgBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CExtraMsgBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CExtraMsgBlock::IsInitialized() const {
  return true;
}

void CExtraMsgBlock::InternalSwap(CExtraMsgBlock* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.contents_, lhs_arena,
      &other->_impl_.contents_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CExtraMsgBlock, _impl_.msg_key_)
      + sizeof(CExtraMsgBlock::_impl_.msg_key_)
      - PROTOBUF_FIELD_OFFSET(CExtraMsgBlock, _impl_.msg_type_)>(
          reinterpret_cast<char*>(&_impl_.msg_type_),
          reinterpret_cast<char*>(&other->_impl_.msg_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CExtraMsgBlock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[0]);
}

// ===================================================================

class CMsgSteamLearnServerInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSteamLearnServerInfo>()._impl_._has_bits_);
  static void set_has_enable_data_submission(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enable_inferencing(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgSteamLearnHMACKeys& hmac_keys(const CMsgSteamLearnServerInfo* msg);
  static void set_has_hmac_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgSteamLearnHMACKeys&
CMsgSteamLearnServerInfo::_Internal::hmac_keys(const CMsgSteamLearnServerInfo* msg) {
  return *msg->_impl_.hmac_keys_;
}
void CMsgSteamLearnServerInfo::clear_hmac_keys() {
  if (_impl_.hmac_keys_ != nullptr) _impl_.hmac_keys_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgSteamLearnServerInfo::CMsgSteamLearnServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSteamLearnServerInfo)
}
CMsgSteamLearnServerInfo::CMsgSteamLearnServerInfo(const CMsgSteamLearnServerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSteamLearnServerInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hmac_keys_){nullptr}
    , decltype(_impl_.enable_data_submission_){}
    , decltype(_impl_.enable_inferencing_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_hmac_keys()) {
    _this->_impl_.hmac_keys_ = new ::CMsgSteamLearnHMACKeys(*from._impl_.hmac_keys_);
  }
  ::memcpy(&_impl_.enable_data_submission_, &from._impl_.enable_data_submission_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enable_inferencing_) -
    reinterpret_cast<char*>(&_impl_.enable_data_submission_)) + sizeof(_impl_.enable_inferencing_));
  // @@protoc_insertion_point(copy_constructor:CMsgSteamLearnServerInfo)
}

inline void CMsgSteamLearnServerInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hmac_keys_){nullptr}
    , decltype(_impl_.enable_data_submission_){false}
    , decltype(_impl_.enable_inferencing_){false}
  };
}

CMsgSteamLearnServerInfo::~CMsgSteamLearnServerInfo() {
  // @@protoc_insertion_point(destructor:CMsgSteamLearnServerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSteamLearnServerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.hmac_keys_;
}

void CMsgSteamLearnServerInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSteamLearnServerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSteamLearnServerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.hmac_keys_ != nullptr);
    _impl_.hmac_keys_->Clear();
  }
  ::memset(&_impl_.enable_data_submission_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.enable_inferencing_) -
      reinterpret_cast<char*>(&_impl_.enable_data_submission_)) + sizeof(_impl_.enable_inferencing_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSteamLearnServerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enable_data_submission = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enable_data_submission(&has_bits);
          _impl_.enable_data_submission_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_inferencing = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_enable_inferencing(&has_bits);
          _impl_.enable_inferencing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamLearnHMACKeys hmac_keys = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_hmac_keys(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSteamLearnServerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSteamLearnServerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enable_data_submission = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enable_data_submission(), target);
  }

  // optional bool enable_inferencing = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_enable_inferencing(), target);
  }

  // optional .CMsgSteamLearnHMACKeys hmac_keys = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::hmac_keys(this),
        _Internal::hmac_keys(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSteamLearnServerInfo)
  return target;
}

size_t CMsgSteamLearnServerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSteamLearnServerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgSteamLearnHMACKeys hmac_keys = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hmac_keys_);
    }

    // optional bool enable_data_submission = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool enable_inferencing = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSteamLearnServerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSteamLearnServerInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSteamLearnServerInfo::GetClassData() const { return &_class_data_; }


void CMsgSteamLearnServerInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSteamLearnServerInfo*>(&to_msg);
  auto& from = static_cast<const CMsgSteamLearnServerInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSteamLearnServerInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_hmac_keys()->::CMsgSteamLearnHMACKeys::MergeFrom(
          from._internal_hmac_keys());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.enable_data_submission_ = from._impl_.enable_data_submission_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.enable_inferencing_ = from._impl_.enable_inferencing_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSteamLearnServerInfo::CopyFrom(const CMsgSteamLearnServerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSteamLearnServerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSteamLearnServerInfo::IsInitialized() const {
  return true;
}

void CMsgSteamLearnServerInfo::InternalSwap(CMsgSteamLearnServerInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSteamLearnServerInfo, _impl_.enable_inferencing_)
      + sizeof(CMsgSteamLearnServerInfo::_impl_.enable_inferencing_)
      - PROTOBUF_FIELD_OFFSET(CMsgSteamLearnServerInfo, _impl_.hmac_keys_)>(
          reinterpret_cast<char*>(&_impl_.hmac_keys_),
          reinterpret_cast<char*>(&other->_impl_.hmac_keys_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSteamLearnServerInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[1]);
}

// ===================================================================

class CMsgGCAssertJobData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCAssertJobData>()._impl_._has_bits_);
  static void set_has_message_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCAssertJobData::CMsgGCAssertJobData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCAssertJobData)
}
CMsgGCAssertJobData::CMsgGCAssertJobData(const CMsgGCAssertJobData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCAssertJobData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_type_){}
    , decltype(_impl_.message_data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message_type()) {
    _this->_impl_.message_type_.Set(from._internal_message_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.message_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message_data()) {
    _this->_impl_.message_data_.Set(from._internal_message_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgGCAssertJobData)
}

inline void CMsgGCAssertJobData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_type_){}
    , decltype(_impl_.message_data_){}
  };
  _impl_.message_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCAssertJobData::~CMsgGCAssertJobData() {
  // @@protoc_insertion_point(destructor:CMsgGCAssertJobData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCAssertJobData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_type_.Destroy();
  _impl_.message_data_.Destroy();
}

void CMsgGCAssertJobData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCAssertJobData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCAssertJobData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.message_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.message_data_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCAssertJobData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string message_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCAssertJobData.message_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes message_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCAssertJobData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCAssertJobData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string message_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message_type().data(), static_cast<int>(this->_internal_message_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCAssertJobData.message_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message_type(), target);
  }

  // optional bytes message_data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_message_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCAssertJobData)
  return target;
}

size_t CMsgGCAssertJobData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCAssertJobData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string message_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message_type());
    }

    // optional bytes message_data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message_data());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCAssertJobData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCAssertJobData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCAssertJobData::GetClassData() const { return &_class_data_; }


void CMsgGCAssertJobData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCAssertJobData*>(&to_msg);
  auto& from = static_cast<const CMsgGCAssertJobData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCAssertJobData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message_type(from._internal_message_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_message_data(from._internal_message_data());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCAssertJobData::CopyFrom(const CMsgGCAssertJobData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCAssertJobData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCAssertJobData::IsInitialized() const {
  return true;
}

void CMsgGCAssertJobData::InternalSwap(CMsgGCAssertJobData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_type_, lhs_arena,
      &other->_impl_.message_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_data_, lhs_arena,
      &other->_impl_.message_data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCAssertJobData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[2]);
}

// ===================================================================

class CMsgGCConCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCConCommand>()._impl_._has_bits_);
  static void set_has_command(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCConCommand::CMsgGCConCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCConCommand)
}
CMsgGCConCommand::CMsgGCConCommand(const CMsgGCConCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCConCommand* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.command_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_command()) {
    _this->_impl_.command_.Set(from._internal_command(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgGCConCommand)
}

inline void CMsgGCConCommand::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){}
  };
  _impl_.command_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCConCommand::~CMsgGCConCommand() {
  // @@protoc_insertion_point(destructor:CMsgGCConCommand)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCConCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.command_.Destroy();
}

void CMsgGCConCommand::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCConCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCConCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.command_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCConCommand::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string command = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_command();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCConCommand.command");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCConCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCConCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string command = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_command().data(), static_cast<int>(this->_internal_command().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCConCommand.command");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_command(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCConCommand)
  return target;
}

size_t CMsgGCConCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCConCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string command = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_command());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCConCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCConCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCConCommand::GetClassData() const { return &_class_data_; }


void CMsgGCConCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCConCommand*>(&to_msg);
  auto& from = static_cast<const CMsgGCConCommand&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCConCommand)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_command()) {
    _this->_internal_set_command(from._internal_command());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCConCommand::CopyFrom(const CMsgGCConCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCConCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCConCommand::IsInitialized() const {
  return true;
}

void CMsgGCConCommand::InternalSwap(CMsgGCConCommand* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.command_, lhs_arena,
      &other->_impl_.command_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCConCommand::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[3]);
}

// ===================================================================

class CMsgSDOAssert_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSDOAssert_Request>()._impl_._has_bits_);
  static void set_has_requesting_job(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSDOAssert_Request::CMsgSDOAssert_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSDOAssert.Request)
}
CMsgSDOAssert_Request::CMsgSDOAssert_Request(const CMsgSDOAssert_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSDOAssert_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){from._impl_.key_}
    , decltype(_impl_.requesting_job_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.requesting_job_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.requesting_job_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_job()) {
    _this->_impl_.requesting_job_.Set(from._internal_requesting_job(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSDOAssert.Request)
}

inline void CMsgSDOAssert_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){arena}
    , decltype(_impl_.requesting_job_){}
  };
  _impl_.requesting_job_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.requesting_job_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSDOAssert_Request::~CMsgSDOAssert_Request() {
  // @@protoc_insertion_point(destructor:CMsgSDOAssert.Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSDOAssert_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.~RepeatedField();
  _impl_.requesting_job_.Destroy();
}

void CMsgSDOAssert_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSDOAssert_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSDOAssert.Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.requesting_job_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSDOAssert_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_key(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_key(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string requesting_job = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_requesting_job();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgSDOAssert.Request.requesting_job");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSDOAssert_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSDOAssert.Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 key = 1;
  for (int i = 0, n = this->_internal_key_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_key(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string requesting_job = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_job().data(), static_cast<int>(this->_internal_requesting_job().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSDOAssert.Request.requesting_job");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_requesting_job(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSDOAssert.Request)
  return target;
}

size_t CMsgSDOAssert_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSDOAssert.Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 key = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.key_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_key_size());
    total_size += data_size;
  }

  // optional string requesting_job = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_requesting_job());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSDOAssert_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSDOAssert_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSDOAssert_Request::GetClassData() const { return &_class_data_; }


void CMsgSDOAssert_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSDOAssert_Request*>(&to_msg);
  auto& from = static_cast<const CMsgSDOAssert_Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSDOAssert.Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.key_.MergeFrom(from._impl_.key_);
  if (from._internal_has_requesting_job()) {
    _this->_internal_set_requesting_job(from._internal_requesting_job());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSDOAssert_Request::CopyFrom(const CMsgSDOAssert_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSDOAssert.Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSDOAssert_Request::IsInitialized() const {
  return true;
}

void CMsgSDOAssert_Request::InternalSwap(CMsgSDOAssert_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.key_.InternalSwap(&other->_impl_.key_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.requesting_job_, lhs_arena,
      &other->_impl_.requesting_job_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSDOAssert_Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[4]);
}

// ===================================================================

class CMsgSDOAssert::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSDOAssert>()._impl_._has_bits_);
  static void set_has_sdo_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSDOAssert::CMsgSDOAssert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSDOAssert)
}
CMsgSDOAssert::CMsgSDOAssert(const CMsgSDOAssert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSDOAssert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.requests_){from._impl_.requests_}
    , decltype(_impl_.sdo_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.sdo_type_ = from._impl_.sdo_type_;
  // @@protoc_insertion_point(copy_constructor:CMsgSDOAssert)
}

inline void CMsgSDOAssert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.requests_){arena}
    , decltype(_impl_.sdo_type_){0}
  };
}

CMsgSDOAssert::~CMsgSDOAssert() {
  // @@protoc_insertion_point(destructor:CMsgSDOAssert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSDOAssert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.requests_.~RepeatedPtrField();
}

void CMsgSDOAssert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSDOAssert::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSDOAssert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.requests_.Clear();
  _impl_.sdo_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSDOAssert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 sdo_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sdo_type(&has_bits);
          _impl_.sdo_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSDOAssert.Request requests = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSDOAssert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSDOAssert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 sdo_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_sdo_type(), target);
  }

  // repeated .CMsgSDOAssert.Request requests = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSDOAssert)
  return target;
}

size_t CMsgSDOAssert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSDOAssert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSDOAssert.Request requests = 2;
  total_size += 1UL * this->_internal_requests_size();
  for (const auto& msg : this->_impl_.requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int32 sdo_type = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sdo_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSDOAssert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSDOAssert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSDOAssert::GetClassData() const { return &_class_data_; }


void CMsgSDOAssert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSDOAssert*>(&to_msg);
  auto& from = static_cast<const CMsgSDOAssert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSDOAssert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.requests_.MergeFrom(from._impl_.requests_);
  if (from._internal_has_sdo_type()) {
    _this->_internal_set_sdo_type(from._internal_sdo_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSDOAssert::CopyFrom(const CMsgSDOAssert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSDOAssert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSDOAssert::IsInitialized() const {
  return true;
}

void CMsgSDOAssert::InternalSwap(CMsgSDOAssert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.requests_.InternalSwap(&other->_impl_.requests_);
  swap(_impl_.sdo_type_, other->_impl_.sdo_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSDOAssert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[5]);
}

// ===================================================================

class CMsgSOIDOwner::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOIDOwner>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSOIDOwner::CMsgSOIDOwner(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOIDOwner)
}
CMsgSOIDOwner::CMsgSOIDOwner(const CMsgSOIDOwner& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSOIDOwner* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:CMsgSOIDOwner)
}

inline void CMsgSOIDOwner::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.type_){0u}
  };
}

CMsgSOIDOwner::~CMsgSOIDOwner() {
  // @@protoc_insertion_point(destructor:CMsgSOIDOwner)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOIDOwner::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSOIDOwner::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOIDOwner::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOIDOwner)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSOIDOwner::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOIDOwner::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOIDOwner)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // optional uint64 id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOIDOwner)
  return target;
}

size_t CMsgSOIDOwner::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOIDOwner)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
    }

    // optional uint32 type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSOIDOwner::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSOIDOwner::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSOIDOwner::GetClassData() const { return &_class_data_; }


void CMsgSOIDOwner::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSOIDOwner*>(&to_msg);
  auto& from = static_cast<const CMsgSOIDOwner&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOIDOwner)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSOIDOwner::CopyFrom(const CMsgSOIDOwner& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOIDOwner)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOIDOwner::IsInitialized() const {
  return true;
}

void CMsgSOIDOwner::InternalSwap(CMsgSOIDOwner* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOIDOwner, _impl_.type_)
      + sizeof(CMsgSOIDOwner::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOIDOwner, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSOIDOwner::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[6]);
}

// ===================================================================

class CMsgSOSingleObject::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOSingleObject>()._impl_._has_bits_);
  static void set_has_type_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_object_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOSingleObject* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_service_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOSingleObject::_Internal::owner_soid(const CMsgSOSingleObject* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOSingleObject::CMsgSOSingleObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOSingleObject)
}
CMsgSOSingleObject::CMsgSOSingleObject(const CMsgSOSingleObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSOSingleObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_data_){}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){}
    , decltype(_impl_.type_id_){}
    , decltype(_impl_.service_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.object_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_object_data()) {
    _this->_impl_.object_data_.Set(from._internal_object_data(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.service_id_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSOSingleObject)
}

inline void CMsgSOSingleObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_data_){}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){uint64_t{0u}}
    , decltype(_impl_.type_id_){0}
    , decltype(_impl_.service_id_){0u}
  };
  _impl_.object_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSOSingleObject::~CMsgSOSingleObject() {
  // @@protoc_insertion_point(destructor:CMsgSOSingleObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOSingleObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.object_data_.Destroy();
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOSingleObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOSingleObject::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOSingleObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.object_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
      _impl_.owner_soid_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.service_id_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSOSingleObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type_id(&has_bits);
          _impl_.type_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes object_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_object_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSOIDOwner owner_soid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 service_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_service_id(&has_bits);
          _impl_.service_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOSingleObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOSingleObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 type_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_type_id(), target);
  }

  // optional bytes object_data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_object_data(), target);
  }

  // optional fixed64 version = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_version(), target);
  }

  // optional .CMsgSOIDOwner owner_soid = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  // optional uint32 service_id = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_service_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOSingleObject)
  return target;
}

size_t CMsgSOSingleObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOSingleObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes object_data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_object_data());
    }

    // optional .CMsgSOIDOwner owner_soid = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_soid_);
    }

    // optional fixed64 version = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional int32 type_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type_id());
    }

    // optional uint32 service_id = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_service_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSOSingleObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSOSingleObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSOSingleObject::GetClassData() const { return &_class_data_; }


void CMsgSOSingleObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSOSingleObject*>(&to_msg);
  auto& from = static_cast<const CMsgSOSingleObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOSingleObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_object_data(from._internal_object_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
          from._internal_owner_soid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_id_ = from._impl_.type_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.service_id_ = from._impl_.service_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSOSingleObject::CopyFrom(const CMsgSOSingleObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOSingleObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOSingleObject::IsInitialized() const {
  return true;
}

void CMsgSOSingleObject::InternalSwap(CMsgSOSingleObject* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.object_data_, lhs_arena,
      &other->_impl_.object_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOSingleObject, _impl_.service_id_)
      + sizeof(CMsgSOSingleObject::_impl_.service_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOSingleObject, _impl_.owner_soid_)>(
          reinterpret_cast<char*>(&_impl_.owner_soid_),
          reinterpret_cast<char*>(&other->_impl_.owner_soid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSOSingleObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[7]);
}

// ===================================================================

class CMsgSOMultipleObjects_SingleObject::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOMultipleObjects_SingleObject>()._impl_._has_bits_);
  static void set_has_type_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_object_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSOMultipleObjects_SingleObject::CMsgSOMultipleObjects_SingleObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOMultipleObjects.SingleObject)
}
CMsgSOMultipleObjects_SingleObject::CMsgSOMultipleObjects_SingleObject(const CMsgSOMultipleObjects_SingleObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSOMultipleObjects_SingleObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_data_){}
    , decltype(_impl_.type_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.object_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_object_data()) {
    _this->_impl_.object_data_.Set(from._internal_object_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_id_ = from._impl_.type_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgSOMultipleObjects.SingleObject)
}

inline void CMsgSOMultipleObjects_SingleObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_data_){}
    , decltype(_impl_.type_id_){0}
  };
  _impl_.object_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSOMultipleObjects_SingleObject::~CMsgSOMultipleObjects_SingleObject() {
  // @@protoc_insertion_point(destructor:CMsgSOMultipleObjects.SingleObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOMultipleObjects_SingleObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.object_data_.Destroy();
}

void CMsgSOMultipleObjects_SingleObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOMultipleObjects_SingleObject::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOMultipleObjects.SingleObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.object_data_.ClearNonDefaultToEmpty();
  }
  _impl_.type_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSOMultipleObjects_SingleObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type_id(&has_bits);
          _impl_.type_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes object_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_object_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOMultipleObjects_SingleObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOMultipleObjects.SingleObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 type_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_type_id(), target);
  }

  // optional bytes object_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_object_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOMultipleObjects.SingleObject)
  return target;
}

size_t CMsgSOMultipleObjects_SingleObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOMultipleObjects.SingleObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes object_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_object_data());
    }

    // optional int32 type_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSOMultipleObjects_SingleObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSOMultipleObjects_SingleObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSOMultipleObjects_SingleObject::GetClassData() const { return &_class_data_; }


void CMsgSOMultipleObjects_SingleObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSOMultipleObjects_SingleObject*>(&to_msg);
  auto& from = static_cast<const CMsgSOMultipleObjects_SingleObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOMultipleObjects.SingleObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_object_data(from._internal_object_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_id_ = from._impl_.type_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSOMultipleObjects_SingleObject::CopyFrom(const CMsgSOMultipleObjects_SingleObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOMultipleObjects.SingleObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOMultipleObjects_SingleObject::IsInitialized() const {
  return true;
}

void CMsgSOMultipleObjects_SingleObject::InternalSwap(CMsgSOMultipleObjects_SingleObject* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.object_data_, lhs_arena,
      &other->_impl_.object_data_, rhs_arena
  );
  swap(_impl_.type_id_, other->_impl_.type_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSOMultipleObjects_SingleObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[8]);
}

// ===================================================================

class CMsgSOMultipleObjects::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOMultipleObjects>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOMultipleObjects* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_service_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOMultipleObjects::_Internal::owner_soid(const CMsgSOMultipleObjects* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOMultipleObjects::CMsgSOMultipleObjects(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOMultipleObjects)
}
CMsgSOMultipleObjects::CMsgSOMultipleObjects(const CMsgSOMultipleObjects& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSOMultipleObjects* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_modified_){from._impl_.objects_modified_}
    , decltype(_impl_.objects_added_){from._impl_.objects_added_}
    , decltype(_impl_.objects_removed_){from._impl_.objects_removed_}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){}
    , decltype(_impl_.service_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.service_id_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSOMultipleObjects)
}

inline void CMsgSOMultipleObjects::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_modified_){arena}
    , decltype(_impl_.objects_added_){arena}
    , decltype(_impl_.objects_removed_){arena}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){uint64_t{0u}}
    , decltype(_impl_.service_id_){0u}
  };
}

CMsgSOMultipleObjects::~CMsgSOMultipleObjects() {
  // @@protoc_insertion_point(destructor:CMsgSOMultipleObjects)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOMultipleObjects::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_modified_.~RepeatedPtrField();
  _impl_.objects_added_.~RepeatedPtrField();
  _impl_.objects_removed_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOMultipleObjects::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOMultipleObjects::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOMultipleObjects)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_modified_.Clear();
  _impl_.objects_added_.Clear();
  _impl_.objects_removed_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
    _impl_.owner_soid_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.service_id_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSOMultipleObjects::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgSOMultipleObjects.SingleObject objects_modified = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects_modified(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSOMultipleObjects.SingleObject objects_added = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects_added(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSOMultipleObjects.SingleObject objects_removed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects_removed(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSOIDOwner owner_soid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 service_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_service_id(&has_bits);
          _impl_.service_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOMultipleObjects::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOMultipleObjects)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgSOMultipleObjects.SingleObject objects_modified = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_modified_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects_modified(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_version(), target);
  }

  // repeated .CMsgSOMultipleObjects.SingleObject objects_added = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_added_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects_added(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgSOMultipleObjects.SingleObject objects_removed = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_removed_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects_removed(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .CMsgSOIDOwner owner_soid = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  // optional uint32 service_id = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_service_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOMultipleObjects)
  return target;
}

size_t CMsgSOMultipleObjects::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOMultipleObjects)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSOMultipleObjects.SingleObject objects_modified = 2;
  total_size += 1UL * this->_internal_objects_modified_size();
  for (const auto& msg : this->_impl_.objects_modified_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSOMultipleObjects.SingleObject objects_added = 4;
  total_size += 1UL * this->_internal_objects_added_size();
  for (const auto& msg : this->_impl_.objects_added_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSOMultipleObjects.SingleObject objects_removed = 5;
  total_size += 1UL * this->_internal_objects_removed_size();
  for (const auto& msg : this->_impl_.objects_removed_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgSOIDOwner owner_soid = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_soid_);
    }

    // optional fixed64 version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 service_id = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_service_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSOMultipleObjects::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSOMultipleObjects::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSOMultipleObjects::GetClassData() const { return &_class_data_; }


void CMsgSOMultipleObjects::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSOMultipleObjects*>(&to_msg);
  auto& from = static_cast<const CMsgSOMultipleObjects&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOMultipleObjects)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_modified_.MergeFrom(from._impl_.objects_modified_);
  _this->_impl_.objects_added_.MergeFrom(from._impl_.objects_added_);
  _this->_impl_.objects_removed_.MergeFrom(from._impl_.objects_removed_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
          from._internal_owner_soid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.service_id_ = from._impl_.service_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSOMultipleObjects::CopyFrom(const CMsgSOMultipleObjects& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOMultipleObjects)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOMultipleObjects::IsInitialized() const {
  return true;
}

void CMsgSOMultipleObjects::InternalSwap(CMsgSOMultipleObjects* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.objects_modified_.InternalSwap(&other->_impl_.objects_modified_);
  _impl_.objects_added_.InternalSwap(&other->_impl_.objects_added_);
  _impl_.objects_removed_.InternalSwap(&other->_impl_.objects_removed_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOMultipleObjects, _impl_.service_id_)
      + sizeof(CMsgSOMultipleObjects::_impl_.service_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOMultipleObjects, _impl_.owner_soid_)>(
          reinterpret_cast<char*>(&_impl_.owner_soid_),
          reinterpret_cast<char*>(&other->_impl_.owner_soid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSOMultipleObjects::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[9]);
}

// ===================================================================

class CMsgSOCacheSubscribed_SubscribedType::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheSubscribed_SubscribedType>()._impl_._has_bits_);
  static void set_has_type_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSOCacheSubscribed_SubscribedType::CMsgSOCacheSubscribed_SubscribedType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheSubscribed.SubscribedType)
}
CMsgSOCacheSubscribed_SubscribedType::CMsgSOCacheSubscribed_SubscribedType(const CMsgSOCacheSubscribed_SubscribedType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSOCacheSubscribed_SubscribedType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_data_){from._impl_.object_data_}
    , decltype(_impl_.type_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.type_id_ = from._impl_.type_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheSubscribed.SubscribedType)
}

inline void CMsgSOCacheSubscribed_SubscribedType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_data_){arena}
    , decltype(_impl_.type_id_){0}
  };
}

CMsgSOCacheSubscribed_SubscribedType::~CMsgSOCacheSubscribed_SubscribedType() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheSubscribed.SubscribedType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheSubscribed_SubscribedType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.object_data_.~RepeatedPtrField();
}

void CMsgSOCacheSubscribed_SubscribedType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheSubscribed_SubscribedType::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheSubscribed.SubscribedType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.object_data_.Clear();
  _impl_.type_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSOCacheSubscribed_SubscribedType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type_id(&has_bits);
          _impl_.type_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes object_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_object_data();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheSubscribed_SubscribedType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheSubscribed.SubscribedType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 type_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_type_id(), target);
  }

  // repeated bytes object_data = 2;
  for (int i = 0, n = this->_internal_object_data_size(); i < n; i++) {
    const auto& s = this->_internal_object_data(i);
    target = stream->WriteBytes(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheSubscribed.SubscribedType)
  return target;
}

size_t CMsgSOCacheSubscribed_SubscribedType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheSubscribed.SubscribedType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes object_data = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.object_data_.size());
  for (int i = 0, n = _impl_.object_data_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.object_data_.Get(i));
  }

  // optional int32 type_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSOCacheSubscribed_SubscribedType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSOCacheSubscribed_SubscribedType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSOCacheSubscribed_SubscribedType::GetClassData() const { return &_class_data_; }


void CMsgSOCacheSubscribed_SubscribedType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSOCacheSubscribed_SubscribedType*>(&to_msg);
  auto& from = static_cast<const CMsgSOCacheSubscribed_SubscribedType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheSubscribed.SubscribedType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.object_data_.MergeFrom(from._impl_.object_data_);
  if (from._internal_has_type_id()) {
    _this->_internal_set_type_id(from._internal_type_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSOCacheSubscribed_SubscribedType::CopyFrom(const CMsgSOCacheSubscribed_SubscribedType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheSubscribed.SubscribedType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheSubscribed_SubscribedType::IsInitialized() const {
  return true;
}

void CMsgSOCacheSubscribed_SubscribedType::InternalSwap(CMsgSOCacheSubscribed_SubscribedType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.object_data_.InternalSwap(&other->_impl_.object_data_);
  swap(_impl_.type_id_, other->_impl_.type_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSOCacheSubscribed_SubscribedType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[10]);
}

// ===================================================================

class CMsgSOCacheSubscribed::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheSubscribed>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOCacheSubscribed* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_service_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sync_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOCacheSubscribed::_Internal::owner_soid(const CMsgSOCacheSubscribed* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOCacheSubscribed::CMsgSOCacheSubscribed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheSubscribed)
}
CMsgSOCacheSubscribed::CMsgSOCacheSubscribed(const CMsgSOCacheSubscribed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSOCacheSubscribed* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_){from._impl_.objects_}
    , decltype(_impl_.service_list_){from._impl_.service_list_}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){}
    , decltype(_impl_.sync_version_){}
    , decltype(_impl_.service_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.service_id_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheSubscribed)
}

inline void CMsgSOCacheSubscribed::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_){arena}
    , decltype(_impl_.service_list_){arena}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){uint64_t{0u}}
    , decltype(_impl_.sync_version_){uint64_t{0u}}
    , decltype(_impl_.service_id_){0u}
  };
}

CMsgSOCacheSubscribed::~CMsgSOCacheSubscribed() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheSubscribed)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheSubscribed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_.~RepeatedPtrField();
  _impl_.service_list_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOCacheSubscribed::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheSubscribed::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheSubscribed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_.Clear();
  _impl_.service_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
    _impl_.owner_soid_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.service_id_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSOCacheSubscribed::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgSOCacheSubscribed.SubscribedType objects = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSOIDOwner owner_soid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 service_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_service_id(&has_bits);
          _impl_.service_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 service_list = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_service_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_service_list(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 sync_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_sync_version(&has_bits);
          _impl_.sync_version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheSubscribed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheSubscribed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgSOCacheSubscribed.SubscribedType objects = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_version(), target);
  }

  // optional .CMsgSOIDOwner owner_soid = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  // optional uint32 service_id = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_service_id(), target);
  }

  // repeated uint32 service_list = 6;
  for (int i = 0, n = this->_internal_service_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_service_list(i), target);
  }

  // optional fixed64 sync_version = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(7, this->_internal_sync_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheSubscribed)
  return target;
}

size_t CMsgSOCacheSubscribed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheSubscribed)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSOCacheSubscribed.SubscribedType objects = 2;
  total_size += 1UL * this->_internal_objects_size();
  for (const auto& msg : this->_impl_.objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 service_list = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.service_list_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_service_list_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgSOIDOwner owner_soid = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_soid_);
    }

    // optional fixed64 version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional fixed64 sync_version = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 service_id = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_service_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSOCacheSubscribed::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSOCacheSubscribed::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSOCacheSubscribed::GetClassData() const { return &_class_data_; }


void CMsgSOCacheSubscribed::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSOCacheSubscribed*>(&to_msg);
  auto& from = static_cast<const CMsgSOCacheSubscribed&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheSubscribed)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_.MergeFrom(from._impl_.objects_);
  _this->_impl_.service_list_.MergeFrom(from._impl_.service_list_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
          from._internal_owner_soid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sync_version_ = from._impl_.sync_version_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.service_id_ = from._impl_.service_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSOCacheSubscribed::CopyFrom(const CMsgSOCacheSubscribed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheSubscribed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheSubscribed::IsInitialized() const {
  return true;
}

void CMsgSOCacheSubscribed::InternalSwap(CMsgSOCacheSubscribed* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.objects_.InternalSwap(&other->_impl_.objects_);
  _impl_.service_list_.InternalSwap(&other->_impl_.service_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOCacheSubscribed, _impl_.service_id_)
      + sizeof(CMsgSOCacheSubscribed::_impl_.service_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOCacheSubscribed, _impl_.owner_soid_)>(
          reinterpret_cast<char*>(&_impl_.owner_soid_),
          reinterpret_cast<char*>(&other->_impl_.owner_soid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSOCacheSubscribed::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[11]);
}

// ===================================================================

class CMsgSOCacheSubscribedUpToDate::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheSubscribedUpToDate>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOCacheSubscribedUpToDate* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_service_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sync_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOCacheSubscribedUpToDate::_Internal::owner_soid(const CMsgSOCacheSubscribedUpToDate* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOCacheSubscribedUpToDate::CMsgSOCacheSubscribedUpToDate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheSubscribedUpToDate)
}
CMsgSOCacheSubscribedUpToDate::CMsgSOCacheSubscribedUpToDate(const CMsgSOCacheSubscribedUpToDate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSOCacheSubscribedUpToDate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.service_list_){from._impl_.service_list_}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){}
    , decltype(_impl_.sync_version_){}
    , decltype(_impl_.service_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.service_id_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheSubscribedUpToDate)
}

inline void CMsgSOCacheSubscribedUpToDate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.service_list_){arena}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){uint64_t{0u}}
    , decltype(_impl_.sync_version_){uint64_t{0u}}
    , decltype(_impl_.service_id_){0u}
  };
}

CMsgSOCacheSubscribedUpToDate::~CMsgSOCacheSubscribedUpToDate() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheSubscribedUpToDate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheSubscribedUpToDate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.service_list_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOCacheSubscribedUpToDate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheSubscribedUpToDate::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheSubscribedUpToDate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.service_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
    _impl_.owner_soid_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.service_id_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSOCacheSubscribedUpToDate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSOIDOwner owner_soid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 service_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_service_id(&has_bits);
          _impl_.service_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 service_list = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_service_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_service_list(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 sync_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_sync_version(&has_bits);
          _impl_.sync_version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheSubscribedUpToDate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheSubscribedUpToDate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 version = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_version(), target);
  }

  // optional .CMsgSOIDOwner owner_soid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  // optional uint32 service_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_service_id(), target);
  }

  // repeated uint32 service_list = 4;
  for (int i = 0, n = this->_internal_service_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_service_list(i), target);
  }

  // optional fixed64 sync_version = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(5, this->_internal_sync_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheSubscribedUpToDate)
  return target;
}

size_t CMsgSOCacheSubscribedUpToDate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheSubscribedUpToDate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 service_list = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.service_list_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_service_list_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgSOIDOwner owner_soid = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_soid_);
    }

    // optional fixed64 version = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional fixed64 sync_version = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 service_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_service_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSOCacheSubscribedUpToDate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSOCacheSubscribedUpToDate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSOCacheSubscribedUpToDate::GetClassData() const { return &_class_data_; }


void CMsgSOCacheSubscribedUpToDate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSOCacheSubscribedUpToDate*>(&to_msg);
  auto& from = static_cast<const CMsgSOCacheSubscribedUpToDate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheSubscribedUpToDate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.service_list_.MergeFrom(from._impl_.service_list_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
          from._internal_owner_soid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sync_version_ = from._impl_.sync_version_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.service_id_ = from._impl_.service_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSOCacheSubscribedUpToDate::CopyFrom(const CMsgSOCacheSubscribedUpToDate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheSubscribedUpToDate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheSubscribedUpToDate::IsInitialized() const {
  return true;
}

void CMsgSOCacheSubscribedUpToDate::InternalSwap(CMsgSOCacheSubscribedUpToDate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.service_list_.InternalSwap(&other->_impl_.service_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOCacheSubscribedUpToDate, _impl_.service_id_)
      + sizeof(CMsgSOCacheSubscribedUpToDate::_impl_.service_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOCacheSubscribedUpToDate, _impl_.owner_soid_)>(
          reinterpret_cast<char*>(&_impl_.owner_soid_),
          reinterpret_cast<char*>(&other->_impl_.owner_soid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSOCacheSubscribedUpToDate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[12]);
}

// ===================================================================

class CMsgSOCacheUnsubscribed::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheUnsubscribed>()._impl_._has_bits_);
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOCacheUnsubscribed* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOCacheUnsubscribed::_Internal::owner_soid(const CMsgSOCacheUnsubscribed* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOCacheUnsubscribed::CMsgSOCacheUnsubscribed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheUnsubscribed)
}
CMsgSOCacheUnsubscribed::CMsgSOCacheUnsubscribed(const CMsgSOCacheUnsubscribed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSOCacheUnsubscribed* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_soid_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheUnsubscribed)
}

inline void CMsgSOCacheUnsubscribed::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_soid_){nullptr}
  };
}

CMsgSOCacheUnsubscribed::~CMsgSOCacheUnsubscribed() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheUnsubscribed)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheUnsubscribed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOCacheUnsubscribed::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheUnsubscribed::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheUnsubscribed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
    _impl_.owner_soid_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSOCacheUnsubscribed::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSOIDOwner owner_soid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheUnsubscribed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheUnsubscribed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSOIDOwner owner_soid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheUnsubscribed)
  return target;
}

size_t CMsgSOCacheUnsubscribed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheUnsubscribed)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgSOIDOwner owner_soid = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.owner_soid_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSOCacheUnsubscribed::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSOCacheUnsubscribed::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSOCacheUnsubscribed::GetClassData() const { return &_class_data_; }


void CMsgSOCacheUnsubscribed::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSOCacheUnsubscribed*>(&to_msg);
  auto& from = static_cast<const CMsgSOCacheUnsubscribed&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheUnsubscribed)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_owner_soid()) {
    _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
        from._internal_owner_soid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSOCacheUnsubscribed::CopyFrom(const CMsgSOCacheUnsubscribed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheUnsubscribed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheUnsubscribed::IsInitialized() const {
  return true;
}

void CMsgSOCacheUnsubscribed::InternalSwap(CMsgSOCacheUnsubscribed* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.owner_soid_, other->_impl_.owner_soid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSOCacheUnsubscribed::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[13]);
}

// ===================================================================

class CMsgSOCacheSubscriptionCheck::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheSubscriptionCheck>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOCacheSubscriptionCheck* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_service_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sync_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOCacheSubscriptionCheck::_Internal::owner_soid(const CMsgSOCacheSubscriptionCheck* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOCacheSubscriptionCheck::CMsgSOCacheSubscriptionCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheSubscriptionCheck)
}
CMsgSOCacheSubscriptionCheck::CMsgSOCacheSubscriptionCheck(const CMsgSOCacheSubscriptionCheck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSOCacheSubscriptionCheck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.service_list_){from._impl_.service_list_}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){}
    , decltype(_impl_.sync_version_){}
    , decltype(_impl_.service_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.service_id_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheSubscriptionCheck)
}

inline void CMsgSOCacheSubscriptionCheck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.service_list_){arena}
    , decltype(_impl_.owner_soid_){nullptr}
    , decltype(_impl_.version_){uint64_t{0u}}
    , decltype(_impl_.sync_version_){uint64_t{0u}}
    , decltype(_impl_.service_id_){0u}
  };
}

CMsgSOCacheSubscriptionCheck::~CMsgSOCacheSubscriptionCheck() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheSubscriptionCheck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheSubscriptionCheck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.service_list_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOCacheSubscriptionCheck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheSubscriptionCheck::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheSubscriptionCheck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.service_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
    _impl_.owner_soid_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.service_id_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSOCacheSubscriptionCheck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSOIDOwner owner_soid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 service_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_service_id(&has_bits);
          _impl_.service_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 service_list = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_service_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_service_list(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 sync_version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_sync_version(&has_bits);
          _impl_.sync_version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheSubscriptionCheck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheSubscriptionCheck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_version(), target);
  }

  // optional .CMsgSOIDOwner owner_soid = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  // optional uint32 service_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_service_id(), target);
  }

  // repeated uint32 service_list = 5;
  for (int i = 0, n = this->_internal_service_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_service_list(i), target);
  }

  // optional fixed64 sync_version = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(6, this->_internal_sync_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheSubscriptionCheck)
  return target;
}

size_t CMsgSOCacheSubscriptionCheck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheSubscriptionCheck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 service_list = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.service_list_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_service_list_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgSOIDOwner owner_soid = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_soid_);
    }

    // optional fixed64 version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional fixed64 sync_version = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 service_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_service_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSOCacheSubscriptionCheck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSOCacheSubscriptionCheck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSOCacheSubscriptionCheck::GetClassData() const { return &_class_data_; }


void CMsgSOCacheSubscriptionCheck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSOCacheSubscriptionCheck*>(&to_msg);
  auto& from = static_cast<const CMsgSOCacheSubscriptionCheck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheSubscriptionCheck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.service_list_.MergeFrom(from._impl_.service_list_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
          from._internal_owner_soid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sync_version_ = from._impl_.sync_version_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.service_id_ = from._impl_.service_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSOCacheSubscriptionCheck::CopyFrom(const CMsgSOCacheSubscriptionCheck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheSubscriptionCheck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheSubscriptionCheck::IsInitialized() const {
  return true;
}

void CMsgSOCacheSubscriptionCheck::InternalSwap(CMsgSOCacheSubscriptionCheck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.service_list_.InternalSwap(&other->_impl_.service_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOCacheSubscriptionCheck, _impl_.service_id_)
      + sizeof(CMsgSOCacheSubscriptionCheck::_impl_.service_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOCacheSubscriptionCheck, _impl_.owner_soid_)>(
          reinterpret_cast<char*>(&_impl_.owner_soid_),
          reinterpret_cast<char*>(&other->_impl_.owner_soid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSOCacheSubscriptionCheck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[14]);
}

// ===================================================================

class CMsgSOCacheSubscriptionRefresh::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheSubscriptionRefresh>()._impl_._has_bits_);
  static const ::CMsgSOIDOwner& owner_soid(const CMsgSOCacheSubscriptionRefresh* msg);
  static void set_has_owner_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOCacheSubscriptionRefresh::_Internal::owner_soid(const CMsgSOCacheSubscriptionRefresh* msg) {
  return *msg->_impl_.owner_soid_;
}
CMsgSOCacheSubscriptionRefresh::CMsgSOCacheSubscriptionRefresh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheSubscriptionRefresh)
}
CMsgSOCacheSubscriptionRefresh::CMsgSOCacheSubscriptionRefresh(const CMsgSOCacheSubscriptionRefresh& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSOCacheSubscriptionRefresh* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_soid_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_owner_soid()) {
    _this->_impl_.owner_soid_ = new ::CMsgSOIDOwner(*from._impl_.owner_soid_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheSubscriptionRefresh)
}

inline void CMsgSOCacheSubscriptionRefresh::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_soid_){nullptr}
  };
}

CMsgSOCacheSubscriptionRefresh::~CMsgSOCacheSubscriptionRefresh() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheSubscriptionRefresh)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheSubscriptionRefresh::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.owner_soid_;
}

void CMsgSOCacheSubscriptionRefresh::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheSubscriptionRefresh::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheSubscriptionRefresh)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.owner_soid_ != nullptr);
    _impl_.owner_soid_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSOCacheSubscriptionRefresh::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSOIDOwner owner_soid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheSubscriptionRefresh::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheSubscriptionRefresh)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSOIDOwner owner_soid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::owner_soid(this),
        _Internal::owner_soid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheSubscriptionRefresh)
  return target;
}

size_t CMsgSOCacheSubscriptionRefresh::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheSubscriptionRefresh)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgSOIDOwner owner_soid = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.owner_soid_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSOCacheSubscriptionRefresh::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSOCacheSubscriptionRefresh::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSOCacheSubscriptionRefresh::GetClassData() const { return &_class_data_; }


void CMsgSOCacheSubscriptionRefresh::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSOCacheSubscriptionRefresh*>(&to_msg);
  auto& from = static_cast<const CMsgSOCacheSubscriptionRefresh&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheSubscriptionRefresh)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_owner_soid()) {
    _this->_internal_mutable_owner_soid()->::CMsgSOIDOwner::MergeFrom(
        from._internal_owner_soid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSOCacheSubscriptionRefresh::CopyFrom(const CMsgSOCacheSubscriptionRefresh& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheSubscriptionRefresh)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheSubscriptionRefresh::IsInitialized() const {
  return true;
}

void CMsgSOCacheSubscriptionRefresh::InternalSwap(CMsgSOCacheSubscriptionRefresh* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.owner_soid_, other->_impl_.owner_soid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSOCacheSubscriptionRefresh::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[15]);
}

// ===================================================================

class CMsgSOCacheVersion::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheVersion>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSOCacheVersion::CMsgSOCacheVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheVersion)
}
CMsgSOCacheVersion::CMsgSOCacheVersion(const CMsgSOCacheVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSOCacheVersion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheVersion)
}

inline void CMsgSOCacheVersion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.version_){uint64_t{0u}}
  };
}

CMsgSOCacheVersion::~CMsgSOCacheVersion() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheVersion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheVersion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSOCacheVersion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheVersion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.version_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSOCacheVersion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheVersion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheVersion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheVersion)
  return target;
}

size_t CMsgSOCacheVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheVersion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 version = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSOCacheVersion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSOCacheVersion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSOCacheVersion::GetClassData() const { return &_class_data_; }


void CMsgSOCacheVersion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSOCacheVersion*>(&to_msg);
  auto& from = static_cast<const CMsgSOCacheVersion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheVersion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_version()) {
    _this->_internal_set_version(from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSOCacheVersion::CopyFrom(const CMsgSOCacheVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheVersion::IsInitialized() const {
  return true;
}

void CMsgSOCacheVersion::InternalSwap(CMsgSOCacheVersion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.version_, other->_impl_.version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSOCacheVersion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[16]);
}

// ===================================================================

class CMsgGCMultiplexMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCMultiplexMessage>()._impl_._has_bits_);
  static void set_has_msgtype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCMultiplexMessage::CMsgGCMultiplexMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCMultiplexMessage)
}
CMsgGCMultiplexMessage::CMsgGCMultiplexMessage(const CMsgGCMultiplexMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCMultiplexMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamids_){from._impl_.steamids_}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.msgtype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload()) {
    _this->_impl_.payload_.Set(from._internal_payload(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.msgtype_ = from._impl_.msgtype_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCMultiplexMessage)
}

inline void CMsgGCMultiplexMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamids_){arena}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.msgtype_){0u}
  };
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCMultiplexMessage::~CMsgGCMultiplexMessage() {
  // @@protoc_insertion_point(destructor:CMsgGCMultiplexMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCMultiplexMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.steamids_.~RepeatedField();
  _impl_.payload_.Destroy();
}

void CMsgGCMultiplexMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCMultiplexMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCMultiplexMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steamids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.payload_.ClearNonDefaultToEmpty();
  }
  _impl_.msgtype_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCMultiplexMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 msgtype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msgtype(&has_bits);
          _impl_.msgtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes payload = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed64 steamids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_steamids(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<25>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_steamids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCMultiplexMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCMultiplexMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 msgtype = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msgtype(), target);
  }

  // optional bytes payload = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_payload(), target);
  }

  // repeated fixed64 steamids = 3;
  for (int i = 0, n = this->_internal_steamids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_steamids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCMultiplexMessage)
  return target;
}

size_t CMsgGCMultiplexMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCMultiplexMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 steamids = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_steamids_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_steamids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes payload = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload());
    }

    // optional uint32 msgtype = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msgtype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCMultiplexMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCMultiplexMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCMultiplexMessage::GetClassData() const { return &_class_data_; }


void CMsgGCMultiplexMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCMultiplexMessage*>(&to_msg);
  auto& from = static_cast<const CMsgGCMultiplexMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCMultiplexMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.steamids_.MergeFrom(from._impl_.steamids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_payload(from._internal_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.msgtype_ = from._impl_.msgtype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCMultiplexMessage::CopyFrom(const CMsgGCMultiplexMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCMultiplexMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCMultiplexMessage::IsInitialized() const {
  return true;
}

void CMsgGCMultiplexMessage::InternalSwap(CMsgGCMultiplexMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.steamids_.InternalSwap(&other->_impl_.steamids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.payload_, lhs_arena,
      &other->_impl_.payload_, rhs_arena
  );
  swap(_impl_.msgtype_, other->_impl_.msgtype_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCMultiplexMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[17]);
}

// ===================================================================

class CMsgGCToGCSubGCStarting::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCSubGCStarting>()._impl_._has_bits_);
  static void set_has_dir_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCSubGCStarting::CMsgGCToGCSubGCStarting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCSubGCStarting)
}
CMsgGCToGCSubGCStarting::CMsgGCToGCSubGCStarting(const CMsgGCToGCSubGCStarting& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCSubGCStarting* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dir_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.dir_index_ = from._impl_.dir_index_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCSubGCStarting)
}

inline void CMsgGCToGCSubGCStarting::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dir_index_){-1}
  };
}

CMsgGCToGCSubGCStarting::~CMsgGCToGCSubGCStarting() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCSubGCStarting)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCSubGCStarting::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToGCSubGCStarting::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCSubGCStarting::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCSubGCStarting)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dir_index_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCSubGCStarting::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 dir_index = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dir_index(&has_bits);
          _impl_.dir_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCSubGCStarting::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCSubGCStarting)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 dir_index = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dir_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCSubGCStarting)
  return target;
}

size_t CMsgGCToGCSubGCStarting::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCSubGCStarting)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 dir_index = 1 [default = -1];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dir_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCSubGCStarting::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCSubGCStarting::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCSubGCStarting::GetClassData() const { return &_class_data_; }


void CMsgGCToGCSubGCStarting::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCSubGCStarting*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCSubGCStarting&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCSubGCStarting)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dir_index()) {
    _this->_internal_set_dir_index(from._internal_dir_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCSubGCStarting::CopyFrom(const CMsgGCToGCSubGCStarting& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCSubGCStarting)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCSubGCStarting::IsInitialized() const {
  return true;
}

void CMsgGCToGCSubGCStarting::InternalSwap(CMsgGCToGCSubGCStarting* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.dir_index_, other->_impl_.dir_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCSubGCStarting::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[18]);
}

// ===================================================================

class CGCToGCMsgMasterAck_Process::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCToGCMsgMasterAck_Process>()._impl_._has_bits_);
  static void set_has_dir_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGCToGCMsgMasterAck_Process::CGCToGCMsgMasterAck_Process(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCToGCMsgMasterAck.Process)
}
CGCToGCMsgMasterAck_Process::CGCToGCMsgMasterAck_Process(const CGCToGCMsgMasterAck_Process& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CGCToGCMsgMasterAck_Process* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_instances_){from._impl_.type_instances_}
    , decltype(_impl_.dir_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.dir_index_ = from._impl_.dir_index_;
  // @@protoc_insertion_point(copy_constructor:CGCToGCMsgMasterAck.Process)
}

inline void CGCToGCMsgMasterAck_Process::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_instances_){arena}
    , decltype(_impl_.dir_index_){-1}
  };
}

CGCToGCMsgMasterAck_Process::~CGCToGCMsgMasterAck_Process() {
  // @@protoc_insertion_point(destructor:CGCToGCMsgMasterAck.Process)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCToGCMsgMasterAck_Process::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_instances_.~RepeatedField();
}

void CGCToGCMsgMasterAck_Process::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCToGCMsgMasterAck_Process::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCToGCMsgMasterAck.Process)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_instances_.Clear();
  _impl_.dir_index_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGCToGCMsgMasterAck_Process::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 dir_index = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dir_index(&has_bits);
          _impl_.dir_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 type_instances = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_type_instances(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_type_instances(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCToGCMsgMasterAck_Process::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCToGCMsgMasterAck.Process)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 dir_index = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dir_index(), target);
  }

  // repeated uint32 type_instances = 2;
  for (int i = 0, n = this->_internal_type_instances_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_type_instances(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCToGCMsgMasterAck.Process)
  return target;
}

size_t CGCToGCMsgMasterAck_Process::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCToGCMsgMasterAck.Process)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 type_instances = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.type_instances_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_type_instances_size());
    total_size += data_size;
  }

  // optional int32 dir_index = 1 [default = -1];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dir_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGCToGCMsgMasterAck_Process::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CGCToGCMsgMasterAck_Process::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGCToGCMsgMasterAck_Process::GetClassData() const { return &_class_data_; }


void CGCToGCMsgMasterAck_Process::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CGCToGCMsgMasterAck_Process*>(&to_msg);
  auto& from = static_cast<const CGCToGCMsgMasterAck_Process&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCToGCMsgMasterAck.Process)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.type_instances_.MergeFrom(from._impl_.type_instances_);
  if (from._internal_has_dir_index()) {
    _this->_internal_set_dir_index(from._internal_dir_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGCToGCMsgMasterAck_Process::CopyFrom(const CGCToGCMsgMasterAck_Process& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCToGCMsgMasterAck.Process)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCToGCMsgMasterAck_Process::IsInitialized() const {
  return true;
}

void CGCToGCMsgMasterAck_Process::InternalSwap(CGCToGCMsgMasterAck_Process* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.type_instances_.InternalSwap(&other->_impl_.type_instances_);
  swap(_impl_.dir_index_, other->_impl_.dir_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGCToGCMsgMasterAck_Process::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[19]);
}

// ===================================================================

class CGCToGCMsgMasterAck::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCToGCMsgMasterAck>()._impl_._has_bits_);
  static void set_has_dir_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_machine_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_process_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CGCToGCMsgMasterAck::CGCToGCMsgMasterAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCToGCMsgMasterAck)
}
CGCToGCMsgMasterAck::CGCToGCMsgMasterAck(const CGCToGCMsgMasterAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CGCToGCMsgMasterAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.directory_){from._impl_.directory_}
    , decltype(_impl_.machine_name_){}
    , decltype(_impl_.process_name_){}
    , decltype(_impl_.dir_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.machine_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_name()) {
    _this->_impl_.machine_name_.Set(from._internal_machine_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.process_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.process_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_process_name()) {
    _this->_impl_.process_name_.Set(from._internal_process_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.dir_index_ = from._impl_.dir_index_;
  // @@protoc_insertion_point(copy_constructor:CGCToGCMsgMasterAck)
}

inline void CGCToGCMsgMasterAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.directory_){arena}
    , decltype(_impl_.machine_name_){}
    , decltype(_impl_.process_name_){}
    , decltype(_impl_.dir_index_){-1}
  };
  _impl_.machine_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.process_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.process_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGCToGCMsgMasterAck::~CGCToGCMsgMasterAck() {
  // @@protoc_insertion_point(destructor:CGCToGCMsgMasterAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCToGCMsgMasterAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.directory_.~RepeatedPtrField();
  _impl_.machine_name_.Destroy();
  _impl_.process_name_.Destroy();
}

void CGCToGCMsgMasterAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCToGCMsgMasterAck::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCToGCMsgMasterAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.directory_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.machine_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.process_name_.ClearNonDefaultToEmpty();
    }
    _impl_.dir_index_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGCToGCMsgMasterAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 dir_index = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dir_index(&has_bits);
          _impl_.dir_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string machine_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_machine_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CGCToGCMsgMasterAck.machine_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string process_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_process_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CGCToGCMsgMasterAck.process_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .CGCToGCMsgMasterAck.Process directory = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_directory(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCToGCMsgMasterAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCToGCMsgMasterAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 dir_index = 1 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dir_index(), target);
  }

  // optional string machine_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_machine_name().data(), static_cast<int>(this->_internal_machine_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CGCToGCMsgMasterAck.machine_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_machine_name(), target);
  }

  // optional string process_name = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_process_name().data(), static_cast<int>(this->_internal_process_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CGCToGCMsgMasterAck.process_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_process_name(), target);
  }

  // repeated .CGCToGCMsgMasterAck.Process directory = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_directory_size()); i < n; i++) {
    const auto& repfield = this->_internal_directory(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCToGCMsgMasterAck)
  return target;
}

size_t CGCToGCMsgMasterAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCToGCMsgMasterAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGCToGCMsgMasterAck.Process directory = 6;
  total_size += 1UL * this->_internal_directory_size();
  for (const auto& msg : this->_impl_.directory_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string machine_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_machine_name());
    }

    // optional string process_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_process_name());
    }

    // optional int32 dir_index = 1 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dir_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGCToGCMsgMasterAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CGCToGCMsgMasterAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGCToGCMsgMasterAck::GetClassData() const { return &_class_data_; }


void CGCToGCMsgMasterAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CGCToGCMsgMasterAck*>(&to_msg);
  auto& from = static_cast<const CGCToGCMsgMasterAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCToGCMsgMasterAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.directory_.MergeFrom(from._impl_.directory_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_machine_name(from._internal_machine_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_process_name(from._internal_process_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.dir_index_ = from._impl_.dir_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGCToGCMsgMasterAck::CopyFrom(const CGCToGCMsgMasterAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCToGCMsgMasterAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCToGCMsgMasterAck::IsInitialized() const {
  return true;
}

void CGCToGCMsgMasterAck::InternalSwap(CGCToGCMsgMasterAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.directory_.InternalSwap(&other->_impl_.directory_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_name_, lhs_arena,
      &other->_impl_.machine_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.process_name_, lhs_arena,
      &other->_impl_.process_name_, rhs_arena
  );
  swap(_impl_.dir_index_, other->_impl_.dir_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGCToGCMsgMasterAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[20]);
}

// ===================================================================

class CGCToGCMsgMasterAck_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCToGCMsgMasterAck_Response>()._impl_._has_bits_);
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGCToGCMsgMasterAck_Response::CGCToGCMsgMasterAck_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCToGCMsgMasterAck_Response)
}
CGCToGCMsgMasterAck_Response::CGCToGCMsgMasterAck_Response(const CGCToGCMsgMasterAck_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CGCToGCMsgMasterAck_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.eresult_ = from._impl_.eresult_;
  // @@protoc_insertion_point(copy_constructor:CGCToGCMsgMasterAck_Response)
}

inline void CGCToGCMsgMasterAck_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eresult_){2}
  };
}

CGCToGCMsgMasterAck_Response::~CGCToGCMsgMasterAck_Response() {
  // @@protoc_insertion_point(destructor:CGCToGCMsgMasterAck_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCToGCMsgMasterAck_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGCToGCMsgMasterAck_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCToGCMsgMasterAck_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCToGCMsgMasterAck_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.eresult_ = 2;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGCToGCMsgMasterAck_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 eresult = 1 [default = 2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCToGCMsgMasterAck_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCToGCMsgMasterAck_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 eresult = 1 [default = 2];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_eresult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCToGCMsgMasterAck_Response)
  return target;
}

size_t CGCToGCMsgMasterAck_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCToGCMsgMasterAck_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 eresult = 1 [default = 2];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eresult());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGCToGCMsgMasterAck_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CGCToGCMsgMasterAck_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGCToGCMsgMasterAck_Response::GetClassData() const { return &_class_data_; }


void CGCToGCMsgMasterAck_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CGCToGCMsgMasterAck_Response*>(&to_msg);
  auto& from = static_cast<const CGCToGCMsgMasterAck_Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCToGCMsgMasterAck_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_eresult()) {
    _this->_internal_set_eresult(from._internal_eresult());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGCToGCMsgMasterAck_Response::CopyFrom(const CGCToGCMsgMasterAck_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCToGCMsgMasterAck_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCToGCMsgMasterAck_Response::IsInitialized() const {
  return true;
}

void CGCToGCMsgMasterAck_Response::InternalSwap(CGCToGCMsgMasterAck_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGCToGCMsgMasterAck_Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[21]);
}

// ===================================================================

class CMsgGCToGCUniverseStartup::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCUniverseStartup>()._impl_._has_bits_);
  static void set_has_is_initial_startup(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCUniverseStartup::CMsgGCToGCUniverseStartup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCUniverseStartup)
}
CMsgGCToGCUniverseStartup::CMsgGCToGCUniverseStartup(const CMsgGCToGCUniverseStartup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCUniverseStartup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.is_initial_startup_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.is_initial_startup_ = from._impl_.is_initial_startup_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCUniverseStartup)
}

inline void CMsgGCToGCUniverseStartup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.is_initial_startup_){false}
  };
}

CMsgGCToGCUniverseStartup::~CMsgGCToGCUniverseStartup() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCUniverseStartup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCUniverseStartup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToGCUniverseStartup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCUniverseStartup::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCUniverseStartup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.is_initial_startup_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCUniverseStartup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_initial_startup = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_initial_startup(&has_bits);
          _impl_.is_initial_startup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCUniverseStartup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCUniverseStartup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_initial_startup = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_initial_startup(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCUniverseStartup)
  return target;
}

size_t CMsgGCToGCUniverseStartup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCUniverseStartup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool is_initial_startup = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCUniverseStartup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCUniverseStartup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCUniverseStartup::GetClassData() const { return &_class_data_; }


void CMsgGCToGCUniverseStartup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCUniverseStartup*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCUniverseStartup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCUniverseStartup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_is_initial_startup()) {
    _this->_internal_set_is_initial_startup(from._internal_is_initial_startup());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCUniverseStartup::CopyFrom(const CMsgGCToGCUniverseStartup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCUniverseStartup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCUniverseStartup::IsInitialized() const {
  return true;
}

void CMsgGCToGCUniverseStartup::InternalSwap(CMsgGCToGCUniverseStartup* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.is_initial_startup_, other->_impl_.is_initial_startup_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCUniverseStartup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[22]);
}

// ===================================================================

class CMsgGCToGCUniverseStartupResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCUniverseStartupResponse>()._impl_._has_bits_);
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCUniverseStartupResponse::CMsgGCToGCUniverseStartupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCUniverseStartupResponse)
}
CMsgGCToGCUniverseStartupResponse::CMsgGCToGCUniverseStartupResponse(const CMsgGCToGCUniverseStartupResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCUniverseStartupResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.eresult_ = from._impl_.eresult_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCUniverseStartupResponse)
}

inline void CMsgGCToGCUniverseStartupResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eresult_){0}
  };
}

CMsgGCToGCUniverseStartupResponse::~CMsgGCToGCUniverseStartupResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCUniverseStartupResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCUniverseStartupResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToGCUniverseStartupResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCUniverseStartupResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCUniverseStartupResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.eresult_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCUniverseStartupResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 eresult = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCUniverseStartupResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCUniverseStartupResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 eresult = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_eresult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCUniverseStartupResponse)
  return target;
}

size_t CMsgGCToGCUniverseStartupResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCUniverseStartupResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 eresult = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eresult());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCUniverseStartupResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCUniverseStartupResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCUniverseStartupResponse::GetClassData() const { return &_class_data_; }


void CMsgGCToGCUniverseStartupResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCUniverseStartupResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCUniverseStartupResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCUniverseStartupResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_eresult()) {
    _this->_internal_set_eresult(from._internal_eresult());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCUniverseStartupResponse::CopyFrom(const CMsgGCToGCUniverseStartupResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCUniverseStartupResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCUniverseStartupResponse::IsInitialized() const {
  return true;
}

void CMsgGCToGCUniverseStartupResponse::InternalSwap(CMsgGCToGCUniverseStartupResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCUniverseStartupResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[23]);
}

// ===================================================================

class CGCToGCMsgMasterStartupComplete_GCInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCToGCMsgMasterStartupComplete_GCInfo>()._impl_._has_bits_);
  static void set_has_dir_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_machine_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGCToGCMsgMasterStartupComplete_GCInfo::CGCToGCMsgMasterStartupComplete_GCInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCToGCMsgMasterStartupComplete.GCInfo)
}
CGCToGCMsgMasterStartupComplete_GCInfo::CGCToGCMsgMasterStartupComplete_GCInfo(const CGCToGCMsgMasterStartupComplete_GCInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CGCToGCMsgMasterStartupComplete_GCInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.machine_name_){}
    , decltype(_impl_.dir_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.machine_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_name()) {
    _this->_impl_.machine_name_.Set(from._internal_machine_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.dir_index_ = from._impl_.dir_index_;
  // @@protoc_insertion_point(copy_constructor:CGCToGCMsgMasterStartupComplete.GCInfo)
}

inline void CGCToGCMsgMasterStartupComplete_GCInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.machine_name_){}
    , decltype(_impl_.dir_index_){-1}
  };
  _impl_.machine_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGCToGCMsgMasterStartupComplete_GCInfo::~CGCToGCMsgMasterStartupComplete_GCInfo() {
  // @@protoc_insertion_point(destructor:CGCToGCMsgMasterStartupComplete.GCInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCToGCMsgMasterStartupComplete_GCInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machine_name_.Destroy();
}

void CGCToGCMsgMasterStartupComplete_GCInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCToGCMsgMasterStartupComplete_GCInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCToGCMsgMasterStartupComplete.GCInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.machine_name_.ClearNonDefaultToEmpty();
    }
    _impl_.dir_index_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGCToGCMsgMasterStartupComplete_GCInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 dir_index = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dir_index(&has_bits);
          _impl_.dir_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string machine_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_machine_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CGCToGCMsgMasterStartupComplete.GCInfo.machine_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCToGCMsgMasterStartupComplete_GCInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCToGCMsgMasterStartupComplete.GCInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 dir_index = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dir_index(), target);
  }

  // optional string machine_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_machine_name().data(), static_cast<int>(this->_internal_machine_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CGCToGCMsgMasterStartupComplete.GCInfo.machine_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_machine_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCToGCMsgMasterStartupComplete.GCInfo)
  return target;
}

size_t CGCToGCMsgMasterStartupComplete_GCInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCToGCMsgMasterStartupComplete.GCInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string machine_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_machine_name());
    }

    // optional int32 dir_index = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dir_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGCToGCMsgMasterStartupComplete_GCInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CGCToGCMsgMasterStartupComplete_GCInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGCToGCMsgMasterStartupComplete_GCInfo::GetClassData() const { return &_class_data_; }


void CGCToGCMsgMasterStartupComplete_GCInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CGCToGCMsgMasterStartupComplete_GCInfo*>(&to_msg);
  auto& from = static_cast<const CGCToGCMsgMasterStartupComplete_GCInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCToGCMsgMasterStartupComplete.GCInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_machine_name(from._internal_machine_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dir_index_ = from._impl_.dir_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGCToGCMsgMasterStartupComplete_GCInfo::CopyFrom(const CGCToGCMsgMasterStartupComplete_GCInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCToGCMsgMasterStartupComplete.GCInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCToGCMsgMasterStartupComplete_GCInfo::IsInitialized() const {
  return true;
}

void CGCToGCMsgMasterStartupComplete_GCInfo::InternalSwap(CGCToGCMsgMasterStartupComplete_GCInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_name_, lhs_arena,
      &other->_impl_.machine_name_, rhs_arena
  );
  swap(_impl_.dir_index_, other->_impl_.dir_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGCToGCMsgMasterStartupComplete_GCInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[24]);
}

// ===================================================================

class CGCToGCMsgMasterStartupComplete::_Internal {
 public:
};

CGCToGCMsgMasterStartupComplete::CGCToGCMsgMasterStartupComplete(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCToGCMsgMasterStartupComplete)
}
CGCToGCMsgMasterStartupComplete::CGCToGCMsgMasterStartupComplete(const CGCToGCMsgMasterStartupComplete& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CGCToGCMsgMasterStartupComplete* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.gc_info_){from._impl_.gc_info_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGCToGCMsgMasterStartupComplete)
}

inline void CGCToGCMsgMasterStartupComplete::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.gc_info_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CGCToGCMsgMasterStartupComplete::~CGCToGCMsgMasterStartupComplete() {
  // @@protoc_insertion_point(destructor:CGCToGCMsgMasterStartupComplete)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCToGCMsgMasterStartupComplete::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gc_info_.~RepeatedPtrField();
}

void CGCToGCMsgMasterStartupComplete::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCToGCMsgMasterStartupComplete::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCToGCMsgMasterStartupComplete)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gc_info_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGCToGCMsgMasterStartupComplete::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CGCToGCMsgMasterStartupComplete.GCInfo gc_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gc_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCToGCMsgMasterStartupComplete::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCToGCMsgMasterStartupComplete)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CGCToGCMsgMasterStartupComplete.GCInfo gc_info = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gc_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_gc_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCToGCMsgMasterStartupComplete)
  return target;
}

size_t CGCToGCMsgMasterStartupComplete::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCToGCMsgMasterStartupComplete)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGCToGCMsgMasterStartupComplete.GCInfo gc_info = 1;
  total_size += 1UL * this->_internal_gc_info_size();
  for (const auto& msg : this->_impl_.gc_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGCToGCMsgMasterStartupComplete::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CGCToGCMsgMasterStartupComplete::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGCToGCMsgMasterStartupComplete::GetClassData() const { return &_class_data_; }


void CGCToGCMsgMasterStartupComplete::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CGCToGCMsgMasterStartupComplete*>(&to_msg);
  auto& from = static_cast<const CGCToGCMsgMasterStartupComplete&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCToGCMsgMasterStartupComplete)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.gc_info_.MergeFrom(from._impl_.gc_info_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGCToGCMsgMasterStartupComplete::CopyFrom(const CGCToGCMsgMasterStartupComplete& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCToGCMsgMasterStartupComplete)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCToGCMsgMasterStartupComplete::IsInitialized() const {
  return true;
}

void CGCToGCMsgMasterStartupComplete::InternalSwap(CGCToGCMsgMasterStartupComplete* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.gc_info_.InternalSwap(&other->_impl_.gc_info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGCToGCMsgMasterStartupComplete::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[25]);
}

// ===================================================================

class CGCToGCMsgRouted::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCToGCMsgRouted>()._impl_._has_bits_);
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sender_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_net_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGCToGCMsgRouted::CGCToGCMsgRouted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCToGCMsgRouted)
}
CGCToGCMsgRouted::CGCToGCMsgRouted(const CGCToGCMsgRouted& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CGCToGCMsgRouted* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.net_message_){}
    , decltype(_impl_.sender_id_){}
    , decltype(_impl_.msg_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.net_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_net_message()) {
    _this->_impl_.net_message_.Set(from._internal_net_message(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.sender_id_, &from._impl_.sender_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.msg_type_) -
    reinterpret_cast<char*>(&_impl_.sender_id_)) + sizeof(_impl_.msg_type_));
  // @@protoc_insertion_point(copy_constructor:CGCToGCMsgRouted)
}

inline void CGCToGCMsgRouted::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.net_message_){}
    , decltype(_impl_.sender_id_){uint64_t{0u}}
    , decltype(_impl_.msg_type_){0u}
  };
  _impl_.net_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGCToGCMsgRouted::~CGCToGCMsgRouted() {
  // @@protoc_insertion_point(destructor:CGCToGCMsgRouted)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCToGCMsgRouted::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.net_message_.Destroy();
}

void CGCToGCMsgRouted::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCToGCMsgRouted::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCToGCMsgRouted)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.net_message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.sender_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.msg_type_) -
        reinterpret_cast<char*>(&_impl_.sender_id_)) + sizeof(_impl_.msg_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGCToGCMsgRouted::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 msg_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_type(&has_bits);
          _impl_.msg_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 sender_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_sender_id(&has_bits);
          _impl_.sender_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional bytes net_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_net_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCToGCMsgRouted::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCToGCMsgRouted)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 msg_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msg_type(), target);
  }

  // optional fixed64 sender_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_sender_id(), target);
  }

  // optional bytes net_message = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_net_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCToGCMsgRouted)
  return target;
}

size_t CGCToGCMsgRouted::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCToGCMsgRouted)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes net_message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_net_message());
    }

    // optional fixed64 sender_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 msg_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGCToGCMsgRouted::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CGCToGCMsgRouted::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGCToGCMsgRouted::GetClassData() const { return &_class_data_; }


void CGCToGCMsgRouted::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CGCToGCMsgRouted*>(&to_msg);
  auto& from = static_cast<const CGCToGCMsgRouted&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCToGCMsgRouted)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_net_message(from._internal_net_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sender_id_ = from._impl_.sender_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGCToGCMsgRouted::CopyFrom(const CGCToGCMsgRouted& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCToGCMsgRouted)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCToGCMsgRouted::IsInitialized() const {
  return true;
}

void CGCToGCMsgRouted::InternalSwap(CGCToGCMsgRouted* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.net_message_, lhs_arena,
      &other->_impl_.net_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGCToGCMsgRouted, _impl_.msg_type_)
      + sizeof(CGCToGCMsgRouted::_impl_.msg_type_)
      - PROTOBUF_FIELD_OFFSET(CGCToGCMsgRouted, _impl_.sender_id_)>(
          reinterpret_cast<char*>(&_impl_.sender_id_),
          reinterpret_cast<char*>(&other->_impl_.sender_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CGCToGCMsgRouted::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[26]);
}

// ===================================================================

class CGCToGCMsgRoutedReply::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCToGCMsgRoutedReply>()._impl_._has_bits_);
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_net_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGCToGCMsgRoutedReply::CGCToGCMsgRoutedReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCToGCMsgRoutedReply)
}
CGCToGCMsgRoutedReply::CGCToGCMsgRoutedReply(const CGCToGCMsgRoutedReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CGCToGCMsgRoutedReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.net_message_){}
    , decltype(_impl_.msg_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.net_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_net_message()) {
    _this->_impl_.net_message_.Set(from._internal_net_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.msg_type_ = from._impl_.msg_type_;
  // @@protoc_insertion_point(copy_constructor:CGCToGCMsgRoutedReply)
}

inline void CGCToGCMsgRoutedReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.net_message_){}
    , decltype(_impl_.msg_type_){0u}
  };
  _impl_.net_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGCToGCMsgRoutedReply::~CGCToGCMsgRoutedReply() {
  // @@protoc_insertion_point(destructor:CGCToGCMsgRoutedReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCToGCMsgRoutedReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.net_message_.Destroy();
}

void CGCToGCMsgRoutedReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCToGCMsgRoutedReply::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCToGCMsgRoutedReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.net_message_.ClearNonDefaultToEmpty();
  }
  _impl_.msg_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGCToGCMsgRoutedReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 msg_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_type(&has_bits);
          _impl_.msg_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes net_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_net_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCToGCMsgRoutedReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCToGCMsgRoutedReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 msg_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msg_type(), target);
  }

  // optional bytes net_message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_net_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCToGCMsgRoutedReply)
  return target;
}

size_t CGCToGCMsgRoutedReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCToGCMsgRoutedReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes net_message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_net_message());
    }

    // optional uint32 msg_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGCToGCMsgRoutedReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CGCToGCMsgRoutedReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGCToGCMsgRoutedReply::GetClassData() const { return &_class_data_; }


void CGCToGCMsgRoutedReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CGCToGCMsgRoutedReply*>(&to_msg);
  auto& from = static_cast<const CGCToGCMsgRoutedReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCToGCMsgRoutedReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_net_message(from._internal_net_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGCToGCMsgRoutedReply::CopyFrom(const CGCToGCMsgRoutedReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCToGCMsgRoutedReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCToGCMsgRoutedReply::IsInitialized() const {
  return true;
}

void CGCToGCMsgRoutedReply::InternalSwap(CGCToGCMsgRoutedReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.net_message_, lhs_arena,
      &other->_impl_.net_message_, rhs_arena
  );
  swap(_impl_.msg_type_, other->_impl_.msg_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGCToGCMsgRoutedReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[27]);
}

// ===================================================================

class CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_trusted(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::CMsgGCUpdateSubGCSessionInfo_CMsgUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate)
}
CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::CMsgGCUpdateSubGCSessionInfo_CMsgUpdate(const CMsgGCUpdateSubGCSessionInfo_CMsgUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCUpdateSubGCSessionInfo_CMsgUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.trusted_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.trusted_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.trusted_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate)
}

inline void CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.ip_){0u}
    , decltype(_impl_.trusted_){false}
  };
}

CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::~CMsgGCUpdateSubGCSessionInfo_CMsgUpdate() {
  // @@protoc_insertion_point(destructor:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.trusted_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.trusted_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_ip(&has_bits);
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional bool trusted = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_trusted(&has_bits);
          _impl_.trusted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional fixed32 ip = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_ip(), target);
  }

  // optional bool trusted = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_trusted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate)
  return target;
}

size_t CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional fixed64 steamid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed32 ip = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional bool trusted = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::GetClassData() const { return &_class_data_; }


void CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate*>(&to_msg);
  auto& from = static_cast<const CMsgGCUpdateSubGCSessionInfo_CMsgUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ip_ = from._impl_.ip_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.trusted_ = from._impl_.trusted_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::CopyFrom(const CMsgGCUpdateSubGCSessionInfo_CMsgUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCUpdateSubGCSessionInfo.CMsgUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::IsInitialized() const {
  return true;
}

void CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::InternalSwap(CMsgGCUpdateSubGCSessionInfo_CMsgUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCUpdateSubGCSessionInfo_CMsgUpdate, _impl_.trusted_)
      + sizeof(CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::_impl_.trusted_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCUpdateSubGCSessionInfo_CMsgUpdate, _impl_.steamid_)>(
          reinterpret_cast<char*>(&_impl_.steamid_),
          reinterpret_cast<char*>(&other->_impl_.steamid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[28]);
}

// ===================================================================

class CMsgGCUpdateSubGCSessionInfo::_Internal {
 public:
};

CMsgGCUpdateSubGCSessionInfo::CMsgGCUpdateSubGCSessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCUpdateSubGCSessionInfo)
}
CMsgGCUpdateSubGCSessionInfo::CMsgGCUpdateSubGCSessionInfo(const CMsgGCUpdateSubGCSessionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCUpdateSubGCSessionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.updates_){from._impl_.updates_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCUpdateSubGCSessionInfo)
}

inline void CMsgGCUpdateSubGCSessionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.updates_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGCUpdateSubGCSessionInfo::~CMsgGCUpdateSubGCSessionInfo() {
  // @@protoc_insertion_point(destructor:CMsgGCUpdateSubGCSessionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCUpdateSubGCSessionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.updates_.~RepeatedPtrField();
}

void CMsgGCUpdateSubGCSessionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCUpdateSubGCSessionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCUpdateSubGCSessionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.updates_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCUpdateSubGCSessionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGCUpdateSubGCSessionInfo.CMsgUpdate updates = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_updates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCUpdateSubGCSessionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCUpdateSubGCSessionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGCUpdateSubGCSessionInfo.CMsgUpdate updates = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_updates_size()); i < n; i++) {
    const auto& repfield = this->_internal_updates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCUpdateSubGCSessionInfo)
  return target;
}

size_t CMsgGCUpdateSubGCSessionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCUpdateSubGCSessionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGCUpdateSubGCSessionInfo.CMsgUpdate updates = 1;
  total_size += 1UL * this->_internal_updates_size();
  for (const auto& msg : this->_impl_.updates_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCUpdateSubGCSessionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCUpdateSubGCSessionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCUpdateSubGCSessionInfo::GetClassData() const { return &_class_data_; }


void CMsgGCUpdateSubGCSessionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCUpdateSubGCSessionInfo*>(&to_msg);
  auto& from = static_cast<const CMsgGCUpdateSubGCSessionInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCUpdateSubGCSessionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.updates_.MergeFrom(from._impl_.updates_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCUpdateSubGCSessionInfo::CopyFrom(const CMsgGCUpdateSubGCSessionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCUpdateSubGCSessionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCUpdateSubGCSessionInfo::IsInitialized() const {
  return true;
}

void CMsgGCUpdateSubGCSessionInfo::InternalSwap(CMsgGCUpdateSubGCSessionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.updates_.InternalSwap(&other->_impl_.updates_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCUpdateSubGCSessionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[29]);
}

// ===================================================================

class CMsgGCRequestSubGCSessionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCRequestSubGCSessionInfo>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCRequestSubGCSessionInfo::CMsgGCRequestSubGCSessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCRequestSubGCSessionInfo)
}
CMsgGCRequestSubGCSessionInfo::CMsgGCRequestSubGCSessionInfo(const CMsgGCRequestSubGCSessionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCRequestSubGCSessionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.steamid_ = from._impl_.steamid_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCRequestSubGCSessionInfo)
}

inline void CMsgGCRequestSubGCSessionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steamid_){uint64_t{0u}}
  };
}

CMsgGCRequestSubGCSessionInfo::~CMsgGCRequestSubGCSessionInfo() {
  // @@protoc_insertion_point(destructor:CMsgGCRequestSubGCSessionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCRequestSubGCSessionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCRequestSubGCSessionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCRequestSubGCSessionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCRequestSubGCSessionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steamid_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCRequestSubGCSessionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCRequestSubGCSessionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCRequestSubGCSessionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCRequestSubGCSessionInfo)
  return target;
}

size_t CMsgGCRequestSubGCSessionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCRequestSubGCSessionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 steamid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCRequestSubGCSessionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCRequestSubGCSessionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCRequestSubGCSessionInfo::GetClassData() const { return &_class_data_; }


void CMsgGCRequestSubGCSessionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCRequestSubGCSessionInfo*>(&to_msg);
  auto& from = static_cast<const CMsgGCRequestSubGCSessionInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCRequestSubGCSessionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_steamid()) {
    _this->_internal_set_steamid(from._internal_steamid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCRequestSubGCSessionInfo::CopyFrom(const CMsgGCRequestSubGCSessionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCRequestSubGCSessionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCRequestSubGCSessionInfo::IsInitialized() const {
  return true;
}

void CMsgGCRequestSubGCSessionInfo::InternalSwap(CMsgGCRequestSubGCSessionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.steamid_, other->_impl_.steamid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCRequestSubGCSessionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[30]);
}

// ===================================================================

class CMsgGCRequestSubGCSessionInfoResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCRequestSubGCSessionInfoResponse>()._impl_._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_trusted(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgGCRequestSubGCSessionInfoResponse::CMsgGCRequestSubGCSessionInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCRequestSubGCSessionInfoResponse)
}
CMsgGCRequestSubGCSessionInfoResponse::CMsgGCRequestSubGCSessionInfoResponse(const CMsgGCRequestSubGCSessionInfoResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCRequestSubGCSessionInfoResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.port_){}
    , decltype(_impl_.trusted_){}
    , decltype(_impl_.success_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ip_, &from._impl_.ip_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.success_) -
    reinterpret_cast<char*>(&_impl_.ip_)) + sizeof(_impl_.success_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCRequestSubGCSessionInfoResponse)
}

inline void CMsgGCRequestSubGCSessionInfoResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){0u}
    , decltype(_impl_.port_){0u}
    , decltype(_impl_.trusted_){false}
    , decltype(_impl_.success_){false}
  };
}

CMsgGCRequestSubGCSessionInfoResponse::~CMsgGCRequestSubGCSessionInfoResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCRequestSubGCSessionInfoResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCRequestSubGCSessionInfoResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCRequestSubGCSessionInfoResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCRequestSubGCSessionInfoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCRequestSubGCSessionInfoResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.ip_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.success_) -
        reinterpret_cast<char*>(&_impl_.ip_)) + sizeof(_impl_.success_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCRequestSubGCSessionInfoResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_ip(&has_bits);
          _impl_.ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional bool trusted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_trusted(&has_bits);
          _impl_.trusted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCRequestSubGCSessionInfoResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCRequestSubGCSessionInfoResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_ip(), target);
  }

  // optional bool trusted = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_trusted(), target);
  }

  // optional uint32 port = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_port(), target);
  }

  // optional bool success = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_success(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCRequestSubGCSessionInfoResponse)
  return target;
}

size_t CMsgGCRequestSubGCSessionInfoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCRequestSubGCSessionInfoResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional fixed32 ip = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional uint32 port = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
    }

    // optional bool trusted = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCRequestSubGCSessionInfoResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCRequestSubGCSessionInfoResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCRequestSubGCSessionInfoResponse::GetClassData() const { return &_class_data_; }


void CMsgGCRequestSubGCSessionInfoResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCRequestSubGCSessionInfoResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCRequestSubGCSessionInfoResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCRequestSubGCSessionInfoResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ip_ = from._impl_.ip_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.trusted_ = from._impl_.trusted_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.success_ = from._impl_.success_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCRequestSubGCSessionInfoResponse::CopyFrom(const CMsgGCRequestSubGCSessionInfoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCRequestSubGCSessionInfoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCRequestSubGCSessionInfoResponse::IsInitialized() const {
  return true;
}

void CMsgGCRequestSubGCSessionInfoResponse::InternalSwap(CMsgGCRequestSubGCSessionInfoResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCRequestSubGCSessionInfoResponse, _impl_.success_)
      + sizeof(CMsgGCRequestSubGCSessionInfoResponse::_impl_.success_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCRequestSubGCSessionInfoResponse, _impl_.ip_)>(
          reinterpret_cast<char*>(&_impl_.ip_),
          reinterpret_cast<char*>(&other->_impl_.ip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCRequestSubGCSessionInfoResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[31]);
}

// ===================================================================

class CMsgSOCacheHaveVersion::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSOCacheHaveVersion>()._impl_._has_bits_);
  static const ::CMsgSOIDOwner& soid(const CMsgSOCacheHaveVersion* msg);
  static void set_has_soid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_service_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cached_file_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgSOIDOwner&
CMsgSOCacheHaveVersion::_Internal::soid(const CMsgSOCacheHaveVersion* msg) {
  return *msg->_impl_.soid_;
}
CMsgSOCacheHaveVersion::CMsgSOCacheHaveVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSOCacheHaveVersion)
}
CMsgSOCacheHaveVersion::CMsgSOCacheHaveVersion(const CMsgSOCacheHaveVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSOCacheHaveVersion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.soid_){nullptr}
    , decltype(_impl_.version_){}
    , decltype(_impl_.service_id_){}
    , decltype(_impl_.cached_file_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_soid()) {
    _this->_impl_.soid_ = new ::CMsgSOIDOwner(*from._impl_.soid_);
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cached_file_version_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.cached_file_version_));
  // @@protoc_insertion_point(copy_constructor:CMsgSOCacheHaveVersion)
}

inline void CMsgSOCacheHaveVersion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.soid_){nullptr}
    , decltype(_impl_.version_){uint64_t{0u}}
    , decltype(_impl_.service_id_){0u}
    , decltype(_impl_.cached_file_version_){0u}
  };
}

CMsgSOCacheHaveVersion::~CMsgSOCacheHaveVersion() {
  // @@protoc_insertion_point(destructor:CMsgSOCacheHaveVersion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSOCacheHaveVersion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.soid_;
}

void CMsgSOCacheHaveVersion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSOCacheHaveVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSOCacheHaveVersion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.soid_ != nullptr);
    _impl_.soid_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cached_file_version_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.cached_file_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSOCacheHaveVersion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSOIDOwner soid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_soid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 service_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_service_id(&has_bits);
          _impl_.service_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cached_file_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_cached_file_version(&has_bits);
          _impl_.cached_file_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSOCacheHaveVersion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSOCacheHaveVersion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgSOIDOwner soid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::soid(this),
        _Internal::soid(this).GetCachedSize(), target, stream);
  }

  // optional fixed64 version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_version(), target);
  }

  // optional uint32 service_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_service_id(), target);
  }

  // optional uint32 cached_file_version = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_cached_file_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSOCacheHaveVersion)
  return target;
}

size_t CMsgSOCacheHaveVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSOCacheHaveVersion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgSOIDOwner soid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.soid_);
    }

    // optional fixed64 version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 service_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_service_id());
    }

    // optional uint32 cached_file_version = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cached_file_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSOCacheHaveVersion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSOCacheHaveVersion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSOCacheHaveVersion::GetClassData() const { return &_class_data_; }


void CMsgSOCacheHaveVersion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSOCacheHaveVersion*>(&to_msg);
  auto& from = static_cast<const CMsgSOCacheHaveVersion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSOCacheHaveVersion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_soid()->::CMsgSOIDOwner::MergeFrom(
          from._internal_soid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.service_id_ = from._impl_.service_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.cached_file_version_ = from._impl_.cached_file_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSOCacheHaveVersion::CopyFrom(const CMsgSOCacheHaveVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSOCacheHaveVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSOCacheHaveVersion::IsInitialized() const {
  return true;
}

void CMsgSOCacheHaveVersion::InternalSwap(CMsgSOCacheHaveVersion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSOCacheHaveVersion, _impl_.cached_file_version_)
      + sizeof(CMsgSOCacheHaveVersion::_impl_.cached_file_version_)
      - PROTOBUF_FIELD_OFFSET(CMsgSOCacheHaveVersion, _impl_.soid_)>(
          reinterpret_cast<char*>(&_impl_.soid_),
          reinterpret_cast<char*>(&other->_impl_.soid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSOCacheHaveVersion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[32]);
}

// ===================================================================

class CMsgClientHello::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientHello>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_client_session_need(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_client_launcher(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_secret_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_language(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_engine(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_steamdatagram_login(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_platform_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_game_msg(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_os_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_render_system(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_render_system_req(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_screen_width(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_screen_height(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_screen_refresh(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_render_width(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_render_height(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_swap_width(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_swap_height(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_is_steam_china(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_is_steam_china_client(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_platform_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgClientHello::CMsgClientHello(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientHello)
}
CMsgClientHello::CMsgClientHello(const CMsgClientHello& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientHello* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.socache_have_versions_){from._impl_.socache_have_versions_}
    , decltype(_impl_.secret_key_){}
    , decltype(_impl_.steamdatagram_login_){}
    , decltype(_impl_.game_msg_){}
    , decltype(_impl_.platform_name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.client_session_need_){}
    , decltype(_impl_.client_launcher_){}
    , decltype(_impl_.client_language_){}
    , decltype(_impl_.engine_){}
    , decltype(_impl_.platform_id_){}
    , decltype(_impl_.os_type_){}
    , decltype(_impl_.render_system_){}
    , decltype(_impl_.render_system_req_){}
    , decltype(_impl_.screen_width_){}
    , decltype(_impl_.screen_height_){}
    , decltype(_impl_.screen_refresh_){}
    , decltype(_impl_.render_width_){}
    , decltype(_impl_.render_height_){}
    , decltype(_impl_.swap_width_){}
    , decltype(_impl_.swap_height_){}
    , decltype(_impl_.is_steam_china_){}
    , decltype(_impl_.is_steam_china_client_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.secret_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secret_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_secret_key()) {
    _this->_impl_.secret_key_.Set(from._internal_secret_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.steamdatagram_login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.steamdatagram_login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_steamdatagram_login()) {
    _this->_impl_.steamdatagram_login_.Set(from._internal_steamdatagram_login(), 
      _this->GetArenaForAllocation());
  }
  _impl_.game_msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_msg()) {
    _this->_impl_.game_msg_.Set(from._internal_game_msg(), 
      _this->GetArenaForAllocation());
  }
  _impl_.platform_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.platform_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_platform_name()) {
    _this->_impl_.platform_name_.Set(from._internal_platform_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_steam_china_client_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.is_steam_china_client_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientHello)
}

inline void CMsgClientHello::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.socache_have_versions_){arena}
    , decltype(_impl_.secret_key_){}
    , decltype(_impl_.steamdatagram_login_){}
    , decltype(_impl_.game_msg_){}
    , decltype(_impl_.platform_name_){}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.client_session_need_){0u}
    , decltype(_impl_.client_launcher_){0}
    , decltype(_impl_.client_language_){0u}
    , decltype(_impl_.engine_){0}
    , decltype(_impl_.platform_id_){0u}
    , decltype(_impl_.os_type_){0}
    , decltype(_impl_.render_system_){0u}
    , decltype(_impl_.render_system_req_){0u}
    , decltype(_impl_.screen_width_){0u}
    , decltype(_impl_.screen_height_){0u}
    , decltype(_impl_.screen_refresh_){0u}
    , decltype(_impl_.render_width_){0u}
    , decltype(_impl_.render_height_){0u}
    , decltype(_impl_.swap_width_){0u}
    , decltype(_impl_.swap_height_){0u}
    , decltype(_impl_.is_steam_china_){false}
    , decltype(_impl_.is_steam_china_client_){false}
  };
  _impl_.secret_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secret_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.steamdatagram_login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.steamdatagram_login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.game_msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.platform_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.platform_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgClientHello::~CMsgClientHello() {
  // @@protoc_insertion_point(destructor:CMsgClientHello)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientHello::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.socache_have_versions_.~RepeatedPtrField();
  _impl_.secret_key_.Destroy();
  _impl_.steamdatagram_login_.Destroy();
  _impl_.game_msg_.Destroy();
  _impl_.platform_name_.Destroy();
}

void CMsgClientHello::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientHello::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientHello)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.socache_have_versions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.secret_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.steamdatagram_login_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.game_msg_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.platform_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.client_language_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.client_language_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.engine_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.screen_refresh_) -
        reinterpret_cast<char*>(&_impl_.engine_)) + sizeof(_impl_.screen_refresh_));
  }
  if (cached_has_bits & 0x003f0000u) {
    ::memset(&_impl_.render_width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_steam_china_client_) -
        reinterpret_cast<char*>(&_impl_.render_width_)) + sizeof(_impl_.is_steam_china_client_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientHello::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSOCacheHaveVersion socache_have_versions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_socache_have_versions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_session_need = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_client_session_need(&has_bits);
          _impl_.client_session_need_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PartnerAccountType client_launcher = 4 [default = PARTNER_NONE];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PartnerAccountType_IsValid(val))) {
            _internal_set_client_launcher(static_cast<::PartnerAccountType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string secret_key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_secret_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgClientHello.secret_key");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_language = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_client_language(&has_bits);
          _impl_.client_language_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ESourceEngine engine = 7 [default = k_ESE_Source1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESourceEngine_IsValid(val))) {
            _internal_set_engine(static_cast<::ESourceEngine>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes steamdatagram_login = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_steamdatagram_login();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 platform_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_platform_id(&has_bits);
          _impl_.platform_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes game_msg = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_game_msg();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 os_type = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_os_type(&has_bits);
          _impl_.os_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 render_system = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_render_system(&has_bits);
          _impl_.render_system_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 render_system_req = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_render_system_req(&has_bits);
          _impl_.render_system_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 screen_width = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_screen_width(&has_bits);
          _impl_.screen_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 screen_height = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_screen_height(&has_bits);
          _impl_.screen_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 screen_refresh = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_screen_refresh(&has_bits);
          _impl_.screen_refresh_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 render_width = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_render_width(&has_bits);
          _impl_.render_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 render_height = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_render_height(&has_bits);
          _impl_.render_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 swap_width = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_swap_width(&has_bits);
          _impl_.swap_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 swap_height = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_swap_height(&has_bits);
          _impl_.swap_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_steam_china = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_is_steam_china(&has_bits);
          _impl_.is_steam_china_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string platform_name = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_platform_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgClientHello.platform_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool is_steam_china_client = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_is_steam_china_client(&has_bits);
          _impl_.is_steam_china_client_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientHello::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientHello)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 version = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // repeated .CMsgSOCacheHaveVersion socache_have_versions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_socache_have_versions_size()); i < n; i++) {
    const auto& repfield = this->_internal_socache_have_versions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 client_session_need = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_client_session_need(), target);
  }

  // optional .PartnerAccountType client_launcher = 4 [default = PARTNER_NONE];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_client_launcher(), target);
  }

  // optional string secret_key = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_secret_key().data(), static_cast<int>(this->_internal_secret_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgClientHello.secret_key");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_secret_key(), target);
  }

  // optional uint32 client_language = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_client_language(), target);
  }

  // optional .ESourceEngine engine = 7 [default = k_ESE_Source1];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_engine(), target);
  }

  // optional bytes steamdatagram_login = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_steamdatagram_login(), target);
  }

  // optional uint32 platform_id = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_platform_id(), target);
  }

  // optional bytes game_msg = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        10, this->_internal_game_msg(), target);
  }

  // optional int32 os_type = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_os_type(), target);
  }

  // optional uint32 render_system = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_render_system(), target);
  }

  // optional uint32 render_system_req = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_render_system_req(), target);
  }

  // optional uint32 screen_width = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_screen_width(), target);
  }

  // optional uint32 screen_height = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_screen_height(), target);
  }

  // optional uint32 screen_refresh = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_screen_refresh(), target);
  }

  // optional uint32 render_width = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_render_width(), target);
  }

  // optional uint32 render_height = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_render_height(), target);
  }

  // optional uint32 swap_width = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_swap_width(), target);
  }

  // optional uint32 swap_height = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_swap_height(), target);
  }

  // optional bool is_steam_china = 22;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_is_steam_china(), target);
  }

  // optional string platform_name = 23;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_platform_name().data(), static_cast<int>(this->_internal_platform_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgClientHello.platform_name");
    target = stream->WriteStringMaybeAliased(
        23, this->_internal_platform_name(), target);
  }

  // optional bool is_steam_china_client = 24;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_is_steam_china_client(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientHello)
  return target;
}

size_t CMsgClientHello::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientHello)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSOCacheHaveVersion socache_have_versions = 2;
  total_size += 1UL * this->_internal_socache_have_versions_size();
  for (const auto& msg : this->_impl_.socache_have_versions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string secret_key = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_secret_key());
    }

    // optional bytes steamdatagram_login = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_steamdatagram_login());
    }

    // optional bytes game_msg = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_game_msg());
    }

    // optional string platform_name = 23;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_platform_name());
    }

    // optional uint32 version = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional uint32 client_session_need = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_session_need());
    }

    // optional .PartnerAccountType client_launcher = 4 [default = PARTNER_NONE];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_client_launcher());
    }

    // optional uint32 client_language = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_language());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .ESourceEngine engine = 7 [default = k_ESE_Source1];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_engine());
    }

    // optional uint32 platform_id = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_platform_id());
    }

    // optional int32 os_type = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_os_type());
    }

    // optional uint32 render_system = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_render_system());
    }

    // optional uint32 render_system_req = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_render_system_req());
    }

    // optional uint32 screen_width = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_screen_width());
    }

    // optional uint32 screen_height = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_screen_height());
    }

    // optional uint32 screen_refresh = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_screen_refresh());
    }

  }
  if (cached_has_bits & 0x003f0000u) {
    // optional uint32 render_width = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_render_width());
    }

    // optional uint32 render_height = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_render_height());
    }

    // optional uint32 swap_width = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_swap_width());
    }

    // optional uint32 swap_height = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_swap_height());
    }

    // optional bool is_steam_china = 22;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool is_steam_china_client = 24;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientHello::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientHello::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientHello::GetClassData() const { return &_class_data_; }


void CMsgClientHello::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientHello*>(&to_msg);
  auto& from = static_cast<const CMsgClientHello&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientHello)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.socache_have_versions_.MergeFrom(from._impl_.socache_have_versions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_secret_key(from._internal_secret_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_steamdatagram_login(from._internal_steamdatagram_login());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_game_msg(from._internal_game_msg());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_platform_name(from._internal_platform_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.client_session_need_ = from._impl_.client_session_need_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.client_launcher_ = from._impl_.client_launcher_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.client_language_ = from._impl_.client_language_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.engine_ = from._impl_.engine_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.platform_id_ = from._impl_.platform_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.os_type_ = from._impl_.os_type_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.render_system_ = from._impl_.render_system_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.render_system_req_ = from._impl_.render_system_req_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.screen_width_ = from._impl_.screen_width_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.screen_height_ = from._impl_.screen_height_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.screen_refresh_ = from._impl_.screen_refresh_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x003f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.render_width_ = from._impl_.render_width_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.render_height_ = from._impl_.render_height_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.swap_width_ = from._impl_.swap_width_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.swap_height_ = from._impl_.swap_height_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.is_steam_china_ = from._impl_.is_steam_china_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.is_steam_china_client_ = from._impl_.is_steam_china_client_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientHello::CopyFrom(const CMsgClientHello& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientHello)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientHello::IsInitialized() const {
  return true;
}

void CMsgClientHello::InternalSwap(CMsgClientHello* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.socache_have_versions_.InternalSwap(&other->_impl_.socache_have_versions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.secret_key_, lhs_arena,
      &other->_impl_.secret_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.steamdatagram_login_, lhs_arena,
      &other->_impl_.steamdatagram_login_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_msg_, lhs_arena,
      &other->_impl_.game_msg_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.platform_name_, lhs_arena,
      &other->_impl_.platform_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientHello, _impl_.is_steam_china_client_)
      + sizeof(CMsgClientHello::_impl_.is_steam_china_client_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientHello, _impl_.version_)>(
          reinterpret_cast<char*>(&_impl_.version_),
          reinterpret_cast<char*>(&other->_impl_.version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientHello::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[33]);
}

// ===================================================================

class CMsgClientWelcome_Location::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientWelcome_Location>()._impl_._has_bits_);
  static void set_has_latitude(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_longitude(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_country(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientWelcome_Location::CMsgClientWelcome_Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientWelcome.Location)
}
CMsgClientWelcome_Location::CMsgClientWelcome_Location(const CMsgClientWelcome_Location& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientWelcome_Location* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.country_){}
    , decltype(_impl_.latitude_){}
    , decltype(_impl_.longitude_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country()) {
    _this->_impl_.country_.Set(from._internal_country(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.latitude_, &from._impl_.latitude_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.longitude_) -
    reinterpret_cast<char*>(&_impl_.latitude_)) + sizeof(_impl_.longitude_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientWelcome.Location)
}

inline void CMsgClientWelcome_Location::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.country_){}
    , decltype(_impl_.latitude_){0}
    , decltype(_impl_.longitude_){0}
  };
  _impl_.country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgClientWelcome_Location::~CMsgClientWelcome_Location() {
  // @@protoc_insertion_point(destructor:CMsgClientWelcome.Location)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientWelcome_Location::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.country_.Destroy();
}

void CMsgClientWelcome_Location::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientWelcome_Location::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientWelcome.Location)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.country_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.latitude_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.longitude_) -
        reinterpret_cast<char*>(&_impl_.latitude_)) + sizeof(_impl_.longitude_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientWelcome_Location::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float latitude = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_latitude(&has_bits);
          _impl_.latitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float longitude = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_longitude(&has_bits);
          _impl_.longitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string country = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_country();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgClientWelcome.Location.country");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientWelcome_Location::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientWelcome.Location)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float latitude = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_latitude(), target);
  }

  // optional float longitude = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_longitude(), target);
  }

  // optional string country = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_country().data(), static_cast<int>(this->_internal_country().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgClientWelcome.Location.country");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_country(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientWelcome.Location)
  return target;
}

size_t CMsgClientWelcome_Location::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientWelcome.Location)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string country = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country());
    }

    // optional float latitude = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float longitude = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientWelcome_Location::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientWelcome_Location::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientWelcome_Location::GetClassData() const { return &_class_data_; }


void CMsgClientWelcome_Location::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientWelcome_Location*>(&to_msg);
  auto& from = static_cast<const CMsgClientWelcome_Location&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientWelcome.Location)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_country(from._internal_country());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.latitude_ = from._impl_.latitude_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.longitude_ = from._impl_.longitude_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientWelcome_Location::CopyFrom(const CMsgClientWelcome_Location& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientWelcome.Location)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientWelcome_Location::IsInitialized() const {
  return true;
}

void CMsgClientWelcome_Location::InternalSwap(CMsgClientWelcome_Location* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.country_, lhs_arena,
      &other->_impl_.country_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientWelcome_Location, _impl_.longitude_)
      + sizeof(CMsgClientWelcome_Location::_impl_.longitude_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientWelcome_Location, _impl_.latitude_)>(
          reinterpret_cast<char*>(&_impl_.latitude_),
          reinterpret_cast<char*>(&other->_impl_.latitude_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientWelcome_Location::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[34]);
}

// ===================================================================

class CMsgClientWelcome::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientWelcome>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_game_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgClientWelcome_Location& location(const CMsgClientWelcome* msg);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_save_game_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gc_socache_file_version(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_txn_country_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_game_data2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rtime32_gc_welcome_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_currency(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_balance(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_balance_url(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_has_accepted_china_ssa(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_is_banned_steam_china(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::CExtraMsgBlock& additional_welcome_msgs(const CMsgClientWelcome* msg);
  static void set_has_additional_welcome_msgs(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::CMsgSteamLearnServerInfo& steam_learn_server_info(const CMsgClientWelcome* msg);
  static void set_has_steam_learn_server_info(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::CMsgClientWelcome_Location&
CMsgClientWelcome::_Internal::location(const CMsgClientWelcome* msg) {
  return *msg->_impl_.location_;
}
const ::CExtraMsgBlock&
CMsgClientWelcome::_Internal::additional_welcome_msgs(const CMsgClientWelcome* msg) {
  return *msg->_impl_.additional_welcome_msgs_;
}
const ::CMsgSteamLearnServerInfo&
CMsgClientWelcome::_Internal::steam_learn_server_info(const CMsgClientWelcome* msg) {
  return *msg->_impl_.steam_learn_server_info_;
}
CMsgClientWelcome::CMsgClientWelcome(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientWelcome)
}
CMsgClientWelcome::CMsgClientWelcome(const CMsgClientWelcome& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientWelcome* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.outofdate_subscribed_caches_){from._impl_.outofdate_subscribed_caches_}
    , decltype(_impl_.uptodate_subscribed_caches_){from._impl_.uptodate_subscribed_caches_}
    , decltype(_impl_.game_data_){}
    , decltype(_impl_.save_game_key_){}
    , decltype(_impl_.txn_country_code_){}
    , decltype(_impl_.game_data2_){}
    , decltype(_impl_.balance_url_){}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.additional_welcome_msgs_){nullptr}
    , decltype(_impl_.steam_learn_server_info_){nullptr}
    , decltype(_impl_.version_){}
    , decltype(_impl_.gc_socache_file_version_){}
    , decltype(_impl_.rtime32_gc_welcome_timestamp_){}
    , decltype(_impl_.currency_){}
    , decltype(_impl_.balance_){}
    , decltype(_impl_.has_accepted_china_ssa_){}
    , decltype(_impl_.is_banned_steam_china_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.game_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_data()) {
    _this->_impl_.game_data_.Set(from._internal_game_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.save_game_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.save_game_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_save_game_key()) {
    _this->_impl_.save_game_key_.Set(from._internal_save_game_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.txn_country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_txn_country_code()) {
    _this->_impl_.txn_country_code_.Set(from._internal_txn_country_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.game_data2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_data2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_data2()) {
    _this->_impl_.game_data2_.Set(from._internal_game_data2(), 
      _this->GetArenaForAllocation());
  }
  _impl_.balance_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.balance_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_balance_url()) {
    _this->_impl_.balance_url_.Set(from._internal_balance_url(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_location()) {
    _this->_impl_.location_ = new ::CMsgClientWelcome_Location(*from._impl_.location_);
  }
  if (from._internal_has_additional_welcome_msgs()) {
    _this->_impl_.additional_welcome_msgs_ = new ::CExtraMsgBlock(*from._impl_.additional_welcome_msgs_);
  }
  if (from._internal_has_steam_learn_server_info()) {
    _this->_impl_.steam_learn_server_info_ = new ::CMsgSteamLearnServerInfo(*from._impl_.steam_learn_server_info_);
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_banned_steam_china_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.is_banned_steam_china_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientWelcome)
}

inline void CMsgClientWelcome::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.outofdate_subscribed_caches_){arena}
    , decltype(_impl_.uptodate_subscribed_caches_){arena}
    , decltype(_impl_.game_data_){}
    , decltype(_impl_.save_game_key_){}
    , decltype(_impl_.txn_country_code_){}
    , decltype(_impl_.game_data2_){}
    , decltype(_impl_.balance_url_){}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.additional_welcome_msgs_){nullptr}
    , decltype(_impl_.steam_learn_server_info_){nullptr}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.gc_socache_file_version_){0u}
    , decltype(_impl_.rtime32_gc_welcome_timestamp_){0u}
    , decltype(_impl_.currency_){0u}
    , decltype(_impl_.balance_){0u}
    , decltype(_impl_.has_accepted_china_ssa_){false}
    , decltype(_impl_.is_banned_steam_china_){false}
  };
  _impl_.game_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.save_game_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.save_game_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.txn_country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.txn_country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.game_data2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_data2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.balance_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.balance_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgClientWelcome::~CMsgClientWelcome() {
  // @@protoc_insertion_point(destructor:CMsgClientWelcome)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientWelcome::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.outofdate_subscribed_caches_.~RepeatedPtrField();
  _impl_.uptodate_subscribed_caches_.~RepeatedPtrField();
  _impl_.game_data_.Destroy();
  _impl_.save_game_key_.Destroy();
  _impl_.txn_country_code_.Destroy();
  _impl_.game_data2_.Destroy();
  _impl_.balance_url_.Destroy();
  if (this != internal_default_instance()) delete _impl_.location_;
  if (this != internal_default_instance()) delete _impl_.additional_welcome_msgs_;
  if (this != internal_default_instance()) delete _impl_.steam_learn_server_info_;
}

void CMsgClientWelcome::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientWelcome::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientWelcome)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.outofdate_subscribed_caches_.Clear();
  _impl_.uptodate_subscribed_caches_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.game_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.save_game_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.txn_country_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.game_data2_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.balance_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.location_ != nullptr);
      _impl_.location_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.additional_welcome_msgs_ != nullptr);
      _impl_.additional_welcome_msgs_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.steam_learn_server_info_ != nullptr);
      _impl_.steam_learn_server_info_->Clear();
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_banned_steam_china_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.is_banned_steam_china_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientWelcome::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes game_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_game_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSOCacheSubscribed outofdate_subscribed_caches = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_outofdate_subscribed_caches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSOCacheSubscriptionCheck uptodate_subscribed_caches = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_uptodate_subscribed_caches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgClientWelcome.Location location = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes save_game_key = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_save_game_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gc_socache_file_version = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_gc_socache_file_version(&has_bits);
          _impl_.gc_socache_file_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string txn_country_code = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_txn_country_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgClientWelcome.txn_country_code");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes game_data2 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_game_data2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime32_gc_welcome_timestamp = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_rtime32_gc_welcome_timestamp(&has_bits);
          _impl_.rtime32_gc_welcome_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 currency = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_currency(&has_bits);
          _impl_.currency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 balance = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_balance(&has_bits);
          _impl_.balance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string balance_url = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_balance_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgClientWelcome.balance_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool has_accepted_china_ssa = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_has_accepted_china_ssa(&has_bits);
          _impl_.has_accepted_china_ssa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_banned_steam_china = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_is_banned_steam_china(&has_bits);
          _impl_.is_banned_steam_china_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CExtraMsgBlock additional_welcome_msgs = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_additional_welcome_msgs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSteamLearnServerInfo steam_learn_server_info = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_steam_learn_server_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientWelcome::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientWelcome)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 version = 1;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // optional bytes game_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_game_data(), target);
  }

  // repeated .CMsgSOCacheSubscribed outofdate_subscribed_caches = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outofdate_subscribed_caches_size()); i < n; i++) {
    const auto& repfield = this->_internal_outofdate_subscribed_caches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgSOCacheSubscriptionCheck uptodate_subscribed_caches = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_uptodate_subscribed_caches_size()); i < n; i++) {
    const auto& repfield = this->_internal_uptodate_subscribed_caches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .CMsgClientWelcome.Location location = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::location(this),
        _Internal::location(this).GetCachedSize(), target, stream);
  }

  // optional bytes save_game_key = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_save_game_key(), target);
  }

  // optional uint32 gc_socache_file_version = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_gc_socache_file_version(), target);
  }

  // optional string txn_country_code = 10;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_txn_country_code().data(), static_cast<int>(this->_internal_txn_country_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgClientWelcome.txn_country_code");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_txn_country_code(), target);
  }

  // optional bytes game_data2 = 11;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_game_data2(), target);
  }

  // optional uint32 rtime32_gc_welcome_timestamp = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_rtime32_gc_welcome_timestamp(), target);
  }

  // optional uint32 currency = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_currency(), target);
  }

  // optional uint32 balance = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_balance(), target);
  }

  // optional string balance_url = 15;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_balance_url().data(), static_cast<int>(this->_internal_balance_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgClientWelcome.balance_url");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_balance_url(), target);
  }

  // optional bool has_accepted_china_ssa = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_has_accepted_china_ssa(), target);
  }

  // optional bool is_banned_steam_china = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_is_banned_steam_china(), target);
  }

  // optional .CExtraMsgBlock additional_welcome_msgs = 18;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::additional_welcome_msgs(this),
        _Internal::additional_welcome_msgs(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgSteamLearnServerInfo steam_learn_server_info = 20;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::steam_learn_server_info(this),
        _Internal::steam_learn_server_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientWelcome)
  return target;
}

size_t CMsgClientWelcome::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientWelcome)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSOCacheSubscribed outofdate_subscribed_caches = 3;
  total_size += 1UL * this->_internal_outofdate_subscribed_caches_size();
  for (const auto& msg : this->_impl_.outofdate_subscribed_caches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSOCacheSubscriptionCheck uptodate_subscribed_caches = 4;
  total_size += 1UL * this->_internal_uptodate_subscribed_caches_size();
  for (const auto& msg : this->_impl_.uptodate_subscribed_caches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes game_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_game_data());
    }

    // optional bytes save_game_key = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_save_game_key());
    }

    // optional string txn_country_code = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_txn_country_code());
    }

    // optional bytes game_data2 = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_game_data2());
    }

    // optional string balance_url = 15;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_balance_url());
    }

    // optional .CMsgClientWelcome.Location location = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.location_);
    }

    // optional .CExtraMsgBlock additional_welcome_msgs = 18;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.additional_welcome_msgs_);
    }

    // optional .CMsgSteamLearnServerInfo steam_learn_server_info = 20;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.steam_learn_server_info_);
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional uint32 version = 1;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional uint32 gc_socache_file_version = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gc_socache_file_version());
    }

    // optional uint32 rtime32_gc_welcome_timestamp = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtime32_gc_welcome_timestamp());
    }

    // optional uint32 currency = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_currency());
    }

    // optional uint32 balance = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_balance());
    }

    // optional bool has_accepted_china_ssa = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool is_banned_steam_china = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientWelcome::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientWelcome::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientWelcome::GetClassData() const { return &_class_data_; }


void CMsgClientWelcome::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientWelcome*>(&to_msg);
  auto& from = static_cast<const CMsgClientWelcome&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientWelcome)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.outofdate_subscribed_caches_.MergeFrom(from._impl_.outofdate_subscribed_caches_);
  _this->_impl_.uptodate_subscribed_caches_.MergeFrom(from._impl_.uptodate_subscribed_caches_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_game_data(from._internal_game_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_save_game_key(from._internal_save_game_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_txn_country_code(from._internal_txn_country_code());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_game_data2(from._internal_game_data2());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_balance_url(from._internal_balance_url());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_location()->::CMsgClientWelcome_Location::MergeFrom(
          from._internal_location());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_additional_welcome_msgs()->::CExtraMsgBlock::MergeFrom(
          from._internal_additional_welcome_msgs());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_steam_learn_server_info()->::CMsgSteamLearnServerInfo::MergeFrom(
          from._internal_steam_learn_server_info());
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.gc_socache_file_version_ = from._impl_.gc_socache_file_version_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.rtime32_gc_welcome_timestamp_ = from._impl_.rtime32_gc_welcome_timestamp_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.currency_ = from._impl_.currency_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.balance_ = from._impl_.balance_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.has_accepted_china_ssa_ = from._impl_.has_accepted_china_ssa_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.is_banned_steam_china_ = from._impl_.is_banned_steam_china_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientWelcome::CopyFrom(const CMsgClientWelcome& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientWelcome)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientWelcome::IsInitialized() const {
  return true;
}

void CMsgClientWelcome::InternalSwap(CMsgClientWelcome* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.outofdate_subscribed_caches_.InternalSwap(&other->_impl_.outofdate_subscribed_caches_);
  _impl_.uptodate_subscribed_caches_.InternalSwap(&other->_impl_.uptodate_subscribed_caches_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_data_, lhs_arena,
      &other->_impl_.game_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.save_game_key_, lhs_arena,
      &other->_impl_.save_game_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.txn_country_code_, lhs_arena,
      &other->_impl_.txn_country_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_data2_, lhs_arena,
      &other->_impl_.game_data2_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.balance_url_, lhs_arena,
      &other->_impl_.balance_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientWelcome, _impl_.is_banned_steam_china_)
      + sizeof(CMsgClientWelcome::_impl_.is_banned_steam_china_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientWelcome, _impl_.location_)>(
          reinterpret_cast<char*>(&_impl_.location_),
          reinterpret_cast<char*>(&other->_impl_.location_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientWelcome::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[35]);
}

// ===================================================================

class CMsgConnectionStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgConnectionStatus>()._impl_._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_session_need(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_queue_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_queue_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_wait_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_estimated_wait_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CMsgConnectionStatus::CMsgConnectionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgConnectionStatus)
}
CMsgConnectionStatus::CMsgConnectionStatus(const CMsgConnectionStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgConnectionStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){}
    , decltype(_impl_.client_session_need_){}
    , decltype(_impl_.queue_position_){}
    , decltype(_impl_.queue_size_){}
    , decltype(_impl_.wait_seconds_){}
    , decltype(_impl_.estimated_wait_seconds_remaining_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.status_, &from._impl_.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.estimated_wait_seconds_remaining_) -
    reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.estimated_wait_seconds_remaining_));
  // @@protoc_insertion_point(copy_constructor:CMsgConnectionStatus)
}

inline void CMsgConnectionStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.client_session_need_){0u}
    , decltype(_impl_.queue_position_){0}
    , decltype(_impl_.queue_size_){0}
    , decltype(_impl_.wait_seconds_){0}
    , decltype(_impl_.estimated_wait_seconds_remaining_){0}
  };
}

CMsgConnectionStatus::~CMsgConnectionStatus() {
  // @@protoc_insertion_point(destructor:CMsgConnectionStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgConnectionStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgConnectionStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgConnectionStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgConnectionStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.estimated_wait_seconds_remaining_) -
        reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.estimated_wait_seconds_remaining_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgConnectionStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .GCConnectionStatus status = 1 [default = GCConnectionStatus_HAVE_SESSION];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::GCConnectionStatus_IsValid(val))) {
            _internal_set_status(static_cast<::GCConnectionStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_session_need = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_client_session_need(&has_bits);
          _impl_.client_session_need_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 queue_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_queue_position(&has_bits);
          _impl_.queue_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 queue_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_queue_size(&has_bits);
          _impl_.queue_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 wait_seconds = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_wait_seconds(&has_bits);
          _impl_.wait_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 estimated_wait_seconds_remaining = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_estimated_wait_seconds_remaining(&has_bits);
          _impl_.estimated_wait_seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgConnectionStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgConnectionStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .GCConnectionStatus status = 1 [default = GCConnectionStatus_HAVE_SESSION];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  // optional uint32 client_session_need = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_client_session_need(), target);
  }

  // optional int32 queue_position = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_queue_position(), target);
  }

  // optional int32 queue_size = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_queue_size(), target);
  }

  // optional int32 wait_seconds = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_wait_seconds(), target);
  }

  // optional int32 estimated_wait_seconds_remaining = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_estimated_wait_seconds_remaining(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgConnectionStatus)
  return target;
}

size_t CMsgConnectionStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgConnectionStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .GCConnectionStatus status = 1 [default = GCConnectionStatus_HAVE_SESSION];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional uint32 client_session_need = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_session_need());
    }

    // optional int32 queue_position = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_queue_position());
    }

    // optional int32 queue_size = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_queue_size());
    }

    // optional int32 wait_seconds = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_wait_seconds());
    }

    // optional int32 estimated_wait_seconds_remaining = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_estimated_wait_seconds_remaining());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgConnectionStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgConnectionStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgConnectionStatus::GetClassData() const { return &_class_data_; }


void CMsgConnectionStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgConnectionStatus*>(&to_msg);
  auto& from = static_cast<const CMsgConnectionStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgConnectionStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.client_session_need_ = from._impl_.client_session_need_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.queue_position_ = from._impl_.queue_position_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.queue_size_ = from._impl_.queue_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.wait_seconds_ = from._impl_.wait_seconds_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.estimated_wait_seconds_remaining_ = from._impl_.estimated_wait_seconds_remaining_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgConnectionStatus::CopyFrom(const CMsgConnectionStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgConnectionStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgConnectionStatus::IsInitialized() const {
  return true;
}

void CMsgConnectionStatus::InternalSwap(CMsgConnectionStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgConnectionStatus, _impl_.estimated_wait_seconds_remaining_)
      + sizeof(CMsgConnectionStatus::_impl_.estimated_wait_seconds_remaining_)
      - PROTOBUF_FIELD_OFFSET(CMsgConnectionStatus, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgConnectionStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[36]);
}

// ===================================================================

class CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions>()._impl_._has_bits_);
  static void set_has_service_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions)
}
CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions(const CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.version_){}
    , decltype(_impl_.service_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.service_id_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions)
}

inline void CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.version_){uint64_t{0u}}
    , decltype(_impl_.service_id_){0u}
  };
}

CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::~CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.service_id_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 service_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_service_id(&has_bits);
          _impl_.service_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 service_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_service_id(), target);
  }

  // optional uint64 version = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions)
  return target;
}

size_t CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 version = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_version());
    }

    // optional uint32 service_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_service_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::GetClassData() const { return &_class_data_; }


void CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.service_id_ = from._impl_.service_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::CopyFrom(const CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::IsInitialized() const {
  return true;
}

void CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::InternalSwap(CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions, _impl_.service_id_)
      + sizeof(CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::_impl_.service_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions, _impl_.version_)>(
          reinterpret_cast<char*>(&_impl_.version_),
          reinterpret_cast<char*>(&other->_impl_.version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[37]);
}

// ===================================================================

class CMsgGCToGCSOCacheSubscribe::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCSOCacheSubscribe>()._impl_._has_bits_);
  static void set_has_subscriber(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_subscribe_to_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sync_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_subscribe_to_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgGCToGCSOCacheSubscribe::CMsgGCToGCSOCacheSubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCSOCacheSubscribe)
}
CMsgGCToGCSOCacheSubscribe::CMsgGCToGCSOCacheSubscribe(const CMsgGCToGCSOCacheSubscribe& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCSOCacheSubscribe* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.have_versions_){from._impl_.have_versions_}
    , decltype(_impl_.subscriber_){}
    , decltype(_impl_.subscribe_to_id_){}
    , decltype(_impl_.sync_version_){}
    , decltype(_impl_.subscribe_to_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.subscriber_, &from._impl_.subscriber_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.subscribe_to_type_) -
    reinterpret_cast<char*>(&_impl_.subscriber_)) + sizeof(_impl_.subscribe_to_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCSOCacheSubscribe)
}

inline void CMsgGCToGCSOCacheSubscribe::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.have_versions_){arena}
    , decltype(_impl_.subscriber_){uint64_t{0u}}
    , decltype(_impl_.subscribe_to_id_){uint64_t{0u}}
    , decltype(_impl_.sync_version_){uint64_t{0u}}
    , decltype(_impl_.subscribe_to_type_){0u}
  };
}

CMsgGCToGCSOCacheSubscribe::~CMsgGCToGCSOCacheSubscribe() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCSOCacheSubscribe)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCSOCacheSubscribe::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.have_versions_.~RepeatedPtrField();
}

void CMsgGCToGCSOCacheSubscribe::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCSOCacheSubscribe::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCSOCacheSubscribe)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.have_versions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.subscriber_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.subscribe_to_type_) -
        reinterpret_cast<char*>(&_impl_.subscriber_)) + sizeof(_impl_.subscribe_to_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCSOCacheSubscribe::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 subscriber = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_subscriber(&has_bits);
          _impl_.subscriber_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 subscribe_to_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_subscribe_to_id(&has_bits);
          _impl_.subscribe_to_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 sync_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_sync_version(&has_bits);
          _impl_.sync_version_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions have_versions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_have_versions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 subscribe_to_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_subscribe_to_type(&has_bits);
          _impl_.subscribe_to_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCSOCacheSubscribe::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCSOCacheSubscribe)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 subscriber = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_subscriber(), target);
  }

  // optional fixed64 subscribe_to_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_subscribe_to_id(), target);
  }

  // optional fixed64 sync_version = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_sync_version(), target);
  }

  // repeated .CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions have_versions = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_have_versions_size()); i < n; i++) {
    const auto& repfield = this->_internal_have_versions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 subscribe_to_type = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_subscribe_to_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCSOCacheSubscribe)
  return target;
}

size_t CMsgGCToGCSOCacheSubscribe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCSOCacheSubscribe)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions have_versions = 4;
  total_size += 1UL * this->_internal_have_versions_size();
  for (const auto& msg : this->_impl_.have_versions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional fixed64 subscriber = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 subscribe_to_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional fixed64 sync_version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 subscribe_to_type = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_subscribe_to_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCSOCacheSubscribe::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCSOCacheSubscribe::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCSOCacheSubscribe::GetClassData() const { return &_class_data_; }


void CMsgGCToGCSOCacheSubscribe::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCSOCacheSubscribe*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCSOCacheSubscribe&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCSOCacheSubscribe)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.have_versions_.MergeFrom(from._impl_.have_versions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.subscriber_ = from._impl_.subscriber_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.subscribe_to_id_ = from._impl_.subscribe_to_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sync_version_ = from._impl_.sync_version_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.subscribe_to_type_ = from._impl_.subscribe_to_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCSOCacheSubscribe::CopyFrom(const CMsgGCToGCSOCacheSubscribe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCSOCacheSubscribe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCSOCacheSubscribe::IsInitialized() const {
  return true;
}

void CMsgGCToGCSOCacheSubscribe::InternalSwap(CMsgGCToGCSOCacheSubscribe* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.have_versions_.InternalSwap(&other->_impl_.have_versions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToGCSOCacheSubscribe, _impl_.subscribe_to_type_)
      + sizeof(CMsgGCToGCSOCacheSubscribe::_impl_.subscribe_to_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToGCSOCacheSubscribe, _impl_.subscriber_)>(
          reinterpret_cast<char*>(&_impl_.subscriber_),
          reinterpret_cast<char*>(&other->_impl_.subscriber_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCSOCacheSubscribe::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[38]);
}

// ===================================================================

class CMsgGCToGCSOCacheUnsubscribe::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCSOCacheUnsubscribe>()._impl_._has_bits_);
  static void set_has_subscriber(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_unsubscribe_from_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_unsubscribe_from_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgGCToGCSOCacheUnsubscribe::CMsgGCToGCSOCacheUnsubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCSOCacheUnsubscribe)
}
CMsgGCToGCSOCacheUnsubscribe::CMsgGCToGCSOCacheUnsubscribe(const CMsgGCToGCSOCacheUnsubscribe& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCSOCacheUnsubscribe* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subscriber_){}
    , decltype(_impl_.unsubscribe_from_id_){}
    , decltype(_impl_.unsubscribe_from_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.subscriber_, &from._impl_.subscriber_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.unsubscribe_from_type_) -
    reinterpret_cast<char*>(&_impl_.subscriber_)) + sizeof(_impl_.unsubscribe_from_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCSOCacheUnsubscribe)
}

inline void CMsgGCToGCSOCacheUnsubscribe::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subscriber_){uint64_t{0u}}
    , decltype(_impl_.unsubscribe_from_id_){uint64_t{0u}}
    , decltype(_impl_.unsubscribe_from_type_){0u}
  };
}

CMsgGCToGCSOCacheUnsubscribe::~CMsgGCToGCSOCacheUnsubscribe() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCSOCacheUnsubscribe)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCSOCacheUnsubscribe::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToGCSOCacheUnsubscribe::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCSOCacheUnsubscribe::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCSOCacheUnsubscribe)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.subscriber_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.unsubscribe_from_type_) -
        reinterpret_cast<char*>(&_impl_.subscriber_)) + sizeof(_impl_.unsubscribe_from_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCSOCacheUnsubscribe::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 subscriber = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_subscriber(&has_bits);
          _impl_.subscriber_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 unsubscribe_from_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_unsubscribe_from_id(&has_bits);
          _impl_.unsubscribe_from_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 unsubscribe_from_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_unsubscribe_from_type(&has_bits);
          _impl_.unsubscribe_from_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCSOCacheUnsubscribe::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCSOCacheUnsubscribe)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 subscriber = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_subscriber(), target);
  }

  // optional fixed64 unsubscribe_from_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_unsubscribe_from_id(), target);
  }

  // optional uint32 unsubscribe_from_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_unsubscribe_from_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCSOCacheUnsubscribe)
  return target;
}

size_t CMsgGCToGCSOCacheUnsubscribe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCSOCacheUnsubscribe)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional fixed64 subscriber = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 unsubscribe_from_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 unsubscribe_from_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unsubscribe_from_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCSOCacheUnsubscribe::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCSOCacheUnsubscribe::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCSOCacheUnsubscribe::GetClassData() const { return &_class_data_; }


void CMsgGCToGCSOCacheUnsubscribe::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCSOCacheUnsubscribe*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCSOCacheUnsubscribe&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCSOCacheUnsubscribe)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.subscriber_ = from._impl_.subscriber_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.unsubscribe_from_id_ = from._impl_.unsubscribe_from_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.unsubscribe_from_type_ = from._impl_.unsubscribe_from_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCSOCacheUnsubscribe::CopyFrom(const CMsgGCToGCSOCacheUnsubscribe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCSOCacheUnsubscribe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCSOCacheUnsubscribe::IsInitialized() const {
  return true;
}

void CMsgGCToGCSOCacheUnsubscribe::InternalSwap(CMsgGCToGCSOCacheUnsubscribe* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToGCSOCacheUnsubscribe, _impl_.unsubscribe_from_type_)
      + sizeof(CMsgGCToGCSOCacheUnsubscribe::_impl_.unsubscribe_from_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToGCSOCacheUnsubscribe, _impl_.subscriber_)>(
          reinterpret_cast<char*>(&_impl_.subscriber_),
          reinterpret_cast<char*>(&other->_impl_.subscriber_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCSOCacheUnsubscribe::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[39]);
}

// ===================================================================

class CMsgGCClientPing::_Internal {
 public:
};

CMsgGCClientPing::CMsgGCClientPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgGCClientPing)
}
CMsgGCClientPing::CMsgGCClientPing(const CMsgGCClientPing& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgGCClientPing* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCClientPing)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCClientPing::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCClientPing::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCClientPing::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[40]);
}

// ===================================================================

class CMsgGCToGCForwardAccountDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCForwardAccountDetails>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CGCSystemMsg_GetAccountDetails_Response& account_details(const CMsgGCToGCForwardAccountDetails* msg);
  static void set_has_account_details(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_age_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CGCSystemMsg_GetAccountDetails_Response&
CMsgGCToGCForwardAccountDetails::_Internal::account_details(const CMsgGCToGCForwardAccountDetails* msg) {
  return *msg->_impl_.account_details_;
}
void CMsgGCToGCForwardAccountDetails::clear_account_details() {
  if (_impl_.account_details_ != nullptr) _impl_.account_details_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgGCToGCForwardAccountDetails::CMsgGCToGCForwardAccountDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCForwardAccountDetails)
}
CMsgGCToGCForwardAccountDetails::CMsgGCToGCForwardAccountDetails(const CMsgGCToGCForwardAccountDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCForwardAccountDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_details_){nullptr}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.age_seconds_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_account_details()) {
    _this->_impl_.account_details_ = new ::CGCSystemMsg_GetAccountDetails_Response(*from._impl_.account_details_);
  }
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.age_seconds_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.age_seconds_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCForwardAccountDetails)
}

inline void CMsgGCToGCForwardAccountDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_details_){nullptr}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.age_seconds_){0u}
  };
}

CMsgGCToGCForwardAccountDetails::~CMsgGCToGCForwardAccountDetails() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCForwardAccountDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCForwardAccountDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.account_details_;
}

void CMsgGCToGCForwardAccountDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCForwardAccountDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCForwardAccountDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.account_details_ != nullptr);
    _impl_.account_details_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.age_seconds_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.age_seconds_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCForwardAccountDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CGCSystemMsg_GetAccountDetails_Response account_details = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_account_details(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 age_seconds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_age_seconds(&has_bits);
          _impl_.age_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCForwardAccountDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCForwardAccountDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional .CGCSystemMsg_GetAccountDetails_Response account_details = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::account_details(this),
        _Internal::account_details(this).GetCachedSize(), target, stream);
  }

  // optional uint32 age_seconds = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_age_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCForwardAccountDetails)
  return target;
}

size_t CMsgGCToGCForwardAccountDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCForwardAccountDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CGCSystemMsg_GetAccountDetails_Response account_details = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.account_details_);
    }

    // optional fixed64 steamid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 age_seconds = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_age_seconds());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCForwardAccountDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCForwardAccountDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCForwardAccountDetails::GetClassData() const { return &_class_data_; }


void CMsgGCToGCForwardAccountDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCForwardAccountDetails*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCForwardAccountDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCForwardAccountDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_account_details()->::CGCSystemMsg_GetAccountDetails_Response::MergeFrom(
          from._internal_account_details());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.age_seconds_ = from._impl_.age_seconds_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCForwardAccountDetails::CopyFrom(const CMsgGCToGCForwardAccountDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCForwardAccountDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCForwardAccountDetails::IsInitialized() const {
  return true;
}

void CMsgGCToGCForwardAccountDetails::InternalSwap(CMsgGCToGCForwardAccountDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToGCForwardAccountDetails, _impl_.age_seconds_)
      + sizeof(CMsgGCToGCForwardAccountDetails::_impl_.age_seconds_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToGCForwardAccountDetails, _impl_.account_details_)>(
          reinterpret_cast<char*>(&_impl_.account_details_),
          reinterpret_cast<char*>(&other->_impl_.account_details_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCForwardAccountDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[41]);
}

// ===================================================================

class CMsgGCToGCLoadSessionSOCache::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCLoadSessionSOCache>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgGCToGCForwardAccountDetails& forward_account_details(const CMsgGCToGCLoadSessionSOCache* msg);
  static void set_has_forward_account_details(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgGCToGCForwardAccountDetails&
CMsgGCToGCLoadSessionSOCache::_Internal::forward_account_details(const CMsgGCToGCLoadSessionSOCache* msg) {
  return *msg->_impl_.forward_account_details_;
}
CMsgGCToGCLoadSessionSOCache::CMsgGCToGCLoadSessionSOCache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCLoadSessionSOCache)
}
CMsgGCToGCLoadSessionSOCache::CMsgGCToGCLoadSessionSOCache(const CMsgGCToGCLoadSessionSOCache& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCLoadSessionSOCache* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.forward_account_details_){nullptr}
    , decltype(_impl_.account_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_forward_account_details()) {
    _this->_impl_.forward_account_details_ = new ::CMsgGCToGCForwardAccountDetails(*from._impl_.forward_account_details_);
  }
  _this->_impl_.account_id_ = from._impl_.account_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCLoadSessionSOCache)
}

inline void CMsgGCToGCLoadSessionSOCache::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.forward_account_details_){nullptr}
    , decltype(_impl_.account_id_){0u}
  };
}

CMsgGCToGCLoadSessionSOCache::~CMsgGCToGCLoadSessionSOCache() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCLoadSessionSOCache)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCLoadSessionSOCache::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.forward_account_details_;
}

void CMsgGCToGCLoadSessionSOCache::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCLoadSessionSOCache::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCLoadSessionSOCache)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.forward_account_details_ != nullptr);
    _impl_.forward_account_details_->Clear();
  }
  _impl_.account_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCLoadSessionSOCache::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgGCToGCForwardAccountDetails forward_account_details = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_forward_account_details(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCLoadSessionSOCache::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCLoadSessionSOCache)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional .CMsgGCToGCForwardAccountDetails forward_account_details = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::forward_account_details(this),
        _Internal::forward_account_details(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCLoadSessionSOCache)
  return target;
}

size_t CMsgGCToGCLoadSessionSOCache::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCLoadSessionSOCache)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgGCToGCForwardAccountDetails forward_account_details = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.forward_account_details_);
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCLoadSessionSOCache::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCLoadSessionSOCache::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCLoadSessionSOCache::GetClassData() const { return &_class_data_; }


void CMsgGCToGCLoadSessionSOCache::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCLoadSessionSOCache*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCLoadSessionSOCache&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCLoadSessionSOCache)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_forward_account_details()->::CMsgGCToGCForwardAccountDetails::MergeFrom(
          from._internal_forward_account_details());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCLoadSessionSOCache::CopyFrom(const CMsgGCToGCLoadSessionSOCache& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCLoadSessionSOCache)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCLoadSessionSOCache::IsInitialized() const {
  return true;
}

void CMsgGCToGCLoadSessionSOCache::InternalSwap(CMsgGCToGCLoadSessionSOCache* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToGCLoadSessionSOCache, _impl_.account_id_)
      + sizeof(CMsgGCToGCLoadSessionSOCache::_impl_.account_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToGCLoadSessionSOCache, _impl_.forward_account_details_)>(
          reinterpret_cast<char*>(&_impl_.forward_account_details_),
          reinterpret_cast<char*>(&other->_impl_.forward_account_details_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCLoadSessionSOCache::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[42]);
}

// ===================================================================

class CMsgGCToGCLoadSessionSOCacheResponse::_Internal {
 public:
};

CMsgGCToGCLoadSessionSOCacheResponse::CMsgGCToGCLoadSessionSOCacheResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCLoadSessionSOCacheResponse)
}
CMsgGCToGCLoadSessionSOCacheResponse::CMsgGCToGCLoadSessionSOCacheResponse(const CMsgGCToGCLoadSessionSOCacheResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgGCToGCLoadSessionSOCacheResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCLoadSessionSOCacheResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCLoadSessionSOCacheResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCLoadSessionSOCacheResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCLoadSessionSOCacheResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[43]);
}

// ===================================================================

class CMsgGCToGCUpdateSessionStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCUpdateSessionStats>()._impl_._has_bits_);
  static void set_has_user_sessions(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_server_sessions(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_in_logon_surge(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgGCToGCUpdateSessionStats::CMsgGCToGCUpdateSessionStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCUpdateSessionStats)
}
CMsgGCToGCUpdateSessionStats::CMsgGCToGCUpdateSessionStats(const CMsgGCToGCUpdateSessionStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCUpdateSessionStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_sessions_){}
    , decltype(_impl_.server_sessions_){}
    , decltype(_impl_.in_logon_surge_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.user_sessions_, &from._impl_.user_sessions_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.in_logon_surge_) -
    reinterpret_cast<char*>(&_impl_.user_sessions_)) + sizeof(_impl_.in_logon_surge_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCUpdateSessionStats)
}

inline void CMsgGCToGCUpdateSessionStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_sessions_){0u}
    , decltype(_impl_.server_sessions_){0u}
    , decltype(_impl_.in_logon_surge_){false}
  };
}

CMsgGCToGCUpdateSessionStats::~CMsgGCToGCUpdateSessionStats() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCUpdateSessionStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCUpdateSessionStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToGCUpdateSessionStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCUpdateSessionStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCUpdateSessionStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.user_sessions_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.in_logon_surge_) -
        reinterpret_cast<char*>(&_impl_.user_sessions_)) + sizeof(_impl_.in_logon_surge_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCUpdateSessionStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 user_sessions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_sessions(&has_bits);
          _impl_.user_sessions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_sessions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_server_sessions(&has_bits);
          _impl_.server_sessions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool in_logon_surge = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_in_logon_surge(&has_bits);
          _impl_.in_logon_surge_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCUpdateSessionStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCUpdateSessionStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 user_sessions = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_sessions(), target);
  }

  // optional uint32 server_sessions = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_server_sessions(), target);
  }

  // optional bool in_logon_surge = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_in_logon_surge(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCUpdateSessionStats)
  return target;
}

size_t CMsgGCToGCUpdateSessionStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCUpdateSessionStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 user_sessions = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_sessions());
    }

    // optional uint32 server_sessions = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_sessions());
    }

    // optional bool in_logon_surge = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCUpdateSessionStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCUpdateSessionStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCUpdateSessionStats::GetClassData() const { return &_class_data_; }


void CMsgGCToGCUpdateSessionStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCUpdateSessionStats*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCUpdateSessionStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCUpdateSessionStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.user_sessions_ = from._impl_.user_sessions_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.server_sessions_ = from._impl_.server_sessions_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.in_logon_surge_ = from._impl_.in_logon_surge_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCUpdateSessionStats::CopyFrom(const CMsgGCToGCUpdateSessionStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCUpdateSessionStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCUpdateSessionStats::IsInitialized() const {
  return true;
}

void CMsgGCToGCUpdateSessionStats::InternalSwap(CMsgGCToGCUpdateSessionStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToGCUpdateSessionStats, _impl_.in_logon_surge_)
      + sizeof(CMsgGCToGCUpdateSessionStats::_impl_.in_logon_surge_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToGCUpdateSessionStats, _impl_.user_sessions_)>(
          reinterpret_cast<char*>(&_impl_.user_sessions_),
          reinterpret_cast<char*>(&other->_impl_.user_sessions_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCUpdateSessionStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[44]);
}

// ===================================================================

class CMsgGCToClientRequestDropped::_Internal {
 public:
};

CMsgGCToClientRequestDropped::CMsgGCToClientRequestDropped(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgGCToClientRequestDropped)
}
CMsgGCToClientRequestDropped::CMsgGCToClientRequestDropped(const CMsgGCToClientRequestDropped& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgGCToClientRequestDropped* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCToClientRequestDropped)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToClientRequestDropped::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToClientRequestDropped::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToClientRequestDropped::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[45]);
}

// ===================================================================

class CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription>()._impl_._has_bits_);
  static void set_has_gameitemid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
}
CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription(const CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_description_){}
    , decltype(_impl_.gameitemid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.item_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_item_description()) {
    _this->_impl_.item_description_.Set(from._internal_item_description(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.gameitemid_ = from._impl_.gameitemid_;
  // @@protoc_insertion_point(copy_constructor:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
}

inline void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_description_){}
    , decltype(_impl_.gameitemid_){0u}
  };
  _impl_.item_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.item_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::~CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription() {
  // @@protoc_insertion_point(destructor:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.item_description_.Destroy();
}

void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.item_description_.ClearNonDefaultToEmpty();
  }
  _impl_.gameitemid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gameitemid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameitemid(&has_bits);
          _impl_.gameitemid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string item_description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_item_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.item_description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gameitemid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gameitemid(), target);
  }

  // optional string item_description = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_item_description().data(), static_cast<int>(this->_internal_item_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.item_description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_item_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  return target;
}

size_t CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string item_description = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_item_description());
    }

    // optional uint32 gameitemid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gameitemid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::GetClassData() const { return &_class_data_; }


void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription*>(&to_msg);
  auto& from = static_cast<const CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_item_description(from._internal_item_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gameitemid_ = from._impl_.gameitemid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::CopyFrom(const CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::IsInitialized() const {
  return true;
}

void CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::InternalSwap(CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.item_description_, lhs_arena,
      &other->_impl_.item_description_, rhs_arena
  );
  swap(_impl_.gameitemid_, other->_impl_.gameitemid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[46]);
}

// ===================================================================

class CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock>()._impl_._has_bits_);
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
}
CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock(const CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.descriptions_){from._impl_.descriptions_}
    , decltype(_impl_.language_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
}

inline void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.descriptions_){arena}
    , decltype(_impl_.language_){}
  };
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::~CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock() {
  // @@protoc_insertion_point(destructor:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.descriptions_.~RepeatedPtrField();
  _impl_.language_.Destroy();
}

void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.descriptions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.language_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string language = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.language");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_descriptions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string language = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.language");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_language(), target);
  }

  // repeated .CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_descriptions_size()); i < n; i++) {
    const auto& repfield = this->_internal_descriptions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  return target;
}

size_t CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions = 2;
  total_size += 1UL * this->_internal_descriptions_size();
  for (const auto& msg : this->_impl_.descriptions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string language = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::GetClassData() const { return &_class_data_; }


void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock*>(&to_msg);
  auto& from = static_cast<const CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.descriptions_.MergeFrom(from._impl_.descriptions_);
  if (from._internal_has_language()) {
    _this->_internal_set_language(from._internal_language());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::CopyFrom(const CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::IsInitialized() const {
  return true;
}

void CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::InternalSwap(CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.descriptions_.InternalSwap(&other->_impl_.descriptions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[47]);
}

// ===================================================================

class CWorkshop_PopulateItemDescriptions_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_PopulateItemDescriptions_Request>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CWorkshop_PopulateItemDescriptions_Request::CWorkshop_PopulateItemDescriptions_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_PopulateItemDescriptions_Request)
}
CWorkshop_PopulateItemDescriptions_Request::CWorkshop_PopulateItemDescriptions_Request(const CWorkshop_PopulateItemDescriptions_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CWorkshop_PopulateItemDescriptions_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.languages_){from._impl_.languages_}
    , decltype(_impl_.appid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.appid_ = from._impl_.appid_;
  // @@protoc_insertion_point(copy_constructor:CWorkshop_PopulateItemDescriptions_Request)
}

inline void CWorkshop_PopulateItemDescriptions_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.languages_){arena}
    , decltype(_impl_.appid_){0u}
  };
}

CWorkshop_PopulateItemDescriptions_Request::~CWorkshop_PopulateItemDescriptions_Request() {
  // @@protoc_insertion_point(destructor:CWorkshop_PopulateItemDescriptions_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_PopulateItemDescriptions_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.languages_.~RepeatedPtrField();
}

void CWorkshop_PopulateItemDescriptions_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_PopulateItemDescriptions_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_PopulateItemDescriptions_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.languages_.Clear();
  _impl_.appid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CWorkshop_PopulateItemDescriptions_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_languages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_PopulateItemDescriptions_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_PopulateItemDescriptions_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // repeated .CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_languages_size()); i < n; i++) {
    const auto& repfield = this->_internal_languages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_PopulateItemDescriptions_Request)
  return target;
}

size_t CWorkshop_PopulateItemDescriptions_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_PopulateItemDescriptions_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages = 2;
  total_size += 1UL * this->_internal_languages_size();
  for (const auto& msg : this->_impl_.languages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 appid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CWorkshop_PopulateItemDescriptions_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CWorkshop_PopulateItemDescriptions_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CWorkshop_PopulateItemDescriptions_Request::GetClassData() const { return &_class_data_; }


void CWorkshop_PopulateItemDescriptions_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CWorkshop_PopulateItemDescriptions_Request*>(&to_msg);
  auto& from = static_cast<const CWorkshop_PopulateItemDescriptions_Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_PopulateItemDescriptions_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.languages_.MergeFrom(from._impl_.languages_);
  if (from._internal_has_appid()) {
    _this->_internal_set_appid(from._internal_appid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CWorkshop_PopulateItemDescriptions_Request::CopyFrom(const CWorkshop_PopulateItemDescriptions_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_PopulateItemDescriptions_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_PopulateItemDescriptions_Request::IsInitialized() const {
  return true;
}

void CWorkshop_PopulateItemDescriptions_Request::InternalSwap(CWorkshop_PopulateItemDescriptions_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.languages_.InternalSwap(&other->_impl_.languages_);
  swap(_impl_.appid_, other->_impl_.appid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CWorkshop_PopulateItemDescriptions_Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[48]);
}

// ===================================================================

class CWorkshop_GetContributors_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_GetContributors_Request>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gameitemid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CWorkshop_GetContributors_Request::CWorkshop_GetContributors_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_GetContributors_Request)
}
CWorkshop_GetContributors_Request::CWorkshop_GetContributors_Request(const CWorkshop_GetContributors_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CWorkshop_GetContributors_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.appid_){}
    , decltype(_impl_.gameitemid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.appid_, &from._impl_.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gameitemid_) -
    reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.gameitemid_));
  // @@protoc_insertion_point(copy_constructor:CWorkshop_GetContributors_Request)
}

inline void CWorkshop_GetContributors_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.appid_){0u}
    , decltype(_impl_.gameitemid_){0u}
  };
}

CWorkshop_GetContributors_Request::~CWorkshop_GetContributors_Request() {
  // @@protoc_insertion_point(destructor:CWorkshop_GetContributors_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_GetContributors_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CWorkshop_GetContributors_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_GetContributors_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_GetContributors_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gameitemid_) -
        reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.gameitemid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CWorkshop_GetContributors_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gameitemid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gameitemid(&has_bits);
          _impl_.gameitemid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_GetContributors_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_GetContributors_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 gameitemid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_gameitemid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_GetContributors_Request)
  return target;
}

size_t CWorkshop_GetContributors_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_GetContributors_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 gameitemid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gameitemid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CWorkshop_GetContributors_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CWorkshop_GetContributors_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CWorkshop_GetContributors_Request::GetClassData() const { return &_class_data_; }


void CWorkshop_GetContributors_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CWorkshop_GetContributors_Request*>(&to_msg);
  auto& from = static_cast<const CWorkshop_GetContributors_Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_GetContributors_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gameitemid_ = from._impl_.gameitemid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CWorkshop_GetContributors_Request::CopyFrom(const CWorkshop_GetContributors_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_GetContributors_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_GetContributors_Request::IsInitialized() const {
  return true;
}

void CWorkshop_GetContributors_Request::InternalSwap(CWorkshop_GetContributors_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CWorkshop_GetContributors_Request, _impl_.gameitemid_)
      + sizeof(CWorkshop_GetContributors_Request::_impl_.gameitemid_)
      - PROTOBUF_FIELD_OFFSET(CWorkshop_GetContributors_Request, _impl_.appid_)>(
          reinterpret_cast<char*>(&_impl_.appid_),
          reinterpret_cast<char*>(&other->_impl_.appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CWorkshop_GetContributors_Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[49]);
}

// ===================================================================

class CWorkshop_GetContributors_Response::_Internal {
 public:
};

CWorkshop_GetContributors_Response::CWorkshop_GetContributors_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_GetContributors_Response)
}
CWorkshop_GetContributors_Response::CWorkshop_GetContributors_Response(const CWorkshop_GetContributors_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CWorkshop_GetContributors_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contributors_){from._impl_.contributors_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CWorkshop_GetContributors_Response)
}

inline void CWorkshop_GetContributors_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contributors_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CWorkshop_GetContributors_Response::~CWorkshop_GetContributors_Response() {
  // @@protoc_insertion_point(destructor:CWorkshop_GetContributors_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_GetContributors_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contributors_.~RepeatedField();
}

void CWorkshop_GetContributors_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_GetContributors_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_GetContributors_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contributors_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CWorkshop_GetContributors_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated fixed64 contributors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_contributors(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_contributors(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_GetContributors_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_GetContributors_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated fixed64 contributors = 1;
  for (int i = 0, n = this->_internal_contributors_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_contributors(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_GetContributors_Response)
  return target;
}

size_t CWorkshop_GetContributors_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_GetContributors_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 contributors = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_contributors_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_contributors_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CWorkshop_GetContributors_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CWorkshop_GetContributors_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CWorkshop_GetContributors_Response::GetClassData() const { return &_class_data_; }


void CWorkshop_GetContributors_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CWorkshop_GetContributors_Response*>(&to_msg);
  auto& from = static_cast<const CWorkshop_GetContributors_Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_GetContributors_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.contributors_.MergeFrom(from._impl_.contributors_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CWorkshop_GetContributors_Response::CopyFrom(const CWorkshop_GetContributors_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_GetContributors_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_GetContributors_Response::IsInitialized() const {
  return true;
}

void CWorkshop_GetContributors_Response::InternalSwap(CWorkshop_GetContributors_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.contributors_.InternalSwap(&other->_impl_.contributors_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CWorkshop_GetContributors_Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[50]);
}

// ===================================================================

class CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule>()._impl_._has_bits_);
  static void set_has_workshop_file_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_revenue_percentage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rule_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rule_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
}
CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule(const CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_description_){}
    , decltype(_impl_.workshop_file_id_){}
    , decltype(_impl_.revenue_percentage_){}
    , decltype(_impl_.rule_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.rule_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rule_description()) {
    _this->_impl_.rule_description_.Set(from._internal_rule_description(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.workshop_file_id_, &from._impl_.workshop_file_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rule_type_) -
    reinterpret_cast<char*>(&_impl_.workshop_file_id_)) + sizeof(_impl_.rule_type_));
  // @@protoc_insertion_point(copy_constructor:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
}

inline void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_description_){}
    , decltype(_impl_.workshop_file_id_){uint64_t{0u}}
    , decltype(_impl_.revenue_percentage_){0}
    , decltype(_impl_.rule_type_){1u}
  };
  _impl_.rule_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::~CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule() {
  // @@protoc_insertion_point(destructor:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rule_description_.Destroy();
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.rule_description_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.workshop_file_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.revenue_percentage_) -
        reinterpret_cast<char*>(&_impl_.workshop_file_id_)) + sizeof(_impl_.revenue_percentage_));
    _impl_.rule_type_ = 1u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 workshop_file_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_workshop_file_id(&has_bits);
          _impl_.workshop_file_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float revenue_percentage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_revenue_percentage(&has_bits);
          _impl_.revenue_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string rule_description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rule_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.rule_description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rule_type = 4 [default = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rule_type(&has_bits);
          _impl_.rule_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 workshop_file_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_workshop_file_id(), target);
  }

  // optional float revenue_percentage = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_revenue_percentage(), target);
  }

  // optional string rule_description = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_rule_description().data(), static_cast<int>(this->_internal_rule_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.rule_description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_rule_description(), target);
  }

  // optional uint32 rule_type = 4 [default = 1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_rule_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  return target;
}

size_t CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string rule_description = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rule_description());
    }

    // optional uint64 workshop_file_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_workshop_file_id());
    }

    // optional float revenue_percentage = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 rule_type = 4 [default = 1];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rule_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::GetClassData() const { return &_class_data_; }


void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule*>(&to_msg);
  auto& from = static_cast<const CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_rule_description(from._internal_rule_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.workshop_file_id_ = from._impl_.workshop_file_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.revenue_percentage_ = from._impl_.revenue_percentage_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rule_type_ = from._impl_.rule_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::CopyFrom(const CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::IsInitialized() const {
  return true;
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::InternalSwap(CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rule_description_, lhs_arena,
      &other->_impl_.rule_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule, _impl_.revenue_percentage_)
      + sizeof(CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::_impl_.revenue_percentage_)
      - PROTOBUF_FIELD_OFFSET(CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule, _impl_.workshop_file_id_)>(
          reinterpret_cast<char*>(&_impl_.workshop_file_id_),
          reinterpret_cast<char*>(&other->_impl_.workshop_file_id_));
  swap(_impl_.rule_type_, other->_impl_.rule_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[51]);
}

// ===================================================================

class CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule>()._impl_._has_bits_);
  static void set_has_workshop_file_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rule_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
}
CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule(const CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_description_){}
    , decltype(_impl_.workshop_file_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.rule_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rule_description()) {
    _this->_impl_.rule_description_.Set(from._internal_rule_description(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.workshop_file_id_ = from._impl_.workshop_file_id_;
  // @@protoc_insertion_point(copy_constructor:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
}

inline void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_description_){}
    , decltype(_impl_.workshop_file_id_){uint64_t{0u}}
  };
  _impl_.rule_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::~CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule() {
  // @@protoc_insertion_point(destructor:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rule_description_.Destroy();
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.rule_description_.ClearNonDefaultToEmpty();
  }
  _impl_.workshop_file_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 workshop_file_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_workshop_file_id(&has_bits);
          _impl_.workshop_file_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string rule_description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_rule_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.rule_description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 workshop_file_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_workshop_file_id(), target);
  }

  // optional string rule_description = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_rule_description().data(), static_cast<int>(this->_internal_rule_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.rule_description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_rule_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  return target;
}

size_t CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string rule_description = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rule_description());
    }

    // optional uint64 workshop_file_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_workshop_file_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::GetClassData() const { return &_class_data_; }


void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule*>(&to_msg);
  auto& from = static_cast<const CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_rule_description(from._internal_rule_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.workshop_file_id_ = from._impl_.workshop_file_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::CopyFrom(const CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::IsInitialized() const {
  return true;
}

void CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::InternalSwap(CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rule_description_, lhs_arena,
      &other->_impl_.rule_description_, rhs_arena
  );
  swap(_impl_.workshop_file_id_, other->_impl_.workshop_file_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[52]);
}

// ===================================================================

class CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_revenue_percentage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rule_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
}
CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule(const CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_description_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.revenue_percentage_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.rule_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rule_description()) {
    _this->_impl_.rule_description_.Set(from._internal_rule_description(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.revenue_percentage_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.revenue_percentage_));
  // @@protoc_insertion_point(copy_constructor:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
}

inline void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_description_){}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.revenue_percentage_){0}
  };
  _impl_.rule_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::~CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule() {
  // @@protoc_insertion_point(destructor:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rule_description_.Destroy();
}

void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.rule_description_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.revenue_percentage_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.revenue_percentage_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float revenue_percentage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_revenue_percentage(&has_bits);
          _impl_.revenue_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string rule_description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rule_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.rule_description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional float revenue_percentage = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_revenue_percentage(), target);
  }

  // optional string rule_description = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_rule_description().data(), static_cast<int>(this->_internal_rule_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.rule_description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_rule_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  return target;
}

size_t CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string rule_description = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rule_description());
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional float revenue_percentage = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::GetClassData() const { return &_class_data_; }


void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule*>(&to_msg);
  auto& from = static_cast<const CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_rule_description(from._internal_rule_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.revenue_percentage_ = from._impl_.revenue_percentage_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::CopyFrom(const CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::IsInitialized() const {
  return true;
}

void CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::InternalSwap(CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rule_description_, lhs_arena,
      &other->_impl_.rule_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule, _impl_.revenue_percentage_)
      + sizeof(CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::_impl_.revenue_percentage_)
      - PROTOBUF_FIELD_OFFSET(CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[53]);
}

// ===================================================================

class CWorkshop_SetItemPaymentRules_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CWorkshop_SetItemPaymentRules_Request>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gameitemid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_validate_only(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_make_workshop_files_subscribable(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule& associated_workshop_file_for_direct_payments(const CWorkshop_SetItemPaymentRules_Request* msg);
  static void set_has_associated_workshop_file_for_direct_payments(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule&
CWorkshop_SetItemPaymentRules_Request::_Internal::associated_workshop_file_for_direct_payments(const CWorkshop_SetItemPaymentRules_Request* msg) {
  return *msg->_impl_.associated_workshop_file_for_direct_payments_;
}
CWorkshop_SetItemPaymentRules_Request::CWorkshop_SetItemPaymentRules_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_SetItemPaymentRules_Request)
}
CWorkshop_SetItemPaymentRules_Request::CWorkshop_SetItemPaymentRules_Request(const CWorkshop_SetItemPaymentRules_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CWorkshop_SetItemPaymentRules_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.associated_workshop_files_){from._impl_.associated_workshop_files_}
    , decltype(_impl_.partner_accounts_){from._impl_.partner_accounts_}
    , decltype(_impl_.associated_workshop_file_for_direct_payments_){nullptr}
    , decltype(_impl_.appid_){}
    , decltype(_impl_.gameitemid_){}
    , decltype(_impl_.validate_only_){}
    , decltype(_impl_.make_workshop_files_subscribable_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_associated_workshop_file_for_direct_payments()) {
    _this->_impl_.associated_workshop_file_for_direct_payments_ = new ::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule(*from._impl_.associated_workshop_file_for_direct_payments_);
  }
  ::memcpy(&_impl_.appid_, &from._impl_.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.make_workshop_files_subscribable_) -
    reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.make_workshop_files_subscribable_));
  // @@protoc_insertion_point(copy_constructor:CWorkshop_SetItemPaymentRules_Request)
}

inline void CWorkshop_SetItemPaymentRules_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.associated_workshop_files_){arena}
    , decltype(_impl_.partner_accounts_){arena}
    , decltype(_impl_.associated_workshop_file_for_direct_payments_){nullptr}
    , decltype(_impl_.appid_){0u}
    , decltype(_impl_.gameitemid_){0u}
    , decltype(_impl_.validate_only_){false}
    , decltype(_impl_.make_workshop_files_subscribable_){false}
  };
}

CWorkshop_SetItemPaymentRules_Request::~CWorkshop_SetItemPaymentRules_Request() {
  // @@protoc_insertion_point(destructor:CWorkshop_SetItemPaymentRules_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_SetItemPaymentRules_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.associated_workshop_files_.~RepeatedPtrField();
  _impl_.partner_accounts_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.associated_workshop_file_for_direct_payments_;
}

void CWorkshop_SetItemPaymentRules_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_SetItemPaymentRules_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_SetItemPaymentRules_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.associated_workshop_files_.Clear();
  _impl_.partner_accounts_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.associated_workshop_file_for_direct_payments_ != nullptr);
    _impl_.associated_workshop_file_for_direct_payments_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.make_workshop_files_subscribable_) -
        reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.make_workshop_files_subscribable_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CWorkshop_SetItemPaymentRules_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gameitemid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gameitemid(&has_bits);
          _impl_.gameitemid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_associated_workshop_files(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_partner_accounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool validate_only = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_validate_only(&has_bits);
          _impl_.validate_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool make_workshop_files_subscribable = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_make_workshop_files_subscribable(&has_bits);
          _impl_.make_workshop_files_subscribable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule associated_workshop_file_for_direct_payments = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_associated_workshop_file_for_direct_payments(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_SetItemPaymentRules_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_SetItemPaymentRules_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 gameitemid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_gameitemid(), target);
  }

  // repeated .CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_associated_workshop_files_size()); i < n; i++) {
    const auto& repfield = this->_internal_associated_workshop_files(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_partner_accounts_size()); i < n; i++) {
    const auto& repfield = this->_internal_partner_accounts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool validate_only = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_validate_only(), target);
  }

  // optional bool make_workshop_files_subscribable = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_make_workshop_files_subscribable(), target);
  }

  // optional .CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule associated_workshop_file_for_direct_payments = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::associated_workshop_file_for_direct_payments(this),
        _Internal::associated_workshop_file_for_direct_payments(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_SetItemPaymentRules_Request)
  return target;
}

size_t CWorkshop_SetItemPaymentRules_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_SetItemPaymentRules_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files = 3;
  total_size += 1UL * this->_internal_associated_workshop_files_size();
  for (const auto& msg : this->_impl_.associated_workshop_files_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts = 4;
  total_size += 1UL * this->_internal_partner_accounts_size();
  for (const auto& msg : this->_impl_.partner_accounts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule associated_workshop_file_for_direct_payments = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.associated_workshop_file_for_direct_payments_);
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 gameitemid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gameitemid());
    }

    // optional bool validate_only = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool make_workshop_files_subscribable = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CWorkshop_SetItemPaymentRules_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CWorkshop_SetItemPaymentRules_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CWorkshop_SetItemPaymentRules_Request::GetClassData() const { return &_class_data_; }


void CWorkshop_SetItemPaymentRules_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CWorkshop_SetItemPaymentRules_Request*>(&to_msg);
  auto& from = static_cast<const CWorkshop_SetItemPaymentRules_Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_SetItemPaymentRules_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.associated_workshop_files_.MergeFrom(from._impl_.associated_workshop_files_);
  _this->_impl_.partner_accounts_.MergeFrom(from._impl_.partner_accounts_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_associated_workshop_file_for_direct_payments()->::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule::MergeFrom(
          from._internal_associated_workshop_file_for_direct_payments());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.gameitemid_ = from._impl_.gameitemid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.validate_only_ = from._impl_.validate_only_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.make_workshop_files_subscribable_ = from._impl_.make_workshop_files_subscribable_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CWorkshop_SetItemPaymentRules_Request::CopyFrom(const CWorkshop_SetItemPaymentRules_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_SetItemPaymentRules_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_SetItemPaymentRules_Request::IsInitialized() const {
  return true;
}

void CWorkshop_SetItemPaymentRules_Request::InternalSwap(CWorkshop_SetItemPaymentRules_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.associated_workshop_files_.InternalSwap(&other->_impl_.associated_workshop_files_);
  _impl_.partner_accounts_.InternalSwap(&other->_impl_.partner_accounts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CWorkshop_SetItemPaymentRules_Request, _impl_.make_workshop_files_subscribable_)
      + sizeof(CWorkshop_SetItemPaymentRules_Request::_impl_.make_workshop_files_subscribable_)
      - PROTOBUF_FIELD_OFFSET(CWorkshop_SetItemPaymentRules_Request, _impl_.associated_workshop_file_for_direct_payments_)>(
          reinterpret_cast<char*>(&_impl_.associated_workshop_file_for_direct_payments_),
          reinterpret_cast<char*>(&other->_impl_.associated_workshop_file_for_direct_payments_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CWorkshop_SetItemPaymentRules_Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[54]);
}

// ===================================================================

class CWorkshop_SetItemPaymentRules_Response::_Internal {
 public:
};

CWorkshop_SetItemPaymentRules_Response::CWorkshop_SetItemPaymentRules_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CWorkshop_SetItemPaymentRules_Response)
}
CWorkshop_SetItemPaymentRules_Response::CWorkshop_SetItemPaymentRules_Response(const CWorkshop_SetItemPaymentRules_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CWorkshop_SetItemPaymentRules_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.validation_errors_){from._impl_.validation_errors_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CWorkshop_SetItemPaymentRules_Response)
}

inline void CWorkshop_SetItemPaymentRules_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.validation_errors_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CWorkshop_SetItemPaymentRules_Response::~CWorkshop_SetItemPaymentRules_Response() {
  // @@protoc_insertion_point(destructor:CWorkshop_SetItemPaymentRules_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CWorkshop_SetItemPaymentRules_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.validation_errors_.~RepeatedPtrField();
}

void CWorkshop_SetItemPaymentRules_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CWorkshop_SetItemPaymentRules_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CWorkshop_SetItemPaymentRules_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.validation_errors_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CWorkshop_SetItemPaymentRules_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string validation_errors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_validation_errors();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "CWorkshop_SetItemPaymentRules_Response.validation_errors");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CWorkshop_SetItemPaymentRules_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CWorkshop_SetItemPaymentRules_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string validation_errors = 1;
  for (int i = 0, n = this->_internal_validation_errors_size(); i < n; i++) {
    const auto& s = this->_internal_validation_errors(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CWorkshop_SetItemPaymentRules_Response.validation_errors");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CWorkshop_SetItemPaymentRules_Response)
  return target;
}

size_t CWorkshop_SetItemPaymentRules_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CWorkshop_SetItemPaymentRules_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string validation_errors = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.validation_errors_.size());
  for (int i = 0, n = _impl_.validation_errors_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.validation_errors_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CWorkshop_SetItemPaymentRules_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CWorkshop_SetItemPaymentRules_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CWorkshop_SetItemPaymentRules_Response::GetClassData() const { return &_class_data_; }


void CWorkshop_SetItemPaymentRules_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CWorkshop_SetItemPaymentRules_Response*>(&to_msg);
  auto& from = static_cast<const CWorkshop_SetItemPaymentRules_Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CWorkshop_SetItemPaymentRules_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.validation_errors_.MergeFrom(from._impl_.validation_errors_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CWorkshop_SetItemPaymentRules_Response::CopyFrom(const CWorkshop_SetItemPaymentRules_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CWorkshop_SetItemPaymentRules_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CWorkshop_SetItemPaymentRules_Response::IsInitialized() const {
  return true;
}

void CWorkshop_SetItemPaymentRules_Response::InternalSwap(CWorkshop_SetItemPaymentRules_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.validation_errors_.InternalSwap(&other->_impl_.validation_errors_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CWorkshop_SetItemPaymentRules_Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[55]);
}

// ===================================================================

class CCommunity_ClanAnnouncementInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CCommunity_ClanAnnouncementInfo>()._impl_._has_bits_);
  static void set_has_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_clanid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_posterid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_headline(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_posttime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_updatetime(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_commentcount(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_forum_topic_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

CCommunity_ClanAnnouncementInfo::CCommunity_ClanAnnouncementInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCommunity_ClanAnnouncementInfo)
}
CCommunity_ClanAnnouncementInfo::CCommunity_ClanAnnouncementInfo(const CCommunity_ClanAnnouncementInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCommunity_ClanAnnouncementInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tags_){from._impl_.tags_}
    , decltype(_impl_.headline_){}
    , decltype(_impl_.body_){}
    , decltype(_impl_.gid_){}
    , decltype(_impl_.clanid_){}
    , decltype(_impl_.posterid_){}
    , decltype(_impl_.posttime_){}
    , decltype(_impl_.updatetime_){}
    , decltype(_impl_.commentcount_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.forum_topic_id_){}
    , decltype(_impl_.hidden_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.headline_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.headline_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_headline()) {
    _this->_impl_.headline_.Set(from._internal_headline(), 
      _this->GetArenaForAllocation());
  }
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_body()) {
    _this->_impl_.body_.Set(from._internal_body(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.gid_, &from._impl_.gid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hidden_) -
    reinterpret_cast<char*>(&_impl_.gid_)) + sizeof(_impl_.hidden_));
  // @@protoc_insertion_point(copy_constructor:CCommunity_ClanAnnouncementInfo)
}

inline void CCommunity_ClanAnnouncementInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tags_){arena}
    , decltype(_impl_.headline_){}
    , decltype(_impl_.body_){}
    , decltype(_impl_.gid_){uint64_t{0u}}
    , decltype(_impl_.clanid_){uint64_t{0u}}
    , decltype(_impl_.posterid_){uint64_t{0u}}
    , decltype(_impl_.posttime_){0u}
    , decltype(_impl_.updatetime_){0u}
    , decltype(_impl_.commentcount_){0}
    , decltype(_impl_.language_){0}
    , decltype(_impl_.forum_topic_id_){uint64_t{0u}}
    , decltype(_impl_.hidden_){false}
  };
  _impl_.headline_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.headline_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCommunity_ClanAnnouncementInfo::~CCommunity_ClanAnnouncementInfo() {
  // @@protoc_insertion_point(destructor:CCommunity_ClanAnnouncementInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCommunity_ClanAnnouncementInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tags_.~RepeatedPtrField();
  _impl_.headline_.Destroy();
  _impl_.body_.Destroy();
}

void CCommunity_ClanAnnouncementInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCommunity_ClanAnnouncementInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CCommunity_ClanAnnouncementInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tags_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.headline_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.body_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.gid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.commentcount_) -
        reinterpret_cast<char*>(&_impl_.gid_)) + sizeof(_impl_.commentcount_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.language_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hidden_) -
        reinterpret_cast<char*>(&_impl_.language_)) + sizeof(_impl_.hidden_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCommunity_ClanAnnouncementInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 gid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gid(&has_bits);
          _impl_.gid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 clanid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_clanid(&has_bits);
          _impl_.clanid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 posterid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_posterid(&has_bits);
          _impl_.posterid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string headline = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_headline();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCommunity_ClanAnnouncementInfo.headline");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 posttime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_posttime(&has_bits);
          _impl_.posttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 updatetime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_updatetime(&has_bits);
          _impl_.updatetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string body = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCommunity_ClanAnnouncementInfo.body");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 commentcount = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_commentcount(&has_bits);
          _impl_.commentcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string tags = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_tags();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "CCommunity_ClanAnnouncementInfo.tags");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 language = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_language(&has_bits);
          _impl_.language_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hidden = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_hidden(&has_bits);
          _impl_.hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 forum_topic_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_forum_topic_id(&has_bits);
          _impl_.forum_topic_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCommunity_ClanAnnouncementInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCommunity_ClanAnnouncementInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 gid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_gid(), target);
  }

  // optional uint64 clanid = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_clanid(), target);
  }

  // optional uint64 posterid = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_posterid(), target);
  }

  // optional string headline = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_headline().data(), static_cast<int>(this->_internal_headline().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCommunity_ClanAnnouncementInfo.headline");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_headline(), target);
  }

  // optional uint32 posttime = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_posttime(), target);
  }

  // optional uint32 updatetime = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_updatetime(), target);
  }

  // optional string body = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_body().data(), static_cast<int>(this->_internal_body().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCommunity_ClanAnnouncementInfo.body");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_body(), target);
  }

  // optional int32 commentcount = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_commentcount(), target);
  }

  // repeated string tags = 9;
  for (int i = 0, n = this->_internal_tags_size(); i < n; i++) {
    const auto& s = this->_internal_tags(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCommunity_ClanAnnouncementInfo.tags");
    target = stream->WriteString(9, s, target);
  }

  // optional int32 language = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_language(), target);
  }

  // optional bool hidden = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_hidden(), target);
  }

  // optional fixed64 forum_topic_id = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(12, this->_internal_forum_topic_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCommunity_ClanAnnouncementInfo)
  return target;
}

size_t CCommunity_ClanAnnouncementInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCommunity_ClanAnnouncementInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string tags = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.tags_.size());
  for (int i = 0, n = _impl_.tags_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.tags_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string headline = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_headline());
    }

    // optional string body = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_body());
    }

    // optional uint64 gid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gid());
    }

    // optional uint64 clanid = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_clanid());
    }

    // optional uint64 posterid = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_posterid());
    }

    // optional uint32 posttime = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_posttime());
    }

    // optional uint32 updatetime = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_updatetime());
    }

    // optional int32 commentcount = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_commentcount());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional int32 language = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_language());
    }

    // optional fixed64 forum_topic_id = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional bool hidden = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCommunity_ClanAnnouncementInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCommunity_ClanAnnouncementInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCommunity_ClanAnnouncementInfo::GetClassData() const { return &_class_data_; }


void CCommunity_ClanAnnouncementInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCommunity_ClanAnnouncementInfo*>(&to_msg);
  auto& from = static_cast<const CCommunity_ClanAnnouncementInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCommunity_ClanAnnouncementInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tags_.MergeFrom(from._impl_.tags_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_headline(from._internal_headline());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_body(from._internal_body());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.gid_ = from._impl_.gid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.clanid_ = from._impl_.clanid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.posterid_ = from._impl_.posterid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.posttime_ = from._impl_.posttime_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.updatetime_ = from._impl_.updatetime_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.commentcount_ = from._impl_.commentcount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.language_ = from._impl_.language_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.forum_topic_id_ = from._impl_.forum_topic_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.hidden_ = from._impl_.hidden_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCommunity_ClanAnnouncementInfo::CopyFrom(const CCommunity_ClanAnnouncementInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCommunity_ClanAnnouncementInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCommunity_ClanAnnouncementInfo::IsInitialized() const {
  return true;
}

void CCommunity_ClanAnnouncementInfo::InternalSwap(CCommunity_ClanAnnouncementInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.tags_.InternalSwap(&other->_impl_.tags_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.headline_, lhs_arena,
      &other->_impl_.headline_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.body_, lhs_arena,
      &other->_impl_.body_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCommunity_ClanAnnouncementInfo, _impl_.hidden_)
      + sizeof(CCommunity_ClanAnnouncementInfo::_impl_.hidden_)
      - PROTOBUF_FIELD_OFFSET(CCommunity_ClanAnnouncementInfo, _impl_.gid_)>(
          reinterpret_cast<char*>(&_impl_.gid_),
          reinterpret_cast<char*>(&other->_impl_.gid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCommunity_ClanAnnouncementInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[56]);
}

// ===================================================================

class CCommunity_GetClanAnnouncements_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CCommunity_GetClanAnnouncements_Request>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_maxchars(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_strip_html(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_require_no_tags(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_hidden_only(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_only_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_rtime_oldest_date(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_include_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_include_partner_events(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

CCommunity_GetClanAnnouncements_Request::CCommunity_GetClanAnnouncements_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCommunity_GetClanAnnouncements_Request)
}
CCommunity_GetClanAnnouncements_Request::CCommunity_GetClanAnnouncements_Request(const CCommunity_GetClanAnnouncements_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCommunity_GetClanAnnouncements_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.required_tags_){from._impl_.required_tags_}
    , decltype(_impl_.language_preference_){from._impl_.language_preference_}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.count_){}
    , decltype(_impl_.maxchars_){}
    , decltype(_impl_.strip_html_){}
    , decltype(_impl_.require_no_tags_){}
    , decltype(_impl_.hidden_only_){}
    , decltype(_impl_.only_gid_){}
    , decltype(_impl_.rtime_oldest_date_){}
    , decltype(_impl_.include_hidden_){}
    , decltype(_impl_.include_partner_events_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.include_partner_events_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.include_partner_events_));
  // @@protoc_insertion_point(copy_constructor:CCommunity_GetClanAnnouncements_Request)
}

inline void CCommunity_GetClanAnnouncements_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.required_tags_){arena}
    , decltype(_impl_.language_preference_){arena}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.offset_){0u}
    , decltype(_impl_.count_){0u}
    , decltype(_impl_.maxchars_){0u}
    , decltype(_impl_.strip_html_){false}
    , decltype(_impl_.require_no_tags_){false}
    , decltype(_impl_.hidden_only_){false}
    , decltype(_impl_.only_gid_){false}
    , decltype(_impl_.rtime_oldest_date_){0u}
    , decltype(_impl_.include_hidden_){false}
    , decltype(_impl_.include_partner_events_){false}
  };
}

CCommunity_GetClanAnnouncements_Request::~CCommunity_GetClanAnnouncements_Request() {
  // @@protoc_insertion_point(destructor:CCommunity_GetClanAnnouncements_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCommunity_GetClanAnnouncements_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.required_tags_.~RepeatedPtrField();
  _impl_.language_preference_.~RepeatedField();
}

void CCommunity_GetClanAnnouncements_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCommunity_GetClanAnnouncements_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CCommunity_GetClanAnnouncements_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.required_tags_.Clear();
  _impl_.language_preference_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.only_gid_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.only_gid_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.rtime_oldest_date_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.include_partner_events_) -
        reinterpret_cast<char*>(&_impl_.rtime_oldest_date_)) + sizeof(_impl_.include_partner_events_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCommunity_GetClanAnnouncements_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 maxchars = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_maxchars(&has_bits);
          _impl_.maxchars_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool strip_html = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_strip_html(&has_bits);
          _impl_.strip_html_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string required_tags = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_required_tags();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "CCommunity_GetClanAnnouncements_Request.required_tags");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool require_no_tags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_require_no_tags(&has_bits);
          _impl_.require_no_tags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 language_preference = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_language_preference(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_language_preference(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hidden_only = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_hidden_only(&has_bits);
          _impl_.hidden_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool only_gid = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_only_gid(&has_bits);
          _impl_.only_gid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime_oldest_date = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_rtime_oldest_date(&has_bits);
          _impl_.rtime_oldest_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_hidden = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_include_hidden(&has_bits);
          _impl_.include_hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_partner_events = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_include_partner_events(&has_bits);
          _impl_.include_partner_events_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCommunity_GetClanAnnouncements_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCommunity_GetClanAnnouncements_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 steamid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_steamid(), target);
  }

  // optional uint32 offset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_offset(), target);
  }

  // optional uint32 count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count(), target);
  }

  // optional uint32 maxchars = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_maxchars(), target);
  }

  // optional bool strip_html = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_strip_html(), target);
  }

  // repeated string required_tags = 6;
  for (int i = 0, n = this->_internal_required_tags_size(); i < n; i++) {
    const auto& s = this->_internal_required_tags(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCommunity_GetClanAnnouncements_Request.required_tags");
    target = stream->WriteString(6, s, target);
  }

  // optional bool require_no_tags = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_require_no_tags(), target);
  }

  // repeated uint32 language_preference = 8;
  for (int i = 0, n = this->_internal_language_preference_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_language_preference(i), target);
  }

  // optional bool hidden_only = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_hidden_only(), target);
  }

  // optional bool only_gid = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_only_gid(), target);
  }

  // optional uint32 rtime_oldest_date = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_rtime_oldest_date(), target);
  }

  // optional bool include_hidden = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_include_hidden(), target);
  }

  // optional bool include_partner_events = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_include_partner_events(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCommunity_GetClanAnnouncements_Request)
  return target;
}

size_t CCommunity_GetClanAnnouncements_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCommunity_GetClanAnnouncements_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string required_tags = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.required_tags_.size());
  for (int i = 0, n = _impl_.required_tags_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.required_tags_.Get(i));
  }

  // repeated uint32 language_preference = 8;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.language_preference_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_language_preference_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 steamid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_steamid());
    }

    // optional uint32 offset = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_offset());
    }

    // optional uint32 count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

    // optional uint32 maxchars = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxchars());
    }

    // optional bool strip_html = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool require_no_tags = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool hidden_only = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool only_gid = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 rtime_oldest_date = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtime_oldest_date());
    }

    // optional bool include_hidden = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool include_partner_events = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCommunity_GetClanAnnouncements_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCommunity_GetClanAnnouncements_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCommunity_GetClanAnnouncements_Request::GetClassData() const { return &_class_data_; }


void CCommunity_GetClanAnnouncements_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCommunity_GetClanAnnouncements_Request*>(&to_msg);
  auto& from = static_cast<const CCommunity_GetClanAnnouncements_Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCommunity_GetClanAnnouncements_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.required_tags_.MergeFrom(from._impl_.required_tags_);
  _this->_impl_.language_preference_.MergeFrom(from._impl_.language_preference_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.maxchars_ = from._impl_.maxchars_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.strip_html_ = from._impl_.strip_html_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.require_no_tags_ = from._impl_.require_no_tags_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.hidden_only_ = from._impl_.hidden_only_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.only_gid_ = from._impl_.only_gid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.rtime_oldest_date_ = from._impl_.rtime_oldest_date_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.include_hidden_ = from._impl_.include_hidden_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.include_partner_events_ = from._impl_.include_partner_events_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCommunity_GetClanAnnouncements_Request::CopyFrom(const CCommunity_GetClanAnnouncements_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCommunity_GetClanAnnouncements_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCommunity_GetClanAnnouncements_Request::IsInitialized() const {
  return true;
}

void CCommunity_GetClanAnnouncements_Request::InternalSwap(CCommunity_GetClanAnnouncements_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.required_tags_.InternalSwap(&other->_impl_.required_tags_);
  _impl_.language_preference_.InternalSwap(&other->_impl_.language_preference_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCommunity_GetClanAnnouncements_Request, _impl_.include_partner_events_)
      + sizeof(CCommunity_GetClanAnnouncements_Request::_impl_.include_partner_events_)
      - PROTOBUF_FIELD_OFFSET(CCommunity_GetClanAnnouncements_Request, _impl_.steamid_)>(
          reinterpret_cast<char*>(&_impl_.steamid_),
          reinterpret_cast<char*>(&other->_impl_.steamid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCommunity_GetClanAnnouncements_Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[57]);
}

// ===================================================================

class CCommunity_GetClanAnnouncements_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CCommunity_GetClanAnnouncements_Response>()._impl_._has_bits_);
  static void set_has_maxchars(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_strip_html(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CCommunity_GetClanAnnouncements_Response::CCommunity_GetClanAnnouncements_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCommunity_GetClanAnnouncements_Response)
}
CCommunity_GetClanAnnouncements_Response::CCommunity_GetClanAnnouncements_Response(const CCommunity_GetClanAnnouncements_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCommunity_GetClanAnnouncements_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.announcements_){from._impl_.announcements_}
    , decltype(_impl_.maxchars_){}
    , decltype(_impl_.strip_html_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.maxchars_, &from._impl_.maxchars_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.strip_html_) -
    reinterpret_cast<char*>(&_impl_.maxchars_)) + sizeof(_impl_.strip_html_));
  // @@protoc_insertion_point(copy_constructor:CCommunity_GetClanAnnouncements_Response)
}

inline void CCommunity_GetClanAnnouncements_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.announcements_){arena}
    , decltype(_impl_.maxchars_){0u}
    , decltype(_impl_.strip_html_){false}
  };
}

CCommunity_GetClanAnnouncements_Response::~CCommunity_GetClanAnnouncements_Response() {
  // @@protoc_insertion_point(destructor:CCommunity_GetClanAnnouncements_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCommunity_GetClanAnnouncements_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.announcements_.~RepeatedPtrField();
}

void CCommunity_GetClanAnnouncements_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCommunity_GetClanAnnouncements_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CCommunity_GetClanAnnouncements_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.announcements_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.maxchars_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.strip_html_) -
        reinterpret_cast<char*>(&_impl_.maxchars_)) + sizeof(_impl_.strip_html_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCommunity_GetClanAnnouncements_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 maxchars = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_maxchars(&has_bits);
          _impl_.maxchars_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool strip_html = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_strip_html(&has_bits);
          _impl_.strip_html_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CCommunity_ClanAnnouncementInfo announcements = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_announcements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCommunity_GetClanAnnouncements_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCommunity_GetClanAnnouncements_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 maxchars = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_maxchars(), target);
  }

  // optional bool strip_html = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_strip_html(), target);
  }

  // repeated .CCommunity_ClanAnnouncementInfo announcements = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_announcements_size()); i < n; i++) {
    const auto& repfield = this->_internal_announcements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCommunity_GetClanAnnouncements_Response)
  return target;
}

size_t CCommunity_GetClanAnnouncements_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCommunity_GetClanAnnouncements_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CCommunity_ClanAnnouncementInfo announcements = 3;
  total_size += 1UL * this->_internal_announcements_size();
  for (const auto& msg : this->_impl_.announcements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 maxchars = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxchars());
    }

    // optional bool strip_html = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCommunity_GetClanAnnouncements_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCommunity_GetClanAnnouncements_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCommunity_GetClanAnnouncements_Response::GetClassData() const { return &_class_data_; }


void CCommunity_GetClanAnnouncements_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCommunity_GetClanAnnouncements_Response*>(&to_msg);
  auto& from = static_cast<const CCommunity_GetClanAnnouncements_Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCommunity_GetClanAnnouncements_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.announcements_.MergeFrom(from._impl_.announcements_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.maxchars_ = from._impl_.maxchars_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.strip_html_ = from._impl_.strip_html_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCommunity_GetClanAnnouncements_Response::CopyFrom(const CCommunity_GetClanAnnouncements_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCommunity_GetClanAnnouncements_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCommunity_GetClanAnnouncements_Response::IsInitialized() const {
  return true;
}

void CCommunity_GetClanAnnouncements_Response::InternalSwap(CCommunity_GetClanAnnouncements_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.announcements_.InternalSwap(&other->_impl_.announcements_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCommunity_GetClanAnnouncements_Response, _impl_.strip_html_)
      + sizeof(CCommunity_GetClanAnnouncements_Response::_impl_.strip_html_)
      - PROTOBUF_FIELD_OFFSET(CCommunity_GetClanAnnouncements_Response, _impl_.maxchars_)>(
          reinterpret_cast<char*>(&_impl_.maxchars_),
          reinterpret_cast<char*>(&other->_impl_.maxchars_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCommunity_GetClanAnnouncements_Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[58]);
}

// ===================================================================

class CBroadcast_PostGameDataFrame_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CBroadcast_PostGameDataFrame_Request>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_broadcast_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_frame_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CBroadcast_PostGameDataFrame_Request::CBroadcast_PostGameDataFrame_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CBroadcast_PostGameDataFrame_Request)
}
CBroadcast_PostGameDataFrame_Request::CBroadcast_PostGameDataFrame_Request(const CBroadcast_PostGameDataFrame_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CBroadcast_PostGameDataFrame_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.frame_data_){}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.broadcast_id_){}
    , decltype(_impl_.appid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.frame_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.frame_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_frame_data()) {
    _this->_impl_.frame_data_.Set(from._internal_frame_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.appid_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.appid_));
  // @@protoc_insertion_point(copy_constructor:CBroadcast_PostGameDataFrame_Request)
}

inline void CBroadcast_PostGameDataFrame_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.frame_data_){}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.broadcast_id_){uint64_t{0u}}
    , decltype(_impl_.appid_){0u}
  };
  _impl_.frame_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.frame_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CBroadcast_PostGameDataFrame_Request::~CBroadcast_PostGameDataFrame_Request() {
  // @@protoc_insertion_point(destructor:CBroadcast_PostGameDataFrame_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CBroadcast_PostGameDataFrame_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.frame_data_.Destroy();
}

void CBroadcast_PostGameDataFrame_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CBroadcast_PostGameDataFrame_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CBroadcast_PostGameDataFrame_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.frame_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.appid_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.appid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CBroadcast_PostGameDataFrame_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 broadcast_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_broadcast_id(&has_bits);
          _impl_.broadcast_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional bytes frame_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_frame_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CBroadcast_PostGameDataFrame_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CBroadcast_PostGameDataFrame_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional fixed64 steamid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_steamid(), target);
  }

  // optional fixed64 broadcast_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_broadcast_id(), target);
  }

  // optional bytes frame_data = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_frame_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CBroadcast_PostGameDataFrame_Request)
  return target;
}

size_t CBroadcast_PostGameDataFrame_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CBroadcast_PostGameDataFrame_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes frame_data = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_frame_data());
    }

    // optional fixed64 steamid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional fixed64 broadcast_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CBroadcast_PostGameDataFrame_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CBroadcast_PostGameDataFrame_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CBroadcast_PostGameDataFrame_Request::GetClassData() const { return &_class_data_; }


void CBroadcast_PostGameDataFrame_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CBroadcast_PostGameDataFrame_Request*>(&to_msg);
  auto& from = static_cast<const CBroadcast_PostGameDataFrame_Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CBroadcast_PostGameDataFrame_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_frame_data(from._internal_frame_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.broadcast_id_ = from._impl_.broadcast_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CBroadcast_PostGameDataFrame_Request::CopyFrom(const CBroadcast_PostGameDataFrame_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CBroadcast_PostGameDataFrame_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CBroadcast_PostGameDataFrame_Request::IsInitialized() const {
  return true;
}

void CBroadcast_PostGameDataFrame_Request::InternalSwap(CBroadcast_PostGameDataFrame_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.frame_data_, lhs_arena,
      &other->_impl_.frame_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CBroadcast_PostGameDataFrame_Request, _impl_.appid_)
      + sizeof(CBroadcast_PostGameDataFrame_Request::_impl_.appid_)
      - PROTOBUF_FIELD_OFFSET(CBroadcast_PostGameDataFrame_Request, _impl_.steamid_)>(
          reinterpret_cast<char*>(&_impl_.steamid_),
          reinterpret_cast<char*>(&other->_impl_.steamid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CBroadcast_PostGameDataFrame_Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[59]);
}

// ===================================================================

class CMsgSerializedSOCache_TypeCache::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSerializedSOCache_TypeCache>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_service_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgSerializedSOCache_TypeCache::CMsgSerializedSOCache_TypeCache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSerializedSOCache.TypeCache)
}
CMsgSerializedSOCache_TypeCache::CMsgSerializedSOCache_TypeCache(const CMsgSerializedSOCache_TypeCache& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSerializedSOCache_TypeCache* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_){from._impl_.objects_}
    , decltype(_impl_.type_){}
    , decltype(_impl_.service_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.service_id_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.service_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSerializedSOCache.TypeCache)
}

inline void CMsgSerializedSOCache_TypeCache::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_){arena}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.service_id_){0u}
  };
}

CMsgSerializedSOCache_TypeCache::~CMsgSerializedSOCache_TypeCache() {
  // @@protoc_insertion_point(destructor:CMsgSerializedSOCache.TypeCache)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSerializedSOCache_TypeCache::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_.~RepeatedPtrField();
}

void CMsgSerializedSOCache_TypeCache::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSerializedSOCache_TypeCache::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSerializedSOCache.TypeCache)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.service_id_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.service_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSerializedSOCache_TypeCache::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes objects = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_objects();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 service_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_service_id(&has_bits);
          _impl_.service_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSerializedSOCache_TypeCache::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSerializedSOCache.TypeCache)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // repeated bytes objects = 2;
  for (int i = 0, n = this->_internal_objects_size(); i < n; i++) {
    const auto& s = this->_internal_objects(i);
    target = stream->WriteBytes(2, s, target);
  }

  // optional uint32 service_id = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_service_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSerializedSOCache.TypeCache)
  return target;
}

size_t CMsgSerializedSOCache_TypeCache::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSerializedSOCache.TypeCache)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes objects = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.objects_.size());
  for (int i = 0, n = _impl_.objects_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.objects_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

    // optional uint32 service_id = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_service_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSerializedSOCache_TypeCache::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSerializedSOCache_TypeCache::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSerializedSOCache_TypeCache::GetClassData() const { return &_class_data_; }


void CMsgSerializedSOCache_TypeCache::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSerializedSOCache_TypeCache*>(&to_msg);
  auto& from = static_cast<const CMsgSerializedSOCache_TypeCache&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSerializedSOCache.TypeCache)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_.MergeFrom(from._impl_.objects_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.service_id_ = from._impl_.service_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSerializedSOCache_TypeCache::CopyFrom(const CMsgSerializedSOCache_TypeCache& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSerializedSOCache.TypeCache)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSerializedSOCache_TypeCache::IsInitialized() const {
  return true;
}

void CMsgSerializedSOCache_TypeCache::InternalSwap(CMsgSerializedSOCache_TypeCache* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.objects_.InternalSwap(&other->_impl_.objects_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSerializedSOCache_TypeCache, _impl_.service_id_)
      + sizeof(CMsgSerializedSOCache_TypeCache::_impl_.service_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSerializedSOCache_TypeCache, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSerializedSOCache_TypeCache::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[60]);
}

// ===================================================================

class CMsgSerializedSOCache_Cache_Version::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSerializedSOCache_Cache_Version>()._impl_._has_bits_);
  static void set_has_service(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSerializedSOCache_Cache_Version::CMsgSerializedSOCache_Cache_Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSerializedSOCache.Cache.Version)
}
CMsgSerializedSOCache_Cache_Version::CMsgSerializedSOCache_Cache_Version(const CMsgSerializedSOCache_Cache_Version& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSerializedSOCache_Cache_Version* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.version_){}
    , decltype(_impl_.service_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.service_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_));
  // @@protoc_insertion_point(copy_constructor:CMsgSerializedSOCache.Cache.Version)
}

inline void CMsgSerializedSOCache_Cache_Version::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.version_){uint64_t{0u}}
    , decltype(_impl_.service_){0u}
  };
}

CMsgSerializedSOCache_Cache_Version::~CMsgSerializedSOCache_Cache_Version() {
  // @@protoc_insertion_point(destructor:CMsgSerializedSOCache.Cache.Version)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSerializedSOCache_Cache_Version::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSerializedSOCache_Cache_Version::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSerializedSOCache_Cache_Version::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSerializedSOCache.Cache.Version)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.service_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.service_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSerializedSOCache_Cache_Version::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 service = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_service(&has_bits);
          _impl_.service_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSerializedSOCache_Cache_Version::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSerializedSOCache.Cache.Version)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 service = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_service(), target);
  }

  // optional uint64 version = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSerializedSOCache.Cache.Version)
  return target;
}

size_t CMsgSerializedSOCache_Cache_Version::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSerializedSOCache.Cache.Version)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 version = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_version());
    }

    // optional uint32 service = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_service());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSerializedSOCache_Cache_Version::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSerializedSOCache_Cache_Version::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSerializedSOCache_Cache_Version::GetClassData() const { return &_class_data_; }


void CMsgSerializedSOCache_Cache_Version::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSerializedSOCache_Cache_Version*>(&to_msg);
  auto& from = static_cast<const CMsgSerializedSOCache_Cache_Version&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSerializedSOCache.Cache.Version)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.service_ = from._impl_.service_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSerializedSOCache_Cache_Version::CopyFrom(const CMsgSerializedSOCache_Cache_Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSerializedSOCache.Cache.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSerializedSOCache_Cache_Version::IsInitialized() const {
  return true;
}

void CMsgSerializedSOCache_Cache_Version::InternalSwap(CMsgSerializedSOCache_Cache_Version* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSerializedSOCache_Cache_Version, _impl_.service_)
      + sizeof(CMsgSerializedSOCache_Cache_Version::_impl_.service_)
      - PROTOBUF_FIELD_OFFSET(CMsgSerializedSOCache_Cache_Version, _impl_.version_)>(
          reinterpret_cast<char*>(&_impl_.version_),
          reinterpret_cast<char*>(&other->_impl_.version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSerializedSOCache_Cache_Version::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[61]);
}

// ===================================================================

class CMsgSerializedSOCache_Cache::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSerializedSOCache_Cache>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSerializedSOCache_Cache::CMsgSerializedSOCache_Cache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSerializedSOCache.Cache)
}
CMsgSerializedSOCache_Cache::CMsgSerializedSOCache_Cache(const CMsgSerializedSOCache_Cache& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSerializedSOCache_Cache* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.versions_){from._impl_.versions_}
    , decltype(_impl_.type_caches_){from._impl_.type_caches_}
    , decltype(_impl_.id_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:CMsgSerializedSOCache.Cache)
}

inline void CMsgSerializedSOCache_Cache::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.versions_){arena}
    , decltype(_impl_.type_caches_){arena}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.type_){0u}
  };
}

CMsgSerializedSOCache_Cache::~CMsgSerializedSOCache_Cache() {
  // @@protoc_insertion_point(destructor:CMsgSerializedSOCache.Cache)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSerializedSOCache_Cache::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.versions_.~RepeatedPtrField();
  _impl_.type_caches_.~RepeatedPtrField();
}

void CMsgSerializedSOCache_Cache::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSerializedSOCache_Cache::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSerializedSOCache.Cache)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.versions_.Clear();
  _impl_.type_caches_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSerializedSOCache_Cache::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSerializedSOCache.Cache.Version versions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_versions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSerializedSOCache.TypeCache type_caches = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_type_caches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSerializedSOCache_Cache::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSerializedSOCache.Cache)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // optional uint64 id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_id(), target);
  }

  // repeated .CMsgSerializedSOCache.Cache.Version versions = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_versions_size()); i < n; i++) {
    const auto& repfield = this->_internal_versions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgSerializedSOCache.TypeCache type_caches = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_type_caches_size()); i < n; i++) {
    const auto& repfield = this->_internal_type_caches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSerializedSOCache.Cache)
  return target;
}

size_t CMsgSerializedSOCache_Cache::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSerializedSOCache.Cache)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSerializedSOCache.Cache.Version versions = 3;
  total_size += 1UL * this->_internal_versions_size();
  for (const auto& msg : this->_impl_.versions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSerializedSOCache.TypeCache type_caches = 4;
  total_size += 1UL * this->_internal_type_caches_size();
  for (const auto& msg : this->_impl_.type_caches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
    }

    // optional uint32 type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSerializedSOCache_Cache::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSerializedSOCache_Cache::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSerializedSOCache_Cache::GetClassData() const { return &_class_data_; }


void CMsgSerializedSOCache_Cache::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSerializedSOCache_Cache*>(&to_msg);
  auto& from = static_cast<const CMsgSerializedSOCache_Cache&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSerializedSOCache.Cache)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.versions_.MergeFrom(from._impl_.versions_);
  _this->_impl_.type_caches_.MergeFrom(from._impl_.type_caches_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSerializedSOCache_Cache::CopyFrom(const CMsgSerializedSOCache_Cache& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSerializedSOCache.Cache)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSerializedSOCache_Cache::IsInitialized() const {
  return true;
}

void CMsgSerializedSOCache_Cache::InternalSwap(CMsgSerializedSOCache_Cache* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.versions_.InternalSwap(&other->_impl_.versions_);
  _impl_.type_caches_.InternalSwap(&other->_impl_.type_caches_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSerializedSOCache_Cache, _impl_.type_)
      + sizeof(CMsgSerializedSOCache_Cache::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(CMsgSerializedSOCache_Cache, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSerializedSOCache_Cache::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[62]);
}

// ===================================================================

class CMsgSerializedSOCache::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSerializedSOCache>()._impl_._has_bits_);
  static void set_has_file_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gc_socache_file_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgSerializedSOCache::CMsgSerializedSOCache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSerializedSOCache)
}
CMsgSerializedSOCache::CMsgSerializedSOCache(const CMsgSerializedSOCache& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSerializedSOCache* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.caches_){from._impl_.caches_}
    , decltype(_impl_.file_version_){}
    , decltype(_impl_.gc_socache_file_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.file_version_, &from._impl_.file_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gc_socache_file_version_) -
    reinterpret_cast<char*>(&_impl_.file_version_)) + sizeof(_impl_.gc_socache_file_version_));
  // @@protoc_insertion_point(copy_constructor:CMsgSerializedSOCache)
}

inline void CMsgSerializedSOCache::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.caches_){arena}
    , decltype(_impl_.file_version_){0u}
    , decltype(_impl_.gc_socache_file_version_){0u}
  };
}

CMsgSerializedSOCache::~CMsgSerializedSOCache() {
  // @@protoc_insertion_point(destructor:CMsgSerializedSOCache)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSerializedSOCache::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.caches_.~RepeatedPtrField();
}

void CMsgSerializedSOCache::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSerializedSOCache::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSerializedSOCache)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.caches_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.file_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gc_socache_file_version_) -
        reinterpret_cast<char*>(&_impl_.file_version_)) + sizeof(_impl_.gc_socache_file_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSerializedSOCache::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 file_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_file_version(&has_bits);
          _impl_.file_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSerializedSOCache.Cache caches = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_caches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gc_socache_file_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_gc_socache_file_version(&has_bits);
          _impl_.gc_socache_file_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSerializedSOCache::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSerializedSOCache)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 file_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_file_version(), target);
  }

  // repeated .CMsgSerializedSOCache.Cache caches = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_caches_size()); i < n; i++) {
    const auto& repfield = this->_internal_caches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 gc_socache_file_version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_gc_socache_file_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSerializedSOCache)
  return target;
}

size_t CMsgSerializedSOCache::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSerializedSOCache)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSerializedSOCache.Cache caches = 2;
  total_size += 1UL * this->_internal_caches_size();
  for (const auto& msg : this->_impl_.caches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 file_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_file_version());
    }

    // optional uint32 gc_socache_file_version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gc_socache_file_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSerializedSOCache::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSerializedSOCache::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSerializedSOCache::GetClassData() const { return &_class_data_; }


void CMsgSerializedSOCache::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSerializedSOCache*>(&to_msg);
  auto& from = static_cast<const CMsgSerializedSOCache&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSerializedSOCache)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.caches_.MergeFrom(from._impl_.caches_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.file_version_ = from._impl_.file_version_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gc_socache_file_version_ = from._impl_.gc_socache_file_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSerializedSOCache::CopyFrom(const CMsgSerializedSOCache& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSerializedSOCache)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSerializedSOCache::IsInitialized() const {
  return true;
}

void CMsgSerializedSOCache::InternalSwap(CMsgSerializedSOCache* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.caches_.InternalSwap(&other->_impl_.caches_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSerializedSOCache, _impl_.gc_socache_file_version_)
      + sizeof(CMsgSerializedSOCache::_impl_.gc_socache_file_version_)
      - PROTOBUF_FIELD_OFFSET(CMsgSerializedSOCache, _impl_.file_version_)>(
          reinterpret_cast<char*>(&_impl_.file_version_),
          reinterpret_cast<char*>(&other->_impl_.file_version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSerializedSOCache::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[63]);
}

// ===================================================================

class CMsgGCToClientPollConvarRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToClientPollConvarRequest>()._impl_._has_bits_);
  static void set_has_convar_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_poll_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCToClientPollConvarRequest::CMsgGCToClientPollConvarRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToClientPollConvarRequest)
}
CMsgGCToClientPollConvarRequest::CMsgGCToClientPollConvarRequest(const CMsgGCToClientPollConvarRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToClientPollConvarRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.convar_name_){}
    , decltype(_impl_.poll_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.convar_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.convar_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_convar_name()) {
    _this->_impl_.convar_name_.Set(from._internal_convar_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.poll_id_ = from._impl_.poll_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCToClientPollConvarRequest)
}

inline void CMsgGCToClientPollConvarRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.convar_name_){}
    , decltype(_impl_.poll_id_){0u}
  };
  _impl_.convar_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.convar_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCToClientPollConvarRequest::~CMsgGCToClientPollConvarRequest() {
  // @@protoc_insertion_point(destructor:CMsgGCToClientPollConvarRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToClientPollConvarRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.convar_name_.Destroy();
}

void CMsgGCToClientPollConvarRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToClientPollConvarRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToClientPollConvarRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.convar_name_.ClearNonDefaultToEmpty();
  }
  _impl_.poll_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToClientPollConvarRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string convar_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_convar_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCToClientPollConvarRequest.convar_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 poll_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_poll_id(&has_bits);
          _impl_.poll_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToClientPollConvarRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToClientPollConvarRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string convar_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_convar_name().data(), static_cast<int>(this->_internal_convar_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCToClientPollConvarRequest.convar_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_convar_name(), target);
  }

  // optional uint32 poll_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_poll_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToClientPollConvarRequest)
  return target;
}

size_t CMsgGCToClientPollConvarRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToClientPollConvarRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string convar_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_convar_name());
    }

    // optional uint32 poll_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_poll_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToClientPollConvarRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToClientPollConvarRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToClientPollConvarRequest::GetClassData() const { return &_class_data_; }


void CMsgGCToClientPollConvarRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToClientPollConvarRequest*>(&to_msg);
  auto& from = static_cast<const CMsgGCToClientPollConvarRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToClientPollConvarRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_convar_name(from._internal_convar_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.poll_id_ = from._impl_.poll_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToClientPollConvarRequest::CopyFrom(const CMsgGCToClientPollConvarRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToClientPollConvarRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToClientPollConvarRequest::IsInitialized() const {
  return true;
}

void CMsgGCToClientPollConvarRequest::InternalSwap(CMsgGCToClientPollConvarRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.convar_name_, lhs_arena,
      &other->_impl_.convar_name_, rhs_arena
  );
  swap(_impl_.poll_id_, other->_impl_.poll_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToClientPollConvarRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[64]);
}

// ===================================================================

class CMsgGCToClientPollConvarResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToClientPollConvarResponse>()._impl_._has_bits_);
  static void set_has_poll_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_convar_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToClientPollConvarResponse::CMsgGCToClientPollConvarResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToClientPollConvarResponse)
}
CMsgGCToClientPollConvarResponse::CMsgGCToClientPollConvarResponse(const CMsgGCToClientPollConvarResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToClientPollConvarResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.convar_value_){}
    , decltype(_impl_.poll_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.convar_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.convar_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_convar_value()) {
    _this->_impl_.convar_value_.Set(from._internal_convar_value(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.poll_id_ = from._impl_.poll_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCToClientPollConvarResponse)
}

inline void CMsgGCToClientPollConvarResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.convar_value_){}
    , decltype(_impl_.poll_id_){0u}
  };
  _impl_.convar_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.convar_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCToClientPollConvarResponse::~CMsgGCToClientPollConvarResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCToClientPollConvarResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToClientPollConvarResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.convar_value_.Destroy();
}

void CMsgGCToClientPollConvarResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToClientPollConvarResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToClientPollConvarResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.convar_value_.ClearNonDefaultToEmpty();
  }
  _impl_.poll_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToClientPollConvarResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 poll_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_poll_id(&has_bits);
          _impl_.poll_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string convar_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_convar_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCToClientPollConvarResponse.convar_value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToClientPollConvarResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToClientPollConvarResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 poll_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_poll_id(), target);
  }

  // optional string convar_value = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_convar_value().data(), static_cast<int>(this->_internal_convar_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCToClientPollConvarResponse.convar_value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_convar_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToClientPollConvarResponse)
  return target;
}

size_t CMsgGCToClientPollConvarResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToClientPollConvarResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string convar_value = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_convar_value());
    }

    // optional uint32 poll_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_poll_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToClientPollConvarResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToClientPollConvarResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToClientPollConvarResponse::GetClassData() const { return &_class_data_; }


void CMsgGCToClientPollConvarResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToClientPollConvarResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCToClientPollConvarResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToClientPollConvarResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_convar_value(from._internal_convar_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.poll_id_ = from._impl_.poll_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToClientPollConvarResponse::CopyFrom(const CMsgGCToClientPollConvarResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToClientPollConvarResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToClientPollConvarResponse::IsInitialized() const {
  return true;
}

void CMsgGCToClientPollConvarResponse::InternalSwap(CMsgGCToClientPollConvarResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.convar_value_, lhs_arena,
      &other->_impl_.convar_value_, rhs_arena
  );
  swap(_impl_.poll_id_, other->_impl_.poll_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToClientPollConvarResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[65]);
}

// ===================================================================

class CGCMsgCompressedMsgToClient::_Internal {
 public:
  using HasBits = decltype(std::declval<CGCMsgCompressedMsgToClient>()._impl_._has_bits_);
  static void set_has_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_compressed_msg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGCMsgCompressedMsgToClient::CGCMsgCompressedMsgToClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CGCMsgCompressedMsgToClient)
}
CGCMsgCompressedMsgToClient::CGCMsgCompressedMsgToClient(const CGCMsgCompressedMsgToClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CGCMsgCompressedMsgToClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.compressed_msg_){}
    , decltype(_impl_.msg_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.compressed_msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.compressed_msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_compressed_msg()) {
    _this->_impl_.compressed_msg_.Set(from._internal_compressed_msg(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.msg_id_ = from._impl_.msg_id_;
  // @@protoc_insertion_point(copy_constructor:CGCMsgCompressedMsgToClient)
}

inline void CGCMsgCompressedMsgToClient::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.compressed_msg_){}
    , decltype(_impl_.msg_id_){0u}
  };
  _impl_.compressed_msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.compressed_msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGCMsgCompressedMsgToClient::~CGCMsgCompressedMsgToClient() {
  // @@protoc_insertion_point(destructor:CGCMsgCompressedMsgToClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CGCMsgCompressedMsgToClient::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.compressed_msg_.Destroy();
}

void CGCMsgCompressedMsgToClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CGCMsgCompressedMsgToClient::Clear() {
// @@protoc_insertion_point(message_clear_start:CGCMsgCompressedMsgToClient)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.compressed_msg_.ClearNonDefaultToEmpty();
  }
  _impl_.msg_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGCMsgCompressedMsgToClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 msg_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_id(&has_bits);
          _impl_.msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes compressed_msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_compressed_msg();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGCMsgCompressedMsgToClient::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGCMsgCompressedMsgToClient)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 msg_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msg_id(), target);
  }

  // optional bytes compressed_msg = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_compressed_msg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGCMsgCompressedMsgToClient)
  return target;
}

size_t CGCMsgCompressedMsgToClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGCMsgCompressedMsgToClient)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes compressed_msg = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_compressed_msg());
    }

    // optional uint32 msg_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGCMsgCompressedMsgToClient::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CGCMsgCompressedMsgToClient::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGCMsgCompressedMsgToClient::GetClassData() const { return &_class_data_; }


void CGCMsgCompressedMsgToClient::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CGCMsgCompressedMsgToClient*>(&to_msg);
  auto& from = static_cast<const CGCMsgCompressedMsgToClient&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CGCMsgCompressedMsgToClient)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_compressed_msg(from._internal_compressed_msg());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.msg_id_ = from._impl_.msg_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGCMsgCompressedMsgToClient::CopyFrom(const CGCMsgCompressedMsgToClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGCMsgCompressedMsgToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGCMsgCompressedMsgToClient::IsInitialized() const {
  return true;
}

void CGCMsgCompressedMsgToClient::InternalSwap(CGCMsgCompressedMsgToClient* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.compressed_msg_, lhs_arena,
      &other->_impl_.compressed_msg_, rhs_arena
  );
  swap(_impl_.msg_id_, other->_impl_.msg_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGCMsgCompressedMsgToClient::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[66]);
}

// ===================================================================

class CMsgGCToGCMasterBroadcastMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCMasterBroadcastMessage>()._impl_._has_bits_);
  static void set_has_users_per_second(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_send_to_users(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_send_to_servers(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCMasterBroadcastMessage::CMsgGCToGCMasterBroadcastMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCMasterBroadcastMessage)
}
CMsgGCToGCMasterBroadcastMessage::CMsgGCToGCMasterBroadcastMessage(const CMsgGCToGCMasterBroadcastMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCMasterBroadcastMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.users_per_second_){}
    , decltype(_impl_.send_to_users_){}
    , decltype(_impl_.send_to_servers_){}
    , decltype(_impl_.msg_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg_data()) {
    _this->_impl_.msg_data_.Set(from._internal_msg_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.users_per_second_, &from._impl_.users_per_second_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.msg_id_) -
    reinterpret_cast<char*>(&_impl_.users_per_second_)) + sizeof(_impl_.msg_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCMasterBroadcastMessage)
}

inline void CMsgGCToGCMasterBroadcastMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.users_per_second_){0u}
    , decltype(_impl_.send_to_users_){false}
    , decltype(_impl_.send_to_servers_){false}
    , decltype(_impl_.msg_id_){0u}
  };
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCToGCMasterBroadcastMessage::~CMsgGCToGCMasterBroadcastMessage() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCMasterBroadcastMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCMasterBroadcastMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.msg_data_.Destroy();
}

void CMsgGCToGCMasterBroadcastMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCMasterBroadcastMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCMasterBroadcastMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.users_per_second_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.msg_id_) -
        reinterpret_cast<char*>(&_impl_.users_per_second_)) + sizeof(_impl_.msg_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCMasterBroadcastMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 users_per_second = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_users_per_second(&has_bits);
          _impl_.users_per_second_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool send_to_users = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_send_to_users(&has_bits);
          _impl_.send_to_users_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool send_to_servers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_send_to_servers(&has_bits);
          _impl_.send_to_servers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 msg_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_msg_id(&has_bits);
          _impl_.msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes msg_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_msg_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCMasterBroadcastMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCMasterBroadcastMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 users_per_second = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_users_per_second(), target);
  }

  // optional bool send_to_users = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_send_to_users(), target);
  }

  // optional bool send_to_servers = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_send_to_servers(), target);
  }

  // optional uint32 msg_id = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_msg_id(), target);
  }

  // optional bytes msg_data = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_msg_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCMasterBroadcastMessage)
  return target;
}

size_t CMsgGCToGCMasterBroadcastMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCMasterBroadcastMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes msg_data = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_msg_data());
    }

    // optional uint32 users_per_second = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_users_per_second());
    }

    // optional bool send_to_users = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool send_to_servers = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional uint32 msg_id = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCMasterBroadcastMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCMasterBroadcastMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCMasterBroadcastMessage::GetClassData() const { return &_class_data_; }


void CMsgGCToGCMasterBroadcastMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCMasterBroadcastMessage*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCMasterBroadcastMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCMasterBroadcastMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_msg_data(from._internal_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.users_per_second_ = from._impl_.users_per_second_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.send_to_users_ = from._impl_.send_to_users_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.send_to_servers_ = from._impl_.send_to_servers_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.msg_id_ = from._impl_.msg_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCMasterBroadcastMessage::CopyFrom(const CMsgGCToGCMasterBroadcastMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCMasterBroadcastMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCMasterBroadcastMessage::IsInitialized() const {
  return true;
}

void CMsgGCToGCMasterBroadcastMessage::InternalSwap(CMsgGCToGCMasterBroadcastMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_data_, lhs_arena,
      &other->_impl_.msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToGCMasterBroadcastMessage, _impl_.msg_id_)
      + sizeof(CMsgGCToGCMasterBroadcastMessage::_impl_.msg_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToGCMasterBroadcastMessage, _impl_.users_per_second_)>(
          reinterpret_cast<char*>(&_impl_.users_per_second_),
          reinterpret_cast<char*>(&other->_impl_.users_per_second_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCMasterBroadcastMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[67]);
}

// ===================================================================

class CMsgGCToGCMasterSubscribeToCache::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCMasterSubscribeToCache>()._impl_._has_bits_);
  static void set_has_soid_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_soid_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCMasterSubscribeToCache::CMsgGCToGCMasterSubscribeToCache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCMasterSubscribeToCache)
}
CMsgGCToGCMasterSubscribeToCache::CMsgGCToGCMasterSubscribeToCache(const CMsgGCToGCMasterSubscribeToCache& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCMasterSubscribeToCache* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_ids_){from._impl_.account_ids_}
    , decltype(_impl_.steam_ids_){from._impl_.steam_ids_}
    , decltype(_impl_.soid_id_){}
    , decltype(_impl_.soid_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.soid_id_, &from._impl_.soid_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.soid_type_) -
    reinterpret_cast<char*>(&_impl_.soid_id_)) + sizeof(_impl_.soid_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCMasterSubscribeToCache)
}

inline void CMsgGCToGCMasterSubscribeToCache::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_ids_){arena}
    , decltype(_impl_.steam_ids_){arena}
    , decltype(_impl_.soid_id_){uint64_t{0u}}
    , decltype(_impl_.soid_type_){0u}
  };
}

CMsgGCToGCMasterSubscribeToCache::~CMsgGCToGCMasterSubscribeToCache() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCMasterSubscribeToCache)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCMasterSubscribeToCache::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_ids_.~RepeatedField();
  _impl_.steam_ids_.~RepeatedField();
}

void CMsgGCToGCMasterSubscribeToCache::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCMasterSubscribeToCache::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCMasterSubscribeToCache)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_ids_.Clear();
  _impl_.steam_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.soid_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.soid_type_) -
        reinterpret_cast<char*>(&_impl_.soid_id_)) + sizeof(_impl_.soid_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCMasterSubscribeToCache::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 soid_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_soid_type(&has_bits);
          _impl_.soid_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 soid_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_soid_id(&has_bits);
          _impl_.soid_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 account_ids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_account_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_account_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed64 steam_ids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_steam_ids(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<33>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_steam_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCMasterSubscribeToCache::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCMasterSubscribeToCache)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 soid_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_soid_type(), target);
  }

  // optional fixed64 soid_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_soid_id(), target);
  }

  // repeated uint32 account_ids = 3;
  for (int i = 0, n = this->_internal_account_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_account_ids(i), target);
  }

  // repeated fixed64 steam_ids = 4;
  for (int i = 0, n = this->_internal_steam_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_steam_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCMasterSubscribeToCache)
  return target;
}

size_t CMsgGCToGCMasterSubscribeToCache::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCMasterSubscribeToCache)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 account_ids = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.account_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_account_ids_size());
    total_size += data_size;
  }

  // repeated fixed64 steam_ids = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_steam_ids_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_steam_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 soid_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 soid_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_soid_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCMasterSubscribeToCache::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCMasterSubscribeToCache::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCMasterSubscribeToCache::GetClassData() const { return &_class_data_; }


void CMsgGCToGCMasterSubscribeToCache::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCMasterSubscribeToCache*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCMasterSubscribeToCache&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCMasterSubscribeToCache)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.account_ids_.MergeFrom(from._impl_.account_ids_);
  _this->_impl_.steam_ids_.MergeFrom(from._impl_.steam_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.soid_id_ = from._impl_.soid_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.soid_type_ = from._impl_.soid_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCMasterSubscribeToCache::CopyFrom(const CMsgGCToGCMasterSubscribeToCache& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCMasterSubscribeToCache)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCMasterSubscribeToCache::IsInitialized() const {
  return true;
}

void CMsgGCToGCMasterSubscribeToCache::InternalSwap(CMsgGCToGCMasterSubscribeToCache* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.account_ids_.InternalSwap(&other->_impl_.account_ids_);
  _impl_.steam_ids_.InternalSwap(&other->_impl_.steam_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToGCMasterSubscribeToCache, _impl_.soid_type_)
      + sizeof(CMsgGCToGCMasterSubscribeToCache::_impl_.soid_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToGCMasterSubscribeToCache, _impl_.soid_id_)>(
          reinterpret_cast<char*>(&_impl_.soid_id_),
          reinterpret_cast<char*>(&other->_impl_.soid_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCMasterSubscribeToCache::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[68]);
}

// ===================================================================

class CMsgGCToGCMasterSubscribeToCacheResponse::_Internal {
 public:
};

CMsgGCToGCMasterSubscribeToCacheResponse::CMsgGCToGCMasterSubscribeToCacheResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCMasterSubscribeToCacheResponse)
}
CMsgGCToGCMasterSubscribeToCacheResponse::CMsgGCToGCMasterSubscribeToCacheResponse(const CMsgGCToGCMasterSubscribeToCacheResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CMsgGCToGCMasterSubscribeToCacheResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCMasterSubscribeToCacheResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCMasterSubscribeToCacheResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCMasterSubscribeToCacheResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCMasterSubscribeToCacheResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[69]);
}

// ===================================================================

class CMsgGCToGCMasterSubscribeToCacheAsync::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCMasterSubscribeToCacheAsync>()._impl_._has_bits_);
  static const ::CMsgGCToGCMasterSubscribeToCache& subscribe_msg(const CMsgGCToGCMasterSubscribeToCacheAsync* msg);
  static void set_has_subscribe_msg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgGCToGCMasterSubscribeToCache&
CMsgGCToGCMasterSubscribeToCacheAsync::_Internal::subscribe_msg(const CMsgGCToGCMasterSubscribeToCacheAsync* msg) {
  return *msg->_impl_.subscribe_msg_;
}
CMsgGCToGCMasterSubscribeToCacheAsync::CMsgGCToGCMasterSubscribeToCacheAsync(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCMasterSubscribeToCacheAsync)
}
CMsgGCToGCMasterSubscribeToCacheAsync::CMsgGCToGCMasterSubscribeToCacheAsync(const CMsgGCToGCMasterSubscribeToCacheAsync& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCMasterSubscribeToCacheAsync* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subscribe_msg_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_subscribe_msg()) {
    _this->_impl_.subscribe_msg_ = new ::CMsgGCToGCMasterSubscribeToCache(*from._impl_.subscribe_msg_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCMasterSubscribeToCacheAsync)
}

inline void CMsgGCToGCMasterSubscribeToCacheAsync::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subscribe_msg_){nullptr}
  };
}

CMsgGCToGCMasterSubscribeToCacheAsync::~CMsgGCToGCMasterSubscribeToCacheAsync() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCMasterSubscribeToCacheAsync)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCMasterSubscribeToCacheAsync::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.subscribe_msg_;
}

void CMsgGCToGCMasterSubscribeToCacheAsync::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCMasterSubscribeToCacheAsync::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCMasterSubscribeToCacheAsync)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.subscribe_msg_ != nullptr);
    _impl_.subscribe_msg_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCMasterSubscribeToCacheAsync::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgGCToGCMasterSubscribeToCache subscribe_msg = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_subscribe_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCMasterSubscribeToCacheAsync::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCMasterSubscribeToCacheAsync)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgGCToGCMasterSubscribeToCache subscribe_msg = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::subscribe_msg(this),
        _Internal::subscribe_msg(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCMasterSubscribeToCacheAsync)
  return target;
}

size_t CMsgGCToGCMasterSubscribeToCacheAsync::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCMasterSubscribeToCacheAsync)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgGCToGCMasterSubscribeToCache subscribe_msg = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.subscribe_msg_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCMasterSubscribeToCacheAsync::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCMasterSubscribeToCacheAsync::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCMasterSubscribeToCacheAsync::GetClassData() const { return &_class_data_; }


void CMsgGCToGCMasterSubscribeToCacheAsync::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCMasterSubscribeToCacheAsync*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCMasterSubscribeToCacheAsync&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCMasterSubscribeToCacheAsync)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_subscribe_msg()) {
    _this->_internal_mutable_subscribe_msg()->::CMsgGCToGCMasterSubscribeToCache::MergeFrom(
        from._internal_subscribe_msg());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCMasterSubscribeToCacheAsync::CopyFrom(const CMsgGCToGCMasterSubscribeToCacheAsync& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCMasterSubscribeToCacheAsync)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCMasterSubscribeToCacheAsync::IsInitialized() const {
  return true;
}

void CMsgGCToGCMasterSubscribeToCacheAsync::InternalSwap(CMsgGCToGCMasterSubscribeToCacheAsync* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.subscribe_msg_, other->_impl_.subscribe_msg_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCMasterSubscribeToCacheAsync::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[70]);
}

// ===================================================================

class CMsgGCToGCMasterUnsubscribeFromCache::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCMasterUnsubscribeFromCache>()._impl_._has_bits_);
  static void set_has_soid_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_soid_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCMasterUnsubscribeFromCache::CMsgGCToGCMasterUnsubscribeFromCache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCMasterUnsubscribeFromCache)
}
CMsgGCToGCMasterUnsubscribeFromCache::CMsgGCToGCMasterUnsubscribeFromCache(const CMsgGCToGCMasterUnsubscribeFromCache& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCMasterUnsubscribeFromCache* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_ids_){from._impl_.account_ids_}
    , decltype(_impl_.steam_ids_){from._impl_.steam_ids_}
    , decltype(_impl_.soid_id_){}
    , decltype(_impl_.soid_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.soid_id_, &from._impl_.soid_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.soid_type_) -
    reinterpret_cast<char*>(&_impl_.soid_id_)) + sizeof(_impl_.soid_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCMasterUnsubscribeFromCache)
}

inline void CMsgGCToGCMasterUnsubscribeFromCache::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_ids_){arena}
    , decltype(_impl_.steam_ids_){arena}
    , decltype(_impl_.soid_id_){uint64_t{0u}}
    , decltype(_impl_.soid_type_){0u}
  };
}

CMsgGCToGCMasterUnsubscribeFromCache::~CMsgGCToGCMasterUnsubscribeFromCache() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCMasterUnsubscribeFromCache)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCMasterUnsubscribeFromCache::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_ids_.~RepeatedField();
  _impl_.steam_ids_.~RepeatedField();
}

void CMsgGCToGCMasterUnsubscribeFromCache::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCMasterUnsubscribeFromCache::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCMasterUnsubscribeFromCache)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_ids_.Clear();
  _impl_.steam_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.soid_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.soid_type_) -
        reinterpret_cast<char*>(&_impl_.soid_id_)) + sizeof(_impl_.soid_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCMasterUnsubscribeFromCache::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 soid_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_soid_type(&has_bits);
          _impl_.soid_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 soid_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_soid_id(&has_bits);
          _impl_.soid_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 account_ids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_account_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_account_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed64 steam_ids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_steam_ids(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<33>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_steam_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCMasterUnsubscribeFromCache::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCMasterUnsubscribeFromCache)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 soid_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_soid_type(), target);
  }

  // optional fixed64 soid_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_soid_id(), target);
  }

  // repeated uint32 account_ids = 3;
  for (int i = 0, n = this->_internal_account_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_account_ids(i), target);
  }

  // repeated fixed64 steam_ids = 4;
  for (int i = 0, n = this->_internal_steam_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_steam_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCMasterUnsubscribeFromCache)
  return target;
}

size_t CMsgGCToGCMasterUnsubscribeFromCache::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCMasterUnsubscribeFromCache)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 account_ids = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.account_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_account_ids_size());
    total_size += data_size;
  }

  // repeated fixed64 steam_ids = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_steam_ids_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_steam_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 soid_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 soid_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_soid_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCMasterUnsubscribeFromCache::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCMasterUnsubscribeFromCache::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCMasterUnsubscribeFromCache::GetClassData() const { return &_class_data_; }


void CMsgGCToGCMasterUnsubscribeFromCache::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCMasterUnsubscribeFromCache*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCMasterUnsubscribeFromCache&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCMasterUnsubscribeFromCache)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.account_ids_.MergeFrom(from._impl_.account_ids_);
  _this->_impl_.steam_ids_.MergeFrom(from._impl_.steam_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.soid_id_ = from._impl_.soid_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.soid_type_ = from._impl_.soid_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCMasterUnsubscribeFromCache::CopyFrom(const CMsgGCToGCMasterUnsubscribeFromCache& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCMasterUnsubscribeFromCache)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCMasterUnsubscribeFromCache::IsInitialized() const {
  return true;
}

void CMsgGCToGCMasterUnsubscribeFromCache::InternalSwap(CMsgGCToGCMasterUnsubscribeFromCache* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.account_ids_.InternalSwap(&other->_impl_.account_ids_);
  _impl_.steam_ids_.InternalSwap(&other->_impl_.steam_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToGCMasterUnsubscribeFromCache, _impl_.soid_type_)
      + sizeof(CMsgGCToGCMasterUnsubscribeFromCache::_impl_.soid_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToGCMasterUnsubscribeFromCache, _impl_.soid_id_)>(
          reinterpret_cast<char*>(&_impl_.soid_id_),
          reinterpret_cast<char*>(&other->_impl_.soid_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCMasterUnsubscribeFromCache::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[71]);
}

// ===================================================================

class CMsgGCToGCMasterDestroyCache::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToGCMasterDestroyCache>()._impl_._has_bits_);
  static void set_has_soid_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_soid_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToGCMasterDestroyCache::CMsgGCToGCMasterDestroyCache(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToGCMasterDestroyCache)
}
CMsgGCToGCMasterDestroyCache::CMsgGCToGCMasterDestroyCache(const CMsgGCToGCMasterDestroyCache& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToGCMasterDestroyCache* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.soid_id_){}
    , decltype(_impl_.soid_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.soid_id_, &from._impl_.soid_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.soid_type_) -
    reinterpret_cast<char*>(&_impl_.soid_id_)) + sizeof(_impl_.soid_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCToGCMasterDestroyCache)
}

inline void CMsgGCToGCMasterDestroyCache::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.soid_id_){uint64_t{0u}}
    , decltype(_impl_.soid_type_){0u}
  };
}

CMsgGCToGCMasterDestroyCache::~CMsgGCToGCMasterDestroyCache() {
  // @@protoc_insertion_point(destructor:CMsgGCToGCMasterDestroyCache)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToGCMasterDestroyCache::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToGCMasterDestroyCache::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToGCMasterDestroyCache::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToGCMasterDestroyCache)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.soid_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.soid_type_) -
        reinterpret_cast<char*>(&_impl_.soid_id_)) + sizeof(_impl_.soid_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToGCMasterDestroyCache::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 soid_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_soid_type(&has_bits);
          _impl_.soid_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 soid_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_soid_id(&has_bits);
          _impl_.soid_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToGCMasterDestroyCache::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToGCMasterDestroyCache)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 soid_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_soid_type(), target);
  }

  // optional fixed64 soid_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_soid_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToGCMasterDestroyCache)
  return target;
}

size_t CMsgGCToGCMasterDestroyCache::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToGCMasterDestroyCache)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 soid_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 soid_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_soid_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToGCMasterDestroyCache::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToGCMasterDestroyCache::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToGCMasterDestroyCache::GetClassData() const { return &_class_data_; }


void CMsgGCToGCMasterDestroyCache::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToGCMasterDestroyCache*>(&to_msg);
  auto& from = static_cast<const CMsgGCToGCMasterDestroyCache&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToGCMasterDestroyCache)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.soid_id_ = from._impl_.soid_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.soid_type_ = from._impl_.soid_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToGCMasterDestroyCache::CopyFrom(const CMsgGCToGCMasterDestroyCache& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToGCMasterDestroyCache)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToGCMasterDestroyCache::IsInitialized() const {
  return true;
}

void CMsgGCToGCMasterDestroyCache::InternalSwap(CMsgGCToGCMasterDestroyCache* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToGCMasterDestroyCache, _impl_.soid_type_)
      + sizeof(CMsgGCToGCMasterDestroyCache::_impl_.soid_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToGCMasterDestroyCache, _impl_.soid_id_)>(
          reinterpret_cast<char*>(&_impl_.soid_id_),
          reinterpret_cast<char*>(&other->_impl_.soid_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToGCMasterDestroyCache::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gcsdk_5fgcmessages_2eproto_getter, &descriptor_table_gcsdk_5fgcmessages_2eproto_once,
      file_level_metadata_gcsdk_5fgcmessages_2eproto[72]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CExtraMsgBlock*
Arena::CreateMaybeMessage< ::CExtraMsgBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CExtraMsgBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSteamLearnServerInfo*
Arena::CreateMaybeMessage< ::CMsgSteamLearnServerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSteamLearnServerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCAssertJobData*
Arena::CreateMaybeMessage< ::CMsgGCAssertJobData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCAssertJobData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCConCommand*
Arena::CreateMaybeMessage< ::CMsgGCConCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCConCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSDOAssert_Request*
Arena::CreateMaybeMessage< ::CMsgSDOAssert_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSDOAssert_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSDOAssert*
Arena::CreateMaybeMessage< ::CMsgSDOAssert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSDOAssert >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOIDOwner*
Arena::CreateMaybeMessage< ::CMsgSOIDOwner >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOIDOwner >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOSingleObject*
Arena::CreateMaybeMessage< ::CMsgSOSingleObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOSingleObject >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOMultipleObjects_SingleObject*
Arena::CreateMaybeMessage< ::CMsgSOMultipleObjects_SingleObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOMultipleObjects_SingleObject >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOMultipleObjects*
Arena::CreateMaybeMessage< ::CMsgSOMultipleObjects >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOMultipleObjects >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheSubscribed_SubscribedType*
Arena::CreateMaybeMessage< ::CMsgSOCacheSubscribed_SubscribedType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheSubscribed_SubscribedType >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheSubscribed*
Arena::CreateMaybeMessage< ::CMsgSOCacheSubscribed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheSubscribed >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheSubscribedUpToDate*
Arena::CreateMaybeMessage< ::CMsgSOCacheSubscribedUpToDate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheSubscribedUpToDate >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheUnsubscribed*
Arena::CreateMaybeMessage< ::CMsgSOCacheUnsubscribed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheUnsubscribed >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheSubscriptionCheck*
Arena::CreateMaybeMessage< ::CMsgSOCacheSubscriptionCheck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheSubscriptionCheck >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheSubscriptionRefresh*
Arena::CreateMaybeMessage< ::CMsgSOCacheSubscriptionRefresh >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheSubscriptionRefresh >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheVersion*
Arena::CreateMaybeMessage< ::CMsgSOCacheVersion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCMultiplexMessage*
Arena::CreateMaybeMessage< ::CMsgGCMultiplexMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCMultiplexMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCSubGCStarting*
Arena::CreateMaybeMessage< ::CMsgGCToGCSubGCStarting >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCSubGCStarting >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCToGCMsgMasterAck_Process*
Arena::CreateMaybeMessage< ::CGCToGCMsgMasterAck_Process >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCToGCMsgMasterAck_Process >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCToGCMsgMasterAck*
Arena::CreateMaybeMessage< ::CGCToGCMsgMasterAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCToGCMsgMasterAck >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCToGCMsgMasterAck_Response*
Arena::CreateMaybeMessage< ::CGCToGCMsgMasterAck_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCToGCMsgMasterAck_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCUniverseStartup*
Arena::CreateMaybeMessage< ::CMsgGCToGCUniverseStartup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCUniverseStartup >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCUniverseStartupResponse*
Arena::CreateMaybeMessage< ::CMsgGCToGCUniverseStartupResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCUniverseStartupResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCToGCMsgMasterStartupComplete_GCInfo*
Arena::CreateMaybeMessage< ::CGCToGCMsgMasterStartupComplete_GCInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCToGCMsgMasterStartupComplete_GCInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCToGCMsgMasterStartupComplete*
Arena::CreateMaybeMessage< ::CGCToGCMsgMasterStartupComplete >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCToGCMsgMasterStartupComplete >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCToGCMsgRouted*
Arena::CreateMaybeMessage< ::CGCToGCMsgRouted >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCToGCMsgRouted >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCToGCMsgRoutedReply*
Arena::CreateMaybeMessage< ::CGCToGCMsgRoutedReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCToGCMsgRoutedReply >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCUpdateSubGCSessionInfo_CMsgUpdate*
Arena::CreateMaybeMessage< ::CMsgGCUpdateSubGCSessionInfo_CMsgUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCUpdateSubGCSessionInfo_CMsgUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCUpdateSubGCSessionInfo*
Arena::CreateMaybeMessage< ::CMsgGCUpdateSubGCSessionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCUpdateSubGCSessionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCRequestSubGCSessionInfo*
Arena::CreateMaybeMessage< ::CMsgGCRequestSubGCSessionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCRequestSubGCSessionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCRequestSubGCSessionInfoResponse*
Arena::CreateMaybeMessage< ::CMsgGCRequestSubGCSessionInfoResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCRequestSubGCSessionInfoResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSOCacheHaveVersion*
Arena::CreateMaybeMessage< ::CMsgSOCacheHaveVersion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSOCacheHaveVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientHello*
Arena::CreateMaybeMessage< ::CMsgClientHello >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientHello >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientWelcome_Location*
Arena::CreateMaybeMessage< ::CMsgClientWelcome_Location >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientWelcome_Location >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientWelcome*
Arena::CreateMaybeMessage< ::CMsgClientWelcome >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientWelcome >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgConnectionStatus*
Arena::CreateMaybeMessage< ::CMsgConnectionStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgConnectionStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions*
Arena::CreateMaybeMessage< ::CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCSOCacheSubscribe*
Arena::CreateMaybeMessage< ::CMsgGCToGCSOCacheSubscribe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCSOCacheSubscribe >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCSOCacheUnsubscribe*
Arena::CreateMaybeMessage< ::CMsgGCToGCSOCacheUnsubscribe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCSOCacheUnsubscribe >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCClientPing*
Arena::CreateMaybeMessage< ::CMsgGCClientPing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCClientPing >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCForwardAccountDetails*
Arena::CreateMaybeMessage< ::CMsgGCToGCForwardAccountDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCForwardAccountDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCLoadSessionSOCache*
Arena::CreateMaybeMessage< ::CMsgGCToGCLoadSessionSOCache >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCLoadSessionSOCache >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCLoadSessionSOCacheResponse*
Arena::CreateMaybeMessage< ::CMsgGCToGCLoadSessionSOCacheResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCLoadSessionSOCacheResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCUpdateSessionStats*
Arena::CreateMaybeMessage< ::CMsgGCToGCUpdateSessionStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCUpdateSessionStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToClientRequestDropped*
Arena::CreateMaybeMessage< ::CMsgGCToClientRequestDropped >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToClientRequestDropped >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription*
Arena::CreateMaybeMessage< ::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock*
Arena::CreateMaybeMessage< ::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_PopulateItemDescriptions_Request*
Arena::CreateMaybeMessage< ::CWorkshop_PopulateItemDescriptions_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_PopulateItemDescriptions_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_GetContributors_Request*
Arena::CreateMaybeMessage< ::CWorkshop_GetContributors_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_GetContributors_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_GetContributors_Response*
Arena::CreateMaybeMessage< ::CWorkshop_GetContributors_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_GetContributors_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule*
Arena::CreateMaybeMessage< ::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule*
Arena::CreateMaybeMessage< ::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule*
Arena::CreateMaybeMessage< ::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_SetItemPaymentRules_Request*
Arena::CreateMaybeMessage< ::CWorkshop_SetItemPaymentRules_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_SetItemPaymentRules_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CWorkshop_SetItemPaymentRules_Response*
Arena::CreateMaybeMessage< ::CWorkshop_SetItemPaymentRules_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CWorkshop_SetItemPaymentRules_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CCommunity_ClanAnnouncementInfo*
Arena::CreateMaybeMessage< ::CCommunity_ClanAnnouncementInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCommunity_ClanAnnouncementInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CCommunity_GetClanAnnouncements_Request*
Arena::CreateMaybeMessage< ::CCommunity_GetClanAnnouncements_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCommunity_GetClanAnnouncements_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CCommunity_GetClanAnnouncements_Response*
Arena::CreateMaybeMessage< ::CCommunity_GetClanAnnouncements_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCommunity_GetClanAnnouncements_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CBroadcast_PostGameDataFrame_Request*
Arena::CreateMaybeMessage< ::CBroadcast_PostGameDataFrame_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CBroadcast_PostGameDataFrame_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSerializedSOCache_TypeCache*
Arena::CreateMaybeMessage< ::CMsgSerializedSOCache_TypeCache >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSerializedSOCache_TypeCache >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSerializedSOCache_Cache_Version*
Arena::CreateMaybeMessage< ::CMsgSerializedSOCache_Cache_Version >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSerializedSOCache_Cache_Version >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSerializedSOCache_Cache*
Arena::CreateMaybeMessage< ::CMsgSerializedSOCache_Cache >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSerializedSOCache_Cache >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSerializedSOCache*
Arena::CreateMaybeMessage< ::CMsgSerializedSOCache >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSerializedSOCache >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToClientPollConvarRequest*
Arena::CreateMaybeMessage< ::CMsgGCToClientPollConvarRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToClientPollConvarRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToClientPollConvarResponse*
Arena::CreateMaybeMessage< ::CMsgGCToClientPollConvarResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToClientPollConvarResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CGCMsgCompressedMsgToClient*
Arena::CreateMaybeMessage< ::CGCMsgCompressedMsgToClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGCMsgCompressedMsgToClient >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCMasterBroadcastMessage*
Arena::CreateMaybeMessage< ::CMsgGCToGCMasterBroadcastMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCMasterBroadcastMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCMasterSubscribeToCache*
Arena::CreateMaybeMessage< ::CMsgGCToGCMasterSubscribeToCache >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCMasterSubscribeToCache >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCMasterSubscribeToCacheResponse*
Arena::CreateMaybeMessage< ::CMsgGCToGCMasterSubscribeToCacheResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCMasterSubscribeToCacheResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCMasterSubscribeToCacheAsync*
Arena::CreateMaybeMessage< ::CMsgGCToGCMasterSubscribeToCacheAsync >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCMasterSubscribeToCacheAsync >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCMasterUnsubscribeFromCache*
Arena::CreateMaybeMessage< ::CMsgGCToGCMasterUnsubscribeFromCache >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCMasterUnsubscribeFromCache >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToGCMasterDestroyCache*
Arena::CreateMaybeMessage< ::CMsgGCToGCMasterDestroyCache >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToGCMasterDestroyCache >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
