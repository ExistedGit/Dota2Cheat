// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_common.proto

#include "dota_gcmessages_common.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CSODOTAGameAccountClient_RoleHandicap::CSODOTAGameAccountClient_RoleHandicap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.role_)*/0u
  , /*decltype(_impl_.handicap_)*/0} {}
struct CSODOTAGameAccountClient_RoleHandicapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSODOTAGameAccountClient_RoleHandicapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSODOTAGameAccountClient_RoleHandicapDefaultTypeInternal() {}
  union {
    CSODOTAGameAccountClient_RoleHandicap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSODOTAGameAccountClient_RoleHandicapDefaultTypeInternal _CSODOTAGameAccountClient_RoleHandicap_default_instance_;
PROTOBUF_CONSTEXPR CSODOTAGameAccountClient::CSODOTAGameAccountClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.role_handicaps_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.wins_)*/0u
  , /*decltype(_impl_.losses_)*/0u
  , /*decltype(_impl_.xp_)*/0u
  , /*decltype(_impl_.level_)*/0u
  , /*decltype(_impl_.initial_skill_)*/0u
  , /*decltype(_impl_.leaver_count_)*/0u
  , /*decltype(_impl_.low_priority_until_date_)*/0u
  , /*decltype(_impl_.prevent_text_chat_until_date_)*/0u
  , /*decltype(_impl_.prevent_voice_until_date_)*/0u
  , /*decltype(_impl_.last_abandoned_game_date_)*/0u
  , /*decltype(_impl_.leaver_penalty_count_)*/0u
  , /*decltype(_impl_.completed_game_streak_)*/0u
  , /*decltype(_impl_.account_disabled_until_date_)*/0u
  , /*decltype(_impl_.account_disabled_count_)*/0u
  , /*decltype(_impl_.match_disabled_until_date_)*/0u
  , /*decltype(_impl_.match_disabled_count_)*/0u
  , /*decltype(_impl_.shutdownlawterminatetimestamp_)*/0u
  , /*decltype(_impl_.low_priority_games_remaining_)*/0u
  , /*decltype(_impl_.competitive_rank_)*/0u
  , /*decltype(_impl_.competitive_calibration_games_remaining_)*/0u
  , /*decltype(_impl_.recruitment_level_)*/0u
  , /*decltype(_impl_.secondary_leaver_count_)*/0u
  , /*decltype(_impl_.last_secondary_abandoned_game_date_)*/0u
  , /*decltype(_impl_.casual_games_played_)*/0u
  , /*decltype(_impl_.solo_competitive_games_played_)*/0u
  , /*decltype(_impl_.party_competitive_games_played_)*/0u
  , /*decltype(_impl_.has_new_notifications_)*/false
  , /*decltype(_impl_.is_league_admin_)*/false
  , /*decltype(_impl_.player_behavior_report_old_data_)*/false
  , /*decltype(_impl_.casual_1v1_games_played_)*/0u
  , /*decltype(_impl_.curr_all_hero_challenge_id_)*/0u
  , /*decltype(_impl_.play_time_points_)*/0u
  , /*decltype(_impl_.account_flags_)*/0u
  , /*decltype(_impl_.play_time_level_)*/0u
  , /*decltype(_impl_.player_behavior_seq_num_last_report_)*/0u
  , /*decltype(_impl_.player_behavior_score_last_report_)*/0u
  , /*decltype(_impl_.tourney_skill_level_)*/0u
  , /*decltype(_impl_.tourney_recent_participation_date_)*/0u
  , /*decltype(_impl_.prevent_public_text_chat_until_date_)*/0u
  , /*decltype(_impl_.anchored_phone_number_id_)*/uint64_t{0u}
  , /*decltype(_impl_.ranked_matchmaking_ban_until_date_)*/0u
  , /*decltype(_impl_.recent_game_time_1_)*/0u
  , /*decltype(_impl_.recent_game_time_2_)*/0u
  , /*decltype(_impl_.recent_game_time_3_)*/0u
  , /*decltype(_impl_.favorite_team_packed_)*/uint64_t{0u}
  , /*decltype(_impl_.recent_report_time_)*/0u
  , /*decltype(_impl_.custom_game_disabled_until_date_)*/0u
  , /*decltype(_impl_.recent_win_time_1_)*/0u
  , /*decltype(_impl_.recent_win_time_2_)*/0u
  , /*decltype(_impl_.recent_win_time_3_)*/0u
  , /*decltype(_impl_.coach_rating_)*/0u
  , /*decltype(_impl_.queue_points_)*/0u
  , /*decltype(_impl_.event_mode_recent_time_)*/0u
  , /*decltype(_impl_.mmr_recalibration_time_)*/0u
  , /*decltype(_impl_.prevent_new_player_chat_until_date_)*/0u} {}
struct CSODOTAGameAccountClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSODOTAGameAccountClientDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSODOTAGameAccountClientDefaultTypeInternal() {}
  union {
    CSODOTAGameAccountClient _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSODOTAGameAccountClientDefaultTypeInternal _CSODOTAGameAccountClient_default_instance_;
PROTOBUF_CONSTEXPR CSODOTAGameAccountPlus::CSODOTAGameAccountPlus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.original_start_date_)*/0u
  , /*decltype(_impl_.plus_flags_)*/0u
  , /*decltype(_impl_.plus_status_)*/0u
  , /*decltype(_impl_.prepaid_time_start_)*/0u
  , /*decltype(_impl_.prepaid_time_balance_)*/0u
  , /*decltype(_impl_.steam_agreement_id_)*/uint64_t{0u}
  , /*decltype(_impl_.next_payment_date_)*/0u} {}
struct CSODOTAGameAccountPlusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSODOTAGameAccountPlusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSODOTAGameAccountPlusDefaultTypeInternal() {}
  union {
    CSODOTAGameAccountPlus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSODOTAGameAccountPlusDefaultTypeInternal _CSODOTAGameAccountPlus_default_instance_;
PROTOBUF_CONSTEXPR CMsgLobbyFeaturedGamemodeProgress_AccountProgress::CMsgLobbyFeaturedGamemodeProgress_AccountProgress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.current_value_)*/0u
  , /*decltype(_impl_.max_value_)*/0u} {}
struct CMsgLobbyFeaturedGamemodeProgress_AccountProgressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgLobbyFeaturedGamemodeProgress_AccountProgressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgLobbyFeaturedGamemodeProgress_AccountProgressDefaultTypeInternal() {}
  union {
    CMsgLobbyFeaturedGamemodeProgress_AccountProgress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgLobbyFeaturedGamemodeProgress_AccountProgressDefaultTypeInternal _CMsgLobbyFeaturedGamemodeProgress_AccountProgress_default_instance_;
PROTOBUF_CONSTEXPR CMsgLobbyFeaturedGamemodeProgress::CMsgLobbyFeaturedGamemodeProgress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accounts_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgLobbyFeaturedGamemodeProgressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgLobbyFeaturedGamemodeProgressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgLobbyFeaturedGamemodeProgressDefaultTypeInternal() {}
  union {
    CMsgLobbyFeaturedGamemodeProgress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgLobbyFeaturedGamemodeProgressDefaultTypeInternal _CMsgLobbyFeaturedGamemodeProgress_default_instance_;
PROTOBUF_CONSTEXPR CMsgBattleCupVictory::CMsgBattleCupVictory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.win_date_)*/0u
  , /*decltype(_impl_.valid_until_)*/0u
  , /*decltype(_impl_.skill_level_)*/0u
  , /*decltype(_impl_.tournament_id_)*/0u
  , /*decltype(_impl_.division_id_)*/0u
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.streak_)*/0u
  , /*decltype(_impl_.trophy_id_)*/0u} {}
struct CMsgBattleCupVictoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgBattleCupVictoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgBattleCupVictoryDefaultTypeInternal() {}
  union {
    CMsgBattleCupVictory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgBattleCupVictoryDefaultTypeInternal _CMsgBattleCupVictory_default_instance_;
PROTOBUF_CONSTEXPR CMsgLobbyBattleCupVictoryList::CMsgLobbyBattleCupVictoryList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.winners_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgLobbyBattleCupVictoryListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgLobbyBattleCupVictoryListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgLobbyBattleCupVictoryListDefaultTypeInternal() {}
  union {
    CMsgLobbyBattleCupVictoryList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgLobbyBattleCupVictoryListDefaultTypeInternal _CMsgLobbyBattleCupVictoryList_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTABroadcastNotification::CMsgDOTABroadcastNotification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgDOTABroadcastNotificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTABroadcastNotificationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTABroadcastNotificationDefaultTypeInternal() {}
  union {
    CMsgDOTABroadcastNotification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTABroadcastNotificationDefaultTypeInternal _CMsgDOTABroadcastNotification_default_instance_;
PROTOBUF_CONSTEXPR CProtoItemHeroStatue::CProtoItemHeroStatue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.wearable_)*/{}
  , /*decltype(_impl_.style_)*/{}
  , /*decltype(_impl_.sequence_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.inscription_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.status_effect_index_)*/0u
  , /*decltype(_impl_.cycle_)*/0
  , /*decltype(_impl_.tournament_drop_)*/false} {}
struct CProtoItemHeroStatueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CProtoItemHeroStatueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CProtoItemHeroStatueDefaultTypeInternal() {}
  union {
    CProtoItemHeroStatue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CProtoItemHeroStatueDefaultTypeInternal _CProtoItemHeroStatue_default_instance_;
PROTOBUF_CONSTEXPR CMatchPlayerAbilityUpgrade::CMatchPlayerAbilityUpgrade(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.time_)*/0u
  , /*decltype(_impl_.ability_)*/-1} {}
struct CMatchPlayerAbilityUpgradeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMatchPlayerAbilityUpgradeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMatchPlayerAbilityUpgradeDefaultTypeInternal() {}
  union {
    CMatchPlayerAbilityUpgrade _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMatchPlayerAbilityUpgradeDefaultTypeInternal _CMatchPlayerAbilityUpgrade_default_instance_;
PROTOBUF_CONSTEXPR CMatchPlayerTimedStats::CMatchPlayerTimedStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.time_)*/0u
  , /*decltype(_impl_.kills_)*/0u
  , /*decltype(_impl_.deaths_)*/0u
  , /*decltype(_impl_.assists_)*/0u
  , /*decltype(_impl_.net_worth_)*/0u
  , /*decltype(_impl_.xp_)*/0u
  , /*decltype(_impl_.last_hits_)*/0u
  , /*decltype(_impl_.denies_)*/0u
  , /*decltype(_impl_.bounty_rune_gold_)*/0u
  , /*decltype(_impl_.range_creep_upgrade_gold_)*/0u
  , /*decltype(_impl_.observer_wards_dewarded_)*/0u
  , /*decltype(_impl_.reliable_gold_earned_)*/0u
  , /*decltype(_impl_.gold_loss_prevented_)*/0u
  , /*decltype(_impl_.hero_kill_gold_)*/0u
  , /*decltype(_impl_.creep_kill_gold_)*/0u
  , /*decltype(_impl_.building_gold_)*/0u
  , /*decltype(_impl_.other_gold_)*/0u
  , /*decltype(_impl_.comeback_gold_)*/0u
  , /*decltype(_impl_.experimental_gold_)*/0u
  , /*decltype(_impl_.experimental2_gold_)*/0u
  , /*decltype(_impl_.creep_deny_gold_)*/0u
  , /*decltype(_impl_.tp_scrolls_purchased_1_)*/0u
  , /*decltype(_impl_.tp_scrolls_purchased_2_)*/0u
  , /*decltype(_impl_.tp_scrolls_purchased_3_)*/0u
  , /*decltype(_impl_.tp_scrolls_purchased_4_)*/0u
  , /*decltype(_impl_.tp_scrolls_purchased_5_)*/0u
  , /*decltype(_impl_.neutral_gold_)*/0u
  , /*decltype(_impl_.courier_gold_)*/0u
  , /*decltype(_impl_.roshan_gold_)*/0u
  , /*decltype(_impl_.income_gold_)*/0u
  , /*decltype(_impl_.custom_stats_1_)*/0u
  , /*decltype(_impl_.custom_stats_2_)*/0u
  , /*decltype(_impl_.custom_stats_3_)*/0u
  , /*decltype(_impl_.custom_stats_4_)*/0u
  , /*decltype(_impl_.custom_stats_5_)*/0u
  , /*decltype(_impl_.item_value_)*/0u
  , /*decltype(_impl_.support_gold_spent_)*/0u
  , /*decltype(_impl_.camps_stacked_)*/0u
  , /*decltype(_impl_.wards_placed_)*/0u
  , /*decltype(_impl_.triple_kills_)*/0u
  , /*decltype(_impl_.rampages_)*/0u} {}
struct CMatchPlayerTimedStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMatchPlayerTimedStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMatchPlayerTimedStatsDefaultTypeInternal() {}
  union {
    CMatchPlayerTimedStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMatchPlayerTimedStatsDefaultTypeInternal _CMatchPlayerTimedStats_default_instance_;
PROTOBUF_CONSTEXPR CMatchTeamTimedStats::CMatchTeamTimedStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.time_)*/0u
  , /*decltype(_impl_.enemy_towers_killed_)*/0u
  , /*decltype(_impl_.enemy_barracks_killed_)*/0u
  , /*decltype(_impl_.enemy_towers_status_)*/0u
  , /*decltype(_impl_.enemy_barracks_status_)*/0u} {}
struct CMatchTeamTimedStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMatchTeamTimedStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMatchTeamTimedStatsDefaultTypeInternal() {}
  union {
    CMatchTeamTimedStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMatchTeamTimedStatsDefaultTypeInternal _CMatchTeamTimedStats_default_instance_;
PROTOBUF_CONSTEXPR CMatchAdditionalUnitInventory::CMatchAdditionalUnitInventory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.unit_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMatchAdditionalUnitInventoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMatchAdditionalUnitInventoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMatchAdditionalUnitInventoryDefaultTypeInternal() {}
  union {
    CMatchAdditionalUnitInventory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMatchAdditionalUnitInventoryDefaultTypeInternal _CMatchAdditionalUnitInventory_default_instance_;
PROTOBUF_CONSTEXPR CMatchPlayerPermanentBuff::CMatchPlayerPermanentBuff(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.permanent_buff_)*/0u
  , /*decltype(_impl_.stack_count_)*/0u
  , /*decltype(_impl_.grant_time_)*/0u} {}
struct CMatchPlayerPermanentBuffDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMatchPlayerPermanentBuffDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMatchPlayerPermanentBuffDefaultTypeInternal() {}
  union {
    CMatchPlayerPermanentBuff _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMatchPlayerPermanentBuffDefaultTypeInternal _CMatchPlayerPermanentBuff_default_instance_;
PROTOBUF_CONSTEXPR CMatchHeroSelectEvent::CMatchHeroSelectEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.is_pick_)*/false
  , /*decltype(_impl_.team_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u} {}
struct CMatchHeroSelectEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMatchHeroSelectEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMatchHeroSelectEventDefaultTypeInternal() {}
  union {
    CMatchHeroSelectEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMatchHeroSelectEventDefaultTypeInternal _CMatchHeroSelectEvent_default_instance_;
PROTOBUF_CONSTEXPR CMatchClip::CMatchClip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.player_account_id_)*/0u
  , /*decltype(_impl_.game_time_seconds_)*/0u
  , /*decltype(_impl_.duration_seconds_)*/0u
  , /*decltype(_impl_.player_id_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.camera_mode_)*/0u
  , /*decltype(_impl_.ability_id_)*/-1} {}
struct CMatchClipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMatchClipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMatchClipDefaultTypeInternal() {}
  union {
    CMatchClip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMatchClipDefaultTypeInternal _CMatchClip_default_instance_;
PROTOBUF_CONSTEXPR CPartySearchClientParty::CPartySearchClientParty(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.party_members_)*/{}
  , /*decltype(_impl_.party_id_)*/uint64_t{0u}
  , /*decltype(_impl_.beacon_type_)*/0} {}
struct CPartySearchClientPartyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CPartySearchClientPartyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CPartySearchClientPartyDefaultTypeInternal() {}
  union {
    CPartySearchClientParty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CPartySearchClientPartyDefaultTypeInternal _CPartySearchClientParty_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAHasItemQuery::CMsgDOTAHasItemQuery(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.account_id_)*/0u} {}
struct CMsgDOTAHasItemQueryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAHasItemQueryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAHasItemQueryDefaultTypeInternal() {}
  union {
    CMsgDOTAHasItemQuery _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAHasItemQueryDefaultTypeInternal _CMsgDOTAHasItemQuery_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAHasItemResponse::CMsgDOTAHasItemResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.has_item_)*/false} {}
struct CMsgDOTAHasItemResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAHasItemResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAHasItemResponseDefaultTypeInternal() {}
  union {
    CMsgDOTAHasItemResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAHasItemResponseDefaultTypeInternal _CMsgDOTAHasItemResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCGetPlayerCardItemInfo::CMsgGCGetPlayerCardItemInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_card_item_ids_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.all_for_event_)*/0u} {}
struct CMsgGCGetPlayerCardItemInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGetPlayerCardItemInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGetPlayerCardItemInfoDefaultTypeInternal() {}
  union {
    CMsgGCGetPlayerCardItemInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGetPlayerCardItemInfoDefaultTypeInternal _CMsgGCGetPlayerCardItemInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_card_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.packed_bonuses_)*/uint64_t{0u}
  , /*decltype(_impl_.account_id_)*/0u} {}
struct CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfoDefaultTypeInternal() {}
  union {
    CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfoDefaultTypeInternal _CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCGetPlayerCardItemInfoResponse::CMsgGCGetPlayerCardItemInfoResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.player_card_infos_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGCGetPlayerCardItemInfoResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCGetPlayerCardItemInfoResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCGetPlayerCardItemInfoResponseDefaultTypeInternal() {}
  union {
    CMsgGCGetPlayerCardItemInfoResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCGetPlayerCardItemInfoResponseDefaultTypeInternal _CMsgGCGetPlayerCardItemInfoResponse_default_instance_;
PROTOBUF_CONSTEXPR CSODOTAMapLocationState::CSODOTAMapLocationState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.location_id_)*/0
  , /*decltype(_impl_.completed_)*/false} {}
struct CSODOTAMapLocationStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSODOTAMapLocationStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSODOTAMapLocationStateDefaultTypeInternal() {}
  union {
    CSODOTAMapLocationState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSODOTAMapLocationStateDefaultTypeInternal _CSODOTAMapLocationState_default_instance_;
PROTOBUF_CONSTEXPR CMsgLeagueAdminList::CMsgLeagueAdminList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgLeagueAdminListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgLeagueAdminListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgLeagueAdminListDefaultTypeInternal() {}
  union {
    CMsgLeagueAdminList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgLeagueAdminListDefaultTypeInternal _CMsgLeagueAdminList_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot_Trophy::CMsgDOTAProfileCard_Slot_Trophy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.trophy_id_)*/0u
  , /*decltype(_impl_.trophy_score_)*/0u} {}
struct CMsgDOTAProfileCard_Slot_TrophyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot_TrophyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAProfileCard_Slot_TrophyDefaultTypeInternal() {}
  union {
    CMsgDOTAProfileCard_Slot_Trophy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAProfileCard_Slot_TrophyDefaultTypeInternal _CMsgDOTAProfileCard_Slot_Trophy_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot_Stat::CMsgDOTAProfileCard_Slot_Stat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stat_score_)*/0u
  , /*decltype(_impl_.stat_id_)*/3} {}
struct CMsgDOTAProfileCard_Slot_StatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot_StatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAProfileCard_Slot_StatDefaultTypeInternal() {}
  union {
    CMsgDOTAProfileCard_Slot_Stat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAProfileCard_Slot_StatDefaultTypeInternal _CMsgDOTAProfileCard_Slot_Stat_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot_Item::CMsgDOTAProfileCard_Slot_Item(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.serialized_item_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}} {}
struct CMsgDOTAProfileCard_Slot_ItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot_ItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAProfileCard_Slot_ItemDefaultTypeInternal() {}
  union {
    CMsgDOTAProfileCard_Slot_Item _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAProfileCard_Slot_ItemDefaultTypeInternal _CMsgDOTAProfileCard_Slot_Item_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot_Hero::CMsgDOTAProfileCard_Slot_Hero(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.hero_wins_)*/0u
  , /*decltype(_impl_.hero_losses_)*/0u} {}
struct CMsgDOTAProfileCard_Slot_HeroDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot_HeroDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAProfileCard_Slot_HeroDefaultTypeInternal() {}
  union {
    CMsgDOTAProfileCard_Slot_Hero _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAProfileCard_Slot_HeroDefaultTypeInternal _CMsgDOTAProfileCard_Slot_Hero_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot_Emoticon::CMsgDOTAProfileCard_Slot_Emoticon(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.emoticon_id_)*/0u} {}
struct CMsgDOTAProfileCard_Slot_EmoticonDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot_EmoticonDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAProfileCard_Slot_EmoticonDefaultTypeInternal() {}
  union {
    CMsgDOTAProfileCard_Slot_Emoticon _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAProfileCard_Slot_EmoticonDefaultTypeInternal _CMsgDOTAProfileCard_Slot_Emoticon_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot_Team::CMsgDOTAProfileCard_Slot_Team(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.team_id_)*/0u} {}
struct CMsgDOTAProfileCard_Slot_TeamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot_TeamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAProfileCard_Slot_TeamDefaultTypeInternal() {}
  union {
    CMsgDOTAProfileCard_Slot_Team _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAProfileCard_Slot_TeamDefaultTypeInternal _CMsgDOTAProfileCard_Slot_Team_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_Slot::CMsgDOTAProfileCard_Slot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.trophy_)*/nullptr
  , /*decltype(_impl_.stat_)*/nullptr
  , /*decltype(_impl_.item_)*/nullptr
  , /*decltype(_impl_.hero_)*/nullptr
  , /*decltype(_impl_.emoticon_)*/nullptr
  , /*decltype(_impl_.team_)*/nullptr
  , /*decltype(_impl_.slot_id_)*/0u} {}
struct CMsgDOTAProfileCard_SlotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAProfileCard_SlotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAProfileCard_SlotDefaultTypeInternal() {}
  union {
    CMsgDOTAProfileCard_Slot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAProfileCard_SlotDefaultTypeInternal _CMsgDOTAProfileCard_Slot_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAProfileCard::CMsgDOTAProfileCard(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.slots_)*/{}
  , /*decltype(_impl_.recent_battle_cup_victory_)*/nullptr
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.badge_points_)*/0u
  , /*decltype(_impl_.event_points_)*/0u
  , /*decltype(_impl_.event_id_)*/0u
  , /*decltype(_impl_.rank_tier_)*/0u
  , /*decltype(_impl_.leaderboard_rank_)*/0u
  , /*decltype(_impl_.is_plus_subscriber_)*/false
  , /*decltype(_impl_.plus_original_start_date_)*/0u
  , /*decltype(_impl_.rank_tier_score_)*/0u
  , /*decltype(_impl_.leaderboard_rank_core_)*/0u
  , /*decltype(_impl_.favorite_team_packed_)*/uint64_t{0u}
  , /*decltype(_impl_.title_)*/0u
  , /*decltype(_impl_.lifetime_games_)*/0u} {}
struct CMsgDOTAProfileCardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAProfileCardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAProfileCardDefaultTypeInternal() {}
  union {
    CMsgDOTAProfileCard _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAProfileCardDefaultTypeInternal _CMsgDOTAProfileCard_default_instance_;
PROTOBUF_CONSTEXPR CSODOTAPlayerChallenge::CSODOTAPlayerChallenge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.event_id_)*/0u
  , /*decltype(_impl_.slot_id_)*/0u
  , /*decltype(_impl_.int_param_0_)*/0u
  , /*decltype(_impl_.int_param_1_)*/0u
  , /*decltype(_impl_.created_time_)*/0u
  , /*decltype(_impl_.completed_)*/0u
  , /*decltype(_impl_.sequence_id_)*/0u
  , /*decltype(_impl_.challenge_tier_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.attempts_)*/0u
  , /*decltype(_impl_.complete_limit_)*/0u
  , /*decltype(_impl_.quest_rank_)*/0u
  , /*decltype(_impl_.max_quest_rank_)*/0u
  , /*decltype(_impl_.instance_id_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.template_id_)*/0u} {}
struct CSODOTAPlayerChallengeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSODOTAPlayerChallengeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSODOTAPlayerChallengeDefaultTypeInternal() {}
  union {
    CSODOTAPlayerChallenge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSODOTAPlayerChallengeDefaultTypeInternal _CSODOTAPlayerChallenge_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCRerollPlayerChallenge::CMsgClientToGCRerollPlayerChallenge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.event_id_)*/0
  , /*decltype(_impl_.sequence_id_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u} {}
struct CMsgClientToGCRerollPlayerChallengeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCRerollPlayerChallengeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCRerollPlayerChallengeDefaultTypeInternal() {}
  union {
    CMsgClientToGCRerollPlayerChallenge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCRerollPlayerChallengeDefaultTypeInternal _CMsgClientToGCRerollPlayerChallenge_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCRerollPlayerChallengeResponse::CMsgGCRerollPlayerChallengeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct CMsgGCRerollPlayerChallengeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCRerollPlayerChallengeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCRerollPlayerChallengeResponseDefaultTypeInternal() {}
  union {
    CMsgGCRerollPlayerChallengeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCRerollPlayerChallengeResponseDefaultTypeInternal _CMsgGCRerollPlayerChallengeResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCTopCustomGamesList::CMsgGCTopCustomGamesList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.top_custom_games_)*/{}
  , /*decltype(_impl_.game_of_the_day_)*/uint64_t{0u}} {}
struct CMsgGCTopCustomGamesListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCTopCustomGamesListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCTopCustomGamesListDefaultTypeInternal() {}
  union {
    CMsgGCTopCustomGamesList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCTopCustomGamesListDefaultTypeInternal _CMsgGCTopCustomGamesList_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_TeamDetails::CMsgDOTARealtimeGameStats_TeamDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_.team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_logo_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_number_)*/0u
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.team_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.score_)*/0u
  , /*decltype(_impl_.only_team_)*/false
  , /*decltype(_impl_.cheers_)*/0u
  , /*decltype(_impl_.net_worth_)*/0u} {}
struct CMsgDOTARealtimeGameStats_TeamDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_TeamDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_TeamDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_TeamDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_TeamDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStats_TeamDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_ItemDetails::CMsgDOTARealtimeGameStats_ItemDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.time_)*/0
  , /*decltype(_impl_.sold_)*/false
  , /*decltype(_impl_.stackcount_)*/0u
  , /*decltype(_impl_.item_ability_id_)*/-1} {}
struct CMsgDOTARealtimeGameStats_ItemDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_ItemDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_ItemDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_ItemDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_ItemDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStats_ItemDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_AbilityDetails::CMsgDOTARealtimeGameStats_AbilityDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.level_)*/0u
  , /*decltype(_impl_.cooldown_)*/0
  , /*decltype(_impl_.cooldown_max_)*/0
  , /*decltype(_impl_.id_)*/-1} {}
struct CMsgDOTARealtimeGameStats_AbilityDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_AbilityDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_AbilityDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_AbilityDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_AbilityDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStats_AbilityDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_HeroToHeroStats::CMsgDOTARealtimeGameStats_HeroToHeroStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.kills_)*/0u
  , /*decltype(_impl_.assists_)*/0u
  , /*decltype(_impl_.victimid_)*/-1} {}
struct CMsgDOTARealtimeGameStats_HeroToHeroStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_HeroToHeroStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_HeroToHeroStatsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_HeroToHeroStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_HeroToHeroStatsDefaultTypeInternal _CMsgDOTARealtimeGameStats_HeroToHeroStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_AbilityList::CMsgDOTARealtimeGameStats_AbilityList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTARealtimeGameStats_AbilityListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_AbilityListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_AbilityListDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_AbilityList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_AbilityListDefaultTypeInternal _CMsgDOTARealtimeGameStats_AbilityList_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_PlayerDetails::CMsgDOTARealtimeGameStats_PlayerDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.abilities_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.stashitems_)*/{}
  , /*decltype(_impl_.itemshoppinglist_)*/{}
  , /*decltype(_impl_.levelpoints_)*/{}
  , /*decltype(_impl_.hero_to_hero_stats_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.accountid_)*/0u
  , /*decltype(_impl_.team_)*/0u
  , /*decltype(_impl_.heroid_)*/0u
  , /*decltype(_impl_.healthpoints_)*/0u
  , /*decltype(_impl_.maxhealthpoints_)*/0u
  , /*decltype(_impl_.healthregenrate_)*/0
  , /*decltype(_impl_.manapoints_)*/0u
  , /*decltype(_impl_.maxmanapoints_)*/0u
  , /*decltype(_impl_.manaregenrate_)*/0
  , /*decltype(_impl_.base_strength_)*/0u
  , /*decltype(_impl_.base_agility_)*/0u
  , /*decltype(_impl_.base_intelligence_)*/0u
  , /*decltype(_impl_.base_armor_)*/0
  , /*decltype(_impl_.base_movespeed_)*/0u
  , /*decltype(_impl_.base_damage_)*/0u
  , /*decltype(_impl_.strength_)*/0u
  , /*decltype(_impl_.agility_)*/0u
  , /*decltype(_impl_.intelligence_)*/0u
  , /*decltype(_impl_.armor_)*/0
  , /*decltype(_impl_.movespeed_)*/0u
  , /*decltype(_impl_.damage_)*/0u
  , /*decltype(_impl_.hero_damage_)*/0u
  , /*decltype(_impl_.tower_damage_)*/0u
  , /*decltype(_impl_.level_)*/0u
  , /*decltype(_impl_.kill_count_)*/0u
  , /*decltype(_impl_.death_count_)*/0u
  , /*decltype(_impl_.assists_count_)*/0u
  , /*decltype(_impl_.denies_count_)*/0u
  , /*decltype(_impl_.lh_count_)*/0u
  , /*decltype(_impl_.hero_healing_)*/0u
  , /*decltype(_impl_.gold_per_min_)*/0u
  , /*decltype(_impl_.xp_per_min_)*/0u
  , /*decltype(_impl_.net_gold_)*/0u
  , /*decltype(_impl_.gold_)*/0u
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.respawn_time_)*/0
  , /*decltype(_impl_.ultimate_cooldown_)*/0u
  , /*decltype(_impl_.has_buyback_)*/false
  , /*decltype(_impl_.has_ultimate_)*/false
  , /*decltype(_impl_.has_ultimate_mana_)*/false
  , /*decltype(_impl_.playerid_)*/-1} {}
struct CMsgDOTARealtimeGameStats_PlayerDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_PlayerDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_PlayerDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_PlayerDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_PlayerDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStats_PlayerDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_BuildingDetails::CMsgDOTARealtimeGameStats_BuildingDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.team_)*/0u
  , /*decltype(_impl_.heading_)*/0
  , /*decltype(_impl_.lane_)*/0u
  , /*decltype(_impl_.tier_)*/0u
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.destroyed_)*/false} {}
struct CMsgDOTARealtimeGameStats_BuildingDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_BuildingDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_BuildingDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_BuildingDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_BuildingDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStats_BuildingDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_KillDetails::CMsgDOTARealtimeGameStats_KillDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.death_time_)*/0
  , /*decltype(_impl_.player_id_)*/-1
  , /*decltype(_impl_.killer_player_id_)*/-1} {}
struct CMsgDOTARealtimeGameStats_KillDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_KillDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_KillDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_KillDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_KillDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStats_KillDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_BroadcasterDetails::CMsgDOTARealtimeGameStats_BroadcasterDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/-1} {}
struct CMsgDOTARealtimeGameStats_BroadcasterDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_BroadcasterDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_BroadcasterDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_BroadcasterDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_BroadcasterDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStats_BroadcasterDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_PickBanDetails::CMsgDOTARealtimeGameStats_PickBanDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hero_)*/0u
  , /*decltype(_impl_.team_)*/0u} {}
struct CMsgDOTARealtimeGameStats_PickBanDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_PickBanDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_PickBanDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_PickBanDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_PickBanDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStats_PickBanDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_MatchDetails::CMsgDOTARealtimeGameStats_MatchDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.picks_)*/{}
  , /*decltype(_impl_.bans_)*/{}
  , /*decltype(_impl_.kills_)*/{}
  , /*decltype(_impl_.broadcasters_)*/{}
  , /*decltype(_impl_.server_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.timestamp_)*/0u
  , /*decltype(_impl_.time_of_day_)*/0
  , /*decltype(_impl_.game_time_)*/0
  , /*decltype(_impl_.teamid_radiant_)*/0u
  , /*decltype(_impl_.teamid_dire_)*/0u
  , /*decltype(_impl_.is_nightstalker_night_)*/false
  , /*decltype(_impl_.single_team_)*/false
  , /*decltype(_impl_.game_mode_)*/0u
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.cheers_peak_)*/0u
  , /*decltype(_impl_.league_node_id_)*/0u
  , /*decltype(_impl_.game_state_)*/0u
  , /*decltype(_impl_.lobby_type_)*/0u
  , /*decltype(_impl_.start_timestamp_)*/0u} {}
struct CMsgDOTARealtimeGameStats_MatchDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_MatchDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_MatchDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_MatchDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_MatchDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStats_MatchDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_GraphData_LocationStats::CMsgDOTARealtimeGameStats_GraphData_LocationStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stats_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTARealtimeGameStats_GraphData_LocationStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_GraphData_LocationStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_GraphData_LocationStatsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_GraphData_LocationStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_GraphData_LocationStatsDefaultTypeInternal _CMsgDOTARealtimeGameStats_GraphData_LocationStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.loc_stats_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTARealtimeGameStats_GraphData_TeamLocationStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_GraphData_TeamLocationStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_GraphData_TeamLocationStatsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_GraphData_TeamLocationStatsDefaultTypeInternal _CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_GraphData::CMsgDOTARealtimeGameStats_GraphData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.graph_gold_)*/{}
  , /*decltype(_impl_.graph_xp_)*/{}
  , /*decltype(_impl_.graph_kill_)*/{}
  , /*decltype(_impl_.graph_tower_)*/{}
  , /*decltype(_impl_.graph_rax_)*/{}
  , /*decltype(_impl_.team_loc_stats_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTARealtimeGameStats_GraphDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats_GraphDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStats_GraphDataDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats_GraphData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStats_GraphDataDefaultTypeInternal _CMsgDOTARealtimeGameStats_GraphData_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStats::CMsgDOTARealtimeGameStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.teams_)*/{}
  , /*decltype(_impl_.buildings_)*/{}
  , /*decltype(_impl_.match_)*/nullptr
  , /*decltype(_impl_.graph_data_)*/nullptr
  , /*decltype(_impl_.delta_frame_)*/false} {}
struct CMsgDOTARealtimeGameStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStatsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStatsDefaultTypeInternal _CMsgDOTARealtimeGameStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse_TeamDetails::CMsgDOTARealtimeGameStatsTerse_TeamDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_.team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_logo_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_number_)*/0u
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.team_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.score_)*/0u
  , /*decltype(_impl_.net_worth_)*/0u} {}
struct CMsgDOTARealtimeGameStatsTerse_TeamDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse_TeamDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStatsTerse_TeamDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStatsTerse_TeamDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStatsTerse_TeamDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStatsTerse_TeamDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse_PlayerDetails::CMsgDOTARealtimeGameStatsTerse_PlayerDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.abilities_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.accountid_)*/0u
  , /*decltype(_impl_.team_)*/0u
  , /*decltype(_impl_.heroid_)*/0u
  , /*decltype(_impl_.level_)*/0u
  , /*decltype(_impl_.kill_count_)*/0u
  , /*decltype(_impl_.death_count_)*/0u
  , /*decltype(_impl_.assists_count_)*/0u
  , /*decltype(_impl_.denies_count_)*/0u
  , /*decltype(_impl_.lh_count_)*/0u
  , /*decltype(_impl_.gold_)*/0u
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.net_worth_)*/0u
  , /*decltype(_impl_.playerid_)*/-1} {}
struct CMsgDOTARealtimeGameStatsTerse_PlayerDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse_PlayerDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStatsTerse_PlayerDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStatsTerse_PlayerDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStatsTerse_PlayerDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStatsTerse_PlayerDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse_BuildingDetails::CMsgDOTARealtimeGameStatsTerse_BuildingDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.team_)*/0u
  , /*decltype(_impl_.heading_)*/0
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.lane_)*/0u
  , /*decltype(_impl_.tier_)*/0u
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.destroyed_)*/false} {}
struct CMsgDOTARealtimeGameStatsTerse_BuildingDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse_BuildingDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStatsTerse_BuildingDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStatsTerse_BuildingDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStatsTerse_BuildingDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStatsTerse_BuildingDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse_PickBanDetails::CMsgDOTARealtimeGameStatsTerse_PickBanDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hero_)*/0u
  , /*decltype(_impl_.team_)*/0u} {}
struct CMsgDOTARealtimeGameStatsTerse_PickBanDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse_PickBanDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStatsTerse_PickBanDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStatsTerse_PickBanDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStatsTerse_PickBanDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStatsTerse_PickBanDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse_MatchDetails::CMsgDOTARealtimeGameStatsTerse_MatchDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steam_broadcaster_account_ids_)*/{}
  , /*decltype(_impl_.picks_)*/{}
  , /*decltype(_impl_.bans_)*/{}
  , /*decltype(_impl_.server_steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.timestamp_)*/0u
  , /*decltype(_impl_.game_time_)*/0
  , /*decltype(_impl_.game_mode_)*/0u
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.league_node_id_)*/0u
  , /*decltype(_impl_.game_state_)*/0u
  , /*decltype(_impl_.lobby_type_)*/0u
  , /*decltype(_impl_.start_timestamp_)*/0u} {}
struct CMsgDOTARealtimeGameStatsTerse_MatchDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse_MatchDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStatsTerse_MatchDetailsDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStatsTerse_MatchDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStatsTerse_MatchDetailsDefaultTypeInternal _CMsgDOTARealtimeGameStatsTerse_MatchDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse_GraphData::CMsgDOTARealtimeGameStatsTerse_GraphData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.graph_gold_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTARealtimeGameStatsTerse_GraphDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse_GraphDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStatsTerse_GraphDataDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStatsTerse_GraphData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStatsTerse_GraphDataDefaultTypeInternal _CMsgDOTARealtimeGameStatsTerse_GraphData_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerse::CMsgDOTARealtimeGameStatsTerse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.teams_)*/{}
  , /*decltype(_impl_.buildings_)*/{}
  , /*decltype(_impl_.match_)*/nullptr
  , /*decltype(_impl_.graph_data_)*/nullptr
  , /*decltype(_impl_.delta_frame_)*/false} {}
struct CMsgDOTARealtimeGameStatsTerseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTARealtimeGameStatsTerseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTARealtimeGameStatsTerseDefaultTypeInternal() {}
  union {
    CMsgDOTARealtimeGameStatsTerse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTARealtimeGameStatsTerseDefaultTypeInternal _CMsgDOTARealtimeGameStatsTerse_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTABroadcastTimelineEvent::CMsgDOTABroadcastTimelineEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.string_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/0u
  , /*decltype(_impl_.data_)*/0u
  , /*decltype(_impl_.event_)*/1} {}
struct CMsgDOTABroadcastTimelineEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTABroadcastTimelineEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTABroadcastTimelineEventDefaultTypeInternal() {}
  union {
    CMsgDOTABroadcastTimelineEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTABroadcastTimelineEventDefaultTypeInternal _CMsgDOTABroadcastTimelineEvent_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToClientMatchGroupsVersion::CMsgGCToClientMatchGroupsVersion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.matchgroups_version_)*/0u} {}
struct CMsgGCToClientMatchGroupsVersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToClientMatchGroupsVersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToClientMatchGroupsVersionDefaultTypeInternal() {}
  union {
    CMsgGCToClientMatchGroupsVersion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToClientMatchGroupsVersionDefaultTypeInternal _CMsgGCToClientMatchGroupsVersion_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTASDOHeroStatsHistory::CMsgDOTASDOHeroStatsHistory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.game_mode_)*/0u
  , /*decltype(_impl_.lobby_type_)*/0u
  , /*decltype(_impl_.start_time_)*/0u
  , /*decltype(_impl_.won_)*/false
  , /*decltype(_impl_.gpm_)*/0u
  , /*decltype(_impl_.xpm_)*/0u
  , /*decltype(_impl_.kills_)*/0u
  , /*decltype(_impl_.deaths_)*/0u
  , /*decltype(_impl_.assists_)*/0u} {}
struct CMsgDOTASDOHeroStatsHistoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTASDOHeroStatsHistoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTASDOHeroStatsHistoryDefaultTypeInternal() {}
  union {
    CMsgDOTASDOHeroStatsHistory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTASDOHeroStatsHistoryDefaultTypeInternal _CMsgDOTASDOHeroStatsHistory_default_instance_;
PROTOBUF_CONSTEXPR CMsgPredictionChoice::CMsgPredictionChoice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/0u
  , /*decltype(_impl_.min_raw_value_)*/0u
  , /*decltype(_impl_.max_raw_value_)*/0u} {}
struct CMsgPredictionChoiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPredictionChoiceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPredictionChoiceDefaultTypeInternal() {}
  union {
    CMsgPredictionChoice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPredictionChoiceDefaultTypeInternal _CMsgPredictionChoice_default_instance_;
PROTOBUF_CONSTEXPR CMsgInGamePrediction_QueryKeyValues::CMsgInGamePrediction_QueryKeyValues(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgInGamePrediction_QueryKeyValuesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgInGamePrediction_QueryKeyValuesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgInGamePrediction_QueryKeyValuesDefaultTypeInternal() {}
  union {
    CMsgInGamePrediction_QueryKeyValues _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgInGamePrediction_QueryKeyValuesDefaultTypeInternal _CMsgInGamePrediction_QueryKeyValues_default_instance_;
PROTOBUF_CONSTEXPR CMsgInGamePrediction::CMsgInGamePrediction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.choices_)*/{}
  , /*decltype(_impl_.required_heroes_)*/{}
  , /*decltype(_impl_.query_values_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.question_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.query_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.group_)*/0
  , /*decltype(_impl_.answer_resolution_type_)*/0
  , /*decltype(_impl_.points_to_grant_)*/0u
  , /*decltype(_impl_.reward_action_)*/0u
  , /*decltype(_impl_.debug_force_selection_)*/0u
  , /*decltype(_impl_.raw_value_type_)*/0} {}
struct CMsgInGamePredictionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgInGamePredictionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgInGamePredictionDefaultTypeInternal() {}
  union {
    CMsgInGamePrediction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgInGamePredictionDefaultTypeInternal _CMsgInGamePrediction_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTASeasonPredictions_Prediction_Answers::CMsgDOTASeasonPredictions_Prediction_Answers(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.answer_id_)*/0u} {}
struct CMsgDOTASeasonPredictions_Prediction_AnswersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTASeasonPredictions_Prediction_AnswersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTASeasonPredictions_Prediction_AnswersDefaultTypeInternal() {}
  union {
    CMsgDOTASeasonPredictions_Prediction_Answers _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTASeasonPredictions_Prediction_AnswersDefaultTypeInternal _CMsgDOTASeasonPredictions_Prediction_Answers_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTASeasonPredictions_Prediction::CMsgDOTASeasonPredictions_Prediction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.choices_)*/{}
  , /*decltype(_impl_.answers_)*/{}
  , /*decltype(_impl_.phases_)*/{}
  , /*decltype(_impl_.question_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.query_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.selection_id_)*/0u
  , /*decltype(_impl_.start_date_)*/0u
  , /*decltype(_impl_.lock_date_)*/0u
  , /*decltype(_impl_.reward_)*/0u
  , /*decltype(_impl_.answer_type_)*/0
  , /*decltype(_impl_.answer_id_)*/0u
  , /*decltype(_impl_.lock_on_selection_id_)*/0u
  , /*decltype(_impl_.lock_on_selection_value_)*/0u
  , /*decltype(_impl_.lock_on_selection_set_)*/false
  , /*decltype(_impl_.use_answer_value_ranges_)*/false
  , /*decltype(_impl_.region_)*/0
  , /*decltype(_impl_.reward_event_)*/0} {}
struct CMsgDOTASeasonPredictions_PredictionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTASeasonPredictions_PredictionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTASeasonPredictions_PredictionDefaultTypeInternal() {}
  union {
    CMsgDOTASeasonPredictions_Prediction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTASeasonPredictions_PredictionDefaultTypeInternal _CMsgDOTASeasonPredictions_Prediction_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTASeasonPredictions::CMsgDOTASeasonPredictions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.predictions_)*/{}
  , /*decltype(_impl_.in_game_predictions_)*/{}
  , /*decltype(_impl_.in_game_prediction_count_per_game_)*/0u
  , /*decltype(_impl_.in_game_prediction_voting_period_minutes_)*/0u} {}
struct CMsgDOTASeasonPredictionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTASeasonPredictionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTASeasonPredictionsDefaultTypeInternal() {}
  union {
    CMsgDOTASeasonPredictions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTASeasonPredictionsDefaultTypeInternal _CMsgDOTASeasonPredictions_default_instance_;
PROTOBUF_CONSTEXPR CMsgAvailablePredictions_MatchPrediction::CMsgAvailablePredictions_MatchPrediction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.predictions_)*/{}
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}} {}
struct CMsgAvailablePredictions_MatchPredictionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAvailablePredictions_MatchPredictionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAvailablePredictions_MatchPredictionDefaultTypeInternal() {}
  union {
    CMsgAvailablePredictions_MatchPrediction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAvailablePredictions_MatchPredictionDefaultTypeInternal _CMsgAvailablePredictions_MatchPrediction_default_instance_;
PROTOBUF_CONSTEXPR CMsgAvailablePredictions::CMsgAvailablePredictions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.match_predictions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgAvailablePredictionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAvailablePredictionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAvailablePredictionsDefaultTypeInternal() {}
  union {
    CMsgAvailablePredictions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAvailablePredictionsDefaultTypeInternal _CMsgAvailablePredictions_default_instance_;
PROTOBUF_CONSTEXPR CMsgLeagueWatchedGames_Series::CMsgLeagueWatchedGames_Series(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.game_)*/{}
  , /*decltype(_impl_.node_id_)*/0u} {}
struct CMsgLeagueWatchedGames_SeriesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgLeagueWatchedGames_SeriesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgLeagueWatchedGames_SeriesDefaultTypeInternal() {}
  union {
    CMsgLeagueWatchedGames_Series _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgLeagueWatchedGames_SeriesDefaultTypeInternal _CMsgLeagueWatchedGames_Series_default_instance_;
PROTOBUF_CONSTEXPR CMsgLeagueWatchedGames_League::CMsgLeagueWatchedGames_League(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.series_)*/{}
  , /*decltype(_impl_.league_id_)*/0u} {}
struct CMsgLeagueWatchedGames_LeagueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgLeagueWatchedGames_LeagueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgLeagueWatchedGames_LeagueDefaultTypeInternal() {}
  union {
    CMsgLeagueWatchedGames_League _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgLeagueWatchedGames_LeagueDefaultTypeInternal _CMsgLeagueWatchedGames_League_default_instance_;
PROTOBUF_CONSTEXPR CMsgLeagueWatchedGames::CMsgLeagueWatchedGames(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.leagues_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgLeagueWatchedGamesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgLeagueWatchedGamesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgLeagueWatchedGamesDefaultTypeInternal() {}
  union {
    CMsgLeagueWatchedGames _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgLeagueWatchedGamesDefaultTypeInternal _CMsgLeagueWatchedGames_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAMatch_Player_CustomGameData::CMsgDOTAMatch_Player_CustomGameData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dota_team_)*/0u
  , /*decltype(_impl_.winner_)*/false} {}
struct CMsgDOTAMatch_Player_CustomGameDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAMatch_Player_CustomGameDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAMatch_Player_CustomGameDataDefaultTypeInternal() {}
  union {
    CMsgDOTAMatch_Player_CustomGameData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAMatch_Player_CustomGameDataDefaultTypeInternal _CMsgDOTAMatch_Player_CustomGameData_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAMatch_Player_HeroDamageReceived::CMsgDOTAMatch_Player_HeroDamageReceived(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pre_reduction_)*/0u
  , /*decltype(_impl_.post_reduction_)*/0u
  , /*decltype(_impl_.damage_type_)*/0} {}
struct CMsgDOTAMatch_Player_HeroDamageReceivedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAMatch_Player_HeroDamageReceivedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAMatch_Player_HeroDamageReceivedDefaultTypeInternal() {}
  union {
    CMsgDOTAMatch_Player_HeroDamageReceived _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAMatch_Player_HeroDamageReceivedDefaultTypeInternal _CMsgDOTAMatch_Player_HeroDamageReceived_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAMatch_Player::CMsgDOTAMatch_Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ability_upgrades_)*/{}
  , /*decltype(_impl_.additional_units_inventory_)*/{}
  , /*decltype(_impl_.permanent_buffs_)*/{}
  , /*decltype(_impl_.hero_damage_received_)*/{}
  , /*decltype(_impl_.hero_damage_dealt_)*/{}
  , /*decltype(_impl_.player_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pro_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.real_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.custom_game_data_)*/nullptr
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.player_slot_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.expected_team_contribution_)*/0
  , /*decltype(_impl_.scaled_metric_)*/0
  , /*decltype(_impl_.previous_rank_)*/0u
  , /*decltype(_impl_.rank_change_)*/0
  , /*decltype(_impl_.kills_)*/0u
  , /*decltype(_impl_.deaths_)*/0u
  , /*decltype(_impl_.assists_)*/0u
  , /*decltype(_impl_.leaver_status_)*/0u
  , /*decltype(_impl_.gold_)*/0u
  , /*decltype(_impl_.last_hits_)*/0u
  , /*decltype(_impl_.denies_)*/0u
  , /*decltype(_impl_.gold_per_min_)*/0u
  , /*decltype(_impl_.xp_per_min_)*/0u
  , /*decltype(_impl_.gold_spent_)*/0u
  , /*decltype(_impl_.hero_damage_)*/0u
  , /*decltype(_impl_.tower_damage_)*/0u
  , /*decltype(_impl_.hero_healing_)*/0u
  , /*decltype(_impl_.level_)*/0u
  , /*decltype(_impl_.time_last_seen_)*/0u
  , /*decltype(_impl_.support_ability_value_)*/0u
  , /*decltype(_impl_.search_rank_)*/0u
  , /*decltype(_impl_.search_rank_uncertainty_)*/0u
  , /*decltype(_impl_.rank_uncertainty_change_)*/0
  , /*decltype(_impl_.party_id_)*/uint64_t{0u}
  , /*decltype(_impl_.hero_play_count_)*/0u
  , /*decltype(_impl_.scaled_kills_)*/0
  , /*decltype(_impl_.scaled_deaths_)*/0
  , /*decltype(_impl_.scaled_assists_)*/0
  , /*decltype(_impl_.claimed_farm_gold_)*/0u
  , /*decltype(_impl_.support_gold_)*/0u
  , /*decltype(_impl_.claimed_denies_)*/0u
  , /*decltype(_impl_.claimed_misses_)*/0u
  , /*decltype(_impl_.misses_)*/0u
  , /*decltype(_impl_.net_worth_)*/0u
  , /*decltype(_impl_.scaled_hero_damage_)*/0u
  , /*decltype(_impl_.feeding_detected_)*/false
  , /*decltype(_impl_.active_plus_subscription_)*/false
  , /*decltype(_impl_.hero_was_randomed_)*/false
  , /*decltype(_impl_.hero_was_dota_plus_suggestion_)*/false
  , /*decltype(_impl_.scaled_tower_damage_)*/0u
  , /*decltype(_impl_.scaled_hero_healing_)*/0u
  , /*decltype(_impl_.bot_difficulty_)*/0u
  , /*decltype(_impl_.hero_pick_order_)*/0u
  , /*decltype(_impl_.seconds_dead_)*/0u
  , /*decltype(_impl_.gold_lost_to_death_)*/0u
  , /*decltype(_impl_.mmr_type_)*/0u
  , /*decltype(_impl_.lane_selection_flags_)*/0u
  , /*decltype(_impl_.bounty_runes_)*/0u
  , /*decltype(_impl_.outposts_captured_)*/0u
  , /*decltype(_impl_.team_number_)*/0
  , /*decltype(_impl_.team_slot_)*/0u
  , /*decltype(_impl_.item_0_)*/-1
  , /*decltype(_impl_.item_1_)*/-1
  , /*decltype(_impl_.item_2_)*/-1
  , /*decltype(_impl_.item_3_)*/-1
  , /*decltype(_impl_.item_4_)*/-1
  , /*decltype(_impl_.item_5_)*/-1
  , /*decltype(_impl_.item_6_)*/-1
  , /*decltype(_impl_.item_7_)*/-1
  , /*decltype(_impl_.item_8_)*/-1
  , /*decltype(_impl_.item_9_)*/-1} {}
struct CMsgDOTAMatch_PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAMatch_PlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAMatch_PlayerDefaultTypeInternal() {}
  union {
    CMsgDOTAMatch_Player _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAMatch_PlayerDefaultTypeInternal _CMsgDOTAMatch_Player_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAMatch_BroadcasterInfo::CMsgDOTAMatch_BroadcasterInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/0u} {}
struct CMsgDOTAMatch_BroadcasterInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAMatch_BroadcasterInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAMatch_BroadcasterInfoDefaultTypeInternal() {}
  union {
    CMsgDOTAMatch_BroadcasterInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAMatch_BroadcasterInfoDefaultTypeInternal _CMsgDOTAMatch_BroadcasterInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAMatch_BroadcasterChannel::CMsgDOTAMatch_BroadcasterChannel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.broadcaster_infos_)*/{}
  , /*decltype(_impl_.country_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgDOTAMatch_BroadcasterChannelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAMatch_BroadcasterChannelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAMatch_BroadcasterChannelDefaultTypeInternal() {}
  union {
    CMsgDOTAMatch_BroadcasterChannel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAMatch_BroadcasterChannelDefaultTypeInternal _CMsgDOTAMatch_BroadcasterChannel_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAMatch_Coach::CMsgDOTAMatch_Coach(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.coach_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.coach_rating_)*/0u
  , /*decltype(_impl_.coach_party_id_)*/uint64_t{0u}
  , /*decltype(_impl_.coach_team_)*/0u
  , /*decltype(_impl_.is_private_coach_)*/false} {}
struct CMsgDOTAMatch_CoachDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAMatch_CoachDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAMatch_CoachDefaultTypeInternal() {}
  union {
    CMsgDOTAMatch_Coach _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAMatch_CoachDefaultTypeInternal _CMsgDOTAMatch_Coach_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAMatch_CustomGameData::CMsgDOTAMatch_CustomGameData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.map_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.custom_game_id_)*/uint64_t{0u}} {}
struct CMsgDOTAMatch_CustomGameDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAMatch_CustomGameDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAMatch_CustomGameDataDefaultTypeInternal() {}
  union {
    CMsgDOTAMatch_CustomGameData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAMatch_CustomGameDataDefaultTypeInternal _CMsgDOTAMatch_CustomGameData_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAMatch::CMsgDOTAMatch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_.tower_status_)*/{}
  , /*decltype(_impl_.barracks_status_)*/{}
  , /*decltype(_impl_.picks_bans_)*/{}
  , /*decltype(_impl_.broadcaster_channels_)*/{}
  , /*decltype(_impl_.coaches_)*/{}
  , /*decltype(_impl_.radiant_team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dire_team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.radiant_team_tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dire_team_tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.radiant_team_logo_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dire_team_logo_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.custom_game_data_)*/nullptr
  , /*decltype(_impl_.duration_)*/0u
  , /*decltype(_impl_.starttime_)*/0u
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.cluster_)*/0u
  , /*decltype(_impl_.first_blood_time_)*/0u
  , /*decltype(_impl_.replay_salt_)*/0u
  , /*decltype(_impl_.server_ip_)*/0u
  , /*decltype(_impl_.server_port_)*/0u
  , /*decltype(_impl_.lobby_type_)*/0u
  , /*decltype(_impl_.human_players_)*/0u
  , /*decltype(_impl_.average_skill_)*/0u
  , /*decltype(_impl_.game_balance_)*/0
  , /*decltype(_impl_.radiant_team_id_)*/0u
  , /*decltype(_impl_.dire_team_id_)*/0u
  , /*decltype(_impl_.leagueid_)*/0u
  , /*decltype(_impl_.radiant_team_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.dire_team_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.radiant_team_complete_)*/0u
  , /*decltype(_impl_.dire_team_complete_)*/0u
  , /*decltype(_impl_.positive_votes_)*/0u
  , /*decltype(_impl_.negative_votes_)*/0u
  , /*decltype(_impl_.game_mode_)*/0
  , /*decltype(_impl_.replay_state_)*/0
  , /*decltype(_impl_.match_seq_num_)*/uint64_t{0u}
  , /*decltype(_impl_.radiant_guild_id_)*/0u
  , /*decltype(_impl_.dire_guild_id_)*/0u
  , /*decltype(_impl_.series_id_)*/0u
  , /*decltype(_impl_.series_type_)*/0u
  , /*decltype(_impl_.engine_)*/0u
  , /*decltype(_impl_.match_flags_)*/0u
  , /*decltype(_impl_.private_metadata_key_)*/0u
  , /*decltype(_impl_.radiant_team_score_)*/0u
  , /*decltype(_impl_.dire_team_score_)*/0u
  , /*decltype(_impl_.match_outcome_)*/0
  , /*decltype(_impl_.tournament_id_)*/0u
  , /*decltype(_impl_.tournament_round_)*/0u
  , /*decltype(_impl_.pre_game_duration_)*/0u} {}
struct CMsgDOTAMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAMatchDefaultTypeInternal() {}
  union {
    CMsgDOTAMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAMatchDefaultTypeInternal _CMsgDOTAMatch_default_instance_;
PROTOBUF_CONSTEXPR CMsgPlayerCard_StatModifier::CMsgPlayerCard_StatModifier(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stat_)*/0u
  , /*decltype(_impl_.value_)*/0u} {}
struct CMsgPlayerCard_StatModifierDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPlayerCard_StatModifierDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPlayerCard_StatModifierDefaultTypeInternal() {}
  union {
    CMsgPlayerCard_StatModifier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPlayerCard_StatModifierDefaultTypeInternal _CMsgPlayerCard_StatModifier_default_instance_;
PROTOBUF_CONSTEXPR CMsgPlayerCard::CMsgPlayerCard(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stat_modifier_)*/{}
  , /*decltype(_impl_.account_id_)*/0u} {}
struct CMsgPlayerCardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPlayerCardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPlayerCardDefaultTypeInternal() {}
  union {
    CMsgPlayerCard _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPlayerCardDefaultTypeInternal _CMsgPlayerCard_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAFantasyPlayerStats::CMsgDOTAFantasyPlayerStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.player_account_id_)*/0u
  , /*decltype(_impl_.match_completed_)*/false
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.delay_)*/0u
  , /*decltype(_impl_.series_id_)*/0u
  , /*decltype(_impl_.series_type_)*/0u
  , /*decltype(_impl_.kills_)*/0u
  , /*decltype(_impl_.deaths_)*/0u
  , /*decltype(_impl_.cs_)*/0u
  , /*decltype(_impl_.gpm_)*/0
  , /*decltype(_impl_.tower_kills_)*/0u
  , /*decltype(_impl_.roshan_kills_)*/0u
  , /*decltype(_impl_.teamfight_participation_)*/0
  , /*decltype(_impl_.wards_placed_)*/0u
  , /*decltype(_impl_.camps_stacked_)*/0u
  , /*decltype(_impl_.runes_grabbed_)*/0u
  , /*decltype(_impl_.first_blood_)*/0u
  , /*decltype(_impl_.stuns_)*/0} {}
struct CMsgDOTAFantasyPlayerStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAFantasyPlayerStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAFantasyPlayerStatsDefaultTypeInternal() {}
  union {
    CMsgDOTAFantasyPlayerStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAFantasyPlayerStatsDefaultTypeInternal _CMsgDOTAFantasyPlayerStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAFantasyPlayerMatchStats::CMsgDOTAFantasyPlayerMatchStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.matches_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgDOTAFantasyPlayerMatchStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAFantasyPlayerMatchStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAFantasyPlayerMatchStatsDefaultTypeInternal() {}
  union {
    CMsgDOTAFantasyPlayerMatchStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAFantasyPlayerMatchStatsDefaultTypeInternal _CMsgDOTAFantasyPlayerMatchStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTABotDebugInfo_Bot_Mode::CMsgDOTABotDebugInfo_Bot_Mode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mode_id_)*/0u
  , /*decltype(_impl_.desire_)*/0
  , /*decltype(_impl_.target_x_)*/0u
  , /*decltype(_impl_.target_y_)*/0u
  , /*decltype(_impl_.target_z_)*/0u
  , /*decltype(_impl_.target_entity_)*/-1} {}
struct CMsgDOTABotDebugInfo_Bot_ModeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTABotDebugInfo_Bot_ModeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTABotDebugInfo_Bot_ModeDefaultTypeInternal() {}
  union {
    CMsgDOTABotDebugInfo_Bot_Mode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTABotDebugInfo_Bot_ModeDefaultTypeInternal _CMsgDOTABotDebugInfo_Bot_Mode_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTABotDebugInfo_Bot_Action::CMsgDOTABotDebugInfo_Bot_Action(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.action_target_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.action_id_)*/0u} {}
struct CMsgDOTABotDebugInfo_Bot_ActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTABotDebugInfo_Bot_ActionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTABotDebugInfo_Bot_ActionDefaultTypeInternal() {}
  union {
    CMsgDOTABotDebugInfo_Bot_Action _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTABotDebugInfo_Bot_ActionDefaultTypeInternal _CMsgDOTABotDebugInfo_Bot_Action_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTABotDebugInfo_Bot::CMsgDOTABotDebugInfo_Bot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.modes_)*/{}
  , /*decltype(_impl_.action_)*/nullptr
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.difficulty_)*/0u
  , /*decltype(_impl_.power_current_)*/0u
  , /*decltype(_impl_.power_max_)*/0u
  , /*decltype(_impl_.move_target_x_)*/0u
  , /*decltype(_impl_.move_target_y_)*/0u
  , /*decltype(_impl_.move_target_z_)*/0u
  , /*decltype(_impl_.active_mode_id_)*/0u
  , /*decltype(_impl_.execution_time_)*/0
  , /*decltype(_impl_.player_owner_id_)*/-1} {}
struct CMsgDOTABotDebugInfo_BotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTABotDebugInfo_BotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTABotDebugInfo_BotDefaultTypeInternal() {}
  union {
    CMsgDOTABotDebugInfo_Bot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTABotDebugInfo_BotDefaultTypeInternal _CMsgDOTABotDebugInfo_Bot_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTABotDebugInfo::CMsgDOTABotDebugInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bots_)*/{}
  , /*decltype(_impl_.rune_status_)*/{}
  , /*decltype(_impl_.desire_push_lane_top_)*/0
  , /*decltype(_impl_.desire_push_lane_mid_)*/0
  , /*decltype(_impl_.desire_push_lane_bot_)*/0
  , /*decltype(_impl_.desire_defend_lane_top_)*/0
  , /*decltype(_impl_.desire_defend_lane_mid_)*/0
  , /*decltype(_impl_.desire_defend_lane_bot_)*/0
  , /*decltype(_impl_.desire_farm_lane_top_)*/0
  , /*decltype(_impl_.desire_farm_lane_mid_)*/0
  , /*decltype(_impl_.desire_farm_lane_bot_)*/0
  , /*decltype(_impl_.desire_farm_roshan_)*/0
  , /*decltype(_impl_.execution_time_)*/0} {}
struct CMsgDOTABotDebugInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTABotDebugInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTABotDebugInfoDefaultTypeInternal() {}
  union {
    CMsgDOTABotDebugInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTABotDebugInfoDefaultTypeInternal _CMsgDOTABotDebugInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgSuccessfulHero::CMsgSuccessfulHero(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.win_percent_)*/0
  , /*decltype(_impl_.longest_streak_)*/0u} {}
struct CMsgSuccessfulHeroDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgSuccessfulHeroDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgSuccessfulHeroDefaultTypeInternal() {}
  union {
    CMsgSuccessfulHero _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgSuccessfulHeroDefaultTypeInternal _CMsgSuccessfulHero_default_instance_;
PROTOBUF_CONSTEXPR CMsgRecentMatchInfo::CMsgRecentMatchInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.game_mode_)*/0
  , /*decltype(_impl_.kills_)*/0u
  , /*decltype(_impl_.deaths_)*/0u
  , /*decltype(_impl_.assists_)*/0u
  , /*decltype(_impl_.duration_)*/0u
  , /*decltype(_impl_.player_slot_)*/0u
  , /*decltype(_impl_.match_outcome_)*/0
  , /*decltype(_impl_.timestamp_)*/0u
  , /*decltype(_impl_.lobby_type_)*/0u
  , /*decltype(_impl_.team_number_)*/0u} {}
struct CMsgRecentMatchInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgRecentMatchInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgRecentMatchInfoDefaultTypeInternal() {}
  union {
    CMsgRecentMatchInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgRecentMatchInfoDefaultTypeInternal _CMsgRecentMatchInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgMatchTips_SingleTip::CMsgMatchTips_SingleTip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.source_account_id_)*/0u
  , /*decltype(_impl_.target_account_id_)*/0u
  , /*decltype(_impl_.tip_amount_)*/0u
  , /*decltype(_impl_.event_id_)*/0} {}
struct CMsgMatchTips_SingleTipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMatchTips_SingleTipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMatchTips_SingleTipDefaultTypeInternal() {}
  union {
    CMsgMatchTips_SingleTip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMatchTips_SingleTipDefaultTypeInternal _CMsgMatchTips_SingleTip_default_instance_;
PROTOBUF_CONSTEXPR CMsgMatchTips::CMsgMatchTips(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tips_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgMatchTipsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMatchTipsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMatchTipsDefaultTypeInternal() {}
  union {
    CMsgMatchTips _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMatchTipsDefaultTypeInternal _CMsgMatchTips_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAMatchMinimal_Player::CMsgDOTAMatchMinimal_Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.pro_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.kills_)*/0u
  , /*decltype(_impl_.deaths_)*/0u
  , /*decltype(_impl_.assists_)*/0u
  , /*decltype(_impl_.player_slot_)*/0u
  , /*decltype(_impl_.level_)*/0u
  , /*decltype(_impl_.team_number_)*/0} {}
struct CMsgDOTAMatchMinimal_PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAMatchMinimal_PlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAMatchMinimal_PlayerDefaultTypeInternal() {}
  union {
    CMsgDOTAMatchMinimal_Player _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAMatchMinimal_PlayerDefaultTypeInternal _CMsgDOTAMatchMinimal_Player_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAMatchMinimal_Tourney::CMsgDOTAMatchMinimal_Tourney(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.radiant_team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dire_team_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.radiant_team_logo_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dire_team_logo_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.radiant_team_id_)*/0u
  , /*decltype(_impl_.radiant_team_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.dire_team_id_)*/0u
  , /*decltype(_impl_.series_type_)*/0u
  , /*decltype(_impl_.dire_team_logo_)*/uint64_t{0u}
  , /*decltype(_impl_.series_game_)*/0u
  , /*decltype(_impl_.weekend_tourney_tournament_id_)*/0u
  , /*decltype(_impl_.weekend_tourney_season_trophy_id_)*/0u
  , /*decltype(_impl_.weekend_tourney_division_)*/0u
  , /*decltype(_impl_.weekend_tourney_skill_level_)*/0u} {}
struct CMsgDOTAMatchMinimal_TourneyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAMatchMinimal_TourneyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAMatchMinimal_TourneyDefaultTypeInternal() {}
  union {
    CMsgDOTAMatchMinimal_Tourney _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAMatchMinimal_TourneyDefaultTypeInternal _CMsgDOTAMatchMinimal_Tourney_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTAMatchMinimal::CMsgDOTAMatchMinimal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_.tourney_)*/nullptr
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.start_time_)*/0u
  , /*decltype(_impl_.duration_)*/0u
  , /*decltype(_impl_.game_mode_)*/0
  , /*decltype(_impl_.match_outcome_)*/0
  , /*decltype(_impl_.radiant_score_)*/0u
  , /*decltype(_impl_.dire_score_)*/0u
  , /*decltype(_impl_.lobby_type_)*/0u} {}
struct CMsgDOTAMatchMinimalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTAMatchMinimalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTAMatchMinimalDefaultTypeInternal() {}
  union {
    CMsgDOTAMatchMinimal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTAMatchMinimalDefaultTypeInternal _CMsgDOTAMatchMinimal_default_instance_;
PROTOBUF_CONSTEXPR CMsgConsumableUsage::CMsgConsumableUsage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_def_)*/0u
  , /*decltype(_impl_.quantity_change_)*/0} {}
struct CMsgConsumableUsageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgConsumableUsageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgConsumableUsageDefaultTypeInternal() {}
  union {
    CMsgConsumableUsage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgConsumableUsageDefaultTypeInternal _CMsgConsumableUsage_default_instance_;
PROTOBUF_CONSTEXPR CMsgMatchConsumableUsage_PlayerUsage::CMsgMatchConsumableUsage_PlayerUsage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.consumables_used_)*/{}
  , /*decltype(_impl_.account_id_)*/0u} {}
struct CMsgMatchConsumableUsage_PlayerUsageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMatchConsumableUsage_PlayerUsageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMatchConsumableUsage_PlayerUsageDefaultTypeInternal() {}
  union {
    CMsgMatchConsumableUsage_PlayerUsage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMatchConsumableUsage_PlayerUsageDefaultTypeInternal _CMsgMatchConsumableUsage_PlayerUsage_default_instance_;
PROTOBUF_CONSTEXPR CMsgMatchConsumableUsage::CMsgMatchConsumableUsage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.player_consumables_used_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgMatchConsumableUsageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMatchConsumableUsageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMatchConsumableUsageDefaultTypeInternal() {}
  union {
    CMsgMatchConsumableUsage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMatchConsumableUsageDefaultTypeInternal _CMsgMatchConsumableUsage_default_instance_;
PROTOBUF_CONSTEXPR CMsgMatchEventActionGrants_PlayerGrants::CMsgMatchEventActionGrants_PlayerGrants(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.actions_granted_)*/{}
  , /*decltype(_impl_.account_id_)*/0u} {}
struct CMsgMatchEventActionGrants_PlayerGrantsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMatchEventActionGrants_PlayerGrantsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMatchEventActionGrants_PlayerGrantsDefaultTypeInternal() {}
  union {
    CMsgMatchEventActionGrants_PlayerGrants _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMatchEventActionGrants_PlayerGrantsDefaultTypeInternal _CMsgMatchEventActionGrants_PlayerGrants_default_instance_;
PROTOBUF_CONSTEXPR CMsgMatchEventActionGrants::CMsgMatchEventActionGrants(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.player_grants_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgMatchEventActionGrantsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMatchEventActionGrantsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMatchEventActionGrantsDefaultTypeInternal() {}
  union {
    CMsgMatchEventActionGrants _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMatchEventActionGrantsDefaultTypeInternal _CMsgMatchEventActionGrants_default_instance_;
PROTOBUF_CONSTEXPR CMsgCustomGameWhitelist::CMsgCustomGameWhitelist(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.custom_games_whitelist_)*/{}
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.disable_whitelist_)*/false} {}
struct CMsgCustomGameWhitelistDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgCustomGameWhitelistDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgCustomGameWhitelistDefaultTypeInternal() {}
  union {
    CMsgCustomGameWhitelist _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgCustomGameWhitelistDefaultTypeInternal _CMsgCustomGameWhitelist_default_instance_;
PROTOBUF_CONSTEXPR CMsgCustomGameWhitelistForEdit_WhitelistEntry::CMsgCustomGameWhitelistForEdit_WhitelistEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.custom_game_id_)*/uint64_t{0u}
  , /*decltype(_impl_.whitelist_state_)*/0} {}
struct CMsgCustomGameWhitelistForEdit_WhitelistEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgCustomGameWhitelistForEdit_WhitelistEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgCustomGameWhitelistForEdit_WhitelistEntryDefaultTypeInternal() {}
  union {
    CMsgCustomGameWhitelistForEdit_WhitelistEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgCustomGameWhitelistForEdit_WhitelistEntryDefaultTypeInternal _CMsgCustomGameWhitelistForEdit_WhitelistEntry_default_instance_;
PROTOBUF_CONSTEXPR CMsgCustomGameWhitelistForEdit::CMsgCustomGameWhitelistForEdit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.whitelist_entries_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgCustomGameWhitelistForEditDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgCustomGameWhitelistForEditDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgCustomGameWhitelistForEditDefaultTypeInternal() {}
  union {
    CMsgCustomGameWhitelistForEdit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgCustomGameWhitelistForEditDefaultTypeInternal _CMsgCustomGameWhitelistForEdit_default_instance_;
PROTOBUF_CONSTEXPR CMsgPlayerRecentMatchInfo::CMsgPlayerRecentMatchInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.timestamp_)*/0u
  , /*decltype(_impl_.duration_)*/0u
  , /*decltype(_impl_.win_)*/false
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.kills_)*/0u
  , /*decltype(_impl_.deaths_)*/0u
  , /*decltype(_impl_.assists_)*/0u} {}
struct CMsgPlayerRecentMatchInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPlayerRecentMatchInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPlayerRecentMatchInfoDefaultTypeInternal() {}
  union {
    CMsgPlayerRecentMatchInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPlayerRecentMatchInfoDefaultTypeInternal _CMsgPlayerRecentMatchInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgPlayerMatchRecord::CMsgPlayerMatchRecord(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.wins_)*/0u
  , /*decltype(_impl_.losses_)*/0u} {}
struct CMsgPlayerMatchRecordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPlayerMatchRecordDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPlayerMatchRecordDefaultTypeInternal() {}
  union {
    CMsgPlayerMatchRecord _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPlayerMatchRecordDefaultTypeInternal _CMsgPlayerMatchRecord_default_instance_;
PROTOBUF_CONSTEXPR CMsgPlayerRecentMatchOutcomes::CMsgPlayerRecentMatchOutcomes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.outcomes_)*/0u
  , /*decltype(_impl_.match_count_)*/0u} {}
struct CMsgPlayerRecentMatchOutcomesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPlayerRecentMatchOutcomesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPlayerRecentMatchOutcomesDefaultTypeInternal() {}
  union {
    CMsgPlayerRecentMatchOutcomes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPlayerRecentMatchOutcomesDefaultTypeInternal _CMsgPlayerRecentMatchOutcomes_default_instance_;
PROTOBUF_CONSTEXPR CMsgPlayerRecentCommends::CMsgPlayerRecentCommends(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.commends_)*/0u
  , /*decltype(_impl_.match_count_)*/0u} {}
struct CMsgPlayerRecentCommendsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPlayerRecentCommendsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPlayerRecentCommendsDefaultTypeInternal() {}
  union {
    CMsgPlayerRecentCommends _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPlayerRecentCommendsDefaultTypeInternal _CMsgPlayerRecentCommends_default_instance_;
PROTOBUF_CONSTEXPR CMsgPlayerRecentAccomplishments::CMsgPlayerRecentAccomplishments(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.recent_outcomes_)*/nullptr
  , /*decltype(_impl_.total_record_)*/nullptr
  , /*decltype(_impl_.recent_commends_)*/nullptr
  , /*decltype(_impl_.last_match_)*/nullptr
  , /*decltype(_impl_.recent_mvps_)*/nullptr
  , /*decltype(_impl_.prediction_streak_)*/0u
  , /*decltype(_impl_.plus_prediction_streak_)*/0u
  , /*decltype(_impl_.first_match_timestamp_)*/0u} {}
struct CMsgPlayerRecentAccomplishmentsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPlayerRecentAccomplishmentsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPlayerRecentAccomplishmentsDefaultTypeInternal() {}
  union {
    CMsgPlayerRecentAccomplishments _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPlayerRecentAccomplishmentsDefaultTypeInternal _CMsgPlayerRecentAccomplishments_default_instance_;
PROTOBUF_CONSTEXPR CMsgPlayerHeroRecentAccomplishments::CMsgPlayerHeroRecentAccomplishments(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.recent_outcomes_)*/nullptr
  , /*decltype(_impl_.total_record_)*/nullptr
  , /*decltype(_impl_.last_match_)*/nullptr} {}
struct CMsgPlayerHeroRecentAccomplishmentsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPlayerHeroRecentAccomplishmentsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPlayerHeroRecentAccomplishmentsDefaultTypeInternal() {}
  union {
    CMsgPlayerHeroRecentAccomplishments _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPlayerHeroRecentAccomplishmentsDefaultTypeInternal _CMsgPlayerHeroRecentAccomplishments_default_instance_;
PROTOBUF_CONSTEXPR CMsgRecentAccomplishments::CMsgRecentAccomplishments(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_accomplishments_)*/nullptr
  , /*decltype(_impl_.hero_accomplishments_)*/nullptr} {}
struct CMsgRecentAccomplishmentsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgRecentAccomplishmentsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgRecentAccomplishmentsDefaultTypeInternal() {}
  union {
    CMsgRecentAccomplishments _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgRecentAccomplishmentsDefaultTypeInternal _CMsgRecentAccomplishments_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerToGCRequestPlayerRecentAccomplishments::CMsgServerToGCRequestPlayerRecentAccomplishments(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u} {}
struct CMsgServerToGCRequestPlayerRecentAccomplishmentsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerToGCRequestPlayerRecentAccomplishmentsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerToGCRequestPlayerRecentAccomplishmentsDefaultTypeInternal() {}
  union {
    CMsgServerToGCRequestPlayerRecentAccomplishments _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerToGCRequestPlayerRecentAccomplishmentsDefaultTypeInternal _CMsgServerToGCRequestPlayerRecentAccomplishments_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_accomplishments_)*/nullptr
  , /*decltype(_impl_.result_)*/0} {}
struct CMsgServerToGCRequestPlayerRecentAccomplishmentsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerToGCRequestPlayerRecentAccomplishmentsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerToGCRequestPlayerRecentAccomplishmentsResponseDefaultTypeInternal() {}
  union {
    CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerToGCRequestPlayerRecentAccomplishmentsResponseDefaultTypeInternal _CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgArcanaVoteMatchVotes::CMsgArcanaVoteMatchVotes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_id_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.vote_count_)*/0u} {}
struct CMsgArcanaVoteMatchVotesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgArcanaVoteMatchVotesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgArcanaVoteMatchVotesDefaultTypeInternal() {}
  union {
    CMsgArcanaVoteMatchVotes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgArcanaVoteMatchVotesDefaultTypeInternal _CMsgArcanaVoteMatchVotes_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCtoGCAssociatedExploiterAccountInfo::CMsgGCtoGCAssociatedExploiterAccountInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.num_matches_to_search_)*/0u
  , /*decltype(_impl_.min_shared_match_count_)*/0u
  , /*decltype(_impl_.num_additional_players_)*/0u} {}
struct CMsgGCtoGCAssociatedExploiterAccountInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCtoGCAssociatedExploiterAccountInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCtoGCAssociatedExploiterAccountInfoDefaultTypeInternal() {}
  union {
    CMsgGCtoGCAssociatedExploiterAccountInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCtoGCAssociatedExploiterAccountInfoDefaultTypeInternal _CMsgGCtoGCAssociatedExploiterAccountInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.persona_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.num_common_matches_)*/0u
  , /*decltype(_impl_.earliest_common_match_)*/0u
  , /*decltype(_impl_.latest_common_match_)*/0u
  , /*decltype(_impl_.generation_)*/0u
  , /*decltype(_impl_.already_banned_)*/false} {}
struct CMsgGCtoGCAssociatedExploiterAccountInfoResponse_AccountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCtoGCAssociatedExploiterAccountInfoResponse_AccountDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCtoGCAssociatedExploiterAccountInfoResponse_AccountDefaultTypeInternal() {}
  union {
    CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCtoGCAssociatedExploiterAccountInfoResponse_AccountDefaultTypeInternal _CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCtoGCAssociatedExploiterAccountInfoResponse::CMsgGCtoGCAssociatedExploiterAccountInfoResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accounts_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGCtoGCAssociatedExploiterAccountInfoResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCtoGCAssociatedExploiterAccountInfoResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCtoGCAssociatedExploiterAccountInfoResponseDefaultTypeInternal() {}
  union {
    CMsgGCtoGCAssociatedExploiterAccountInfoResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCtoGCAssociatedExploiterAccountInfoResponseDefaultTypeInternal _CMsgGCtoGCAssociatedExploiterAccountInfoResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgPullTabsData_Slot::CMsgPullTabsData_Slot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.event_id_)*/0u
  , /*decltype(_impl_.board_id_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.action_id_)*/0u
  , /*decltype(_impl_.redeemed_)*/false} {}
struct CMsgPullTabsData_SlotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPullTabsData_SlotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPullTabsData_SlotDefaultTypeInternal() {}
  union {
    CMsgPullTabsData_Slot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPullTabsData_SlotDefaultTypeInternal _CMsgPullTabsData_Slot_default_instance_;
PROTOBUF_CONSTEXPR CMsgPullTabsData_Jackpot::CMsgPullTabsData_Jackpot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.board_id_)*/0u
  , /*decltype(_impl_.action_id_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u} {}
struct CMsgPullTabsData_JackpotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPullTabsData_JackpotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPullTabsData_JackpotDefaultTypeInternal() {}
  union {
    CMsgPullTabsData_Jackpot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPullTabsData_JackpotDefaultTypeInternal _CMsgPullTabsData_Jackpot_default_instance_;
PROTOBUF_CONSTEXPR CMsgPullTabsData::CMsgPullTabsData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.slots_)*/{}
  , /*decltype(_impl_.jackpots_)*/{}
  , /*decltype(_impl_.last_board_)*/0u} {}
struct CMsgPullTabsDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPullTabsDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPullTabsDataDefaultTypeInternal() {}
  union {
    CMsgPullTabsData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPullTabsDataDefaultTypeInternal _CMsgPullTabsData_default_instance_;
PROTOBUF_CONSTEXPR CMsgUnderDraftData_BenchSlot::CMsgUnderDraftData_BenchSlot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.slot_id_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.stars_)*/0u} {}
struct CMsgUnderDraftData_BenchSlotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgUnderDraftData_BenchSlotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgUnderDraftData_BenchSlotDefaultTypeInternal() {}
  union {
    CMsgUnderDraftData_BenchSlot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgUnderDraftData_BenchSlotDefaultTypeInternal _CMsgUnderDraftData_BenchSlot_default_instance_;
PROTOBUF_CONSTEXPR CMsgUnderDraftData_ShopSlot::CMsgUnderDraftData_ShopSlot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.slot_id_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.is_special_reward_)*/false} {}
struct CMsgUnderDraftData_ShopSlotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgUnderDraftData_ShopSlotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgUnderDraftData_ShopSlotDefaultTypeInternal() {}
  union {
    CMsgUnderDraftData_ShopSlot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgUnderDraftData_ShopSlotDefaultTypeInternal _CMsgUnderDraftData_ShopSlot_default_instance_;
PROTOBUF_CONSTEXPR CMsgUnderDraftData::CMsgUnderDraftData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bench_slots_)*/{}
  , /*decltype(_impl_.shop_slots_)*/{}
  , /*decltype(_impl_.gold_)*/0u
  , /*decltype(_impl_.total_gold_)*/0u
  , /*decltype(_impl_.not_restorable_)*/false} {}
struct CMsgUnderDraftDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgUnderDraftDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgUnderDraftDataDefaultTypeInternal() {}
  union {
    CMsgUnderDraftData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgUnderDraftDataDefaultTypeInternal _CMsgUnderDraftData_default_instance_;
PROTOBUF_CONSTEXPR CMsgPlayerTitleData::CMsgPlayerTitleData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.title_)*/{}
  , /*decltype(_impl_.event_id_)*/{}
  , /*decltype(_impl_.active_)*/0u} {}
struct CMsgPlayerTitleDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPlayerTitleDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPlayerTitleDataDefaultTypeInternal() {}
  union {
    CMsgPlayerTitleData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPlayerTitleDataDefaultTypeInternal _CMsgPlayerTitleData_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTATriviaQuestion::CMsgDOTATriviaQuestion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.answer_values_)*/{}
  , /*decltype(_impl_.question_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.question_id_)*/0u
  , /*decltype(_impl_.category_)*/0
  , /*decltype(_impl_.timestamp_)*/0u
  , /*decltype(_impl_.correct_answer_index_)*/0u} {}
struct CMsgDOTATriviaQuestionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTATriviaQuestionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTATriviaQuestionDefaultTypeInternal() {}
  union {
    CMsgDOTATriviaQuestion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTATriviaQuestionDefaultTypeInternal _CMsgDOTATriviaQuestion_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTATriviaQuestionAnswersSummary::CMsgDOTATriviaQuestionAnswersSummary(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.picked_count_)*/{}
  , /*decltype(_impl_.summary_available_)*/false} {}
struct CMsgDOTATriviaQuestionAnswersSummaryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTATriviaQuestionAnswersSummaryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTATriviaQuestionAnswersSummaryDefaultTypeInternal() {}
  union {
    CMsgDOTATriviaQuestionAnswersSummary _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTATriviaQuestionAnswersSummaryDefaultTypeInternal _CMsgDOTATriviaQuestionAnswersSummary_default_instance_;
PROTOBUF_CONSTEXPR CMsgGameDataSpecialValueBonus::CMsgGameDataSpecialValueBonus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/0
  , /*decltype(_impl_.operation_)*/0u} {}
struct CMsgGameDataSpecialValueBonusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGameDataSpecialValueBonusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGameDataSpecialValueBonusDefaultTypeInternal() {}
  union {
    CMsgGameDataSpecialValueBonus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGameDataSpecialValueBonusDefaultTypeInternal _CMsgGameDataSpecialValueBonus_default_instance_;
PROTOBUF_CONSTEXPR CMsgGameDataSpecialValues::CMsgGameDataSpecialValues(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.values_float_)*/{}
  , /*decltype(_impl_.bonuses_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.heading_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_percentage_)*/false} {}
struct CMsgGameDataSpecialValuesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGameDataSpecialValuesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGameDataSpecialValuesDefaultTypeInternal() {}
  union {
    CMsgGameDataSpecialValues _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGameDataSpecialValuesDefaultTypeInternal _CMsgGameDataSpecialValues_default_instance_;
PROTOBUF_CONSTEXPR CMsgGameDataAbilityOrItem::CMsgGameDataAbilityOrItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.notes_loc_)*/{}
  , /*decltype(_impl_.cast_ranges_)*/{}
  , /*decltype(_impl_.cast_points_)*/{}
  , /*decltype(_impl_.channel_times_)*/{}
  , /*decltype(_impl_.cooldowns_)*/{}
  , /*decltype(_impl_.durations_)*/{}
  , /*decltype(_impl_.damages_)*/{}
  , /*decltype(_impl_.mana_costs_)*/{}
  , /*decltype(_impl_.gold_costs_)*/{}
  , /*decltype(_impl_.special_values_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.desc_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lore_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.shard_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.scepter_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.behavior_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.target_team_)*/0u
  , /*decltype(_impl_.target_type_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.damage_)*/0u
  , /*decltype(_impl_.immunity_)*/0u
  , /*decltype(_impl_.dispellable_)*/0u
  , /*decltype(_impl_.max_level_)*/0u
  , /*decltype(_impl_.is_item_)*/false
  , /*decltype(_impl_.ability_has_scepter_)*/false
  , /*decltype(_impl_.ability_has_shard_)*/false
  , /*decltype(_impl_.ability_is_granted_by_scepter_)*/false
  , /*decltype(_impl_.ability_is_granted_by_shard_)*/false
  , /*decltype(_impl_.item_cost_)*/0u
  , /*decltype(_impl_.item_initial_charges_)*/0u
  , /*decltype(_impl_.item_neutral_tier_)*/0u
  , /*decltype(_impl_.item_stock_max_)*/0u
  , /*decltype(_impl_.item_stock_time_)*/0
  , /*decltype(_impl_.item_quality_)*/0u
  , /*decltype(_impl_.id_)*/-1} {}
struct CMsgGameDataAbilityOrItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGameDataAbilityOrItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGameDataAbilityOrItemDefaultTypeInternal() {}
  union {
    CMsgGameDataAbilityOrItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGameDataAbilityOrItemDefaultTypeInternal _CMsgGameDataAbilityOrItem_default_instance_;
PROTOBUF_CONSTEXPR CMsgGameDataHero::CMsgGameDataHero(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.role_levels_)*/{}
  , /*decltype(_impl_.abilities_)*/{}
  , /*decltype(_impl_.talents_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bio_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hype_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.npe_desc_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.order_id_)*/0u
  , /*decltype(_impl_.str_base_)*/0u
  , /*decltype(_impl_.str_gain_)*/0
  , /*decltype(_impl_.agi_base_)*/0u
  , /*decltype(_impl_.agi_gain_)*/0
  , /*decltype(_impl_.int_base_)*/0u
  , /*decltype(_impl_.int_gain_)*/0
  , /*decltype(_impl_.primary_attr_)*/0u
  , /*decltype(_impl_.complexity_)*/0u
  , /*decltype(_impl_.attack_capability_)*/0u
  , /*decltype(_impl_.damage_min_)*/0u
  , /*decltype(_impl_.damage_max_)*/0u
  , /*decltype(_impl_.attack_rate_)*/0
  , /*decltype(_impl_.attack_range_)*/0u
  , /*decltype(_impl_.projectile_speed_)*/0u
  , /*decltype(_impl_.armor_)*/0
  , /*decltype(_impl_.magic_resistance_)*/0u
  , /*decltype(_impl_.movement_speed_)*/0u
  , /*decltype(_impl_.turn_rate_)*/0
  , /*decltype(_impl_.sight_range_day_)*/0u
  , /*decltype(_impl_.sight_range_night_)*/0u
  , /*decltype(_impl_.max_health_)*/0u
  , /*decltype(_impl_.health_regen_)*/0
  , /*decltype(_impl_.max_mana_)*/0u
  , /*decltype(_impl_.mana_regen_)*/0} {}
struct CMsgGameDataHeroDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGameDataHeroDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGameDataHeroDefaultTypeInternal() {}
  union {
    CMsgGameDataHero _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGameDataHeroDefaultTypeInternal _CMsgGameDataHero_default_instance_;
PROTOBUF_CONSTEXPR CMsgGameDataAbilities::CMsgGameDataAbilities(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.abilities_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGameDataAbilitiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGameDataAbilitiesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGameDataAbilitiesDefaultTypeInternal() {}
  union {
    CMsgGameDataAbilities _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGameDataAbilitiesDefaultTypeInternal _CMsgGameDataAbilities_default_instance_;
PROTOBUF_CONSTEXPR CMsgGameDataItems::CMsgGameDataItems(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGameDataItemsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGameDataItemsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGameDataItemsDefaultTypeInternal() {}
  union {
    CMsgGameDataItems _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGameDataItemsDefaultTypeInternal _CMsgGameDataItems_default_instance_;
PROTOBUF_CONSTEXPR CMsgGameDataHeroes::CMsgGameDataHeroes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.heroes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGameDataHeroesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGameDataHeroesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGameDataHeroesDefaultTypeInternal() {}
  union {
    CMsgGameDataHeroes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGameDataHeroesDefaultTypeInternal _CMsgGameDataHeroes_default_instance_;
PROTOBUF_CONSTEXPR CMsgGameDataHeroList_HeroInfo::CMsgGameDataHeroList_HeroInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_english_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.primary_attr_)*/0u
  , /*decltype(_impl_.complexity_)*/0u} {}
struct CMsgGameDataHeroList_HeroInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGameDataHeroList_HeroInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGameDataHeroList_HeroInfoDefaultTypeInternal() {}
  union {
    CMsgGameDataHeroList_HeroInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGameDataHeroList_HeroInfoDefaultTypeInternal _CMsgGameDataHeroList_HeroInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgGameDataHeroList::CMsgGameDataHeroList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.heroes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGameDataHeroListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGameDataHeroListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGameDataHeroListDefaultTypeInternal() {}
  union {
    CMsgGameDataHeroList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGameDataHeroListDefaultTypeInternal _CMsgGameDataHeroList_default_instance_;
PROTOBUF_CONSTEXPR CMsgGameDataItemAbilityList_ItemAbilityInfo::CMsgGameDataItemAbilityList_ItemAbilityInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_english_loc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.neutral_item_tier_)*/0
  , /*decltype(_impl_.id_)*/-1} {}
struct CMsgGameDataItemAbilityList_ItemAbilityInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGameDataItemAbilityList_ItemAbilityInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGameDataItemAbilityList_ItemAbilityInfoDefaultTypeInternal() {}
  union {
    CMsgGameDataItemAbilityList_ItemAbilityInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGameDataItemAbilityList_ItemAbilityInfoDefaultTypeInternal _CMsgGameDataItemAbilityList_ItemAbilityInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgGameDataItemAbilityList::CMsgGameDataItemAbilityList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.itemabilities_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgGameDataItemAbilityListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGameDataItemAbilityListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGameDataItemAbilityListDefaultTypeInternal() {}
  union {
    CMsgGameDataItemAbilityList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGameDataItemAbilityListDefaultTypeInternal _CMsgGameDataItemAbilityList_default_instance_;
PROTOBUF_CONSTEXPR CMsgLobbyAbilityDraftData::CMsgLobbyAbilityDraftData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.shuffle_draft_order_)*/false} {}
struct CMsgLobbyAbilityDraftDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgLobbyAbilityDraftDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgLobbyAbilityDraftDataDefaultTypeInternal() {}
  union {
    CMsgLobbyAbilityDraftData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgLobbyAbilityDraftDataDefaultTypeInternal _CMsgLobbyAbilityDraftData_default_instance_;
PROTOBUF_CONSTEXPR CSOEconItemDropRateBonus::CSOEconItemDropRateBonus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.expiration_date_)*/0u
  , /*decltype(_impl_.bonus_)*/0
  , /*decltype(_impl_.bonus_count_)*/0u
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.def_index_)*/0u
  , /*decltype(_impl_.seconds_left_)*/0u
  , /*decltype(_impl_.booster_type_)*/0u} {}
struct CSOEconItemDropRateBonusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOEconItemDropRateBonusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOEconItemDropRateBonusDefaultTypeInternal() {}
  union {
    CSOEconItemDropRateBonus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOEconItemDropRateBonusDefaultTypeInternal _CSOEconItemDropRateBonus_default_instance_;
PROTOBUF_CONSTEXPR CSOEconItemTournamentPassport::CSOEconItemTournamentPassport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/0u
  , /*decltype(_impl_.league_id_)*/0u
  , /*decltype(_impl_.item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.original_purchaser_id_)*/0u
  , /*decltype(_impl_.passports_bought_)*/0u
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.def_index_)*/0u
  , /*decltype(_impl_.reward_flags_)*/0u} {}
struct CSOEconItemTournamentPassportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSOEconItemTournamentPassportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSOEconItemTournamentPassportDefaultTypeInternal() {}
  union {
    CSOEconItemTournamentPassport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSOEconItemTournamentPassportDefaultTypeInternal _CSOEconItemTournamentPassport_default_instance_;
PROTOBUF_CONSTEXPR CMsgStickerbookSticker::CMsgStickerbookSticker(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_def_id_)*/0u
  , /*decltype(_impl_.sticker_num_)*/0u
  , /*decltype(_impl_.quality_)*/0u
  , /*decltype(_impl_.position_x_)*/0
  , /*decltype(_impl_.position_y_)*/0
  , /*decltype(_impl_.rotation_)*/0
  , /*decltype(_impl_.scale_)*/0
  , /*decltype(_impl_.position_z_)*/0
  , /*decltype(_impl_.source_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.depth_bias_)*/0u} {}
struct CMsgStickerbookStickerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgStickerbookStickerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgStickerbookStickerDefaultTypeInternal() {}
  union {
    CMsgStickerbookSticker _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgStickerbookStickerDefaultTypeInternal _CMsgStickerbookSticker_default_instance_;
PROTOBUF_CONSTEXPR CMsgStickerbookPage::CMsgStickerbookPage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stickers_)*/{}
  , /*decltype(_impl_.page_num_)*/0u
  , /*decltype(_impl_.event_id_)*/0
  , /*decltype(_impl_.team_id_)*/0u
  , /*decltype(_impl_.page_type_)*/0} {}
struct CMsgStickerbookPageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgStickerbookPageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgStickerbookPageDefaultTypeInternal() {}
  union {
    CMsgStickerbookPage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgStickerbookPageDefaultTypeInternal _CMsgStickerbookPage_default_instance_;
PROTOBUF_CONSTEXPR CMsgStickerbookTeamPageOrderSequence::CMsgStickerbookTeamPageOrderSequence(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.page_numbers_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgStickerbookTeamPageOrderSequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgStickerbookTeamPageOrderSequenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgStickerbookTeamPageOrderSequenceDefaultTypeInternal() {}
  union {
    CMsgStickerbookTeamPageOrderSequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgStickerbookTeamPageOrderSequenceDefaultTypeInternal _CMsgStickerbookTeamPageOrderSequence_default_instance_;
PROTOBUF_CONSTEXPR CMsgStickerbook::CMsgStickerbook(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pages_)*/{}
  , /*decltype(_impl_.team_page_order_sequence_)*/nullptr
  , /*decltype(_impl_.favorite_page_num_)*/0u} {}
struct CMsgStickerbookDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgStickerbookDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgStickerbookDefaultTypeInternal() {}
  union {
    CMsgStickerbook _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgStickerbookDefaultTypeInternal _CMsgStickerbook_default_instance_;
PROTOBUF_CONSTEXPR CMsgStickerHero::CMsgStickerHero(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hero_id_)*/0u
  , /*decltype(_impl_.item_def_id_)*/0u
  , /*decltype(_impl_.source_item_id_)*/uint64_t{0u}
  , /*decltype(_impl_.quality_)*/0u} {}
struct CMsgStickerHeroDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgStickerHeroDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgStickerHeroDefaultTypeInternal() {}
  union {
    CMsgStickerHero _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgStickerHeroDefaultTypeInternal _CMsgStickerHero_default_instance_;
PROTOBUF_CONSTEXPR CMsgStickerHeroes::CMsgStickerHeroes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.heroes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgStickerHeroesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgStickerHeroesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgStickerHeroesDefaultTypeInternal() {}
  union {
    CMsgStickerHeroes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgStickerHeroesDefaultTypeInternal _CMsgStickerHeroes_default_instance_;
PROTOBUF_CONSTEXPR CMsgHeroRoleStats::CMsgHeroRoleStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lane_selection_flags_)*/0u
  , /*decltype(_impl_.match_count_)*/0u
  , /*decltype(_impl_.win_count_)*/0u} {}
struct CMsgHeroRoleStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgHeroRoleStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgHeroRoleStatsDefaultTypeInternal() {}
  union {
    CMsgHeroRoleStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgHeroRoleStatsDefaultTypeInternal _CMsgHeroRoleStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgHeroRoleHeroStats::CMsgHeroRoleHeroStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.role_stats_)*/{}
  , /*decltype(_impl_.hero_id_)*/0u} {}
struct CMsgHeroRoleHeroStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgHeroRoleHeroStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgHeroRoleHeroStatsDefaultTypeInternal() {}
  union {
    CMsgHeroRoleHeroStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgHeroRoleHeroStatsDefaultTypeInternal _CMsgHeroRoleHeroStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgHeroRoleRankStats::CMsgHeroRoleRankStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hero_stats_)*/{}
  , /*decltype(_impl_.rank_tier_)*/0u} {}
struct CMsgHeroRoleRankStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgHeroRoleRankStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgHeroRoleRankStatsDefaultTypeInternal() {}
  union {
    CMsgHeroRoleRankStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgHeroRoleRankStatsDefaultTypeInternal _CMsgHeroRoleRankStats_default_instance_;
PROTOBUF_CONSTEXPR CMsgHeroRoleAllRanksStats::CMsgHeroRoleAllRanksStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rank_stats_)*/{}
  , /*decltype(_impl_.start_timestamp_)*/0u
  , /*decltype(_impl_.end_timestamp_)*/0u} {}
struct CMsgHeroRoleAllRanksStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgHeroRoleAllRanksStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgHeroRoleAllRanksStatsDefaultTypeInternal() {}
  union {
    CMsgHeroRoleAllRanksStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgHeroRoleAllRanksStatsDefaultTypeInternal _CMsgHeroRoleAllRanksStats_default_instance_;
static ::_pb::Metadata file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[149];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[23];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_dota_5fgcmessages_5fcommon_2eproto = nullptr;

const uint32_t TableStruct_dota_5fgcmessages_5fcommon_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient_RoleHandicap, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient_RoleHandicap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient_RoleHandicap, _impl_.role_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient_RoleHandicap, _impl_.handicap_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.wins_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.losses_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.xp_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.initial_skill_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.leaver_count_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.secondary_leaver_count_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.low_priority_until_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.prevent_text_chat_until_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.prevent_voice_until_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.prevent_public_text_chat_until_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.prevent_new_player_chat_until_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.last_abandoned_game_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.last_secondary_abandoned_game_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.leaver_penalty_count_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.completed_game_streak_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.account_disabled_until_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.account_disabled_count_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.match_disabled_until_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.match_disabled_count_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.shutdownlawterminatetimestamp_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.low_priority_games_remaining_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.competitive_rank_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.competitive_calibration_games_remaining_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.recruitment_level_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.has_new_notifications_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.is_league_admin_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.casual_games_played_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.solo_competitive_games_played_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.party_competitive_games_played_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.casual_1v1_games_played_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.curr_all_hero_challenge_id_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.play_time_points_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.account_flags_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.play_time_level_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.player_behavior_seq_num_last_report_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.player_behavior_score_last_report_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.player_behavior_report_old_data_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.tourney_skill_level_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.tourney_recent_participation_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.anchored_phone_number_id_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.ranked_matchmaking_ban_until_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.recent_game_time_1_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.recent_game_time_2_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.recent_game_time_3_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.favorite_team_packed_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.recent_report_time_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.custom_game_disabled_until_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.recent_win_time_1_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.recent_win_time_2_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.recent_win_time_3_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.coach_rating_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.queue_points_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.role_handicaps_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.event_mode_recent_time_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountClient, _impl_.mmr_recalibration_time_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  22,
  7,
  8,
  9,
  39,
  55,
  10,
  23,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  27,
  28,
  24,
  25,
  26,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  29,
  37,
  38,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  ~0u,
  53,
  54,
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountPlus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountPlus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountPlus, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountPlus, _impl_.original_start_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountPlus, _impl_.plus_flags_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountPlus, _impl_.plus_status_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountPlus, _impl_.prepaid_time_start_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountPlus, _impl_.prepaid_time_balance_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountPlus, _impl_.next_payment_date_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAGameAccountPlus, _impl_.steam_agreement_id_),
  0,
  1,
  2,
  3,
  4,
  5,
  7,
  6,
  PROTOBUF_FIELD_OFFSET(::CMsgLobbyFeaturedGamemodeProgress_AccountProgress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgLobbyFeaturedGamemodeProgress_AccountProgress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgLobbyFeaturedGamemodeProgress_AccountProgress, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgLobbyFeaturedGamemodeProgress_AccountProgress, _impl_.current_value_),
  PROTOBUF_FIELD_OFFSET(::CMsgLobbyFeaturedGamemodeProgress_AccountProgress, _impl_.max_value_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgLobbyFeaturedGamemodeProgress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgLobbyFeaturedGamemodeProgress, _impl_.accounts_),
  PROTOBUF_FIELD_OFFSET(::CMsgBattleCupVictory, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgBattleCupVictory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgBattleCupVictory, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgBattleCupVictory, _impl_.win_date_),
  PROTOBUF_FIELD_OFFSET(::CMsgBattleCupVictory, _impl_.valid_until_),
  PROTOBUF_FIELD_OFFSET(::CMsgBattleCupVictory, _impl_.skill_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgBattleCupVictory, _impl_.tournament_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgBattleCupVictory, _impl_.division_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgBattleCupVictory, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgBattleCupVictory, _impl_.streak_),
  PROTOBUF_FIELD_OFFSET(::CMsgBattleCupVictory, _impl_.trophy_id_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgLobbyBattleCupVictoryList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgLobbyBattleCupVictoryList, _impl_.winners_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABroadcastNotification, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABroadcastNotification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABroadcastNotification, _impl_.message_),
  0,
  PROTOBUF_FIELD_OFFSET(::CProtoItemHeroStatue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CProtoItemHeroStatue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CProtoItemHeroStatue, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CProtoItemHeroStatue, _impl_.status_effect_index_),
  PROTOBUF_FIELD_OFFSET(::CProtoItemHeroStatue, _impl_.sequence_name_),
  PROTOBUF_FIELD_OFFSET(::CProtoItemHeroStatue, _impl_.cycle_),
  PROTOBUF_FIELD_OFFSET(::CProtoItemHeroStatue, _impl_.wearable_),
  PROTOBUF_FIELD_OFFSET(::CProtoItemHeroStatue, _impl_.inscription_),
  PROTOBUF_FIELD_OFFSET(::CProtoItemHeroStatue, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::CProtoItemHeroStatue, _impl_.tournament_drop_),
  2,
  3,
  0,
  4,
  ~0u,
  1,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerAbilityUpgrade, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerAbilityUpgrade, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerAbilityUpgrade, _impl_.ability_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerAbilityUpgrade, _impl_.time_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.time_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.kills_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.deaths_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.assists_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.net_worth_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.xp_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.last_hits_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.denies_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.bounty_rune_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.range_creep_upgrade_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.observer_wards_dewarded_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.reliable_gold_earned_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.gold_loss_prevented_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.hero_kill_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.creep_kill_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.building_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.other_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.comeback_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.experimental_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.experimental2_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.creep_deny_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.tp_scrolls_purchased_1_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.tp_scrolls_purchased_2_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.tp_scrolls_purchased_3_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.tp_scrolls_purchased_4_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.tp_scrolls_purchased_5_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.neutral_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.courier_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.roshan_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.income_gold_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.custom_stats_1_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.custom_stats_2_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.custom_stats_3_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.custom_stats_4_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.custom_stats_5_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.item_value_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.support_gold_spent_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.camps_stacked_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.wards_placed_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.triple_kills_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerTimedStats, _impl_.rampages_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  PROTOBUF_FIELD_OFFSET(::CMatchTeamTimedStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMatchTeamTimedStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMatchTeamTimedStats, _impl_.time_),
  PROTOBUF_FIELD_OFFSET(::CMatchTeamTimedStats, _impl_.enemy_towers_killed_),
  PROTOBUF_FIELD_OFFSET(::CMatchTeamTimedStats, _impl_.enemy_barracks_killed_),
  PROTOBUF_FIELD_OFFSET(::CMatchTeamTimedStats, _impl_.enemy_towers_status_),
  PROTOBUF_FIELD_OFFSET(::CMatchTeamTimedStats, _impl_.enemy_barracks_status_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMatchAdditionalUnitInventory, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMatchAdditionalUnitInventory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMatchAdditionalUnitInventory, _impl_.unit_name_),
  PROTOBUF_FIELD_OFFSET(::CMatchAdditionalUnitInventory, _impl_.items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerPermanentBuff, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerPermanentBuff, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerPermanentBuff, _impl_.permanent_buff_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerPermanentBuff, _impl_.stack_count_),
  PROTOBUF_FIELD_OFFSET(::CMatchPlayerPermanentBuff, _impl_.grant_time_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMatchHeroSelectEvent, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMatchHeroSelectEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMatchHeroSelectEvent, _impl_.is_pick_),
  PROTOBUF_FIELD_OFFSET(::CMatchHeroSelectEvent, _impl_.team_),
  PROTOBUF_FIELD_OFFSET(::CMatchHeroSelectEvent, _impl_.hero_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMatchClip, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMatchClip, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMatchClip, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMatchClip, _impl_.player_account_id_),
  PROTOBUF_FIELD_OFFSET(::CMatchClip, _impl_.game_time_seconds_),
  PROTOBUF_FIELD_OFFSET(::CMatchClip, _impl_.duration_seconds_),
  PROTOBUF_FIELD_OFFSET(::CMatchClip, _impl_.player_id_),
  PROTOBUF_FIELD_OFFSET(::CMatchClip, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMatchClip, _impl_.ability_id_),
  PROTOBUF_FIELD_OFFSET(::CMatchClip, _impl_.camera_mode_),
  PROTOBUF_FIELD_OFFSET(::CMatchClip, _impl_.comment_),
  1,
  2,
  3,
  4,
  5,
  6,
  8,
  7,
  0,
  PROTOBUF_FIELD_OFFSET(::CPartySearchClientParty, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CPartySearchClientParty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CPartySearchClientParty, _impl_.party_id_),
  PROTOBUF_FIELD_OFFSET(::CPartySearchClientParty, _impl_.beacon_type_),
  PROTOBUF_FIELD_OFFSET(::CPartySearchClientParty, _impl_.party_members_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAHasItemQuery, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAHasItemQuery, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAHasItemQuery, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAHasItemQuery, _impl_.item_id_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAHasItemResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAHasItemResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAHasItemResponse, _impl_.has_item_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCGetPlayerCardItemInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCGetPlayerCardItemInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCGetPlayerCardItemInfo, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCGetPlayerCardItemInfo, _impl_.player_card_item_ids_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCGetPlayerCardItemInfo, _impl_.all_for_event_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo, _impl_.player_card_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo, _impl_.packed_bonuses_),
  0,
  2,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGCGetPlayerCardItemInfoResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCGetPlayerCardItemInfoResponse, _impl_.player_card_infos_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAMapLocationState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAMapLocationState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSODOTAMapLocationState, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAMapLocationState, _impl_.location_id_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAMapLocationState, _impl_.completed_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgLeagueAdminList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgLeagueAdminList, _impl_.account_ids_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Trophy, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Trophy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Trophy, _impl_.trophy_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Trophy, _impl_.trophy_score_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Stat, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Stat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Stat, _impl_.stat_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Stat, _impl_.stat_score_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Item, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Item, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Item, _impl_.serialized_item_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Item, _impl_.item_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Hero, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Hero, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Hero, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Hero, _impl_.hero_wins_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Hero, _impl_.hero_losses_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Emoticon, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Emoticon, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Emoticon, _impl_.emoticon_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Team, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Team, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot_Team, _impl_.team_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot, _impl_.slot_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot, _impl_.trophy_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot, _impl_.stat_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot, _impl_.item_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot, _impl_.hero_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot, _impl_.emoticon_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard_Slot, _impl_.team_),
  6,
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.slots_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.badge_points_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.event_points_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.event_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.recent_battle_cup_victory_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.rank_tier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.leaderboard_rank_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.is_plus_subscriber_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.plus_original_start_date_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.rank_tier_score_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.leaderboard_rank_core_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.favorite_team_packed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAProfileCard, _impl_.lifetime_games_),
  1,
  ~0u,
  2,
  3,
  4,
  0,
  5,
  6,
  7,
  8,
  9,
  10,
  12,
  11,
  13,
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.event_id_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.slot_id_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.int_param_0_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.int_param_1_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.created_time_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.completed_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.sequence_id_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.challenge_tier_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.attempts_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.complete_limit_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.quest_rank_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.max_quest_rank_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.instance_id_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CSODOTAPlayerChallenge, _impl_.template_id_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCRerollPlayerChallenge, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCRerollPlayerChallenge, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCRerollPlayerChallenge, _impl_.event_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCRerollPlayerChallenge, _impl_.sequence_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCRerollPlayerChallenge, _impl_.hero_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgGCRerollPlayerChallengeResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRerollPlayerChallengeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCRerollPlayerChallengeResponse, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCTopCustomGamesList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCTopCustomGamesList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCTopCustomGamesList, _impl_.top_custom_games_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCTopCustomGamesList, _impl_.game_of_the_day_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _impl_.team_number_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _impl_.team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _impl_.team_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _impl_.team_tag_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _impl_.score_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _impl_.net_worth_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _impl_.players_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _impl_.only_team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _impl_.cheers_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_TeamDetails, _impl_.team_logo_url_),
  3,
  4,
  0,
  5,
  1,
  6,
  9,
  ~0u,
  7,
  8,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_ItemDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_ItemDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_ItemDetails, _impl_.item_ability_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_ItemDetails, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_ItemDetails, _impl_.time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_ItemDetails, _impl_.sold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_ItemDetails, _impl_.stackcount_),
  4,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_AbilityDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_AbilityDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_AbilityDetails, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_AbilityDetails, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_AbilityDetails, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_AbilityDetails, _impl_.cooldown_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_AbilityDetails, _impl_.cooldown_max_),
  4,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_HeroToHeroStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_HeroToHeroStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_HeroToHeroStats, _impl_.victimid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_HeroToHeroStats, _impl_.kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_HeroToHeroStats, _impl_.assists_),
  2,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_AbilityList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_AbilityList, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.accountid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.playerid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.heroid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.healthpoints_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.maxhealthpoints_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.healthregenrate_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.manapoints_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.maxmanapoints_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.manaregenrate_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.base_strength_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.base_agility_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.base_intelligence_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.base_armor_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.base_movespeed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.base_damage_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.strength_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.agility_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.intelligence_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.armor_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.movespeed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.damage_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.hero_damage_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.tower_damage_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.abilities_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.kill_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.death_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.assists_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.denies_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.lh_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.hero_healing_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.gold_per_min_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.xp_per_min_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.net_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.respawn_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.ultimate_cooldown_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.has_buyback_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.stashitems_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.itemshoppinglist_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.levelpoints_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.hero_to_hero_stats_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.has_ultimate_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.has_ultimate_mana_),
  1,
  42,
  0,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  ~0u,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  40,
  41,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BuildingDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BuildingDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BuildingDetails, _impl_.team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BuildingDetails, _impl_.heading_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BuildingDetails, _impl_.lane_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BuildingDetails, _impl_.tier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BuildingDetails, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BuildingDetails, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BuildingDetails, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BuildingDetails, _impl_.destroyed_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_KillDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_KillDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_KillDetails, _impl_.player_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_KillDetails, _impl_.death_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_KillDetails, _impl_.killer_player_id_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BroadcasterDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BroadcasterDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_BroadcasterDetails, _impl_.player_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PickBanDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PickBanDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PickBanDetails, _impl_.hero_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_PickBanDetails, _impl_.team_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.server_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.time_of_day_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.is_nightstalker_night_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.game_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.game_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.teamid_radiant_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.teamid_dire_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.picks_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.bans_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.broadcasters_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.game_mode_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.league_node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.single_team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.cheers_peak_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.lobby_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_MatchDetails, _impl_.start_timestamp_),
  0,
  1,
  2,
  3,
  7,
  4,
  13,
  5,
  6,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  9,
  10,
  12,
  8,
  11,
  14,
  15,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_GraphData_LocationStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_GraphData_LocationStats, _impl_.stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats, _impl_.loc_stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_GraphData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_GraphData, _impl_.graph_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_GraphData, _impl_.graph_xp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_GraphData, _impl_.graph_kill_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_GraphData, _impl_.graph_tower_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_GraphData, _impl_.graph_rax_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats_GraphData, _impl_.team_loc_stats_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats, _impl_.match_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats, _impl_.teams_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats, _impl_.buildings_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats, _impl_.graph_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStats, _impl_.delta_frame_),
  0,
  ~0u,
  ~0u,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_TeamDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_TeamDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_TeamDetails, _impl_.team_number_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_TeamDetails, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_TeamDetails, _impl_.team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_TeamDetails, _impl_.team_tag_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_TeamDetails, _impl_.team_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_TeamDetails, _impl_.score_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_TeamDetails, _impl_.net_worth_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_TeamDetails, _impl_.team_logo_url_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_TeamDetails, _impl_.players_),
  3,
  4,
  0,
  1,
  5,
  6,
  7,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.accountid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.playerid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.heroid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.kill_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.death_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.assists_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.denies_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.lh_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.net_worth_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.abilities_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.items_),
  1,
  14,
  0,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_BuildingDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_BuildingDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_BuildingDetails, _impl_.team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_BuildingDetails, _impl_.heading_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_BuildingDetails, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_BuildingDetails, _impl_.lane_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_BuildingDetails, _impl_.tier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_BuildingDetails, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_BuildingDetails, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_BuildingDetails, _impl_.destroyed_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PickBanDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PickBanDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PickBanDetails, _impl_.hero_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_PickBanDetails, _impl_.team_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.server_steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.game_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.steam_broadcaster_account_ids_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.game_mode_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.league_node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.game_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.picks_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.bans_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.lobby_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.start_timestamp_),
  0,
  1,
  2,
  3,
  ~0u,
  4,
  5,
  6,
  7,
  ~0u,
  ~0u,
  8,
  9,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_GraphData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse_GraphData, _impl_.graph_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse, _impl_.match_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse, _impl_.teams_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse, _impl_.buildings_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse, _impl_.graph_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTARealtimeGameStatsTerse, _impl_.delta_frame_),
  0,
  ~0u,
  ~0u,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABroadcastTimelineEvent, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABroadcastTimelineEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABroadcastTimelineEvent, _impl_.event_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABroadcastTimelineEvent, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABroadcastTimelineEvent, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABroadcastTimelineEvent, _impl_.string_data_),
  3,
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientMatchGroupsVersion, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientMatchGroupsVersion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientMatchGroupsVersion, _impl_.matchgroups_version_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASDOHeroStatsHistory, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASDOHeroStatsHistory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASDOHeroStatsHistory, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASDOHeroStatsHistory, _impl_.game_mode_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASDOHeroStatsHistory, _impl_.lobby_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASDOHeroStatsHistory, _impl_.start_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASDOHeroStatsHistory, _impl_.won_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASDOHeroStatsHistory, _impl_.gpm_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASDOHeroStatsHistory, _impl_.xpm_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASDOHeroStatsHistory, _impl_.kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASDOHeroStatsHistory, _impl_.deaths_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASDOHeroStatsHistory, _impl_.assists_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::CMsgPredictionChoice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPredictionChoice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPredictionChoice, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::CMsgPredictionChoice, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgPredictionChoice, _impl_.min_raw_value_),
  PROTOBUF_FIELD_OFFSET(::CMsgPredictionChoice, _impl_.max_raw_value_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction_QueryKeyValues, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction_QueryKeyValues, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction_QueryKeyValues, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction_QueryKeyValues, _impl_.value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.group_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.question_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.choices_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.required_heroes_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.query_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.query_values_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.answer_resolution_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.points_to_grant_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.reward_action_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.debug_force_selection_),
  PROTOBUF_FIELD_OFFSET(::CMsgInGamePrediction, _impl_.raw_value_type_),
  3,
  0,
  4,
  5,
  1,
  ~0u,
  ~0u,
  2,
  ~0u,
  6,
  7,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction_Answers, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction_Answers, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction_Answers, _impl_.answer_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.question_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.choices_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.selection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.start_date_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.lock_date_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.reward_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.answer_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.answer_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.answers_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.query_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.lock_on_selection_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.lock_on_selection_value_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.lock_on_selection_set_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.use_answer_value_ranges_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.region_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.phases_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions_Prediction, _impl_.reward_event_),
  2,
  0,
  ~0u,
  3,
  4,
  5,
  6,
  7,
  8,
  ~0u,
  1,
  9,
  10,
  11,
  12,
  13,
  ~0u,
  14,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions, _impl_.predictions_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions, _impl_.in_game_predictions_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions, _impl_.in_game_prediction_count_per_game_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTASeasonPredictions, _impl_.in_game_prediction_voting_period_minutes_),
  ~0u,
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgAvailablePredictions_MatchPrediction, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgAvailablePredictions_MatchPrediction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgAvailablePredictions_MatchPrediction, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgAvailablePredictions_MatchPrediction, _impl_.predictions_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgAvailablePredictions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgAvailablePredictions, _impl_.match_predictions_),
  PROTOBUF_FIELD_OFFSET(::CMsgLeagueWatchedGames_Series, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgLeagueWatchedGames_Series, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgLeagueWatchedGames_Series, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgLeagueWatchedGames_Series, _impl_.game_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgLeagueWatchedGames_League, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgLeagueWatchedGames_League, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgLeagueWatchedGames_League, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgLeagueWatchedGames_League, _impl_.series_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgLeagueWatchedGames, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgLeagueWatchedGames, _impl_.leagues_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player_CustomGameData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player_CustomGameData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player_CustomGameData, _impl_.dota_team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player_CustomGameData, _impl_.winner_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player_HeroDamageReceived, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player_HeroDamageReceived, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player_HeroDamageReceived, _impl_.pre_reduction_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player_HeroDamageReceived, _impl_.post_reduction_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player_HeroDamageReceived, _impl_.damage_type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.player_slot_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.item_0_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.item_1_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.item_2_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.item_3_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.item_4_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.item_5_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.item_6_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.item_7_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.item_8_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.item_9_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.expected_team_contribution_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.scaled_metric_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.previous_rank_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.rank_change_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.mmr_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.deaths_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.assists_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.leaver_status_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.last_hits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.denies_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.gold_per_min_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.xp_per_min_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.gold_spent_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.hero_damage_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.tower_damage_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.hero_healing_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.time_last_seen_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.player_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.support_ability_value_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.feeding_detected_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.search_rank_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.search_rank_uncertainty_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.rank_uncertainty_change_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.hero_play_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.party_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.scaled_hero_damage_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.scaled_tower_damage_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.scaled_hero_healing_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.scaled_kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.scaled_deaths_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.scaled_assists_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.claimed_farm_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.support_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.claimed_denies_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.claimed_misses_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.misses_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.ability_upgrades_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.additional_units_inventory_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.permanent_buffs_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.pro_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.real_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.custom_game_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.active_plus_subscription_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.net_worth_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.bot_difficulty_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.hero_pick_order_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.hero_was_randomed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.hero_was_dota_plus_suggestion_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.hero_damage_received_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.hero_damage_dealt_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.seconds_dead_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.gold_lost_to_death_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.lane_selection_flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.bounty_runes_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.outposts_captured_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.team_number_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Player, _impl_.team_slot_),
  4,
  5,
  6,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  7,
  8,
  9,
  10,
  52,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  42,
  27,
  28,
  29,
  31,
  30,
  41,
  46,
  47,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  ~0u,
  ~0u,
  ~0u,
  1,
  2,
  3,
  43,
  40,
  48,
  49,
  44,
  45,
  ~0u,
  ~0u,
  50,
  51,
  53,
  54,
  55,
  56,
  57,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_BroadcasterInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_BroadcasterInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_BroadcasterInfo, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_BroadcasterInfo, _impl_.name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_BroadcasterChannel, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_BroadcasterChannel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_BroadcasterChannel, _impl_.country_code_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_BroadcasterChannel, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_BroadcasterChannel, _impl_.broadcaster_infos_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_BroadcasterChannel, _impl_.language_code_),
  0,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Coach, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Coach, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Coach, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Coach, _impl_.coach_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Coach, _impl_.coach_rating_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Coach, _impl_.coach_team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Coach, _impl_.coach_party_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_Coach, _impl_.is_private_coach_),
  1,
  0,
  2,
  4,
  3,
  5,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_CustomGameData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_CustomGameData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_CustomGameData, _impl_.custom_game_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch_CustomGameData, _impl_.map_name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.starttime_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.players_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.tower_status_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.barracks_status_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.cluster_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.first_blood_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.replay_salt_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.server_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.server_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.lobby_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.human_players_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.average_skill_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.game_balance_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.radiant_team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.dire_team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.leagueid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.radiant_team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.dire_team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.radiant_team_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.dire_team_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.radiant_team_logo_url_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.dire_team_logo_url_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.radiant_team_complete_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.dire_team_complete_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.positive_votes_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.negative_votes_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.game_mode_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.picks_bans_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.match_seq_num_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.replay_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.radiant_guild_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.dire_guild_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.radiant_team_tag_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.dire_team_tag_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.series_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.series_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.broadcaster_channels_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.engine_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.custom_game_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.match_flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.private_metadata_key_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.radiant_team_score_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.dire_team_score_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.match_outcome_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.tournament_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.tournament_round_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.pre_game_duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatch, _impl_.coaches_),
  7,
  8,
  ~0u,
  9,
  ~0u,
  ~0u,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  0,
  1,
  22,
  23,
  4,
  5,
  24,
  25,
  26,
  27,
  28,
  ~0u,
  30,
  29,
  31,
  32,
  2,
  3,
  33,
  34,
  ~0u,
  35,
  6,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerCard_StatModifier, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerCard_StatModifier, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerCard_StatModifier, _impl_.stat_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerCard_StatModifier, _impl_.value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerCard, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerCard, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerCard, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerCard, _impl_.stat_modifier_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.player_account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.match_completed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.delay_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.series_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.series_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.deaths_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.cs_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.gpm_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.tower_kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.roshan_kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.teamfight_participation_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.wards_placed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.camps_stacked_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.runes_grabbed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.first_blood_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerStats, _impl_.stuns_),
  1,
  0,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerMatchStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAFantasyPlayerMatchStats, _impl_.matches_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot_Mode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot_Mode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot_Mode, _impl_.mode_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot_Mode, _impl_.desire_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot_Mode, _impl_.target_entity_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot_Mode, _impl_.target_x_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot_Mode, _impl_.target_y_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot_Mode, _impl_.target_z_),
  0,
  1,
  5,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot_Action, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot_Action, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot_Action, _impl_.action_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot_Action, _impl_.action_target_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_.player_owner_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_.difficulty_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_.power_current_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_.power_max_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_.move_target_x_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_.move_target_y_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_.move_target_z_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_.active_mode_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_.execution_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_.modes_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo_Bot, _impl_.action_),
  10,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.bots_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.desire_push_lane_top_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.desire_push_lane_mid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.desire_push_lane_bot_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.desire_defend_lane_top_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.desire_defend_lane_mid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.desire_defend_lane_bot_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.desire_farm_lane_top_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.desire_farm_lane_mid_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.desire_farm_lane_bot_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.desire_farm_roshan_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.execution_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTABotDebugInfo, _impl_.rune_status_),
  ~0u,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgSuccessfulHero, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSuccessfulHero, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSuccessfulHero, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSuccessfulHero, _impl_.win_percent_),
  PROTOBUF_FIELD_OFFSET(::CMsgSuccessfulHero, _impl_.longest_streak_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _impl_.game_mode_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _impl_.kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _impl_.deaths_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _impl_.assists_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _impl_.player_slot_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _impl_.match_outcome_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _impl_.lobby_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentMatchInfo, _impl_.team_number_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::CMsgMatchTips_SingleTip, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgMatchTips_SingleTip, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMatchTips_SingleTip, _impl_.source_account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgMatchTips_SingleTip, _impl_.target_account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgMatchTips_SingleTip, _impl_.tip_amount_),
  PROTOBUF_FIELD_OFFSET(::CMsgMatchTips_SingleTip, _impl_.event_id_),
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgMatchTips, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMatchTips, _impl_.tips_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Player, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Player, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Player, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Player, _impl_.kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Player, _impl_.deaths_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Player, _impl_.assists_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Player, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Player, _impl_.player_slot_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Player, _impl_.pro_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Player, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Player, _impl_.team_number_),
  1,
  2,
  3,
  4,
  5,
  ~0u,
  6,
  0,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.series_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.series_game_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.weekend_tourney_tournament_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.weekend_tourney_season_trophy_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.weekend_tourney_division_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.weekend_tourney_skill_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.radiant_team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.radiant_team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.radiant_team_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.radiant_team_logo_url_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.dire_team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.dire_team_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.dire_team_logo_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal_Tourney, _impl_.dire_team_logo_url_),
  4,
  8,
  10,
  11,
  12,
  13,
  14,
  5,
  0,
  6,
  2,
  7,
  1,
  9,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal, _impl_.start_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal, _impl_.game_mode_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal, _impl_.players_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal, _impl_.tourney_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal, _impl_.match_outcome_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal, _impl_.radiant_score_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal, _impl_.dire_score_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTAMatchMinimal, _impl_.lobby_type_),
  1,
  2,
  3,
  4,
  ~0u,
  0,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::CMsgConsumableUsage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgConsumableUsage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgConsumableUsage, _impl_.item_def_),
  PROTOBUF_FIELD_OFFSET(::CMsgConsumableUsage, _impl_.quantity_change_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgMatchConsumableUsage_PlayerUsage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgMatchConsumableUsage_PlayerUsage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMatchConsumableUsage_PlayerUsage, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgMatchConsumableUsage_PlayerUsage, _impl_.consumables_used_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgMatchConsumableUsage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMatchConsumableUsage, _impl_.player_consumables_used_),
  PROTOBUF_FIELD_OFFSET(::CMsgMatchEventActionGrants_PlayerGrants, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgMatchEventActionGrants_PlayerGrants, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMatchEventActionGrants_PlayerGrants, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgMatchEventActionGrants_PlayerGrants, _impl_.actions_granted_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgMatchEventActionGrants, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMatchEventActionGrants, _impl_.player_grants_),
  PROTOBUF_FIELD_OFFSET(::CMsgCustomGameWhitelist, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgCustomGameWhitelist, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgCustomGameWhitelist, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::CMsgCustomGameWhitelist, _impl_.custom_games_whitelist_),
  PROTOBUF_FIELD_OFFSET(::CMsgCustomGameWhitelist, _impl_.disable_whitelist_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgCustomGameWhitelistForEdit_WhitelistEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgCustomGameWhitelistForEdit_WhitelistEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgCustomGameWhitelistForEdit_WhitelistEntry, _impl_.custom_game_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgCustomGameWhitelistForEdit_WhitelistEntry, _impl_.whitelist_state_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgCustomGameWhitelistForEdit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgCustomGameWhitelistForEdit, _impl_.whitelist_entries_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchInfo, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchInfo, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchInfo, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchInfo, _impl_.win_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchInfo, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchInfo, _impl_.kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchInfo, _impl_.deaths_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchInfo, _impl_.assists_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerMatchRecord, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerMatchRecord, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerMatchRecord, _impl_.wins_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerMatchRecord, _impl_.losses_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchOutcomes, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchOutcomes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchOutcomes, _impl_.outcomes_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentMatchOutcomes, _impl_.match_count_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentCommends, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentCommends, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentCommends, _impl_.commends_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentCommends, _impl_.match_count_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentAccomplishments, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentAccomplishments, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentAccomplishments, _impl_.recent_outcomes_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentAccomplishments, _impl_.total_record_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentAccomplishments, _impl_.prediction_streak_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentAccomplishments, _impl_.plus_prediction_streak_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentAccomplishments, _impl_.recent_commends_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentAccomplishments, _impl_.first_match_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentAccomplishments, _impl_.last_match_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerRecentAccomplishments, _impl_.recent_mvps_),
  0,
  1,
  5,
  6,
  2,
  7,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerHeroRecentAccomplishments, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerHeroRecentAccomplishments, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerHeroRecentAccomplishments, _impl_.recent_outcomes_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerHeroRecentAccomplishments, _impl_.total_record_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerHeroRecentAccomplishments, _impl_.last_match_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgRecentAccomplishments, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentAccomplishments, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRecentAccomplishments, _impl_.player_accomplishments_),
  PROTOBUF_FIELD_OFFSET(::CMsgRecentAccomplishments, _impl_.hero_accomplishments_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgServerToGCRequestPlayerRecentAccomplishments, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerToGCRequestPlayerRecentAccomplishments, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgServerToGCRequestPlayerRecentAccomplishments, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerToGCRequestPlayerRecentAccomplishments, _impl_.hero_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse, _impl_.player_accomplishments_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVoteMatchVotes, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVoteMatchVotes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVoteMatchVotes, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVoteMatchVotes, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgArcanaVoteMatchVotes, _impl_.vote_count_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfo, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfo, _impl_.num_matches_to_search_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfo, _impl_.min_shared_match_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfo, _impl_.num_additional_players_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account, _impl_.num_common_matches_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account, _impl_.earliest_common_match_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account, _impl_.latest_common_match_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account, _impl_.generation_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account, _impl_.persona_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account, _impl_.already_banned_),
  1,
  2,
  3,
  4,
  5,
  0,
  6,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse, _impl_.accounts_),
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData_Slot, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData_Slot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData_Slot, _impl_.event_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData_Slot, _impl_.board_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData_Slot, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData_Slot, _impl_.action_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData_Slot, _impl_.redeemed_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData_Jackpot, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData_Jackpot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData_Jackpot, _impl_.board_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData_Jackpot, _impl_.action_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData_Jackpot, _impl_.hero_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData, _impl_.slots_),
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData, _impl_.jackpots_),
  PROTOBUF_FIELD_OFFSET(::CMsgPullTabsData, _impl_.last_board_),
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData_BenchSlot, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData_BenchSlot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData_BenchSlot, _impl_.slot_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData_BenchSlot, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData_BenchSlot, _impl_.stars_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData_ShopSlot, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData_ShopSlot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData_ShopSlot, _impl_.slot_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData_ShopSlot, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData_ShopSlot, _impl_.is_special_reward_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData, _impl_.bench_slots_),
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData, _impl_.shop_slots_),
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData, _impl_.gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData, _impl_.total_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgUnderDraftData, _impl_.not_restorable_),
  ~0u,
  ~0u,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerTitleData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerTitleData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerTitleData, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerTitleData, _impl_.event_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPlayerTitleData, _impl_.active_),
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATriviaQuestion, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATriviaQuestion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATriviaQuestion, _impl_.question_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATriviaQuestion, _impl_.category_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATriviaQuestion, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATriviaQuestion, _impl_.question_value_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATriviaQuestion, _impl_.answer_values_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATriviaQuestion, _impl_.correct_answer_index_),
  1,
  2,
  3,
  0,
  ~0u,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATriviaQuestionAnswersSummary, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATriviaQuestionAnswersSummary, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATriviaQuestionAnswersSummary, _impl_.summary_available_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTATriviaQuestionAnswersSummary, _impl_.picked_count_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataSpecialValueBonus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataSpecialValueBonus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataSpecialValueBonus, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataSpecialValueBonus, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataSpecialValueBonus, _impl_.operation_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataSpecialValues, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataSpecialValues, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataSpecialValues, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataSpecialValues, _impl_.values_float_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataSpecialValues, _impl_.is_percentage_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataSpecialValues, _impl_.heading_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataSpecialValues, _impl_.bonuses_),
  0,
  ~0u,
  2,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.name_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.desc_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.lore_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.notes_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.shard_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.scepter_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.behavior_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.target_team_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.target_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.damage_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.immunity_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.dispellable_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.max_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.cast_ranges_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.cast_points_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.channel_times_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.cooldowns_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.durations_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.damages_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.mana_costs_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.gold_costs_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.special_values_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.is_item_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.ability_has_scepter_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.ability_has_shard_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.ability_is_granted_by_scepter_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.ability_is_granted_by_shard_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.item_cost_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.item_initial_charges_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.item_neutral_tier_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.item_stock_max_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.item_stock_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilityOrItem, _impl_.item_quality_),
  26,
  0,
  1,
  2,
  3,
  ~0u,
  4,
  5,
  7,
  6,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.order_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.name_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.bio_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.hype_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.npe_desc_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.str_base_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.str_gain_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.agi_base_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.agi_gain_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.int_base_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.int_gain_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.primary_attr_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.complexity_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.attack_capability_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.role_levels_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.damage_min_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.damage_max_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.attack_rate_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.attack_range_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.projectile_speed_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.armor_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.magic_resistance_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.movement_speed_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.turn_rate_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.sight_range_day_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.sight_range_night_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.max_health_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.health_regen_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.max_mana_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.mana_regen_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.abilities_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHero, _impl_.talents_),
  5,
  0,
  6,
  1,
  2,
  3,
  4,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  ~0u,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilities, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataAbilities, _impl_.abilities_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataItems, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataItems, _impl_.items_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHeroes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHeroes, _impl_.heroes_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHeroList_HeroInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHeroList_HeroInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHeroList_HeroInfo, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHeroList_HeroInfo, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHeroList_HeroInfo, _impl_.name_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHeroList_HeroInfo, _impl_.name_english_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHeroList_HeroInfo, _impl_.primary_attr_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHeroList_HeroInfo, _impl_.complexity_),
  3,
  0,
  1,
  2,
  4,
  5,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHeroList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataHeroList, _impl_.heroes_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataItemAbilityList_ItemAbilityInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataItemAbilityList_ItemAbilityInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataItemAbilityList_ItemAbilityInfo, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataItemAbilityList_ItemAbilityInfo, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataItemAbilityList_ItemAbilityInfo, _impl_.name_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataItemAbilityList_ItemAbilityInfo, _impl_.name_english_loc_),
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataItemAbilityList_ItemAbilityInfo, _impl_.neutral_item_tier_),
  4,
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataItemAbilityList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGameDataItemAbilityList, _impl_.itemabilities_),
  PROTOBUF_FIELD_OFFSET(::CMsgLobbyAbilityDraftData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgLobbyAbilityDraftData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgLobbyAbilityDraftData, _impl_.shuffle_draft_order_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.expiration_date_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.bonus_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.bonus_count_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.item_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.def_index_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.seconds_left_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemDropRateBonus, _impl_.booster_type_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::CSOEconItemTournamentPassport, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemTournamentPassport, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSOEconItemTournamentPassport, _impl_.account_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemTournamentPassport, _impl_.league_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemTournamentPassport, _impl_.item_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemTournamentPassport, _impl_.original_purchaser_id_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemTournamentPassport, _impl_.passports_bought_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemTournamentPassport, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemTournamentPassport, _impl_.def_index_),
  PROTOBUF_FIELD_OFFSET(::CSOEconItemTournamentPassport, _impl_.reward_flags_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookSticker, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookSticker, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookSticker, _impl_.item_def_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookSticker, _impl_.sticker_num_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookSticker, _impl_.quality_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookSticker, _impl_.position_x_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookSticker, _impl_.position_y_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookSticker, _impl_.position_z_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookSticker, _impl_.rotation_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookSticker, _impl_.scale_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookSticker, _impl_.source_item_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookSticker, _impl_.depth_bias_),
  0,
  1,
  2,
  3,
  4,
  7,
  5,
  6,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookPage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookPage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookPage, _impl_.page_num_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookPage, _impl_.event_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookPage, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookPage, _impl_.stickers_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookPage, _impl_.page_type_),
  0,
  1,
  2,
  ~0u,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookTeamPageOrderSequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbookTeamPageOrderSequence, _impl_.page_numbers_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbook, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbook, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbook, _impl_.pages_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbook, _impl_.team_page_order_sequence_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerbook, _impl_.favorite_page_num_),
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgStickerHero, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerHero, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgStickerHero, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerHero, _impl_.item_def_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerHero, _impl_.quality_),
  PROTOBUF_FIELD_OFFSET(::CMsgStickerHero, _impl_.source_item_id_),
  0,
  1,
  3,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgStickerHeroes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgStickerHeroes, _impl_.heroes_),
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleStats, _impl_.lane_selection_flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleStats, _impl_.match_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleStats, _impl_.win_count_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleHeroStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleHeroStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleHeroStats, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleHeroStats, _impl_.role_stats_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleRankStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleRankStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleRankStats, _impl_.rank_tier_),
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleRankStats, _impl_.hero_stats_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleAllRanksStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleAllRanksStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleAllRanksStats, _impl_.start_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleAllRanksStats, _impl_.end_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgHeroRoleAllRanksStats, _impl_.rank_stats_),
  0,
  1,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::CSODOTAGameAccountClient_RoleHandicap)},
  { 10, 73, -1, sizeof(::CSODOTAGameAccountClient)},
  { 130, 144, -1, sizeof(::CSODOTAGameAccountPlus)},
  { 152, 161, -1, sizeof(::CMsgLobbyFeaturedGamemodeProgress_AccountProgress)},
  { 164, -1, -1, sizeof(::CMsgLobbyFeaturedGamemodeProgress)},
  { 171, 186, -1, sizeof(::CMsgBattleCupVictory)},
  { 195, -1, -1, sizeof(::CMsgLobbyBattleCupVictoryList)},
  { 202, 209, -1, sizeof(::CMsgDOTABroadcastNotification)},
  { 210, 224, -1, sizeof(::CProtoItemHeroStatue)},
  { 232, 240, -1, sizeof(::CMatchPlayerAbilityUpgrade)},
  { 242, 289, -1, sizeof(::CMatchPlayerTimedStats)},
  { 330, 341, -1, sizeof(::CMatchTeamTimedStats)},
  { 346, 354, -1, sizeof(::CMatchAdditionalUnitInventory)},
  { 356, 365, -1, sizeof(::CMatchPlayerPermanentBuff)},
  { 368, 377, -1, sizeof(::CMatchHeroSelectEvent)},
  { 380, 395, -1, sizeof(::CMatchClip)},
  { 404, 413, -1, sizeof(::CPartySearchClientParty)},
  { 416, 424, -1, sizeof(::CMsgDOTAHasItemQuery)},
  { 426, 433, -1, sizeof(::CMsgDOTAHasItemResponse)},
  { 434, 443, -1, sizeof(::CMsgGCGetPlayerCardItemInfo)},
  { 446, 455, -1, sizeof(::CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo)},
  { 458, -1, -1, sizeof(::CMsgGCGetPlayerCardItemInfoResponse)},
  { 465, 474, -1, sizeof(::CSODOTAMapLocationState)},
  { 477, -1, -1, sizeof(::CMsgLeagueAdminList)},
  { 484, 492, -1, sizeof(::CMsgDOTAProfileCard_Slot_Trophy)},
  { 494, 502, -1, sizeof(::CMsgDOTAProfileCard_Slot_Stat)},
  { 504, 512, -1, sizeof(::CMsgDOTAProfileCard_Slot_Item)},
  { 514, 523, -1, sizeof(::CMsgDOTAProfileCard_Slot_Hero)},
  { 526, 533, -1, sizeof(::CMsgDOTAProfileCard_Slot_Emoticon)},
  { 534, 541, -1, sizeof(::CMsgDOTAProfileCard_Slot_Team)},
  { 542, 555, -1, sizeof(::CMsgDOTAProfileCard_Slot)},
  { 562, 583, -1, sizeof(::CMsgDOTAProfileCard)},
  { 598, 621, -1, sizeof(::CSODOTAPlayerChallenge)},
  { 638, 647, -1, sizeof(::CMsgClientToGCRerollPlayerChallenge)},
  { 650, 657, -1, sizeof(::CMsgGCRerollPlayerChallengeResponse)},
  { 658, 666, -1, sizeof(::CMsgGCTopCustomGamesList)},
  { 668, 685, -1, sizeof(::CMsgDOTARealtimeGameStats_TeamDetails)},
  { 696, 707, -1, sizeof(::CMsgDOTARealtimeGameStats_ItemDetails)},
  { 712, 723, -1, sizeof(::CMsgDOTARealtimeGameStats_AbilityDetails)},
  { 728, 737, -1, sizeof(::CMsgDOTARealtimeGameStats_HeroToHeroStats)},
  { 740, -1, -1, sizeof(::CMsgDOTARealtimeGameStats_AbilityList)},
  { 747, 802, -1, sizeof(::CMsgDOTARealtimeGameStats_PlayerDetails)},
  { 851, 865, -1, sizeof(::CMsgDOTARealtimeGameStats_BuildingDetails)},
  { 873, 882, -1, sizeof(::CMsgDOTARealtimeGameStats_KillDetails)},
  { 885, 892, -1, sizeof(::CMsgDOTARealtimeGameStats_BroadcasterDetails)},
  { 893, 901, -1, sizeof(::CMsgDOTARealtimeGameStats_PickBanDetails)},
  { 903, 929, -1, sizeof(::CMsgDOTARealtimeGameStats_MatchDetails)},
  { 949, -1, -1, sizeof(::CMsgDOTARealtimeGameStats_GraphData_LocationStats)},
  { 956, -1, -1, sizeof(::CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats)},
  { 963, -1, -1, sizeof(::CMsgDOTARealtimeGameStats_GraphData)},
  { 975, 986, -1, sizeof(::CMsgDOTARealtimeGameStats)},
  { 991, 1006, -1, sizeof(::CMsgDOTARealtimeGameStatsTerse_TeamDetails)},
  { 1015, 1038, -1, sizeof(::CMsgDOTARealtimeGameStatsTerse_PlayerDetails)},
  { 1055, 1069, -1, sizeof(::CMsgDOTARealtimeGameStatsTerse_BuildingDetails)},
  { 1077, 1085, -1, sizeof(::CMsgDOTARealtimeGameStatsTerse_PickBanDetails)},
  { 1087, 1106, -1, sizeof(::CMsgDOTARealtimeGameStatsTerse_MatchDetails)},
  { 1119, -1, -1, sizeof(::CMsgDOTARealtimeGameStatsTerse_GraphData)},
  { 1126, 1137, -1, sizeof(::CMsgDOTARealtimeGameStatsTerse)},
  { 1142, 1152, -1, sizeof(::CMsgDOTABroadcastTimelineEvent)},
  { 1156, 1163, -1, sizeof(::CMsgGCToClientMatchGroupsVersion)},
  { 1164, 1180, -1, sizeof(::CMsgDOTASDOHeroStatsHistory)},
  { 1190, 1200, -1, sizeof(::CMsgPredictionChoice)},
  { 1204, 1212, -1, sizeof(::CMsgInGamePrediction_QueryKeyValues)},
  { 1214, 1234, -1, sizeof(::CMsgInGamePrediction)},
  { 1248, 1255, -1, sizeof(::CMsgDOTASeasonPredictions_Prediction_Answers)},
  { 1256, 1280, -1, sizeof(::CMsgDOTASeasonPredictions_Prediction)},
  { 1298, 1308, -1, sizeof(::CMsgDOTASeasonPredictions)},
  { 1312, 1320, -1, sizeof(::CMsgAvailablePredictions_MatchPrediction)},
  { 1322, -1, -1, sizeof(::CMsgAvailablePredictions)},
  { 1329, 1337, -1, sizeof(::CMsgLeagueWatchedGames_Series)},
  { 1339, 1347, -1, sizeof(::CMsgLeagueWatchedGames_League)},
  { 1349, -1, -1, sizeof(::CMsgLeagueWatchedGames)},
  { 1356, 1364, -1, sizeof(::CMsgDOTAMatch_Player_CustomGameData)},
  { 1366, 1375, -1, sizeof(::CMsgDOTAMatch_Player_HeroDamageReceived)},
  { 1378, 1457, -1, sizeof(::CMsgDOTAMatch_Player)},
  { 1530, 1538, -1, sizeof(::CMsgDOTAMatch_BroadcasterInfo)},
  { 1540, 1550, -1, sizeof(::CMsgDOTAMatch_BroadcasterChannel)},
  { 1554, 1566, -1, sizeof(::CMsgDOTAMatch_Coach)},
  { 1572, 1580, -1, sizeof(::CMsgDOTAMatch_CustomGameData)},
  { 1582, 1638, -1, sizeof(::CMsgDOTAMatch)},
  { 1688, 1696, -1, sizeof(::CMsgPlayerCard_StatModifier)},
  { 1698, 1706, -1, sizeof(::CMsgPlayerCard)},
  { 1708, 1734, -1, sizeof(::CMsgDOTAFantasyPlayerStats)},
  { 1754, -1, -1, sizeof(::CMsgDOTAFantasyPlayerMatchStats)},
  { 1761, 1773, -1, sizeof(::CMsgDOTABotDebugInfo_Bot_Mode)},
  { 1779, 1787, -1, sizeof(::CMsgDOTABotDebugInfo_Bot_Action)},
  { 1789, 1807, -1, sizeof(::CMsgDOTABotDebugInfo_Bot)},
  { 1819, 1838, -1, sizeof(::CMsgDOTABotDebugInfo)},
  { 1851, 1860, -1, sizeof(::CMsgSuccessfulHero)},
  { 1863, 1880, -1, sizeof(::CMsgRecentMatchInfo)},
  { 1891, 1901, -1, sizeof(::CMsgMatchTips_SingleTip)},
  { 1905, -1, -1, sizeof(::CMsgMatchTips)},
  { 1912, 1928, -1, sizeof(::CMsgDOTAMatchMinimal_Player)},
  { 1938, 1959, -1, sizeof(::CMsgDOTAMatchMinimal_Tourney)},
  { 1974, 1990, -1, sizeof(::CMsgDOTAMatchMinimal)},
  { 2000, 2008, -1, sizeof(::CMsgConsumableUsage)},
  { 2010, 2018, -1, sizeof(::CMsgMatchConsumableUsage_PlayerUsage)},
  { 2020, -1, -1, sizeof(::CMsgMatchConsumableUsage)},
  { 2027, 2035, -1, sizeof(::CMsgMatchEventActionGrants_PlayerGrants)},
  { 2037, -1, -1, sizeof(::CMsgMatchEventActionGrants)},
  { 2044, 2053, -1, sizeof(::CMsgCustomGameWhitelist)},
  { 2056, 2064, -1, sizeof(::CMsgCustomGameWhitelistForEdit_WhitelistEntry)},
  { 2066, -1, -1, sizeof(::CMsgCustomGameWhitelistForEdit)},
  { 2073, 2087, -1, sizeof(::CMsgPlayerRecentMatchInfo)},
  { 2095, 2103, -1, sizeof(::CMsgPlayerMatchRecord)},
  { 2105, 2113, -1, sizeof(::CMsgPlayerRecentMatchOutcomes)},
  { 2115, 2123, -1, sizeof(::CMsgPlayerRecentCommends)},
  { 2125, 2139, -1, sizeof(::CMsgPlayerRecentAccomplishments)},
  { 2147, 2156, -1, sizeof(::CMsgPlayerHeroRecentAccomplishments)},
  { 2159, 2167, -1, sizeof(::CMsgRecentAccomplishments)},
  { 2169, 2177, -1, sizeof(::CMsgServerToGCRequestPlayerRecentAccomplishments)},
  { 2179, 2187, -1, sizeof(::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse)},
  { 2189, 2198, -1, sizeof(::CMsgArcanaVoteMatchVotes)},
  { 2201, 2211, -1, sizeof(::CMsgGCtoGCAssociatedExploiterAccountInfo)},
  { 2215, 2228, -1, sizeof(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account)},
  { 2235, -1, -1, sizeof(::CMsgGCtoGCAssociatedExploiterAccountInfoResponse)},
  { 2242, 2253, -1, sizeof(::CMsgPullTabsData_Slot)},
  { 2258, 2267, -1, sizeof(::CMsgPullTabsData_Jackpot)},
  { 2270, 2279, -1, sizeof(::CMsgPullTabsData)},
  { 2282, 2291, -1, sizeof(::CMsgUnderDraftData_BenchSlot)},
  { 2294, 2303, -1, sizeof(::CMsgUnderDraftData_ShopSlot)},
  { 2306, 2317, -1, sizeof(::CMsgUnderDraftData)},
  { 2322, 2331, -1, sizeof(::CMsgPlayerTitleData)},
  { 2334, 2346, -1, sizeof(::CMsgDOTATriviaQuestion)},
  { 2352, 2360, -1, sizeof(::CMsgDOTATriviaQuestionAnswersSummary)},
  { 2362, 2371, -1, sizeof(::CMsgGameDataSpecialValueBonus)},
  { 2374, 2385, -1, sizeof(::CMsgGameDataSpecialValues)},
  { 2390, 2433, -1, sizeof(::CMsgGameDataAbilityOrItem)},
  { 2470, 2510, -1, sizeof(::CMsgGameDataHero)},
  { 2544, -1, -1, sizeof(::CMsgGameDataAbilities)},
  { 2551, -1, -1, sizeof(::CMsgGameDataItems)},
  { 2558, -1, -1, sizeof(::CMsgGameDataHeroes)},
  { 2565, 2577, -1, sizeof(::CMsgGameDataHeroList_HeroInfo)},
  { 2583, -1, -1, sizeof(::CMsgGameDataHeroList)},
  { 2590, 2601, -1, sizeof(::CMsgGameDataItemAbilityList_ItemAbilityInfo)},
  { 2606, -1, -1, sizeof(::CMsgGameDataItemAbilityList)},
  { 2613, 2620, -1, sizeof(::CMsgLobbyAbilityDraftData)},
  { 2621, 2635, -1, sizeof(::CSOEconItemDropRateBonus)},
  { 2643, 2657, -1, sizeof(::CSOEconItemTournamentPassport)},
  { 2665, 2681, -1, sizeof(::CMsgStickerbookSticker)},
  { 2691, 2702, -1, sizeof(::CMsgStickerbookPage)},
  { 2707, -1, -1, sizeof(::CMsgStickerbookTeamPageOrderSequence)},
  { 2714, 2723, -1, sizeof(::CMsgStickerbook)},
  { 2726, 2736, -1, sizeof(::CMsgStickerHero)},
  { 2740, -1, -1, sizeof(::CMsgStickerHeroes)},
  { 2747, 2756, -1, sizeof(::CMsgHeroRoleStats)},
  { 2759, 2767, -1, sizeof(::CMsgHeroRoleHeroStats)},
  { 2769, 2777, -1, sizeof(::CMsgHeroRoleRankStats)},
  { 2779, 2788, -1, sizeof(::CMsgHeroRoleAllRanksStats)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CSODOTAGameAccountClient_RoleHandicap_default_instance_._instance,
  &::_CSODOTAGameAccountClient_default_instance_._instance,
  &::_CSODOTAGameAccountPlus_default_instance_._instance,
  &::_CMsgLobbyFeaturedGamemodeProgress_AccountProgress_default_instance_._instance,
  &::_CMsgLobbyFeaturedGamemodeProgress_default_instance_._instance,
  &::_CMsgBattleCupVictory_default_instance_._instance,
  &::_CMsgLobbyBattleCupVictoryList_default_instance_._instance,
  &::_CMsgDOTABroadcastNotification_default_instance_._instance,
  &::_CProtoItemHeroStatue_default_instance_._instance,
  &::_CMatchPlayerAbilityUpgrade_default_instance_._instance,
  &::_CMatchPlayerTimedStats_default_instance_._instance,
  &::_CMatchTeamTimedStats_default_instance_._instance,
  &::_CMatchAdditionalUnitInventory_default_instance_._instance,
  &::_CMatchPlayerPermanentBuff_default_instance_._instance,
  &::_CMatchHeroSelectEvent_default_instance_._instance,
  &::_CMatchClip_default_instance_._instance,
  &::_CPartySearchClientParty_default_instance_._instance,
  &::_CMsgDOTAHasItemQuery_default_instance_._instance,
  &::_CMsgDOTAHasItemResponse_default_instance_._instance,
  &::_CMsgGCGetPlayerCardItemInfo_default_instance_._instance,
  &::_CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo_default_instance_._instance,
  &::_CMsgGCGetPlayerCardItemInfoResponse_default_instance_._instance,
  &::_CSODOTAMapLocationState_default_instance_._instance,
  &::_CMsgLeagueAdminList_default_instance_._instance,
  &::_CMsgDOTAProfileCard_Slot_Trophy_default_instance_._instance,
  &::_CMsgDOTAProfileCard_Slot_Stat_default_instance_._instance,
  &::_CMsgDOTAProfileCard_Slot_Item_default_instance_._instance,
  &::_CMsgDOTAProfileCard_Slot_Hero_default_instance_._instance,
  &::_CMsgDOTAProfileCard_Slot_Emoticon_default_instance_._instance,
  &::_CMsgDOTAProfileCard_Slot_Team_default_instance_._instance,
  &::_CMsgDOTAProfileCard_Slot_default_instance_._instance,
  &::_CMsgDOTAProfileCard_default_instance_._instance,
  &::_CSODOTAPlayerChallenge_default_instance_._instance,
  &::_CMsgClientToGCRerollPlayerChallenge_default_instance_._instance,
  &::_CMsgGCRerollPlayerChallengeResponse_default_instance_._instance,
  &::_CMsgGCTopCustomGamesList_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_TeamDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_ItemDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_AbilityDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_HeroToHeroStats_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_AbilityList_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_PlayerDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_BuildingDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_KillDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_BroadcasterDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_PickBanDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_MatchDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_GraphData_LocationStats_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_GraphData_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStats_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStatsTerse_TeamDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStatsTerse_PlayerDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStatsTerse_BuildingDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStatsTerse_PickBanDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStatsTerse_MatchDetails_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStatsTerse_GraphData_default_instance_._instance,
  &::_CMsgDOTARealtimeGameStatsTerse_default_instance_._instance,
  &::_CMsgDOTABroadcastTimelineEvent_default_instance_._instance,
  &::_CMsgGCToClientMatchGroupsVersion_default_instance_._instance,
  &::_CMsgDOTASDOHeroStatsHistory_default_instance_._instance,
  &::_CMsgPredictionChoice_default_instance_._instance,
  &::_CMsgInGamePrediction_QueryKeyValues_default_instance_._instance,
  &::_CMsgInGamePrediction_default_instance_._instance,
  &::_CMsgDOTASeasonPredictions_Prediction_Answers_default_instance_._instance,
  &::_CMsgDOTASeasonPredictions_Prediction_default_instance_._instance,
  &::_CMsgDOTASeasonPredictions_default_instance_._instance,
  &::_CMsgAvailablePredictions_MatchPrediction_default_instance_._instance,
  &::_CMsgAvailablePredictions_default_instance_._instance,
  &::_CMsgLeagueWatchedGames_Series_default_instance_._instance,
  &::_CMsgLeagueWatchedGames_League_default_instance_._instance,
  &::_CMsgLeagueWatchedGames_default_instance_._instance,
  &::_CMsgDOTAMatch_Player_CustomGameData_default_instance_._instance,
  &::_CMsgDOTAMatch_Player_HeroDamageReceived_default_instance_._instance,
  &::_CMsgDOTAMatch_Player_default_instance_._instance,
  &::_CMsgDOTAMatch_BroadcasterInfo_default_instance_._instance,
  &::_CMsgDOTAMatch_BroadcasterChannel_default_instance_._instance,
  &::_CMsgDOTAMatch_Coach_default_instance_._instance,
  &::_CMsgDOTAMatch_CustomGameData_default_instance_._instance,
  &::_CMsgDOTAMatch_default_instance_._instance,
  &::_CMsgPlayerCard_StatModifier_default_instance_._instance,
  &::_CMsgPlayerCard_default_instance_._instance,
  &::_CMsgDOTAFantasyPlayerStats_default_instance_._instance,
  &::_CMsgDOTAFantasyPlayerMatchStats_default_instance_._instance,
  &::_CMsgDOTABotDebugInfo_Bot_Mode_default_instance_._instance,
  &::_CMsgDOTABotDebugInfo_Bot_Action_default_instance_._instance,
  &::_CMsgDOTABotDebugInfo_Bot_default_instance_._instance,
  &::_CMsgDOTABotDebugInfo_default_instance_._instance,
  &::_CMsgSuccessfulHero_default_instance_._instance,
  &::_CMsgRecentMatchInfo_default_instance_._instance,
  &::_CMsgMatchTips_SingleTip_default_instance_._instance,
  &::_CMsgMatchTips_default_instance_._instance,
  &::_CMsgDOTAMatchMinimal_Player_default_instance_._instance,
  &::_CMsgDOTAMatchMinimal_Tourney_default_instance_._instance,
  &::_CMsgDOTAMatchMinimal_default_instance_._instance,
  &::_CMsgConsumableUsage_default_instance_._instance,
  &::_CMsgMatchConsumableUsage_PlayerUsage_default_instance_._instance,
  &::_CMsgMatchConsumableUsage_default_instance_._instance,
  &::_CMsgMatchEventActionGrants_PlayerGrants_default_instance_._instance,
  &::_CMsgMatchEventActionGrants_default_instance_._instance,
  &::_CMsgCustomGameWhitelist_default_instance_._instance,
  &::_CMsgCustomGameWhitelistForEdit_WhitelistEntry_default_instance_._instance,
  &::_CMsgCustomGameWhitelistForEdit_default_instance_._instance,
  &::_CMsgPlayerRecentMatchInfo_default_instance_._instance,
  &::_CMsgPlayerMatchRecord_default_instance_._instance,
  &::_CMsgPlayerRecentMatchOutcomes_default_instance_._instance,
  &::_CMsgPlayerRecentCommends_default_instance_._instance,
  &::_CMsgPlayerRecentAccomplishments_default_instance_._instance,
  &::_CMsgPlayerHeroRecentAccomplishments_default_instance_._instance,
  &::_CMsgRecentAccomplishments_default_instance_._instance,
  &::_CMsgServerToGCRequestPlayerRecentAccomplishments_default_instance_._instance,
  &::_CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_default_instance_._instance,
  &::_CMsgArcanaVoteMatchVotes_default_instance_._instance,
  &::_CMsgGCtoGCAssociatedExploiterAccountInfo_default_instance_._instance,
  &::_CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account_default_instance_._instance,
  &::_CMsgGCtoGCAssociatedExploiterAccountInfoResponse_default_instance_._instance,
  &::_CMsgPullTabsData_Slot_default_instance_._instance,
  &::_CMsgPullTabsData_Jackpot_default_instance_._instance,
  &::_CMsgPullTabsData_default_instance_._instance,
  &::_CMsgUnderDraftData_BenchSlot_default_instance_._instance,
  &::_CMsgUnderDraftData_ShopSlot_default_instance_._instance,
  &::_CMsgUnderDraftData_default_instance_._instance,
  &::_CMsgPlayerTitleData_default_instance_._instance,
  &::_CMsgDOTATriviaQuestion_default_instance_._instance,
  &::_CMsgDOTATriviaQuestionAnswersSummary_default_instance_._instance,
  &::_CMsgGameDataSpecialValueBonus_default_instance_._instance,
  &::_CMsgGameDataSpecialValues_default_instance_._instance,
  &::_CMsgGameDataAbilityOrItem_default_instance_._instance,
  &::_CMsgGameDataHero_default_instance_._instance,
  &::_CMsgGameDataAbilities_default_instance_._instance,
  &::_CMsgGameDataItems_default_instance_._instance,
  &::_CMsgGameDataHeroes_default_instance_._instance,
  &::_CMsgGameDataHeroList_HeroInfo_default_instance_._instance,
  &::_CMsgGameDataHeroList_default_instance_._instance,
  &::_CMsgGameDataItemAbilityList_ItemAbilityInfo_default_instance_._instance,
  &::_CMsgGameDataItemAbilityList_default_instance_._instance,
  &::_CMsgLobbyAbilityDraftData_default_instance_._instance,
  &::_CSOEconItemDropRateBonus_default_instance_._instance,
  &::_CSOEconItemTournamentPassport_default_instance_._instance,
  &::_CMsgStickerbookSticker_default_instance_._instance,
  &::_CMsgStickerbookPage_default_instance_._instance,
  &::_CMsgStickerbookTeamPageOrderSequence_default_instance_._instance,
  &::_CMsgStickerbook_default_instance_._instance,
  &::_CMsgStickerHero_default_instance_._instance,
  &::_CMsgStickerHeroes_default_instance_._instance,
  &::_CMsgHeroRoleStats_default_instance_._instance,
  &::_CMsgHeroRoleHeroStats_default_instance_._instance,
  &::_CMsgHeroRoleRankStats_default_instance_._instance,
  &::_CMsgHeroRoleAllRanksStats_default_instance_._instance,
};

const char descriptor_table_protodef_dota_5fgcmessages_5fcommon_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\034dota_gcmessages_common.proto\032\023steammes"
  "sages.proto\032\026gcsdk_gcmessages.proto\032\027dot"
  "a_shared_enums.proto\"\355\016\n\030CSODOTAGameAcco"
  "untClient\022\030\n\naccount_id\030\001 \001(\rB\004\200\246\035\001\022\014\n\004w"
  "ins\030\003 \001(\r\022\016\n\006losses\030\004 \001(\r\022\n\n\002xp\030\014 \001(\r\022\r\n"
  "\005level\030\r \001(\r\022\025\n\rinitial_skill\030\016 \001(\r\022\024\n\014l"
  "eaver_count\030\017 \001(\r\022\036\n\026secondary_leaver_co"
  "unt\030: \001(\r\022\037\n\027low_priority_until_date\030\022 \001"
  "(\r\022$\n\034prevent_text_chat_until_date\030\024 \001(\r"
  "\022 \n\030prevent_voice_until_date\030\025 \001(\r\022+\n#pr"
  "event_public_text_chat_until_date\030V \001(\r\022"
  "*\n\"prevent_new_player_chat_until_date\030z "
  "\001(\r\022 \n\030last_abandoned_game_date\030\026 \001(\r\022*\n"
  "\"last_secondary_abandoned_game_date\030; \001("
  "\r\022\034\n\024leaver_penalty_count\030\027 \001(\r\022\035\n\025compl"
  "eted_game_streak\030\030 \001(\r\022#\n\033account_disabl"
  "ed_until_date\030& \001(\r\022\036\n\026account_disabled_"
  "count\030\' \001(\r\022!\n\031match_disabled_until_date"
  "\030) \001(\r\022\034\n\024match_disabled_count\030* \001(\r\022%\n\035"
  "shutdownlawterminatetimestamp\030/ \001(\r\022$\n\034l"
  "ow_priority_games_remaining\0300 \001(\r\022\030\n\020com"
  "petitive_rank\0301 \001(\r\022/\n\'competitive_calib"
  "ration_games_remaining\0303 \001(\r\022\031\n\021recruitm"
  "ent_level\0307 \001(\r\022\035\n\025has_new_notifications"
  "\0308 \001(\010\022\027\n\017is_league_admin\0309 \001(\010\022\033\n\023casua"
  "l_games_played\030< \001(\r\022%\n\035solo_competitive"
  "_games_played\030= \001(\r\022&\n\036party_competitive"
  "_games_played\030> \001(\r\022\037\n\027casual_1v1_games_"
  "played\030A \001(\r\022\"\n\032curr_all_hero_challenge_"
  "id\030C \001(\r\022\030\n\020play_time_points\030D \001(\r\022\025\n\rac"
  "count_flags\030E \001(\r\022\027\n\017play_time_level\030F \001"
  "(\r\022+\n#player_behavior_seq_num_last_repor"
  "t\030G \001(\r\022)\n!player_behavior_score_last_re"
  "port\030H \001(\r\022\'\n\037player_behavior_report_old"
  "_data\030I \001(\010\022\033\n\023tourney_skill_level\030J \001(\r"
  "\022)\n!tourney_recent_participation_date\030U "
  "\001(\r\022 \n\030anchored_phone_number_id\030X \001(\004\022)\n"
  "!ranked_matchmaking_ban_until_date\030Y \001(\r"
  "\022\032\n\022recent_game_time_1\030Z \001(\r\022\032\n\022recent_g"
  "ame_time_2\030[ \001(\r\022\032\n\022recent_game_time_3\030\\"
  " \001(\r\022\034\n\024favorite_team_packed\030g \001(\004\022\032\n\022re"
  "cent_report_time\030h \001(\r\022\'\n\037custom_game_di"
  "sabled_until_date\030i \001(\r\022\031\n\021recent_win_ti"
  "me_1\030j \001(\r\022\031\n\021recent_win_time_2\030k \001(\r\022\031\n"
  "\021recent_win_time_3\030l \001(\r\022\024\n\014coach_rating"
  "\030m \001(\r\022\024\n\014queue_points\030r \001(\r\022>\n\016role_han"
  "dicaps\030s \003(\0132&.CSODOTAGameAccountClient."
  "RoleHandicap\022\036\n\026event_mode_recent_time\030x"
  " \001(\r\022\036\n\026mmr_recalibration_time\030y \001(\r\032.\n\014"
  "RoleHandicap\022\014\n\004role\030\001 \001(\r\022\020\n\010handicap\030\002"
  " \001(\002\"\351\001\n\026CSODOTAGameAccountPlus\022\030\n\naccou"
  "nt_id\030\001 \001(\rB\004\200\246\035\001\022\033\n\023original_start_date"
  "\030\002 \001(\r\022\022\n\nplus_flags\030\003 \001(\r\022\023\n\013plus_statu"
  "s\030\004 \001(\r\022\032\n\022prepaid_time_start\030\005 \001(\r\022\034\n\024p"
  "repaid_time_balance\030\006 \001(\r\022\031\n\021next_paymen"
  "t_date\030\007 \001(\007\022\032\n\022steam_agreement_id\030\010 \001(\006"
  "\"\272\001\n!CMsgLobbyFeaturedGamemodeProgress\022D"
  "\n\010accounts\030\001 \003(\01322.CMsgLobbyFeaturedGame"
  "modeProgress.AccountProgress\032O\n\017AccountP"
  "rogress\022\022\n\naccount_id\030\001 \001(\r\022\025\n\rcurrent_v"
  "alue\030\002 \001(\r\022\021\n\tmax_value\030\003 \001(\r\"\306\001\n\024CMsgBa"
  "ttleCupVictory\022\022\n\naccount_id\030\001 \001(\r\022\020\n\010wi"
  "n_date\030\002 \001(\r\022\023\n\013valid_until\030\003 \001(\r\022\023\n\013ski"
  "ll_level\030\004 \001(\r\022\025\n\rtournament_id\030\005 \001(\r\022\023\n"
  "\013division_id\030\006 \001(\r\022\017\n\007team_id\030\007 \001(\r\022\016\n\006s"
  "treak\030\010 \001(\r\022\021\n\ttrophy_id\030\t \001(\r\"G\n\035CMsgLo"
  "bbyBattleCupVictoryList\022&\n\007winners\030\001 \003(\013"
  "2\025.CMsgBattleCupVictory\"0\n\035CMsgDOTABroad"
  "castNotification\022\017\n\007message\030\001 \001(\t\"\271\001\n\024CP"
  "rotoItemHeroStatue\022\017\n\007hero_id\030\001 \001(\r\022\033\n\023s"
  "tatus_effect_index\030\002 \001(\r\022\025\n\rsequence_nam"
  "e\030\003 \001(\t\022\r\n\005cycle\030\004 \001(\002\022\020\n\010wearable\030\005 \003(\r"
  "\022\023\n\013inscription\030\006 \001(\t\022\r\n\005style\030\007 \003(\r\022\027\n\017"
  "tournament_drop\030\010 \001(\010\"\?\n\032CMatchPlayerAbi"
  "lityUpgrade\022\023\n\007ability\030\001 \001(\005:\002-1\022\014\n\004time"
  "\030\002 \001(\r\"\346\007\n\026CMatchPlayerTimedStats\022\014\n\004tim"
  "e\030\001 \001(\r\022\r\n\005kills\030\002 \001(\r\022\016\n\006deaths\030\003 \001(\r\022\017"
  "\n\007assists\030\004 \001(\r\022\021\n\tnet_worth\030\005 \001(\r\022\n\n\002xp"
  "\030\006 \001(\r\022\021\n\tlast_hits\030\007 \001(\r\022\016\n\006denies\030\010 \001("
  "\r\022\030\n\020bounty_rune_gold\030\t \001(\r\022 \n\030range_cre"
  "ep_upgrade_gold\030\n \001(\r\022\037\n\027observer_wards_"
  "dewarded\030\013 \001(\r\022\034\n\024reliable_gold_earned\030\014"
  " \001(\r\022\033\n\023gold_loss_prevented\030\r \001(\r\022\026\n\016her"
  "o_kill_gold\030\016 \001(\r\022\027\n\017creep_kill_gold\030\017 \001"
  "(\r\022\025\n\rbuilding_gold\030\020 \001(\r\022\022\n\nother_gold\030"
  "\021 \001(\r\022\025\n\rcomeback_gold\030\022 \001(\r\022\031\n\021experime"
  "ntal_gold\030\023 \001(\r\022\032\n\022experimental2_gold\030\024 "
  "\001(\r\022\027\n\017creep_deny_gold\030\025 \001(\r\022\036\n\026tp_scrol"
  "ls_purchased_1\030\026 \001(\r\022\036\n\026tp_scrolls_purch"
  "ased_2\030\027 \001(\r\022\036\n\026tp_scrolls_purchased_3\030\030"
  " \001(\r\022\036\n\026tp_scrolls_purchased_4\030\031 \001(\r\022\036\n\026"
  "tp_scrolls_purchased_5\030\032 \001(\r\022\024\n\014neutral_"
  "gold\030\033 \001(\r\022\024\n\014courier_gold\030\034 \001(\r\022\023\n\013rosh"
  "an_gold\030\035 \001(\r\022\023\n\013income_gold\030\036 \001(\r\022\026\n\016cu"
  "stom_stats_1\030\037 \001(\r\022\026\n\016custom_stats_2\030  \001"
  "(\r\022\026\n\016custom_stats_3\030! \001(\r\022\026\n\016custom_sta"
  "ts_4\030\" \001(\r\022\026\n\016custom_stats_5\030# \001(\r\022\022\n\nit"
  "em_value\030$ \001(\r\022\032\n\022support_gold_spent\030% \001"
  "(\r\022\025\n\rcamps_stacked\030& \001(\r\022\024\n\014wards_place"
  "d\030\' \001(\r\022\024\n\014triple_kills\030( \001(\r\022\020\n\010rampage"
  "s\030) \001(\r\"\234\001\n\024CMatchTeamTimedStats\022\014\n\004time"
  "\030\001 \001(\r\022\033\n\023enemy_towers_killed\030\002 \001(\r\022\035\n\025e"
  "nemy_barracks_killed\030\003 \001(\r\022\033\n\023enemy_towe"
  "rs_status\030\004 \001(\r\022\035\n\025enemy_barracks_status"
  "\030\005 \001(\r\"A\n\035CMatchAdditionalUnitInventory\022"
  "\021\n\tunit_name\030\001 \001(\t\022\r\n\005items\030\002 \003(\005\"\\\n\031CMa"
  "tchPlayerPermanentBuff\022\026\n\016permanent_buff"
  "\030\001 \001(\r\022\023\n\013stack_count\030\002 \001(\r\022\022\n\ngrant_tim"
  "e\030\003 \001(\r\"G\n\025CMatchHeroSelectEvent\022\017\n\007is_p"
  "ick\030\001 \001(\010\022\014\n\004team\030\002 \001(\r\022\017\n\007hero_id\030\003 \001(\r"
  "\"\320\001\n\nCMatchClip\022\020\n\010match_id\030\001 \001(\004\022\031\n\021pla"
  "yer_account_id\030\002 \001(\r\022\031\n\021game_time_second"
  "s\030\003 \001(\r\022\030\n\020duration_seconds\030\004 \001(\r\022\021\n\tpla"
  "yer_id\030\005 \001(\r\022\017\n\007hero_id\030\006 \001(\r\022\026\n\nability"
  "_id\030\007 \001(\005:\002-1\022\023\n\013camera_mode\030\010 \001(\r\022\017\n\007co"
  "mment\030\t \001(\t\"W\n\027CPartySearchClientParty\022\020"
  "\n\010party_id\030\001 \001(\006\022\023\n\013beacon_type\030\002 \001(\005\022\025\n"
  "\rparty_members\030\003 \003(\007\";\n\024CMsgDOTAHasItemQ"
  "uery\022\022\n\naccount_id\030\001 \001(\r\022\017\n\007item_id\030\002 \001("
  "\004\"+\n\027CMsgDOTAHasItemResponse\022\020\n\010has_item"
  "\030\001 \001(\010\"f\n\033CMsgGCGetPlayerCardItemInfo\022\022\n"
  "\naccount_id\030\001 \001(\r\022\034\n\024player_card_item_id"
  "s\030\002 \003(\004\022\025\n\rall_for_event\030\003 \001(\r\"\320\001\n#CMsgG"
  "CGetPlayerCardItemInfoResponse\022N\n\021player"
  "_card_infos\030\001 \003(\01323.CMsgGCGetPlayerCardI"
  "temInfoResponse.PlayerCardInfo\032Y\n\016Player"
  "CardInfo\022\033\n\023player_card_item_id\030\001 \001(\004\022\022\n"
  "\naccount_id\030\002 \001(\r\022\026\n\016packed_bonuses\030\003 \001("
  "\004\"a\n\027CSODOTAMapLocationState\022\030\n\naccount_"
  "id\030\001 \001(\rB\004\200\246\035\001\022\031\n\013location_id\030\002 \001(\005B\004\200\246\035"
  "\001\022\021\n\tcompleted\030\003 \001(\010\"*\n\023CMsgLeagueAdminL"
  "ist\022\023\n\013account_ids\030\001 \003(\r\"\305\t\n\023CMsgDOTAPro"
  "fileCard\022\022\n\naccount_id\030\001 \001(\r\022(\n\005slots\030\003 "
  "\003(\0132\031.CMsgDOTAProfileCard.Slot\022\024\n\014badge_"
  "points\030\004 \001(\r\022\024\n\014event_points\030\005 \001(\r\022\020\n\010ev"
  "ent_id\030\006 \001(\r\0228\n\031recent_battle_cup_victor"
  "y\030\007 \001(\0132\025.CMsgBattleCupVictory\022\021\n\trank_t"
  "ier\030\010 \001(\r\022\030\n\020leaderboard_rank\030\t \001(\r\022\032\n\022i"
  "s_plus_subscriber\030\n \001(\010\022 \n\030plus_original"
  "_start_date\030\013 \001(\r\022\027\n\017rank_tier_score\030\014 \001"
  "(\r\022\035\n\025leaderboard_rank_core\030\021 \001(\r\022\r\n\005tit"
  "le\030\027 \001(\r\022\034\n\024favorite_team_packed\030\030 \001(\004\022\026"
  "\n\016lifetime_games\030\031 \001(\r\032\360\004\n\004Slot\022\017\n\007slot_"
  "id\030\001 \001(\r\0220\n\006trophy\030\002 \001(\0132 .CMsgDOTAProfi"
  "leCard.Slot.Trophy\022,\n\004stat\030\003 \001(\0132\036.CMsgD"
  "OTAProfileCard.Slot.Stat\022,\n\004item\030\004 \001(\0132\036"
  ".CMsgDOTAProfileCard.Slot.Item\022,\n\004hero\030\005"
  " \001(\0132\036.CMsgDOTAProfileCard.Slot.Hero\0224\n\010"
  "emoticon\030\006 \001(\0132\".CMsgDOTAProfileCard.Slo"
  "t.Emoticon\022,\n\004team\030\007 \001(\0132\036.CMsgDOTAProfi"
  "leCard.Slot.Team\0321\n\006Trophy\022\021\n\ttrophy_id\030"
  "\001 \001(\r\022\024\n\014trophy_score\030\002 \001(\r\032W\n\004Stat\022;\n\007s"
  "tat_id\030\001 \001(\0162\034.CMsgDOTAProfileCard.EStat"
  "ID:\014k_eStat_Wins\022\022\n\nstat_score\030\002 \001(\r\0320\n\004"
  "Item\022\027\n\017serialized_item\030\001 \001(\014\022\017\n\007item_id"
  "\030\002 \001(\004\032\?\n\004Hero\022\017\n\007hero_id\030\001 \001(\r\022\021\n\thero_"
  "wins\030\002 \001(\r\022\023\n\013hero_losses\030\003 \001(\r\032\037\n\010Emoti"
  "con\022\023\n\013emoticon_id\030\001 \001(\r\032\027\n\004Team\022\017\n\007team"
  "_id\030\001 \001(\r\"\234\001\n\007EStatID\022\020\n\014k_eStat_Wins\020\003\022"
  "\024\n\020k_eStat_Commends\020\004\022\027\n\023k_eStat_GamesPl"
  "ayed\020\005\022\032\n\026k_eStat_FirstMatchDate\020\006\022\036\n\032k_"
  "eStat_PreviousSeasonRank\020\007\022\024\n\020k_eStat_Ga"
  "mesMVP\020\010\"\201\003\n\026CSODOTAPlayerChallenge\022\030\n\na"
  "ccount_id\030\001 \001(\rB\004\200\246\035\001\022\026\n\010event_id\030\002 \001(\rB"
  "\004\200\246\035\001\022\025\n\007slot_id\030\003 \001(\rB\004\200\246\035\001\022\023\n\013int_para"
  "m_0\030\005 \001(\r\022\023\n\013int_param_1\030\006 \001(\r\022\024\n\014create"
  "d_time\030\007 \001(\r\022\021\n\tcompleted\030\010 \001(\r\022\023\n\013seque"
  "nce_id\030\t \001(\r\022\026\n\016challenge_tier\030\n \001(\r\022\r\n\005"
  "flags\030\013 \001(\r\022\020\n\010attempts\030\014 \001(\r\022\026\n\016complet"
  "e_limit\030\r \001(\r\022\022\n\nquest_rank\030\016 \001(\r\022\026\n\016max"
  "_quest_rank\030\017 \001(\r\022\023\n\013instance_id\030\020 \001(\r\022\017"
  "\n\007hero_id\030\021 \001(\r\022\023\n\013template_id\030\022 \001(\r\"u\n#"
  "CMsgClientToGCRerollPlayerChallenge\022(\n\010e"
  "vent_id\030\001 \001(\0162\007.EEvent:\rEVENT_ID_NONE\022\023\n"
  "\013sequence_id\030\003 \001(\r\022\017\n\007hero_id\030\004 \001(\r\"\360\001\n#"
  "CMsgGCRerollPlayerChallengeResponse\022M\n\006r"
  "esult\030\001 \001(\0162,.CMsgGCRerollPlayerChalleng"
  "eResponse.EResult:\017eResult_Success\"z\n\007ER"
  "esult\022\023\n\017eResult_Success\020\000\022\023\n\017eResult_Dr"
  "opped\020\001\022\024\n\020eResult_NotFound\020\002\022\026\n\022eResult"
  "_CantReroll\020\003\022\027\n\023eResult_ServerError\020\004\"M"
  "\n\030CMsgGCTopCustomGamesList\022\030\n\020top_custom"
  "_games\030\001 \003(\004\022\027\n\017game_of_the_day\030\002 \001(\004\"\304\033"
  "\n\031CMsgDOTARealtimeGameStats\0226\n\005match\030\001 \001"
  "(\0132\'.CMsgDOTARealtimeGameStats.MatchDeta"
  "ils\0225\n\005teams\030\002 \003(\0132&.CMsgDOTARealtimeGam"
  "eStats.TeamDetails\022=\n\tbuildings\030\003 \003(\0132*."
  "CMsgDOTARealtimeGameStats.BuildingDetail"
  "s\0228\n\ngraph_data\030\004 \001(\0132$.CMsgDOTARealtime"
  "GameStats.GraphData\022\023\n\013delta_frame\030\005 \001(\010"
  "\032\202\002\n\013TeamDetails\022\023\n\013team_number\030\001 \001(\r\022\017\n"
  "\007team_id\030\002 \001(\r\022\021\n\tteam_name\030\003 \001(\t\022\021\n\ttea"
  "m_logo\030\004 \001(\006\022\020\n\010team_tag\030\n \001(\t\022\r\n\005score\030"
  "\005 \001(\r\022\021\n\tnet_worth\030\t \001(\r\0229\n\007players\030\006 \003("
  "\0132(.CMsgDOTARealtimeGameStats.PlayerDeta"
  "ils\022\021\n\tonly_team\030\007 \001(\010\022\016\n\006cheers\030\010 \001(\r\022\025"
  "\n\rteam_logo_url\030\013 \001(\t\032h\n\013ItemDetails\022\033\n\017"
  "item_ability_id\030\001 \001(\005:\002-1\022\014\n\004name\030\002 \001(\t\022"
  "\014\n\004time\030\003 \001(\005\022\014\n\004sold\030\004 \001(\010\022\022\n\nstackcoun"
  "t\030\005 \001(\r\032e\n\016AbilityDetails\022\016\n\002id\030\001 \001(\005:\002-"
  "1\022\014\n\004name\030\002 \001(\t\022\r\n\005level\030\003 \001(\r\022\020\n\010cooldo"
  "wn\030\004 \001(\002\022\024\n\014cooldown_max\030\005 \001(\002\032G\n\017HeroTo"
  "HeroStats\022\024\n\010victimid\030\001 \001(\005:\002-1\022\r\n\005kills"
  "\030\002 \001(\r\022\017\n\007assists\030\003 \001(\r\032\031\n\013AbilityList\022\n"
  "\n\002id\030\001 \003(\005\032\351\t\n\rPlayerDetails\022\021\n\taccounti"
  "d\030\001 \001(\r\022\024\n\010playerid\030\002 \001(\005:\002-1\022\014\n\004name\030\003 "
  "\001(\t\022\014\n\004team\030\004 \001(\r\022\016\n\006heroid\030\005 \001(\r\022\024\n\014hea"
  "lthpoints\030\006 \001(\r\022\027\n\017maxhealthpoints\030\007 \001(\r"
  "\022\027\n\017healthregenrate\030\010 \001(\002\022\022\n\nmanapoints\030"
  "\t \001(\r\022\025\n\rmaxmanapoints\030\n \001(\r\022\025\n\rmanarege"
  "nrate\030\013 \001(\002\022\025\n\rbase_strength\030\014 \001(\r\022\024\n\014ba"
  "se_agility\030\r \001(\r\022\031\n\021base_intelligence\030\016 "
  "\001(\r\022\022\n\nbase_armor\030\017 \001(\005\022\026\n\016base_movespee"
  "d\030\020 \001(\r\022\023\n\013base_damage\030\021 \001(\r\022\020\n\010strength"
  "\030\022 \001(\r\022\017\n\007agility\030\023 \001(\r\022\024\n\014intelligence\030"
  "\024 \001(\r\022\r\n\005armor\030\025 \001(\005\022\021\n\tmovespeed\030\026 \001(\r\022"
  "\016\n\006damage\030\027 \001(\r\022\023\n\013hero_damage\030\030 \001(\r\022\024\n\014"
  "tower_damage\030\031 \001(\r\022<\n\tabilities\030\032 \003(\0132)."
  "CMsgDOTARealtimeGameStats.AbilityDetails"
  "\022\r\n\005level\030\033 \001(\r\022\022\n\nkill_count\030\034 \001(\r\022\023\n\013d"
  "eath_count\030\035 \001(\r\022\025\n\rassists_count\030\036 \001(\r\022"
  "\024\n\014denies_count\030\037 \001(\r\022\020\n\010lh_count\030  \001(\r\022"
  "\024\n\014hero_healing\030! \001(\r\022\024\n\014gold_per_min\030\" "
  "\001(\r\022\022\n\nxp_per_min\030# \001(\r\022\020\n\010net_gold\030$ \001("
  "\r\022\014\n\004gold\030% \001(\r\022\t\n\001x\030& \001(\002\022\t\n\001y\030\' \001(\002\022\024\n"
  "\014respawn_time\030( \001(\005\022\031\n\021ultimate_cooldown"
  "\030) \001(\r\022\023\n\013has_buyback\030* \001(\010\0225\n\005items\030+ \003"
  "(\0132&.CMsgDOTARealtimeGameStats.ItemDetai"
  "ls\022:\n\nstashitems\030, \003(\0132&.CMsgDOTARealtim"
  "eGameStats.ItemDetails\022@\n\020itemshoppingli"
  "st\030- \003(\0132&.CMsgDOTARealtimeGameStats.Ite"
  "mDetails\022;\n\013levelpoints\030. \003(\0132&.CMsgDOTA"
  "RealtimeGameStats.AbilityList\022F\n\022hero_to"
  "_hero_stats\030/ \003(\0132*.CMsgDOTARealtimeGame"
  "Stats.HeroToHeroStats\022\024\n\014has_ultimate\0300 "
  "\001(\010\022\031\n\021has_ultimate_mana\0301 \001(\010\032\203\001\n\017Build"
  "ingDetails\022\014\n\004team\030\002 \001(\r\022\017\n\007heading\030\003 \001("
  "\002\022\014\n\004lane\030\004 \001(\r\022\014\n\004tier\030\005 \001(\r\022\014\n\004type\030\006 "
  "\001(\r\022\t\n\001x\030\007 \001(\002\022\t\n\001y\030\010 \001(\002\022\021\n\tdestroyed\030\t"
  " \001(\010\032V\n\013KillDetails\022\025\n\tplayer_id\030\001 \001(\005:\002"
  "-1\022\022\n\ndeath_time\030\002 \001(\005\022\034\n\020killer_player_"
  "id\030\003 \001(\005:\002-1\032+\n\022BroadcasterDetails\022\025\n\tpl"
  "ayer_id\030\001 \001(\005:\002-1\032,\n\016PickBanDetails\022\014\n\004h"
  "ero\030\001 \001(\r\022\014\n\004team\030\002 \001(\r\032\330\004\n\014MatchDetails"
  "\022\027\n\017server_steam_id\030\001 \001(\006\022\020\n\010match_id\030\002 "
  "\001(\004\022\021\n\ttimestamp\030\003 \001(\r\022\023\n\013time_of_day\030\004 "
  "\001(\002\022\035\n\025is_nightstalker_night\030\005 \001(\010\022\021\n\tga"
  "me_time\030\006 \001(\005\022\022\n\ngame_state\030\023 \001(\r\022\026\n\016tea"
  "mid_radiant\030\010 \001(\r\022\023\n\013teamid_dire\030\t \001(\r\0228"
  "\n\005picks\030\n \003(\0132).CMsgDOTARealtimeGameStat"
  "s.PickBanDetails\0227\n\004bans\030\013 \003(\0132).CMsgDOT"
  "ARealtimeGameStats.PickBanDetails\0225\n\005kil"
  "ls\030\014 \003(\0132&.CMsgDOTARealtimeGameStats.Kil"
  "lDetails\022C\n\014broadcasters\030\r \003(\0132-.CMsgDOT"
  "ARealtimeGameStats.BroadcasterDetails\022\021\n"
  "\tgame_mode\030\016 \001(\r\022\021\n\tleague_id\030\017 \001(\r\022\026\n\016l"
  "eague_node_id\030\022 \001(\r\022\023\n\013single_team\030\020 \001(\010"
  "\022\023\n\013cheers_peak\030\021 \001(\r\022\022\n\nlobby_type\030\024 \001("
  "\r\022\027\n\017start_timestamp\030\025 \001(\r\032\357\003\n\tGraphData"
  "\022\022\n\ngraph_gold\030\001 \003(\005\022\020\n\010graph_xp\030\002 \003(\005\022\022"
  "\n\ngraph_kill\030\003 \003(\005\022\023\n\013graph_tower\030\004 \003(\005\022"
  "\021\n\tgraph_rax\030\005 \003(\005\022N\n\016team_loc_stats\030\006 \003"
  "(\01326.CMsgDOTARealtimeGameStats.GraphData"
  ".TeamLocationStats\032\036\n\rLocationStats\022\r\n\005s"
  "tats\030\001 \003(\005\032Z\n\021TeamLocationStats\022E\n\tloc_s"
  "tats\030\001 \003(\01322.CMsgDOTARealtimeGameStats.G"
  "raphData.LocationStats\"[\n\005eStat\022\023\n\017Creep"
  "GoldEarned\020\000\022\022\n\016KillGoldEarned\020\001\022\033\n\027Deat"
  "hAndBuybackGoldLost\020\002\022\014\n\010XPEarned\020\003\"W\n\te"
  "Location\022\013\n\007BotLane\020\000\022\013\n\007MidLane\020\001\022\013\n\007To"
  "pLane\020\002\022\n\n\006Jungle\020\003\022\014\n\010Ancients\020\004\022\t\n\005Oth"
  "er\020\005\"\251\013\n\036CMsgDOTARealtimeGameStatsTerse\022"
  ";\n\005match\030\001 \001(\0132,.CMsgDOTARealtimeGameSta"
  "tsTerse.MatchDetails\022:\n\005teams\030\002 \003(\0132+.CM"
  "sgDOTARealtimeGameStatsTerse.TeamDetails"
  "\022B\n\tbuildings\030\003 \003(\0132/.CMsgDOTARealtimeGa"
  "meStatsTerse.BuildingDetails\022=\n\ngraph_da"
  "ta\030\004 \001(\0132).CMsgDOTARealtimeGameStatsTers"
  "e.GraphData\022\023\n\013delta_frame\030\005 \001(\010\032\344\001\n\013Tea"
  "mDetails\022\023\n\013team_number\030\001 \001(\r\022\017\n\007team_id"
  "\030\002 \001(\r\022\021\n\tteam_name\030\003 \001(\t\022\020\n\010team_tag\030\010 "
  "\001(\t\022\021\n\tteam_logo\030\004 \001(\006\022\r\n\005score\030\005 \001(\r\022\021\n"
  "\tnet_worth\030\007 \001(\r\022\025\n\rteam_logo_url\030\t \001(\t\022"
  ">\n\007players\030\006 \003(\0132-.CMsgDOTARealtimeGameS"
  "tatsTerse.PlayerDetails\032\264\002\n\rPlayerDetail"
  "s\022\021\n\taccountid\030\001 \001(\r\022\024\n\010playerid\030\002 \001(\005:\002"
  "-1\022\014\n\004name\030\003 \001(\t\022\014\n\004team\030\004 \001(\r\022\016\n\006heroid"
  "\030\005 \001(\r\022\r\n\005level\030\006 \001(\r\022\022\n\nkill_count\030\007 \001("
  "\r\022\023\n\013death_count\030\010 \001(\r\022\025\n\rassists_count\030"
  "\t \001(\r\022\024\n\014denies_count\030\n \001(\r\022\020\n\010lh_count\030"
  "\013 \001(\r\022\014\n\004gold\030\014 \001(\r\022\t\n\001x\030\r \001(\002\022\t\n\001y\030\016 \001("
  "\002\022\021\n\tnet_worth\030\017 \001(\r\022\021\n\tabilities\030\020 \003(\005\022"
  "\r\n\005items\030\021 \003(\005\032\203\001\n\017BuildingDetails\022\014\n\004te"
  "am\030\001 \001(\r\022\017\n\007heading\030\002 \001(\002\022\014\n\004type\030\003 \001(\r\022"
  "\014\n\004lane\030\004 \001(\r\022\014\n\004tier\030\005 \001(\r\022\t\n\001x\030\006 \001(\002\022\t"
  "\n\001y\030\007 \001(\002\022\021\n\tdestroyed\030\010 \001(\010\032,\n\016PickBanD"
  "etails\022\014\n\004hero\030\001 \001(\r\022\014\n\004team\030\002 \001(\r\032\202\003\n\014M"
  "atchDetails\022\027\n\017server_steam_id\030\001 \001(\006\022\020\n\010"
  "match_id\030\002 \001(\004\022\021\n\ttimestamp\030\003 \001(\r\022\021\n\tgam"
  "e_time\030\004 \001(\005\022%\n\035steam_broadcaster_accoun"
  "t_ids\030\006 \003(\r\022\021\n\tgame_mode\030\007 \001(\r\022\021\n\tleague"
  "_id\030\010 \001(\r\022\026\n\016league_node_id\030\t \001(\r\022\022\n\ngam"
  "e_state\030\n \001(\r\022=\n\005picks\030\013 \003(\0132..CMsgDOTAR"
  "ealtimeGameStatsTerse.PickBanDetails\022<\n\004"
  "bans\030\014 \003(\0132..CMsgDOTARealtimeGameStatsTe"
  "rse.PickBanDetails\022\022\n\nlobby_type\030\r \001(\r\022\027"
  "\n\017start_timestamp\030\016 \001(\r\032\037\n\tGraphData\022\022\n\n"
  "graph_gold\030\001 \003(\005\"\245\001\n\036CMsgDOTABroadcastTi"
  "melineEvent\022M\n\005event\030\001 \001(\0162\030.EBroadcastT"
  "imelineEvent:$EBroadcastTimelineEvent_Ma"
  "tchStarted\022\021\n\ttimestamp\030\002 \001(\007\022\014\n\004data\030\003 "
  "\001(\r\022\023\n\013string_data\030\004 \001(\t\"\?\n CMsgGCToClie"
  "ntMatchGroupsVersion\022\033\n\023matchgroups_vers"
  "ion\030\001 \001(\r\"\301\001\n\033CMsgDOTASDOHeroStatsHistor"
  "y\022\020\n\010match_id\030\001 \001(\004\022\021\n\tgame_mode\030\002 \001(\r\022\022"
  "\n\nlobby_type\030\003 \001(\r\022\022\n\nstart_time\030\004 \001(\r\022\013"
  "\n\003won\030\005 \001(\010\022\013\n\003gpm\030\006 \001(\r\022\013\n\003xpm\030\007 \001(\r\022\r\n"
  "\005kills\030\010 \001(\r\022\016\n\006deaths\030\t \001(\r\022\017\n\007assists\030"
  "\n \001(\r\"a\n\024CMsgPredictionChoice\022\r\n\005value\030\001"
  " \001(\r\022\014\n\004name\030\002 \001(\t\022\025\n\rmin_raw_value\030\003 \001("
  "\r\022\025\n\rmax_raw_value\030\004 \001(\r\"\262\010\n\024CMsgInGameP"
  "rediction\022\n\n\002id\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\022<\n\004t"
  "ype\030\003 \001(\0162%.CMsgInGamePrediction.EPredic"
  "tionType:\007Generic\022G\n\005group\030\004 \001(\0162-.CMsgI"
  "nGamePrediction.ERandomSelectionGroup_t:"
  "\tEarlyGame\022\020\n\010question\030\005 \001(\t\022&\n\007choices\030"
  "\006 \003(\0132\025.CMsgPredictionChoice\022\027\n\017required"
  "_heroes\030\007 \003(\t\022\022\n\nquery_name\030\010 \001(\t\022:\n\014que"
  "ry_values\030\t \003(\0132$.CMsgInGamePrediction.Q"
  "ueryKeyValues\022U\n\026answer_resolution_type\030"
  "\n \001(\0162\'.CMsgInGamePrediction.EResolution"
  "Type_t:\014InvalidQuery\022\027\n\017points_to_grant\030"
  "\013 \001(\r\022\025\n\rreward_action\030\014 \001(\r\022\035\n\025debug_fo"
  "rce_selection\030\r \001(\r\022E\n\016raw_value_type\030\016 "
  "\001(\0162%.CMsgInGamePrediction.ERawValueType"
  "_t:\006Number\032-\n\016QueryKeyValues\022\014\n\004name\030\001 \001"
  "(\t\022\r\n\005value\030\002 \001(\t\"\'\n\017ERawValueType_t\022\n\n\006"
  "Number\020\000\022\010\n\004Time\020\001\"j\n\017EPredictionType\022\013\n"
  "\007Generic\020\000\022\010\n\004Hero\020\001\022\010\n\004Team\020\002\022\n\n\006Player"
  "\020\003\022\013\n\007Special\020\004\022\t\n\005YesNo\020\005\022\022\n\016Qualifiers"
  "Team\020\006\"\324\001\n\021EResolutionType_t\022\020\n\014InvalidQ"
  "uery\020\000\022\024\n\020FirstToPassQuery\020\001\022\023\n\017LastToPa"
  "ssQuery\020\002\022\026\n\022LastRemainingQuery\020\003\022\022\n\016Max"
  "ToPassQuery\020\004\022\022\n\016MinToPassQuery\020\005\022\014\n\010Sum"
  "Query\020\006\022\031\n\025MaxTeamSumToPassQuery\020\007\022\031\n\025Mi"
  "nTeamSumToPassQuery\020\010\"N\n\027ERandomSelectio"
  "nGroup_t\022\r\n\tEarlyGame\020\000\022\013\n\007MidGame\020\001\022\014\n\010"
  "LateGame\020\002\022\t\n\005Count\020\003\"\271\t\n\031CMsgDOTASeason"
  "Predictions\022:\n\013predictions\030\001 \003(\0132%.CMsgD"
  "OTASeasonPredictions.Prediction\0222\n\023in_ga"
  "me_predictions\030\002 \003(\0132\025.CMsgInGamePredict"
  "ion\022)\n!in_game_prediction_count_per_game"
  "\030\003 \001(\r\0220\n(in_game_prediction_voting_peri"
  "od_minutes\030\004 \001(\r\032\316\007\n\nPrediction\022L\n\004type\030"
  "\001 \001(\01625.CMsgDOTASeasonPredictions.Predic"
  "tion.EPredictionType:\007Generic\022\020\n\010questio"
  "n\030\002 \001(\t\022&\n\007choices\030\003 \003(\0132\025.CMsgPredictio"
  "nChoice\022\024\n\014selection_id\030\004 \001(\r\022\022\n\nstart_d"
  "ate\030\005 \001(\r\022\021\n\tlock_date\030\006 \001(\r\022\016\n\006reward\030\007"
  " \001(\r\022Q\n\013answer_type\030\010 \001(\01621.CMsgDOTASeas"
  "onPredictions.Prediction.EAnswerType:\tSi"
  "ngleInt\022\021\n\tanswer_id\030\t \001(\r\022>\n\007answers\030\n "
  "\003(\0132-.CMsgDOTASeasonPredictions.Predicti"
  "on.Answers\022\022\n\nquery_name\030\013 \001(\t\022\034\n\024lock_o"
  "n_selection_id\030\r \001(\r\022\037\n\027lock_on_selectio"
  "n_value\030\016 \001(\r\022\035\n\025lock_on_selection_set\030\017"
  " \001(\010\022\037\n\027use_answer_value_ranges\030\020 \001(\010\0223\n"
  "\006region\030\021 \001(\0162\016.ELeagueRegion:\023LEAGUE_RE"
  "GION_UNSET\022\035\n\006phases\030\022 \003(\0162\r.ELeaguePhas"
  "e\022,\n\014reward_event\030\023 \001(\0162\007.EEvent:\rEVENT_"
  "ID_NONE\032\034\n\007Answers\022\021\n\tanswer_id\030\001 \001(\r\"~\n"
  "\017EPredictionType\022\013\n\007Generic\020\000\022\010\n\004Hero\020\001\022"
  "\010\n\004Team\020\002\022\n\n\006Player\020\003\022\013\n\007Special\020\004\022\t\n\005Ye"
  "sNo\020\005\022\022\n\016QualifiersTeam\020\006\022\022\n\016LastChanceT"
  "eam\020\007\"\221\001\n\013EAnswerType\022\r\n\tSingleInt\020\000\022\017\n\013"
  "SingleFloat\020\001\022\017\n\013MultipleInt\020\002\022\021\n\rMultip"
  "leFloat\020\003\022\016\n\nAnswerTeam\020\004\022\016\n\nSingleTime\020"
  "\005\022\020\n\014MultipleTime\020\006\022\014\n\010NoAnswer\020\007\"\261\001\n\030CM"
  "sgAvailablePredictions\022D\n\021match_predicti"
  "ons\030\001 \003(\0132).CMsgAvailablePredictions.Mat"
  "chPrediction\032O\n\017MatchPrediction\022\020\n\010match"
  "_id\030\001 \001(\004\022*\n\013predictions\030\002 \003(\0132\025.CMsgInG"
  "amePrediction\"\277\001\n\026CMsgLeagueWatchedGames"
  "\022/\n\007leagues\030\001 \003(\0132\036.CMsgLeagueWatchedGam"
  "es.League\032\'\n\006Series\022\017\n\007node_id\030\001 \001(\r\022\014\n\004"
  "game\030\002 \003(\r\032K\n\006League\022\021\n\tleague_id\030\001 \001(\r\022"
  ".\n\006series\030\002 \003(\0132\036.CMsgLeagueWatchedGames"
  ".Series\"\275 \n\rCMsgDOTAMatch\022\020\n\010duration\030\003 "
  "\001(\r\022\021\n\tstarttime\030\004 \001(\007\022&\n\007players\030\005 \003(\0132"
  "\025.CMsgDOTAMatch.Player\022\020\n\010match_id\030\006 \001(\004"
  "\022\024\n\014tower_status\030\010 \003(\r\022\027\n\017barracks_statu"
  "s\030\t \003(\r\022\017\n\007cluster\030\n \001(\r\022\030\n\020first_blood_"
  "time\030\014 \001(\r\022\023\n\013replay_salt\030\r \001(\007\022\021\n\tserve"
  "r_ip\030\016 \001(\007\022\023\n\013server_port\030\017 \001(\r\022\022\n\nlobby"
  "_type\030\020 \001(\r\022\025\n\rhuman_players\030\021 \001(\r\022\025\n\rav"
  "erage_skill\030\022 \001(\r\022\024\n\014game_balance\030\023 \001(\002\022"
  "\027\n\017radiant_team_id\030\024 \001(\r\022\024\n\014dire_team_id"
  "\030\025 \001(\r\022\020\n\010leagueid\030\026 \001(\r\022\031\n\021radiant_team"
  "_name\030\027 \001(\t\022\026\n\016dire_team_name\030\030 \001(\t\022\031\n\021r"
  "adiant_team_logo\030\031 \001(\004\022\026\n\016dire_team_logo"
  "\030\032 \001(\004\022\035\n\025radiant_team_logo_url\0306 \001(\t\022\032\n"
  "\022dire_team_logo_url\0307 \001(\t\022\035\n\025radiant_tea"
  "m_complete\030\033 \001(\r\022\032\n\022dire_team_complete\030\034"
  " \001(\r\022\026\n\016positive_votes\030\035 \001(\r\022\026\n\016negative"
  "_votes\030\036 \001(\r\0225\n\tgame_mode\030\037 \001(\0162\016.DOTA_G"
  "ameMode:\022DOTA_GAMEMODE_NONE\022*\n\npicks_ban"
  "s\030  \003(\0132\026.CMatchHeroSelectEvent\022\025\n\rmatch"
  "_seq_num\030! \001(\004\022B\n\014replay_state\030\" \001(\0162\032.C"
  "MsgDOTAMatch.ReplayState:\020REPLAY_AVAILAB"
  "LE\022\030\n\020radiant_guild_id\030# \001(\r\022\025\n\rdire_gui"
  "ld_id\030$ \001(\r\022\030\n\020radiant_team_tag\030% \001(\t\022\025\n"
  "\rdire_team_tag\030& \001(\t\022\021\n\tseries_id\030\' \001(\r\022"
  "\023\n\013series_type\030( \001(\r\022\?\n\024broadcaster_chan"
  "nels\030+ \003(\0132!.CMsgDOTAMatch.BroadcasterCh"
  "annel\022\016\n\006engine\030, \001(\r\0227\n\020custom_game_dat"
  "a\030- \001(\0132\035.CMsgDOTAMatch.CustomGameData\022\023"
  "\n\013match_flags\030. \001(\r\022\034\n\024private_metadata_"
  "key\030/ \001(\007\022\032\n\022radiant_team_score\0300 \001(\r\022\027\n"
  "\017dire_team_score\0301 \001(\r\022>\n\rmatch_outcome\030"
  "2 \001(\0162\016.EMatchOutcome:\027k_EMatchOutcome_U"
  "nknown\022\025\n\rtournament_id\0303 \001(\r\022\030\n\020tournam"
  "ent_round\0304 \001(\r\022\031\n\021pre_game_duration\0305 \001"
  "(\r\022%\n\007coaches\0309 \003(\0132\024.CMsgDOTAMatch.Coac"
  "h\032\276\021\n\006Player\022\022\n\naccount_id\030\001 \001(\r\022\023\n\013play"
  "er_slot\030\002 \001(\r\022\017\n\007hero_id\030\003 \001(\r\022\022\n\006item_0"
  "\030\004 \001(\005:\002-1\022\022\n\006item_1\030\005 \001(\005:\002-1\022\022\n\006item_2"
  "\030\006 \001(\005:\002-1\022\022\n\006item_3\030\007 \001(\005:\002-1\022\022\n\006item_4"
  "\030\010 \001(\005:\002-1\022\022\n\006item_5\030\t \001(\005:\002-1\022\022\n\006item_6"
  "\030; \001(\005:\002-1\022\022\n\006item_7\030< \001(\005:\002-1\022\022\n\006item_8"
  "\030= \001(\005:\002-1\022\022\n\006item_9\030L \001(\005:\002-1\022\"\n\032expect"
  "ed_team_contribution\030\n \001(\002\022\025\n\rscaled_met"
  "ric\030\013 \001(\002\022\025\n\rprevious_rank\030\014 \001(\r\022\023\n\013rank"
  "_change\030\r \001(\021\022\020\n\010mmr_type\030J \001(\r\022\r\n\005kills"
  "\030\016 \001(\r\022\016\n\006deaths\030\017 \001(\r\022\017\n\007assists\030\020 \001(\r\022"
  "\025\n\rleaver_status\030\021 \001(\r\022\014\n\004gold\030\022 \001(\r\022\021\n\t"
  "last_hits\030\023 \001(\r\022\016\n\006denies\030\024 \001(\r\022\024\n\014gold_"
  "per_min\030\025 \001(\r\022\022\n\nxp_per_min\030\026 \001(\r\022\022\n\ngol"
  "d_spent\030\027 \001(\r\022\023\n\013hero_damage\030\030 \001(\r\022\024\n\014to"
  "wer_damage\030\031 \001(\r\022\024\n\014hero_healing\030\032 \001(\r\022\r"
  "\n\005level\030\033 \001(\r\022\026\n\016time_last_seen\030\034 \001(\r\022\023\n"
  "\013player_name\030\035 \001(\t\022\035\n\025support_ability_va"
  "lue\030\036 \001(\r\022\030\n\020feeding_detected\030  \001(\010\022\023\n\013s"
  "earch_rank\030\" \001(\r\022\037\n\027search_rank_uncertai"
  "nty\030# \001(\r\022\037\n\027rank_uncertainty_change\030$ \001"
  "(\005\022\027\n\017hero_play_count\030% \001(\r\022\020\n\010party_id\030"
  "& \001(\006\022\032\n\022scaled_hero_damage\0306 \001(\r\022\033\n\023sca"
  "led_tower_damage\0307 \001(\r\022\033\n\023scaled_hero_he"
  "aling\0308 \001(\r\022\024\n\014scaled_kills\030\' \001(\002\022\025\n\rsca"
  "led_deaths\030( \001(\002\022\026\n\016scaled_assists\030) \001(\002"
  "\022\031\n\021claimed_farm_gold\030* \001(\r\022\024\n\014support_g"
  "old\030+ \001(\r\022\026\n\016claimed_denies\030, \001(\r\022\026\n\016cla"
  "imed_misses\030- \001(\r\022\016\n\006misses\030. \001(\r\0225\n\020abi"
  "lity_upgrades\030/ \003(\0132\033.CMatchPlayerAbilit"
  "yUpgrade\022B\n\032additional_units_inventory\0300"
  " \003(\0132\036.CMatchAdditionalUnitInventory\0223\n\017"
  "permanent_buffs\0309 \003(\0132\032.CMatchPlayerPerm"
  "anentBuff\022\020\n\010pro_name\030H \001(\t\022\021\n\treal_name"
  "\030I \001(\t\022>\n\020custom_game_data\0302 \001(\0132$.CMsgD"
  "OTAMatch.Player.CustomGameData\022 \n\030active"
  "_plus_subscription\0303 \001(\010\022\021\n\tnet_worth\0304 "
  "\001(\r\022\026\n\016bot_difficulty\030: \001(\r\022\027\n\017hero_pick"
  "_order\030\? \001(\r\022\031\n\021hero_was_randomed\030@ \001(\010\022"
  "%\n\035hero_was_dota_plus_suggestion\030E \001(\010\022F"
  "\n\024hero_damage_received\030C \003(\0132(.CMsgDOTAM"
  "atch.Player.HeroDamageReceived\022C\n\021hero_d"
  "amage_dealt\030O \003(\0132(.CMsgDOTAMatch.Player"
  ".HeroDamageReceived\022\024\n\014seconds_dead\030F \001("
  "\r\022\032\n\022gold_lost_to_death\030G \001(\r\022\034\n\024lane_se"
  "lection_flags\030K \001(\r\022\024\n\014bounty_runes\030M \001("
  "\r\022\031\n\021outposts_captured\030N \001(\r\022:\n\013team_num"
  "ber\030P \001(\0162\r.DOTA_GC_TEAM:\026DOTA_GC_TEAM_G"
  "OOD_GUYS\022\021\n\tteam_slot\030Q \001(\r\0323\n\016CustomGam"
  "eData\022\021\n\tdota_team\030\001 \001(\r\022\016\n\006winner\030\002 \001(\010"
  "\032\224\001\n\022HeroDamageReceived\022\025\n\rpre_reduction"
  "\030\001 \001(\r\022\026\n\016post_reduction\030\002 \001(\r\022O\n\013damage"
  "_type\030\003 \001(\0162$.CMsgDOTAMatch.Player.HeroD"
  "amageType:\024HERO_DAMAGE_PHYSICAL\"Y\n\016HeroD"
  "amageType\022\030\n\024HERO_DAMAGE_PHYSICAL\020\000\022\027\n\023H"
  "ERO_DAMAGE_MAGICAL\020\001\022\024\n\020HERO_DAMAGE_PURE"
  "\020\002\0323\n\017BroadcasterInfo\022\022\n\naccount_id\030\001 \001("
  "\r\022\014\n\004name\030\002 \001(\t\032\221\001\n\022BroadcasterChannel\022\024"
  "\n\014country_code\030\001 \001(\t\022\023\n\013description\030\002 \001("
  "\t\0229\n\021broadcaster_infos\030\003 \003(\0132\036.CMsgDOTAM"
  "atch.BroadcasterInfo\022\025\n\rlanguage_code\030\004 "
  "\001(\t\032\213\001\n\005Coach\022\022\n\naccount_id\030\001 \001(\r\022\022\n\ncoa"
  "ch_name\030\002 \001(\t\022\024\n\014coach_rating\030\003 \001(\r\022\022\n\nc"
  "oach_team\030\004 \001(\r\022\026\n\016coach_party_id\030\005 \001(\004\022"
  "\030\n\020is_private_coach\030\006 \001(\010\032:\n\016CustomGameD"
  "ata\022\026\n\016custom_game_id\030\001 \001(\004\022\020\n\010map_name\030"
  "\002 \001(\t\"P\n\013ReplayState\022\024\n\020REPLAY_AVAILABLE"
  "\020\000\022\027\n\023REPLAY_NOT_RECORDED\020\001\022\022\n\016REPLAY_EX"
  "PIRED\020\002\"\206\001\n\016CMsgPlayerCard\022\022\n\naccount_id"
  "\030\001 \001(\r\0223\n\rstat_modifier\030\002 \003(\0132\034.CMsgPlay"
  "erCard.StatModifier\032+\n\014StatModifier\022\014\n\004s"
  "tat\030\001 \001(\r\022\r\n\005value\030\002 \001(\r\"\251\003\n\032CMsgDOTAFan"
  "tasyPlayerStats\022\031\n\021player_account_id\030\001 \001"
  "(\r\022\020\n\010match_id\030\002 \001(\004\022\027\n\017match_completed\030"
  "\003 \001(\010\022\017\n\007team_id\030\004 \001(\r\022\021\n\tleague_id\030\005 \001("
  "\r\022\r\n\005delay\030\006 \001(\r\022\021\n\tseries_id\030\007 \001(\r\022\023\n\013s"
  "eries_type\030\010 \001(\r\022\r\n\005kills\030\n \001(\r\022\016\n\006death"
  "s\030\013 \001(\r\022\n\n\002cs\030\014 \001(\r\022\013\n\003gpm\030\r \001(\002\022\023\n\013towe"
  "r_kills\030\016 \001(\r\022\024\n\014roshan_kills\030\017 \001(\r\022\037\n\027t"
  "eamfight_participation\030\020 \001(\002\022\024\n\014wards_pl"
  "aced\030\021 \001(\r\022\025\n\rcamps_stacked\030\022 \001(\r\022\025\n\rrun"
  "es_grabbed\030\023 \001(\r\022\023\n\013first_blood\030\024 \001(\r\022\r\n"
  "\005stuns\030\025 \001(\002\"O\n\037CMsgDOTAFantasyPlayerMat"
  "chStats\022,\n\007matches\030\001 \003(\0132\033.CMsgDOTAFanta"
  "syPlayerStats\"\224\007\n\024CMsgDOTABotDebugInfo\022\'"
  "\n\004bots\030\001 \003(\0132\031.CMsgDOTABotDebugInfo.Bot\022"
  "\034\n\024desire_push_lane_top\030\002 \001(\002\022\034\n\024desire_"
  "push_lane_mid\030\003 \001(\002\022\034\n\024desire_push_lane_"
  "bot\030\004 \001(\002\022\036\n\026desire_defend_lane_top\030\005 \001("
  "\002\022\036\n\026desire_defend_lane_mid\030\006 \001(\002\022\036\n\026des"
  "ire_defend_lane_bot\030\007 \001(\002\022\034\n\024desire_farm"
  "_lane_top\030\010 \001(\002\022\034\n\024desire_farm_lane_mid\030"
  "\t \001(\002\022\034\n\024desire_farm_lane_bot\030\n \001(\002\022\032\n\022d"
  "esire_farm_roshan\030\013 \001(\002\022\026\n\016execution_tim"
  "e\030\014 \001(\002\022\023\n\013rune_status\030\r \003(\r\032\365\003\n\003Bot\022\033\n\017"
  "player_owner_id\030\001 \001(\005:\002-1\022\017\n\007hero_id\030\002 \001"
  "(\r\022\022\n\ndifficulty\030\003 \001(\r\022\025\n\rpower_current\030"
  "\004 \001(\r\022\021\n\tpower_max\030\005 \001(\r\022\025\n\rmove_target_"
  "x\030\006 \001(\r\022\025\n\rmove_target_y\030\007 \001(\r\022\025\n\rmove_t"
  "arget_z\030\010 \001(\r\022\026\n\016active_mode_id\030\t \001(\r\022\026\n"
  "\016execution_time\030\n \001(\002\022-\n\005modes\030\013 \003(\0132\036.C"
  "MsgDOTABotDebugInfo.Bot.Mode\0220\n\006action\030\014"
  " \001(\0132 .CMsgDOTABotDebugInfo.Bot.Action\032x"
  "\n\004Mode\022\017\n\007mode_id\030\001 \001(\r\022\016\n\006desire\030\002 \001(\002\022"
  "\031\n\rtarget_entity\030\003 \001(\005:\002-1\022\020\n\010target_x\030\004"
  " \001(\r\022\020\n\010target_y\030\005 \001(\r\022\020\n\010target_z\030\006 \001(\r"
  "\0322\n\006Action\022\021\n\taction_id\030\001 \001(\r\022\025\n\raction_"
  "target\030\002 \001(\t\"R\n\022CMsgSuccessfulHero\022\017\n\007he"
  "ro_id\030\001 \001(\r\022\023\n\013win_percent\030\002 \001(\002\022\026\n\016long"
  "est_streak\030\003 \001(\r\"\261\002\n\023CMsgRecentMatchInfo"
  "\022\020\n\010match_id\030\001 \001(\004\0225\n\tgame_mode\030\002 \001(\0162\016."
  "DOTA_GameMode:\022DOTA_GAMEMODE_NONE\022\r\n\005kil"
  "ls\030\003 \001(\r\022\016\n\006deaths\030\004 \001(\r\022\017\n\007assists\030\005 \001("
  "\r\022\020\n\010duration\030\006 \001(\r\022\023\n\013player_slot\030\007 \001(\r"
  "\022>\n\rmatch_outcome\030\010 \001(\0162\016.EMatchOutcome:"
  "\027k_EMatchOutcome_Unknown\022\021\n\ttimestamp\030\t "
  "\001(\r\022\022\n\nlobby_type\030\n \001(\r\022\023\n\013team_number\030\013"
  " \001(\r\"\270\001\n\rCMsgMatchTips\022&\n\004tips\030\002 \003(\0132\030.C"
  "MsgMatchTips.SingleTip\032\177\n\tSingleTip\022\031\n\021s"
  "ource_account_id\030\001 \001(\r\022\031\n\021target_account"
  "_id\030\002 \001(\r\022\022\n\ntip_amount\030\003 \001(\r\022(\n\010event_i"
  "d\030\004 \001(\0162\007.EEvent:\rEVENT_ID_NONE\"\365\007\n\024CMsg"
  "DOTAMatchMinimal\022\020\n\010match_id\030\001 \001(\004\022\022\n\nst"
  "art_time\030\002 \001(\007\022\020\n\010duration\030\003 \001(\r\0225\n\tgame"
  "_mode\030\004 \001(\0162\016.DOTA_GameMode:\022DOTA_GAMEMO"
  "DE_NONE\022-\n\007players\030\006 \003(\0132\034.CMsgDOTAMatch"
  "Minimal.Player\022.\n\007tourney\030\007 \001(\0132\035.CMsgDO"
  "TAMatchMinimal.Tourney\022>\n\rmatch_outcome\030"
  "\010 \001(\0162\016.EMatchOutcome:\027k_EMatchOutcome_U"
  "nknown\022\025\n\rradiant_score\030\t \001(\r\022\022\n\ndire_sc"
  "ore\030\n \001(\r\022\022\n\nlobby_type\030\013 \001(\r\032\336\001\n\006Player"
  "\022\022\n\naccount_id\030\001 \001(\r\022\017\n\007hero_id\030\002 \001(\r\022\r\n"
  "\005kills\030\003 \001(\r\022\016\n\006deaths\030\004 \001(\r\022\017\n\007assists\030"
  "\005 \001(\r\022\r\n\005items\030\006 \003(\005\022\023\n\013player_slot\030\007 \001("
  "\r\022\020\n\010pro_name\030\010 \001(\t\022\r\n\005level\030\t \001(\r\022:\n\013te"
  "am_number\030\n \001(\0162\r.DOTA_GC_TEAM:\026DOTA_GC_"
  "TEAM_GOOD_GUYS\032\256\003\n\007Tourney\022\021\n\tleague_id\030"
  "\001 \001(\r\022\023\n\013series_type\030\010 \001(\r\022\023\n\013series_gam"
  "e\030\t \001(\r\022%\n\035weekend_tourney_tournament_id"
  "\030\n \001(\r\022(\n weekend_tourney_season_trophy_"
  "id\030\013 \001(\r\022 \n\030weekend_tourney_division\030\014 \001"
  "(\r\022#\n\033weekend_tourney_skill_level\030\r \001(\r\022"
  "\027\n\017radiant_team_id\030\002 \001(\r\022\031\n\021radiant_team"
  "_name\030\003 \001(\t\022\031\n\021radiant_team_logo\030\004 \001(\006\022\035"
  "\n\025radiant_team_logo_url\030\016 \001(\t\022\024\n\014dire_te"
  "am_id\030\005 \001(\r\022\026\n\016dire_team_name\030\006 \001(\t\022\026\n\016d"
  "ire_team_logo\030\007 \001(\006\022\032\n\022dire_team_logo_ur"
  "l\030\017 \001(\t\"@\n\023CMsgConsumableUsage\022\020\n\010item_d"
  "ef\030\001 \001(\r\022\027\n\017quantity_change\030\002 \001(\005\"\265\001\n\030CM"
  "sgMatchConsumableUsage\022F\n\027player_consuma"
  "bles_used\030\001 \003(\0132%.CMsgMatchConsumableUsa"
  "ge.PlayerUsage\032Q\n\013PlayerUsage\022\022\n\naccount"
  "_id\030\001 \001(\r\022.\n\020consumables_used\030\002 \003(\0132\024.CM"
  "sgConsumableUsage\"\262\001\n\032CMsgMatchEventActi"
  "onGrants\022\?\n\rplayer_grants\030\001 \003(\0132(.CMsgMa"
  "tchEventActionGrants.PlayerGrants\032S\n\014Pla"
  "yerGrants\022\022\n\naccount_id\030\001 \001(\r\022/\n\017actions"
  "_granted\030\003 \003(\0132\026.CMsgPendingEventAward\"e"
  "\n\027CMsgCustomGameWhitelist\022\017\n\007version\030\001 \001"
  "(\r\022\036\n\026custom_games_whitelist\030\002 \003(\004\022\031\n\021di"
  "sable_whitelist\030\003 \001(\010\"\360\001\n\036CMsgCustomGame"
  "WhitelistForEdit\022I\n\021whitelist_entries\030\001 "
  "\003(\0132..CMsgCustomGameWhitelistForEdit.Whi"
  "telistEntry\032\202\001\n\016WhitelistEntry\022\026\n\016custom"
  "_game_id\030\001 \001(\004\022X\n\017whitelist_state\030\002 \001(\0162"
  "\032.ECustomGameWhitelistState:#CUSTOM_GAME"
  "_WHITELIST_STATE_UNKNOWN\"\240\001\n\031CMsgPlayerR"
  "ecentMatchInfo\022\020\n\010match_id\030\001 \001(\004\022\021\n\ttime"
  "stamp\030\002 \001(\r\022\020\n\010duration\030\003 \001(\r\022\013\n\003win\030\004 \001"
  "(\010\022\017\n\007hero_id\030\005 \001(\r\022\r\n\005kills\030\006 \001(\r\022\016\n\006de"
  "aths\030\007 \001(\r\022\017\n\007assists\030\010 \001(\r\"5\n\025CMsgPlaye"
  "rMatchRecord\022\014\n\004wins\030\001 \001(\r\022\016\n\006losses\030\002 \001"
  "(\r\"F\n\035CMsgPlayerRecentMatchOutcomes\022\020\n\010o"
  "utcomes\030\001 \001(\r\022\023\n\013match_count\030\002 \001(\r\"A\n\030CM"
  "sgPlayerRecentCommends\022\020\n\010commends\030\001 \001(\r"
  "\022\023\n\013match_count\030\002 \001(\r\"\373\002\n\037CMsgPlayerRece"
  "ntAccomplishments\0227\n\017recent_outcomes\030\001 \001"
  "(\0132\036.CMsgPlayerRecentMatchOutcomes\022,\n\014to"
  "tal_record\030\002 \001(\0132\026.CMsgPlayerMatchRecord"
  "\022\031\n\021prediction_streak\030\003 \001(\r\022\036\n\026plus_pred"
  "iction_streak\030\004 \001(\r\0222\n\017recent_commends\030\005"
  " \001(\0132\031.CMsgPlayerRecentCommends\022\035\n\025first"
  "_match_timestamp\030\006 \001(\r\022.\n\nlast_match\030\007 \001"
  "(\0132\032.CMsgPlayerRecentMatchInfo\0223\n\013recent"
  "_mvps\030\010 \001(\0132\036.CMsgPlayerRecentMatchOutco"
  "mes\"\274\001\n#CMsgPlayerHeroRecentAccomplishme"
  "nts\0227\n\017recent_outcomes\030\001 \001(\0132\036.CMsgPlaye"
  "rRecentMatchOutcomes\022,\n\014total_record\030\002 \001"
  "(\0132\026.CMsgPlayerMatchRecord\022.\n\nlast_match"
  "\030\003 \001(\0132\032.CMsgPlayerRecentMatchInfo\"\241\001\n\031C"
  "MsgRecentAccomplishments\022@\n\026player_accom"
  "plishments\030\001 \001(\0132 .CMsgPlayerRecentAccom"
  "plishments\022B\n\024hero_accomplishments\030\002 \001(\013"
  "2$.CMsgPlayerHeroRecentAccomplishments\"W"
  "\n0CMsgServerToGCRequestPlayerRecentAccom"
  "plishments\022\022\n\naccount_id\030\001 \001(\r\022\017\n\007hero_i"
  "d\030\002 \001(\r\"\261\002\n8CMsgServerToGCRequestPlayerR"
  "ecentAccomplishmentsResponse\022e\n\006result\030\001"
  " \001(\0162C.CMsgServerToGCRequestPlayerRecent"
  "AccomplishmentsResponse.EResponse:\020k_eIn"
  "ternalError\022:\n\026player_accomplishments\030\002 "
  "\001(\0132\032.CMsgRecentAccomplishments\"R\n\tEResp"
  "onse\022\024\n\020k_eInternalError\020\000\022\016\n\nk_eSuccess"
  "\020\001\022\016\n\nk_eTooBusy\020\002\022\017\n\013k_eDisabled\020\003\"Q\n\030C"
  "MsgArcanaVoteMatchVotes\022\020\n\010match_id\030\001 \001("
  "\r\022\017\n\007hero_id\030\002 \001(\r\022\022\n\nvote_count\030\003 \001(\r\"\235"
  "\001\n(CMsgGCtoGCAssociatedExploiterAccountI"
  "nfo\022\022\n\naccount_id\030\001 \001(\r\022\035\n\025num_matches_t"
  "o_search\030\002 \001(\r\022\036\n\026min_shared_match_count"
  "\030\003 \001(\r\022\036\n\026num_additional_players\030\004 \001(\r\"\264"
  "\002\n0CMsgGCtoGCAssociatedExploiterAccountI"
  "nfoResponse\022K\n\010accounts\030\001 \003(\01329.CMsgGCto"
  "GCAssociatedExploiterAccountInfoResponse"
  ".Account\032\262\001\n\007Account\022\022\n\naccount_id\030\001 \001(\r"
  "\022\032\n\022num_common_matches\030\002 \001(\r\022\035\n\025earliest"
  "_common_match\030\003 \001(\r\022\033\n\023latest_common_mat"
  "ch\030\004 \001(\r\022\022\n\ngeneration\030\005 \001(\r\022\017\n\007persona\030"
  "\006 \001(\t\022\026\n\016already_banned\030\007 \001(\010\"\235\002\n\020CMsgPu"
  "llTabsData\022%\n\005slots\030\001 \003(\0132\026.CMsgPullTabs"
  "Data.Slot\022+\n\010jackpots\030\002 \003(\0132\031.CMsgPullTa"
  "bsData.Jackpot\022\022\n\nlast_board\030\003 \001(\r\032`\n\004Sl"
  "ot\022\020\n\010event_id\030\001 \001(\r\022\020\n\010board_id\030\002 \001(\r\022\017"
  "\n\007hero_id\030\003 \001(\r\022\021\n\taction_id\030\004 \001(\r\022\020\n\010re"
  "deemed\030\005 \001(\010\032\?\n\007Jackpot\022\020\n\010board_id\030\001 \001("
  "\r\022\021\n\taction_id\030\002 \001(\r\022\017\n\007hero_id\030\003 \001(\r\"\273\002"
  "\n\022CMsgUnderDraftData\0222\n\013bench_slots\030\001 \003("
  "\0132\035.CMsgUnderDraftData.BenchSlot\0220\n\nshop"
  "_slots\030\002 \003(\0132\034.CMsgUnderDraftData.ShopSl"
  "ot\022\014\n\004gold\030\003 \001(\r\022\022\n\ntotal_gold\030\004 \001(\r\022\026\n\016"
  "not_restorable\030\005 \001(\010\032<\n\tBenchSlot\022\017\n\007slo"
  "t_id\030\001 \001(\r\022\017\n\007hero_id\030\002 \001(\r\022\r\n\005stars\030\003 \001"
  "(\r\032G\n\010ShopSlot\022\017\n\007slot_id\030\001 \001(\r\022\017\n\007hero_"
  "id\030\002 \001(\r\022\031\n\021is_special_reward\030\003 \001(\010\"F\n\023C"
  "MsgPlayerTitleData\022\r\n\005title\030\001 \003(\r\022\020\n\010eve"
  "nt_id\030\002 \003(\r\022\016\n\006active\030\003 \001(\r\"\350\001\n\026CMsgDOTA"
  "TriviaQuestion\022\023\n\013question_id\030\001 \001(\r\022Y\n\010c"
  "ategory\030\002 \001(\0162\034.EDOTATriviaQuestionCateg"
  "ory:)k_EDOTATriviaQuestionCategory_Abili"
  "tyIcon\022\021\n\ttimestamp\030\003 \001(\r\022\026\n\016question_va"
  "lue\030\004 \001(\t\022\025\n\ranswer_values\030\005 \003(\t\022\034\n\024corr"
  "ect_answer_index\030\006 \001(\r\"W\n$CMsgDOTATrivia"
  "QuestionAnswersSummary\022\031\n\021summary_availa"
  "ble\030\001 \001(\010\022\024\n\014picked_count\030\002 \003(\r\"O\n\035CMsgG"
  "ameDataSpecialValueBonus\022\014\n\004name\030\001 \001(\t\022\r"
  "\n\005value\030\002 \001(\002\022\021\n\toperation\030\003 \001(\r\"\234\001\n\031CMs"
  "gGameDataSpecialValues\022\014\n\004name\030\001 \001(\t\022\024\n\014"
  "values_float\030\002 \003(\002\022\025\n\ris_percentage\030\004 \001("
  "\010\022\023\n\013heading_loc\030\005 \001(\t\022/\n\007bonuses\030\006 \003(\0132"
  "\036.CMsgGameDataSpecialValueBonus\"\311\006\n\031CMsg"
  "GameDataAbilityOrItem\022\016\n\002id\030\001 \001(\005:\002-1\022\014\n"
  "\004name\030\002 \001(\t\022\020\n\010name_loc\030\005 \001(\t\022\020\n\010desc_lo"
  "c\030\006 \001(\t\022\020\n\010lore_loc\030\007 \001(\t\022\021\n\tnotes_loc\030\010"
  " \003(\t\022\021\n\tshard_loc\030\t \001(\t\022\023\n\013scepter_loc\030\n"
  " \001(\t\022\014\n\004type\030\024 \001(\r\022\020\n\010behavior\030\025 \001(\004\022\023\n\013"
  "target_team\030\026 \001(\r\022\023\n\013target_type\030\027 \001(\r\022\r"
  "\n\005flags\030\030 \001(\r\022\016\n\006damage\030\031 \001(\r\022\020\n\010immunit"
  "y\030\032 \001(\r\022\023\n\013dispellable\030\033 \001(\r\022\021\n\tmax_leve"
  "l\030\034 \001(\r\022\023\n\013cast_ranges\030\036 \003(\r\022\023\n\013cast_poi"
  "nts\030\037 \003(\002\022\025\n\rchannel_times\030  \003(\002\022\021\n\tcool"
  "downs\030! \003(\002\022\021\n\tdurations\030\" \003(\002\022\017\n\007damage"
  "s\030# \003(\r\022\022\n\nmana_costs\030$ \003(\r\022\022\n\ngold_cost"
  "s\030% \003(\r\0222\n\016special_values\030( \003(\0132\032.CMsgGa"
  "meDataSpecialValues\022\017\n\007is_item\0302 \001(\010\022\033\n\023"
  "ability_has_scepter\030< \001(\010\022\031\n\021ability_has"
  "_shard\030= \001(\010\022%\n\035ability_is_granted_by_sc"
  "epter\030> \001(\010\022#\n\033ability_is_granted_by_sha"
  "rd\030\? \001(\010\022\021\n\titem_cost\030F \001(\r\022\034\n\024item_init"
  "ial_charges\030G \001(\r\022\031\n\021item_neutral_tier\030H"
  " \001(\r\022\026\n\016item_stock_max\030I \001(\r\022\027\n\017item_sto"
  "ck_time\030J \001(\002\022\024\n\014item_quality\030U \001(\r\"\360\005\n\020"
  "CMsgGameDataHero\022\n\n\002id\030\001 \001(\r\022\014\n\004name\030\002 \001"
  "(\t\022\020\n\010order_id\030\003 \001(\r\022\020\n\010name_loc\030\005 \001(\t\022\017"
  "\n\007bio_loc\030\006 \001(\t\022\020\n\010hype_loc\030\007 \001(\t\022\024\n\014npe"
  "_desc_loc\030\010 \001(\t\022\020\n\010str_base\030\n \001(\r\022\020\n\010str"
  "_gain\030\013 \001(\002\022\020\n\010agi_base\030\014 \001(\r\022\020\n\010agi_gai"
  "n\030\r \001(\002\022\020\n\010int_base\030\016 \001(\r\022\020\n\010int_gain\030\017 "
  "\001(\002\022\024\n\014primary_attr\030\024 \001(\r\022\022\n\ncomplexity\030"
  "\025 \001(\r\022\031\n\021attack_capability\030\026 \001(\r\022\023\n\013role"
  "_levels\030\027 \003(\r\022\022\n\ndamage_min\030\030 \001(\r\022\022\n\ndam"
  "age_max\030\031 \001(\r\022\023\n\013attack_rate\030\032 \001(\002\022\024\n\014at"
  "tack_range\030\033 \001(\r\022\030\n\020projectile_speed\030\034 \001"
  "(\r\022\r\n\005armor\030\035 \001(\002\022\030\n\020magic_resistance\030\036 "
  "\001(\r\022\026\n\016movement_speed\030\037 \001(\r\022\021\n\tturn_rate"
  "\030  \001(\002\022\027\n\017sight_range_day\030! \001(\r\022\031\n\021sight"
  "_range_night\030\" \001(\r\022\022\n\nmax_health\030# \001(\r\022\024"
  "\n\014health_regen\030$ \001(\002\022\020\n\010max_mana\030% \001(\r\022\022"
  "\n\nmana_regen\030& \001(\002\022-\n\tabilities\030( \003(\0132\032."
  "CMsgGameDataAbilityOrItem\022+\n\007talents\030) \003"
  "(\0132\032.CMsgGameDataAbilityOrItem\"F\n\025CMsgGa"
  "meDataAbilities\022-\n\tabilities\030\001 \003(\0132\032.CMs"
  "gGameDataAbilityOrItem\">\n\021CMsgGameDataIt"
  "ems\022)\n\005items\030\001 \003(\0132\032.CMsgGameDataAbility"
  "OrItem\"7\n\022CMsgGameDataHeroes\022!\n\006heroes\030\001"
  " \003(\0132\021.CMsgGameDataHero\"\302\001\n\024CMsgGameData"
  "HeroList\022.\n\006heroes\030\001 \003(\0132\036.CMsgGameDataH"
  "eroList.HeroInfo\032z\n\010HeroInfo\022\n\n\002id\030\001 \001(\r"
  "\022\014\n\004name\030\002 \001(\t\022\020\n\010name_loc\030\003 \001(\t\022\030\n\020name"
  "_english_loc\030\004 \001(\t\022\024\n\014primary_attr\030\005 \001(\r"
  "\022\022\n\ncomplexity\030\006 \001(\r\"\332\001\n\033CMsgGameDataIte"
  "mAbilityList\022C\n\ritemabilities\030\001 \003(\0132,.CM"
  "sgGameDataItemAbilityList.ItemAbilityInf"
  "o\032v\n\017ItemAbilityInfo\022\016\n\002id\030\001 \001(\005:\002-1\022\014\n\004"
  "name\030\002 \001(\t\022\020\n\010name_loc\030\003 \001(\t\022\030\n\020name_eng"
  "lish_loc\030\004 \001(\t\022\031\n\021neutral_item_tier\030\005 \001("
  "\005\"8\n\031CMsgLobbyAbilityDraftData\022\033\n\023shuffl"
  "e_draft_order\030\001 \001(\010\"\315\001\n\030CSOEconItemDropR"
  "ateBonus\022\030\n\naccount_id\030\001 \001(\rB\004\200\246\035\001\022\027\n\017ex"
  "piration_date\030\002 \001(\007\022\023\n\005bonus\030\003 \001(\002B\004\200\246\035\001"
  "\022\023\n\013bonus_count\030\004 \001(\r\022\017\n\007item_id\030\005 \001(\004\022\021"
  "\n\tdef_index\030\006 \001(\r\022\024\n\014seconds_left\030\007 \001(\r\022"
  "\032\n\014booster_type\030\010 \001(\rB\004\200\246\035\001\"\312\001\n\035CSOEconI"
  "temTournamentPassport\022\022\n\naccount_id\030\001 \001("
  "\r\022\021\n\tleague_id\030\002 \001(\r\022\017\n\007item_id\030\003 \001(\004\022\035\n"
  "\025original_purchaser_id\030\004 \001(\r\022\030\n\020passport"
  "s_bought\030\005 \001(\r\022\017\n\007version\030\006 \001(\r\022\021\n\tdef_i"
  "ndex\030\007 \001(\r\022\024\n\014reward_flags\030\010 \001(\r\"\334\001\n\026CMs"
  "gStickerbookSticker\022\023\n\013item_def_id\030\001 \001(\r"
  "\022\023\n\013sticker_num\030\002 \001(\r\022\017\n\007quality\030\003 \001(\r\022\022"
  "\n\nposition_x\030\004 \001(\002\022\022\n\nposition_y\030\005 \001(\002\022\022"
  "\n\nposition_z\030\010 \001(\002\022\020\n\010rotation\030\006 \001(\002\022\r\n\005"
  "scale\030\007 \001(\002\022\026\n\016source_item_id\030\t \001(\004\022\022\n\nd"
  "epth_bias\030\n \001(\r\"\315\001\n\023CMsgStickerbookPage\022"
  "\020\n\010page_num\030\001 \001(\r\022(\n\010event_id\030\002 \001(\0162\007.EE"
  "vent:\rEVENT_ID_NONE\022\017\n\007team_id\030\003 \001(\r\022)\n\010"
  "stickers\030\004 \003(\0132\027.CMsgStickerbookSticker\022"
  ">\n\tpage_type\030\005 \001(\0162\025.EStickerbookPageTyp"
  "e:\024STICKER_PAGE_GENERIC\"<\n$CMsgStickerbo"
  "okTeamPageOrderSequence\022\024\n\014page_numbers\030"
  "\001 \003(\r\"\232\001\n\017CMsgStickerbook\022#\n\005pages\030\001 \003(\013"
  "2\024.CMsgStickerbookPage\022G\n\030team_page_orde"
  "r_sequence\030\002 \001(\0132%.CMsgStickerbookTeamPa"
  "geOrderSequence\022\031\n\021favorite_page_num\030\003 \001"
  "(\r\"`\n\017CMsgStickerHero\022\017\n\007hero_id\030\001 \001(\r\022\023"
  "\n\013item_def_id\030\002 \001(\r\022\017\n\007quality\030\003 \001(\r\022\026\n\016"
  "source_item_id\030\004 \001(\004\"5\n\021CMsgStickerHeroe"
  "s\022 \n\006heroes\030\001 \003(\0132\020.CMsgStickerHero\"Y\n\021C"
  "MsgHeroRoleStats\022\034\n\024lane_selection_flags"
  "\030\001 \001(\r\022\023\n\013match_count\030\002 \001(\r\022\021\n\twin_count"
  "\030\003 \001(\r\"P\n\025CMsgHeroRoleHeroStats\022\017\n\007hero_"
  "id\030\001 \001(\r\022&\n\nrole_stats\030\002 \003(\0132\022.CMsgHeroR"
  "oleStats\"V\n\025CMsgHeroRoleRankStats\022\021\n\tran"
  "k_tier\030\001 \001(\r\022*\n\nhero_stats\030\002 \003(\0132\026.CMsgH"
  "eroRoleHeroStats\"w\n\031CMsgHeroRoleAllRanks"
  "Stats\022\027\n\017start_timestamp\030\001 \001(\r\022\025\n\rend_ti"
  "mestamp\030\002 \001(\r\022*\n\nrank_stats\030\003 \003(\0132\026.CMsg"
  "HeroRoleRankStats*U\n\021ESpecialPingValue\022\037"
  "\n\032k_ESpecialPingValue_NoData\020\376\177\022\037\n\032k_ESp"
  "ecialPingValue_Failed\020\377\177*\206\005\n\022EDOTAGCSess"
  "ionNeed\022 \n\034k_EDOTAGCSessionNeed_Unknown\020"
  "\000\022,\n(k_EDOTAGCSessionNeed_UserNoSessionN"
  "eeded\020d\022)\n%k_EDOTAGCSessionNeed_UserInOn"
  "lineGame\020e\022(\n$k_EDOTAGCSessionNeed_UserI"
  "nLocalGame\020f\022-\n)k_EDOTAGCSessionNeed_Use"
  "rInUIWasConnected\020g\022/\n+k_EDOTAGCSessionN"
  "eed_UserInUINeverConnected\020h\022&\n\"k_EDOTAG"
  "CSessionNeed_UserTutorials\020i\0221\n-k_EDOTAG"
  "CSessionNeed_UserInUIWasConnectedIdle\020j\022"
  "3\n/k_EDOTAGCSessionNeed_UserInUINeverCon"
  "nectedIdle\020k\022*\n%k_EDOTAGCSessionNeed_Gam"
  "eServerOnline\020\310\001\022)\n$k_EDOTAGCSessionNeed"
  "_GameServerLocal\020\311\001\022(\n#k_EDOTAGCSessionN"
  "eed_GameServerIdle\020\312\001\022)\n$k_EDOTAGCSessio"
  "nNeed_GameServerRelay\020\313\001\022/\n*k_EDOTAGCSes"
  "sionNeed_GameServerLocalUpload\020\314\001*\366\001\n\025DO"
  "TA_TournamentEvents\022\022\n\016TE_FIRST_BLOOD\020\000\022"
  "\017\n\013TE_GAME_END\020\001\022\021\n\rTE_MULTI_KILL\020\002\022\020\n\014T"
  "E_HERO_DENY\020\003\022\021\n\rTE_AEGIS_DENY\020\004\022\023\n\017TE_A"
  "EGIS_STOLEN\020\005\022\016\n\nTE_GODLIKE\020\006\022\023\n\017TE_COUR"
  "IER_KILL\020\007\022\017\n\013TE_ECHOSLAM\020\010\022\r\n\tTE_RAPIER"
  "\020\t\022\023\n\017TE_EARLY_ROSHAN\020\n\022\021\n\rTE_BLACK_HOLE"
  "\020\013*\215\003\n\027EBroadcastTimelineEvent\022(\n$EBroad"
  "castTimelineEvent_MatchStarted\020\001\022,\n(EBro"
  "adcastTimelineEvent_GameStateChanged\020\002\022&"
  "\n\"EBroadcastTimelineEvent_TowerDeath\020\003\022)"
  "\n%EBroadcastTimelineEvent_BarracksDeath\020"
  "\004\022(\n$EBroadcastTimelineEvent_AncientDeat"
  "h\020\005\022\'\n#EBroadcastTimelineEvent_RoshanDea"
  "th\020\006\022%\n!EBroadcastTimelineEvent_HeroDeat"
  "h\020\007\022%\n!EBroadcastTimelineEvent_TeamFight"
  "\020\010\022&\n\"EBroadcastTimelineEvent_FirstBlood"
  "\020\t*\230\001\n\031ECustomGameWhitelistState\022\'\n#CUST"
  "OM_GAME_WHITELIST_STATE_UNKNOWN\020\000\022(\n$CUS"
  "TOM_GAME_WHITELIST_STATE_APPROVED\020\001\022(\n$C"
  "USTOM_GAME_WHITELIST_STATE_REJECTED\020\002*\232\007"
  "\n\033EDOTATriviaQuestionCategory\022-\n)k_EDOTA"
  "TriviaQuestionCategory_AbilityIcon\020\000\0221\n-"
  "k_EDOTATriviaQuestionCategory_AbilityCoo"
  "ldown\020\001\0220\n,k_EDOTATriviaQuestionCategory"
  "_HeroAttributes\020\002\0223\n/k_EDOTATriviaQuesti"
  "onCategory_HeroMovementSpeed\020\003\022,\n(k_EDOT"
  "ATriviaQuestionCategory_TalentTree\020\004\022+\n\'"
  "k_EDOTATriviaQuestionCategory_HeroStats\020"
  "\005\022+\n\'k_EDOTATriviaQuestionCategory_ItemP"
  "rice\020\006\022.\n*k_EDOTATriviaQuestionCategory_"
  "AbilitySound\020\007\022/\n+k_EDOTATriviaQuestionC"
  "ategory_InvokerSpells\020\010\0221\n-k_EDOTATrivia"
  "QuestionCategory_AbilityManaCost\020\t\0221\n-k_"
  "EDOTATriviaQuestionCategory_HeroAttackSo"
  "und\020\n\022-\n)k_EDOTATriviaQuestionCategory_A"
  "bilityName\020\013\0220\n,k_EDOTATriviaQuestionCat"
  "egory_ItemComponents\020\014\022*\n&k_EDOTATriviaQ"
  "uestionCategory_ItemLore\020\r\022.\n*k_EDOTATri"
  "viaQuestionCategory_ItemPassives\020\016\0226\n2k_"
  "EDOTATriviaQuestionCategory_STATIC_QUEST"
  "IONS_END\020\017\0229\n5k_EDOTATriviaQuestionCateg"
  "ory_DYNAMIC_QUESTIONS_START\020c\0223\n/k_EDOTA"
  "TriviaQuestionCategory_Dynamic_ItemBuild"
  "\020d*\251\001\n\024EOverwatchConviction\022\037\n\033k_EOverwa"
  "tchConviction_None\020\000\022$\n k_EOverwatchConv"
  "iction_NotGuilty\020\001\022\'\n#k_EOverwatchConvic"
  "tion_GuiltUnclear\020\002\022!\n\035k_EOverwatchConvi"
  "ction_Guilty\020\003*t\n\020EHeroRelicRarity\022&\n\031HE"
  "RO_RELIC_RARITY_INVALID\020\377\377\377\377\377\377\377\377\377\001\022\034\n\030HE"
  "RO_RELIC_RARITY_COMMON\020\000\022\032\n\026HERO_RELIC_R"
  "ARITY_RARE\020\001*\321\001\n\027EStickerbookAuditAction"
  "\022!\n\035STICKERBOOK_AUDIT_CREATE_PAGE\020\000\022!\n\035S"
  "TICKERBOOK_AUDIT_DELETE_PAGE\020\001\022$\n STICKE"
  "RBOOK_AUDIT_STICK_STICKERS\020\002\022&\n\"STICKERB"
  "OOK_AUDIT_REPLACE_STICKERS\020\003\022\"\n\036STICKERB"
  "OOK_AUDIT_HERO_STICKER\020\004*`\n\024EStickerbook"
  "PageType\022\030\n\024STICKER_PAGE_GENERIC\020\000\022\025\n\021ST"
  "ICKER_PAGE_TEAM\020\001\022\027\n\023STICKER_PAGE_TALENT"
  "\020\002"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_dota_5fgcmessages_5fcommon_2eproto_deps[3] = {
  &::descriptor_table_dota_5fshared_5fenums_2eproto,
  &::descriptor_table_gcsdk_5fgcmessages_2eproto,
  &::descriptor_table_steammessages_2eproto,
};
static ::_pbi::once_flag descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_dota_5fgcmessages_5fcommon_2eproto = {
    false, false, 33802, descriptor_table_protodef_dota_5fgcmessages_5fcommon_2eproto,
    "dota_gcmessages_common.proto",
    &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once, descriptor_table_dota_5fgcmessages_5fcommon_2eproto_deps, 3, 149,
    schemas, file_default_instances, TableStruct_dota_5fgcmessages_5fcommon_2eproto::offsets,
    file_level_metadata_dota_5fgcmessages_5fcommon_2eproto, file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto,
    file_level_service_descriptors_dota_5fgcmessages_5fcommon_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter() {
  return &descriptor_table_dota_5fgcmessages_5fcommon_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_dota_5fgcmessages_5fcommon_2eproto(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTAProfileCard_EStatID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[0];
}
bool CMsgDOTAProfileCard_EStatID_IsValid(int value) {
  switch (value) {
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDOTAProfileCard_EStatID CMsgDOTAProfileCard::k_eStat_Wins;
constexpr CMsgDOTAProfileCard_EStatID CMsgDOTAProfileCard::k_eStat_Commends;
constexpr CMsgDOTAProfileCard_EStatID CMsgDOTAProfileCard::k_eStat_GamesPlayed;
constexpr CMsgDOTAProfileCard_EStatID CMsgDOTAProfileCard::k_eStat_FirstMatchDate;
constexpr CMsgDOTAProfileCard_EStatID CMsgDOTAProfileCard::k_eStat_PreviousSeasonRank;
constexpr CMsgDOTAProfileCard_EStatID CMsgDOTAProfileCard::k_eStat_GamesMVP;
constexpr CMsgDOTAProfileCard_EStatID CMsgDOTAProfileCard::EStatID_MIN;
constexpr CMsgDOTAProfileCard_EStatID CMsgDOTAProfileCard::EStatID_MAX;
constexpr int CMsgDOTAProfileCard::EStatID_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgGCRerollPlayerChallengeResponse_EResult_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[1];
}
bool CMsgGCRerollPlayerChallengeResponse_EResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgGCRerollPlayerChallengeResponse_EResult CMsgGCRerollPlayerChallengeResponse::eResult_Success;
constexpr CMsgGCRerollPlayerChallengeResponse_EResult CMsgGCRerollPlayerChallengeResponse::eResult_Dropped;
constexpr CMsgGCRerollPlayerChallengeResponse_EResult CMsgGCRerollPlayerChallengeResponse::eResult_NotFound;
constexpr CMsgGCRerollPlayerChallengeResponse_EResult CMsgGCRerollPlayerChallengeResponse::eResult_CantReroll;
constexpr CMsgGCRerollPlayerChallengeResponse_EResult CMsgGCRerollPlayerChallengeResponse::eResult_ServerError;
constexpr CMsgGCRerollPlayerChallengeResponse_EResult CMsgGCRerollPlayerChallengeResponse::EResult_MIN;
constexpr CMsgGCRerollPlayerChallengeResponse_EResult CMsgGCRerollPlayerChallengeResponse::EResult_MAX;
constexpr int CMsgGCRerollPlayerChallengeResponse::EResult_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTARealtimeGameStats_GraphData_eStat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[2];
}
bool CMsgDOTARealtimeGameStats_GraphData_eStat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDOTARealtimeGameStats_GraphData_eStat CMsgDOTARealtimeGameStats_GraphData::CreepGoldEarned;
constexpr CMsgDOTARealtimeGameStats_GraphData_eStat CMsgDOTARealtimeGameStats_GraphData::KillGoldEarned;
constexpr CMsgDOTARealtimeGameStats_GraphData_eStat CMsgDOTARealtimeGameStats_GraphData::DeathAndBuybackGoldLost;
constexpr CMsgDOTARealtimeGameStats_GraphData_eStat CMsgDOTARealtimeGameStats_GraphData::XPEarned;
constexpr CMsgDOTARealtimeGameStats_GraphData_eStat CMsgDOTARealtimeGameStats_GraphData::eStat_MIN;
constexpr CMsgDOTARealtimeGameStats_GraphData_eStat CMsgDOTARealtimeGameStats_GraphData::eStat_MAX;
constexpr int CMsgDOTARealtimeGameStats_GraphData::eStat_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTARealtimeGameStats_GraphData_eLocation_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[3];
}
bool CMsgDOTARealtimeGameStats_GraphData_eLocation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDOTARealtimeGameStats_GraphData_eLocation CMsgDOTARealtimeGameStats_GraphData::BotLane;
constexpr CMsgDOTARealtimeGameStats_GraphData_eLocation CMsgDOTARealtimeGameStats_GraphData::MidLane;
constexpr CMsgDOTARealtimeGameStats_GraphData_eLocation CMsgDOTARealtimeGameStats_GraphData::TopLane;
constexpr CMsgDOTARealtimeGameStats_GraphData_eLocation CMsgDOTARealtimeGameStats_GraphData::Jungle;
constexpr CMsgDOTARealtimeGameStats_GraphData_eLocation CMsgDOTARealtimeGameStats_GraphData::Ancients;
constexpr CMsgDOTARealtimeGameStats_GraphData_eLocation CMsgDOTARealtimeGameStats_GraphData::Other;
constexpr CMsgDOTARealtimeGameStats_GraphData_eLocation CMsgDOTARealtimeGameStats_GraphData::eLocation_MIN;
constexpr CMsgDOTARealtimeGameStats_GraphData_eLocation CMsgDOTARealtimeGameStats_GraphData::eLocation_MAX;
constexpr int CMsgDOTARealtimeGameStats_GraphData::eLocation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgInGamePrediction_ERawValueType_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[4];
}
bool CMsgInGamePrediction_ERawValueType_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgInGamePrediction_ERawValueType_t CMsgInGamePrediction::Number;
constexpr CMsgInGamePrediction_ERawValueType_t CMsgInGamePrediction::Time;
constexpr CMsgInGamePrediction_ERawValueType_t CMsgInGamePrediction::ERawValueType_t_MIN;
constexpr CMsgInGamePrediction_ERawValueType_t CMsgInGamePrediction::ERawValueType_t_MAX;
constexpr int CMsgInGamePrediction::ERawValueType_t_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgInGamePrediction_EPredictionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[5];
}
bool CMsgInGamePrediction_EPredictionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgInGamePrediction_EPredictionType CMsgInGamePrediction::Generic;
constexpr CMsgInGamePrediction_EPredictionType CMsgInGamePrediction::Hero;
constexpr CMsgInGamePrediction_EPredictionType CMsgInGamePrediction::Team;
constexpr CMsgInGamePrediction_EPredictionType CMsgInGamePrediction::Player;
constexpr CMsgInGamePrediction_EPredictionType CMsgInGamePrediction::Special;
constexpr CMsgInGamePrediction_EPredictionType CMsgInGamePrediction::YesNo;
constexpr CMsgInGamePrediction_EPredictionType CMsgInGamePrediction::QualifiersTeam;
constexpr CMsgInGamePrediction_EPredictionType CMsgInGamePrediction::EPredictionType_MIN;
constexpr CMsgInGamePrediction_EPredictionType CMsgInGamePrediction::EPredictionType_MAX;
constexpr int CMsgInGamePrediction::EPredictionType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgInGamePrediction_EResolutionType_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[6];
}
bool CMsgInGamePrediction_EResolutionType_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgInGamePrediction_EResolutionType_t CMsgInGamePrediction::InvalidQuery;
constexpr CMsgInGamePrediction_EResolutionType_t CMsgInGamePrediction::FirstToPassQuery;
constexpr CMsgInGamePrediction_EResolutionType_t CMsgInGamePrediction::LastToPassQuery;
constexpr CMsgInGamePrediction_EResolutionType_t CMsgInGamePrediction::LastRemainingQuery;
constexpr CMsgInGamePrediction_EResolutionType_t CMsgInGamePrediction::MaxToPassQuery;
constexpr CMsgInGamePrediction_EResolutionType_t CMsgInGamePrediction::MinToPassQuery;
constexpr CMsgInGamePrediction_EResolutionType_t CMsgInGamePrediction::SumQuery;
constexpr CMsgInGamePrediction_EResolutionType_t CMsgInGamePrediction::MaxTeamSumToPassQuery;
constexpr CMsgInGamePrediction_EResolutionType_t CMsgInGamePrediction::MinTeamSumToPassQuery;
constexpr CMsgInGamePrediction_EResolutionType_t CMsgInGamePrediction::EResolutionType_t_MIN;
constexpr CMsgInGamePrediction_EResolutionType_t CMsgInGamePrediction::EResolutionType_t_MAX;
constexpr int CMsgInGamePrediction::EResolutionType_t_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgInGamePrediction_ERandomSelectionGroup_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[7];
}
bool CMsgInGamePrediction_ERandomSelectionGroup_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgInGamePrediction_ERandomSelectionGroup_t CMsgInGamePrediction::EarlyGame;
constexpr CMsgInGamePrediction_ERandomSelectionGroup_t CMsgInGamePrediction::MidGame;
constexpr CMsgInGamePrediction_ERandomSelectionGroup_t CMsgInGamePrediction::LateGame;
constexpr CMsgInGamePrediction_ERandomSelectionGroup_t CMsgInGamePrediction::Count;
constexpr CMsgInGamePrediction_ERandomSelectionGroup_t CMsgInGamePrediction::ERandomSelectionGroup_t_MIN;
constexpr CMsgInGamePrediction_ERandomSelectionGroup_t CMsgInGamePrediction::ERandomSelectionGroup_t_MAX;
constexpr int CMsgInGamePrediction::ERandomSelectionGroup_t_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTASeasonPredictions_Prediction_EPredictionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[8];
}
bool CMsgDOTASeasonPredictions_Prediction_EPredictionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDOTASeasonPredictions_Prediction_EPredictionType CMsgDOTASeasonPredictions_Prediction::Generic;
constexpr CMsgDOTASeasonPredictions_Prediction_EPredictionType CMsgDOTASeasonPredictions_Prediction::Hero;
constexpr CMsgDOTASeasonPredictions_Prediction_EPredictionType CMsgDOTASeasonPredictions_Prediction::Team;
constexpr CMsgDOTASeasonPredictions_Prediction_EPredictionType CMsgDOTASeasonPredictions_Prediction::Player;
constexpr CMsgDOTASeasonPredictions_Prediction_EPredictionType CMsgDOTASeasonPredictions_Prediction::Special;
constexpr CMsgDOTASeasonPredictions_Prediction_EPredictionType CMsgDOTASeasonPredictions_Prediction::YesNo;
constexpr CMsgDOTASeasonPredictions_Prediction_EPredictionType CMsgDOTASeasonPredictions_Prediction::QualifiersTeam;
constexpr CMsgDOTASeasonPredictions_Prediction_EPredictionType CMsgDOTASeasonPredictions_Prediction::LastChanceTeam;
constexpr CMsgDOTASeasonPredictions_Prediction_EPredictionType CMsgDOTASeasonPredictions_Prediction::EPredictionType_MIN;
constexpr CMsgDOTASeasonPredictions_Prediction_EPredictionType CMsgDOTASeasonPredictions_Prediction::EPredictionType_MAX;
constexpr int CMsgDOTASeasonPredictions_Prediction::EPredictionType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTASeasonPredictions_Prediction_EAnswerType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[9];
}
bool CMsgDOTASeasonPredictions_Prediction_EAnswerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDOTASeasonPredictions_Prediction_EAnswerType CMsgDOTASeasonPredictions_Prediction::SingleInt;
constexpr CMsgDOTASeasonPredictions_Prediction_EAnswerType CMsgDOTASeasonPredictions_Prediction::SingleFloat;
constexpr CMsgDOTASeasonPredictions_Prediction_EAnswerType CMsgDOTASeasonPredictions_Prediction::MultipleInt;
constexpr CMsgDOTASeasonPredictions_Prediction_EAnswerType CMsgDOTASeasonPredictions_Prediction::MultipleFloat;
constexpr CMsgDOTASeasonPredictions_Prediction_EAnswerType CMsgDOTASeasonPredictions_Prediction::AnswerTeam;
constexpr CMsgDOTASeasonPredictions_Prediction_EAnswerType CMsgDOTASeasonPredictions_Prediction::SingleTime;
constexpr CMsgDOTASeasonPredictions_Prediction_EAnswerType CMsgDOTASeasonPredictions_Prediction::MultipleTime;
constexpr CMsgDOTASeasonPredictions_Prediction_EAnswerType CMsgDOTASeasonPredictions_Prediction::NoAnswer;
constexpr CMsgDOTASeasonPredictions_Prediction_EAnswerType CMsgDOTASeasonPredictions_Prediction::EAnswerType_MIN;
constexpr CMsgDOTASeasonPredictions_Prediction_EAnswerType CMsgDOTASeasonPredictions_Prediction::EAnswerType_MAX;
constexpr int CMsgDOTASeasonPredictions_Prediction::EAnswerType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTAMatch_Player_HeroDamageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[10];
}
bool CMsgDOTAMatch_Player_HeroDamageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDOTAMatch_Player_HeroDamageType CMsgDOTAMatch_Player::HERO_DAMAGE_PHYSICAL;
constexpr CMsgDOTAMatch_Player_HeroDamageType CMsgDOTAMatch_Player::HERO_DAMAGE_MAGICAL;
constexpr CMsgDOTAMatch_Player_HeroDamageType CMsgDOTAMatch_Player::HERO_DAMAGE_PURE;
constexpr CMsgDOTAMatch_Player_HeroDamageType CMsgDOTAMatch_Player::HeroDamageType_MIN;
constexpr CMsgDOTAMatch_Player_HeroDamageType CMsgDOTAMatch_Player::HeroDamageType_MAX;
constexpr int CMsgDOTAMatch_Player::HeroDamageType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgDOTAMatch_ReplayState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[11];
}
bool CMsgDOTAMatch_ReplayState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgDOTAMatch_ReplayState CMsgDOTAMatch::REPLAY_AVAILABLE;
constexpr CMsgDOTAMatch_ReplayState CMsgDOTAMatch::REPLAY_NOT_RECORDED;
constexpr CMsgDOTAMatch_ReplayState CMsgDOTAMatch::REPLAY_EXPIRED;
constexpr CMsgDOTAMatch_ReplayState CMsgDOTAMatch::ReplayState_MIN;
constexpr CMsgDOTAMatch_ReplayState CMsgDOTAMatch::ReplayState_MAX;
constexpr int CMsgDOTAMatch::ReplayState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[12];
}
bool CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::k_eInternalError;
constexpr CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::k_eSuccess;
constexpr CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::k_eTooBusy;
constexpr CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::k_eDisabled;
constexpr CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::EResponse_MIN;
constexpr CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::EResponse_MAX;
constexpr int CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESpecialPingValue_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[13];
}
bool ESpecialPingValue_IsValid(int value) {
  switch (value) {
    case 16382:
    case 16383:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDOTAGCSessionNeed_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[14];
}
bool EDOTAGCSessionNeed_IsValid(int value) {
  switch (value) {
    case 0:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 200:
    case 201:
    case 202:
    case 203:
    case 204:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_TournamentEvents_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[15];
}
bool DOTA_TournamentEvents_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBroadcastTimelineEvent_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[16];
}
bool EBroadcastTimelineEvent_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECustomGameWhitelistState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[17];
}
bool ECustomGameWhitelistState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDOTATriviaQuestionCategory_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[18];
}
bool EDOTATriviaQuestionCategory_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 99:
    case 100:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EOverwatchConviction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[19];
}
bool EOverwatchConviction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EHeroRelicRarity_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[20];
}
bool EHeroRelicRarity_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStickerbookAuditAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[21];
}
bool EStickerbookAuditAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStickerbookPageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_2eproto[22];
}
bool EStickerbookPageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CSODOTAGameAccountClient_RoleHandicap::_Internal {
 public:
  using HasBits = decltype(std::declval<CSODOTAGameAccountClient_RoleHandicap>()._impl_._has_bits_);
  static void set_has_role(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_handicap(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSODOTAGameAccountClient_RoleHandicap::CSODOTAGameAccountClient_RoleHandicap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSODOTAGameAccountClient.RoleHandicap)
}
CSODOTAGameAccountClient_RoleHandicap::CSODOTAGameAccountClient_RoleHandicap(const CSODOTAGameAccountClient_RoleHandicap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSODOTAGameAccountClient_RoleHandicap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.role_){}
    , decltype(_impl_.handicap_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.role_, &from._impl_.role_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.handicap_) -
    reinterpret_cast<char*>(&_impl_.role_)) + sizeof(_impl_.handicap_));
  // @@protoc_insertion_point(copy_constructor:CSODOTAGameAccountClient.RoleHandicap)
}

inline void CSODOTAGameAccountClient_RoleHandicap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.role_){0u}
    , decltype(_impl_.handicap_){0}
  };
}

CSODOTAGameAccountClient_RoleHandicap::~CSODOTAGameAccountClient_RoleHandicap() {
  // @@protoc_insertion_point(destructor:CSODOTAGameAccountClient.RoleHandicap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSODOTAGameAccountClient_RoleHandicap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSODOTAGameAccountClient_RoleHandicap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSODOTAGameAccountClient_RoleHandicap::Clear() {
// @@protoc_insertion_point(message_clear_start:CSODOTAGameAccountClient.RoleHandicap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.role_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.handicap_) -
        reinterpret_cast<char*>(&_impl_.role_)) + sizeof(_impl_.handicap_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSODOTAGameAccountClient_RoleHandicap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 role = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_role(&has_bits);
          _impl_.role_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float handicap = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_handicap(&has_bits);
          _impl_.handicap_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSODOTAGameAccountClient_RoleHandicap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSODOTAGameAccountClient.RoleHandicap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 role = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_role(), target);
  }

  // optional float handicap = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_handicap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSODOTAGameAccountClient.RoleHandicap)
  return target;
}

size_t CSODOTAGameAccountClient_RoleHandicap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSODOTAGameAccountClient.RoleHandicap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 role = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_role());
    }

    // optional float handicap = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSODOTAGameAccountClient_RoleHandicap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSODOTAGameAccountClient_RoleHandicap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSODOTAGameAccountClient_RoleHandicap::GetClassData() const { return &_class_data_; }


void CSODOTAGameAccountClient_RoleHandicap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSODOTAGameAccountClient_RoleHandicap*>(&to_msg);
  auto& from = static_cast<const CSODOTAGameAccountClient_RoleHandicap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSODOTAGameAccountClient.RoleHandicap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.role_ = from._impl_.role_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.handicap_ = from._impl_.handicap_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSODOTAGameAccountClient_RoleHandicap::CopyFrom(const CSODOTAGameAccountClient_RoleHandicap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSODOTAGameAccountClient.RoleHandicap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSODOTAGameAccountClient_RoleHandicap::IsInitialized() const {
  return true;
}

void CSODOTAGameAccountClient_RoleHandicap::InternalSwap(CSODOTAGameAccountClient_RoleHandicap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSODOTAGameAccountClient_RoleHandicap, _impl_.handicap_)
      + sizeof(CSODOTAGameAccountClient_RoleHandicap::_impl_.handicap_)
      - PROTOBUF_FIELD_OFFSET(CSODOTAGameAccountClient_RoleHandicap, _impl_.role_)>(
          reinterpret_cast<char*>(&_impl_.role_),
          reinterpret_cast<char*>(&other->_impl_.role_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSODOTAGameAccountClient_RoleHandicap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[0]);
}

// ===================================================================

class CSODOTAGameAccountClient::_Internal {
 public:
  using HasBits = decltype(std::declval<CSODOTAGameAccountClient>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_wins(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_losses(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_xp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_initial_skill(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_leaver_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_secondary_leaver_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_low_priority_until_date(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_prevent_text_chat_until_date(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_prevent_voice_until_date(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_prevent_public_text_chat_until_date(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_prevent_new_player_chat_until_date(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static void set_has_last_abandoned_game_date(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_last_secondary_abandoned_game_date(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_leaver_penalty_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_completed_game_streak(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_account_disabled_until_date(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_account_disabled_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_match_disabled_until_date(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_match_disabled_count(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_shutdownlawterminatetimestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_low_priority_games_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_competitive_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_competitive_calibration_games_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_recruitment_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_has_new_notifications(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_is_league_admin(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_casual_games_played(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_solo_competitive_games_played(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_party_competitive_games_played(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_casual_1v1_games_played(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_curr_all_hero_challenge_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_play_time_points(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_account_flags(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_play_time_level(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_player_behavior_seq_num_last_report(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_player_behavior_score_last_report(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_player_behavior_report_old_data(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_tourney_skill_level(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_tourney_recent_participation_date(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_anchored_phone_number_id(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_ranked_matchmaking_ban_until_date(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_recent_game_time_1(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_recent_game_time_2(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_recent_game_time_3(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_favorite_team_packed(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_recent_report_time(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_custom_game_disabled_until_date(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_recent_win_time_1(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static void set_has_recent_win_time_2(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static void set_has_recent_win_time_3(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static void set_has_coach_rating(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static void set_has_queue_points(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static void set_has_event_mode_recent_time(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static void set_has_mmr_recalibration_time(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
};

CSODOTAGameAccountClient::CSODOTAGameAccountClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSODOTAGameAccountClient)
}
CSODOTAGameAccountClient::CSODOTAGameAccountClient(const CSODOTAGameAccountClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSODOTAGameAccountClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.role_handicaps_){from._impl_.role_handicaps_}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.wins_){}
    , decltype(_impl_.losses_){}
    , decltype(_impl_.xp_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.initial_skill_){}
    , decltype(_impl_.leaver_count_){}
    , decltype(_impl_.low_priority_until_date_){}
    , decltype(_impl_.prevent_text_chat_until_date_){}
    , decltype(_impl_.prevent_voice_until_date_){}
    , decltype(_impl_.last_abandoned_game_date_){}
    , decltype(_impl_.leaver_penalty_count_){}
    , decltype(_impl_.completed_game_streak_){}
    , decltype(_impl_.account_disabled_until_date_){}
    , decltype(_impl_.account_disabled_count_){}
    , decltype(_impl_.match_disabled_until_date_){}
    , decltype(_impl_.match_disabled_count_){}
    , decltype(_impl_.shutdownlawterminatetimestamp_){}
    , decltype(_impl_.low_priority_games_remaining_){}
    , decltype(_impl_.competitive_rank_){}
    , decltype(_impl_.competitive_calibration_games_remaining_){}
    , decltype(_impl_.recruitment_level_){}
    , decltype(_impl_.secondary_leaver_count_){}
    , decltype(_impl_.last_secondary_abandoned_game_date_){}
    , decltype(_impl_.casual_games_played_){}
    , decltype(_impl_.solo_competitive_games_played_){}
    , decltype(_impl_.party_competitive_games_played_){}
    , decltype(_impl_.has_new_notifications_){}
    , decltype(_impl_.is_league_admin_){}
    , decltype(_impl_.player_behavior_report_old_data_){}
    , decltype(_impl_.casual_1v1_games_played_){}
    , decltype(_impl_.curr_all_hero_challenge_id_){}
    , decltype(_impl_.play_time_points_){}
    , decltype(_impl_.account_flags_){}
    , decltype(_impl_.play_time_level_){}
    , decltype(_impl_.player_behavior_seq_num_last_report_){}
    , decltype(_impl_.player_behavior_score_last_report_){}
    , decltype(_impl_.tourney_skill_level_){}
    , decltype(_impl_.tourney_recent_participation_date_){}
    , decltype(_impl_.prevent_public_text_chat_until_date_){}
    , decltype(_impl_.anchored_phone_number_id_){}
    , decltype(_impl_.ranked_matchmaking_ban_until_date_){}
    , decltype(_impl_.recent_game_time_1_){}
    , decltype(_impl_.recent_game_time_2_){}
    , decltype(_impl_.recent_game_time_3_){}
    , decltype(_impl_.favorite_team_packed_){}
    , decltype(_impl_.recent_report_time_){}
    , decltype(_impl_.custom_game_disabled_until_date_){}
    , decltype(_impl_.recent_win_time_1_){}
    , decltype(_impl_.recent_win_time_2_){}
    , decltype(_impl_.recent_win_time_3_){}
    , decltype(_impl_.coach_rating_){}
    , decltype(_impl_.queue_points_){}
    , decltype(_impl_.event_mode_recent_time_){}
    , decltype(_impl_.mmr_recalibration_time_){}
    , decltype(_impl_.prevent_new_player_chat_until_date_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prevent_new_player_chat_until_date_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.prevent_new_player_chat_until_date_));
  // @@protoc_insertion_point(copy_constructor:CSODOTAGameAccountClient)
}

inline void CSODOTAGameAccountClient::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.role_handicaps_){arena}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.wins_){0u}
    , decltype(_impl_.losses_){0u}
    , decltype(_impl_.xp_){0u}
    , decltype(_impl_.level_){0u}
    , decltype(_impl_.initial_skill_){0u}
    , decltype(_impl_.leaver_count_){0u}
    , decltype(_impl_.low_priority_until_date_){0u}
    , decltype(_impl_.prevent_text_chat_until_date_){0u}
    , decltype(_impl_.prevent_voice_until_date_){0u}
    , decltype(_impl_.last_abandoned_game_date_){0u}
    , decltype(_impl_.leaver_penalty_count_){0u}
    , decltype(_impl_.completed_game_streak_){0u}
    , decltype(_impl_.account_disabled_until_date_){0u}
    , decltype(_impl_.account_disabled_count_){0u}
    , decltype(_impl_.match_disabled_until_date_){0u}
    , decltype(_impl_.match_disabled_count_){0u}
    , decltype(_impl_.shutdownlawterminatetimestamp_){0u}
    , decltype(_impl_.low_priority_games_remaining_){0u}
    , decltype(_impl_.competitive_rank_){0u}
    , decltype(_impl_.competitive_calibration_games_remaining_){0u}
    , decltype(_impl_.recruitment_level_){0u}
    , decltype(_impl_.secondary_leaver_count_){0u}
    , decltype(_impl_.last_secondary_abandoned_game_date_){0u}
    , decltype(_impl_.casual_games_played_){0u}
    , decltype(_impl_.solo_competitive_games_played_){0u}
    , decltype(_impl_.party_competitive_games_played_){0u}
    , decltype(_impl_.has_new_notifications_){false}
    , decltype(_impl_.is_league_admin_){false}
    , decltype(_impl_.player_behavior_report_old_data_){false}
    , decltype(_impl_.casual_1v1_games_played_){0u}
    , decltype(_impl_.curr_all_hero_challenge_id_){0u}
    , decltype(_impl_.play_time_points_){0u}
    , decltype(_impl_.account_flags_){0u}
    , decltype(_impl_.play_time_level_){0u}
    , decltype(_impl_.player_behavior_seq_num_last_report_){0u}
    , decltype(_impl_.player_behavior_score_last_report_){0u}
    , decltype(_impl_.tourney_skill_level_){0u}
    , decltype(_impl_.tourney_recent_participation_date_){0u}
    , decltype(_impl_.prevent_public_text_chat_until_date_){0u}
    , decltype(_impl_.anchored_phone_number_id_){uint64_t{0u}}
    , decltype(_impl_.ranked_matchmaking_ban_until_date_){0u}
    , decltype(_impl_.recent_game_time_1_){0u}
    , decltype(_impl_.recent_game_time_2_){0u}
    , decltype(_impl_.recent_game_time_3_){0u}
    , decltype(_impl_.favorite_team_packed_){uint64_t{0u}}
    , decltype(_impl_.recent_report_time_){0u}
    , decltype(_impl_.custom_game_disabled_until_date_){0u}
    , decltype(_impl_.recent_win_time_1_){0u}
    , decltype(_impl_.recent_win_time_2_){0u}
    , decltype(_impl_.recent_win_time_3_){0u}
    , decltype(_impl_.coach_rating_){0u}
    , decltype(_impl_.queue_points_){0u}
    , decltype(_impl_.event_mode_recent_time_){0u}
    , decltype(_impl_.mmr_recalibration_time_){0u}
    , decltype(_impl_.prevent_new_player_chat_until_date_){0u}
  };
}

CSODOTAGameAccountClient::~CSODOTAGameAccountClient() {
  // @@protoc_insertion_point(destructor:CSODOTAGameAccountClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSODOTAGameAccountClient::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.role_handicaps_.~RepeatedPtrField();
}

void CSODOTAGameAccountClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSODOTAGameAccountClient::Clear() {
// @@protoc_insertion_point(message_clear_start:CSODOTAGameAccountClient)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.role_handicaps_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.low_priority_until_date_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.low_priority_until_date_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.prevent_text_chat_until_date_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.match_disabled_until_date_) -
        reinterpret_cast<char*>(&_impl_.prevent_text_chat_until_date_)) + sizeof(_impl_.match_disabled_until_date_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.match_disabled_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.last_secondary_abandoned_game_date_) -
        reinterpret_cast<char*>(&_impl_.match_disabled_count_)) + sizeof(_impl_.last_secondary_abandoned_game_date_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.casual_games_played_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.curr_all_hero_challenge_id_) -
        reinterpret_cast<char*>(&_impl_.casual_games_played_)) + sizeof(_impl_.curr_all_hero_challenge_id_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.play_time_points_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.prevent_public_text_chat_until_date_) -
        reinterpret_cast<char*>(&_impl_.play_time_points_)) + sizeof(_impl_.prevent_public_text_chat_until_date_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.anchored_phone_number_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.custom_game_disabled_until_date_) -
        reinterpret_cast<char*>(&_impl_.anchored_phone_number_id_)) + sizeof(_impl_.custom_game_disabled_until_date_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.recent_win_time_1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.prevent_new_player_chat_until_date_) -
        reinterpret_cast<char*>(&_impl_.recent_win_time_1_)) + sizeof(_impl_.prevent_new_player_chat_until_date_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSODOTAGameAccountClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1 [(.key_field) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&_impl_._has_bits_);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 wins = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_wins(&_impl_._has_bits_);
          _impl_.wins_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 losses = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_losses(&_impl_._has_bits_);
          _impl_.losses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 xp = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_xp(&_impl_._has_bits_);
          _impl_.xp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_level(&_impl_._has_bits_);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 initial_skill = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_initial_skill(&_impl_._has_bits_);
          _impl_.initial_skill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 leaver_count = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_leaver_count(&_impl_._has_bits_);
          _impl_.leaver_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 low_priority_until_date = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_low_priority_until_date(&_impl_._has_bits_);
          _impl_.low_priority_until_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prevent_text_chat_until_date = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_prevent_text_chat_until_date(&_impl_._has_bits_);
          _impl_.prevent_text_chat_until_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prevent_voice_until_date = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_prevent_voice_until_date(&_impl_._has_bits_);
          _impl_.prevent_voice_until_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_abandoned_game_date = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_last_abandoned_game_date(&_impl_._has_bits_);
          _impl_.last_abandoned_game_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 leaver_penalty_count = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_leaver_penalty_count(&_impl_._has_bits_);
          _impl_.leaver_penalty_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 completed_game_streak = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_completed_game_streak(&_impl_._has_bits_);
          _impl_.completed_game_streak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account_disabled_until_date = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_account_disabled_until_date(&_impl_._has_bits_);
          _impl_.account_disabled_until_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account_disabled_count = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_account_disabled_count(&_impl_._has_bits_);
          _impl_.account_disabled_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 match_disabled_until_date = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_match_disabled_until_date(&_impl_._has_bits_);
          _impl_.match_disabled_until_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 match_disabled_count = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_match_disabled_count(&_impl_._has_bits_);
          _impl_.match_disabled_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 shutdownlawterminatetimestamp = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_shutdownlawterminatetimestamp(&_impl_._has_bits_);
          _impl_.shutdownlawterminatetimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 low_priority_games_remaining = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_low_priority_games_remaining(&_impl_._has_bits_);
          _impl_.low_priority_games_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 competitive_rank = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_competitive_rank(&_impl_._has_bits_);
          _impl_.competitive_rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 competitive_calibration_games_remaining = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_competitive_calibration_games_remaining(&_impl_._has_bits_);
          _impl_.competitive_calibration_games_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 recruitment_level = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_recruitment_level(&_impl_._has_bits_);
          _impl_.recruitment_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_new_notifications = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_has_new_notifications(&_impl_._has_bits_);
          _impl_.has_new_notifications_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_league_admin = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_is_league_admin(&_impl_._has_bits_);
          _impl_.is_league_admin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 secondary_leaver_count = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_secondary_leaver_count(&_impl_._has_bits_);
          _impl_.secondary_leaver_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_secondary_abandoned_game_date = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_last_secondary_abandoned_game_date(&_impl_._has_bits_);
          _impl_.last_secondary_abandoned_game_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 casual_games_played = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_casual_games_played(&_impl_._has_bits_);
          _impl_.casual_games_played_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 solo_competitive_games_played = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_solo_competitive_games_played(&_impl_._has_bits_);
          _impl_.solo_competitive_games_played_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 party_competitive_games_played = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_party_competitive_games_played(&_impl_._has_bits_);
          _impl_.party_competitive_games_played_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 casual_1v1_games_played = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_casual_1v1_games_played(&_impl_._has_bits_);
          _impl_.casual_1v1_games_played_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 curr_all_hero_challenge_id = 67;
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_curr_all_hero_challenge_id(&_impl_._has_bits_);
          _impl_.curr_all_hero_challenge_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 play_time_points = 68;
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_play_time_points(&_impl_._has_bits_);
          _impl_.play_time_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account_flags = 69;
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_account_flags(&_impl_._has_bits_);
          _impl_.account_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 play_time_level = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_play_time_level(&_impl_._has_bits_);
          _impl_.play_time_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 player_behavior_seq_num_last_report = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_player_behavior_seq_num_last_report(&_impl_._has_bits_);
          _impl_.player_behavior_seq_num_last_report_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 player_behavior_score_last_report = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_player_behavior_score_last_report(&_impl_._has_bits_);
          _impl_.player_behavior_score_last_report_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool player_behavior_report_old_data = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_player_behavior_report_old_data(&_impl_._has_bits_);
          _impl_.player_behavior_report_old_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tourney_skill_level = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_tourney_skill_level(&_impl_._has_bits_);
          _impl_.tourney_skill_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tourney_recent_participation_date = 85;
      case 85:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_tourney_recent_participation_date(&_impl_._has_bits_);
          _impl_.tourney_recent_participation_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prevent_public_text_chat_until_date = 86;
      case 86:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_prevent_public_text_chat_until_date(&_impl_._has_bits_);
          _impl_.prevent_public_text_chat_until_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 anchored_phone_number_id = 88;
      case 88:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_anchored_phone_number_id(&_impl_._has_bits_);
          _impl_.anchored_phone_number_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ranked_matchmaking_ban_until_date = 89;
      case 89:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_ranked_matchmaking_ban_until_date(&_impl_._has_bits_);
          _impl_.ranked_matchmaking_ban_until_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 recent_game_time_1 = 90;
      case 90:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_recent_game_time_1(&_impl_._has_bits_);
          _impl_.recent_game_time_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 recent_game_time_2 = 91;
      case 91:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_recent_game_time_2(&_impl_._has_bits_);
          _impl_.recent_game_time_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 recent_game_time_3 = 92;
      case 92:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_recent_game_time_3(&_impl_._has_bits_);
          _impl_.recent_game_time_3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 favorite_team_packed = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_favorite_team_packed(&_impl_._has_bits_);
          _impl_.favorite_team_packed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 recent_report_time = 104;
      case 104:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_recent_report_time(&_impl_._has_bits_);
          _impl_.recent_report_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 custom_game_disabled_until_date = 105;
      case 105:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_custom_game_disabled_until_date(&_impl_._has_bits_);
          _impl_.custom_game_disabled_until_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 recent_win_time_1 = 106;
      case 106:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_recent_win_time_1(&_impl_._has_bits_);
          _impl_.recent_win_time_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 recent_win_time_2 = 107;
      case 107:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_recent_win_time_2(&_impl_._has_bits_);
          _impl_.recent_win_time_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 recent_win_time_3 = 108;
      case 108:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_recent_win_time_3(&_impl_._has_bits_);
          _impl_.recent_win_time_3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 coach_rating = 109;
      case 109:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_coach_rating(&_impl_._has_bits_);
          _impl_.coach_rating_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 queue_points = 114;
      case 114:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_queue_points(&_impl_._has_bits_);
          _impl_.queue_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSODOTAGameAccountClient.RoleHandicap role_handicaps = 115;
      case 115:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_role_handicaps(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<922>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 event_mode_recent_time = 120;
      case 120:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_event_mode_recent_time(&_impl_._has_bits_);
          _impl_.event_mode_recent_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mmr_recalibration_time = 121;
      case 121:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_mmr_recalibration_time(&_impl_._has_bits_);
          _impl_.mmr_recalibration_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prevent_new_player_chat_until_date = 122;
      case 122:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_prevent_new_player_chat_until_date(&_impl_._has_bits_);
          _impl_.prevent_new_player_chat_until_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSODOTAGameAccountClient::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSODOTAGameAccountClient)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1 [(.key_field) = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 wins = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_wins(), target);
  }

  // optional uint32 losses = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_losses(), target);
  }

  // optional uint32 xp = 12;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_xp(), target);
  }

  // optional uint32 level = 13;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_level(), target);
  }

  // optional uint32 initial_skill = 14;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_initial_skill(), target);
  }

  // optional uint32 leaver_count = 15;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_leaver_count(), target);
  }

  // optional uint32 low_priority_until_date = 18;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_low_priority_until_date(), target);
  }

  // optional uint32 prevent_text_chat_until_date = 20;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_prevent_text_chat_until_date(), target);
  }

  // optional uint32 prevent_voice_until_date = 21;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_prevent_voice_until_date(), target);
  }

  // optional uint32 last_abandoned_game_date = 22;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_last_abandoned_game_date(), target);
  }

  // optional uint32 leaver_penalty_count = 23;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_leaver_penalty_count(), target);
  }

  // optional uint32 completed_game_streak = 24;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_completed_game_streak(), target);
  }

  // optional uint32 account_disabled_until_date = 38;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(38, this->_internal_account_disabled_until_date(), target);
  }

  // optional uint32 account_disabled_count = 39;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(39, this->_internal_account_disabled_count(), target);
  }

  // optional uint32 match_disabled_until_date = 41;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(41, this->_internal_match_disabled_until_date(), target);
  }

  // optional uint32 match_disabled_count = 42;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(42, this->_internal_match_disabled_count(), target);
  }

  // optional uint32 shutdownlawterminatetimestamp = 47;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(47, this->_internal_shutdownlawterminatetimestamp(), target);
  }

  // optional uint32 low_priority_games_remaining = 48;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(48, this->_internal_low_priority_games_remaining(), target);
  }

  // optional uint32 competitive_rank = 49;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(49, this->_internal_competitive_rank(), target);
  }

  // optional uint32 competitive_calibration_games_remaining = 51;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(51, this->_internal_competitive_calibration_games_remaining(), target);
  }

  // optional uint32 recruitment_level = 55;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(55, this->_internal_recruitment_level(), target);
  }

  // optional bool has_new_notifications = 56;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(56, this->_internal_has_new_notifications(), target);
  }

  // optional bool is_league_admin = 57;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(57, this->_internal_is_league_admin(), target);
  }

  // optional uint32 secondary_leaver_count = 58;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(58, this->_internal_secondary_leaver_count(), target);
  }

  // optional uint32 last_secondary_abandoned_game_date = 59;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(59, this->_internal_last_secondary_abandoned_game_date(), target);
  }

  // optional uint32 casual_games_played = 60;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(60, this->_internal_casual_games_played(), target);
  }

  // optional uint32 solo_competitive_games_played = 61;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(61, this->_internal_solo_competitive_games_played(), target);
  }

  // optional uint32 party_competitive_games_played = 62;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(62, this->_internal_party_competitive_games_played(), target);
  }

  // optional uint32 casual_1v1_games_played = 65;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(65, this->_internal_casual_1v1_games_played(), target);
  }

  // optional uint32 curr_all_hero_challenge_id = 67;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(67, this->_internal_curr_all_hero_challenge_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 play_time_points = 68;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(68, this->_internal_play_time_points(), target);
  }

  // optional uint32 account_flags = 69;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(69, this->_internal_account_flags(), target);
  }

  // optional uint32 play_time_level = 70;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(70, this->_internal_play_time_level(), target);
  }

  // optional uint32 player_behavior_seq_num_last_report = 71;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(71, this->_internal_player_behavior_seq_num_last_report(), target);
  }

  // optional uint32 player_behavior_score_last_report = 72;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(72, this->_internal_player_behavior_score_last_report(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool player_behavior_report_old_data = 73;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(73, this->_internal_player_behavior_report_old_data(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 tourney_skill_level = 74;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(74, this->_internal_tourney_skill_level(), target);
  }

  // optional uint32 tourney_recent_participation_date = 85;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(85, this->_internal_tourney_recent_participation_date(), target);
  }

  // optional uint32 prevent_public_text_chat_until_date = 86;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(86, this->_internal_prevent_public_text_chat_until_date(), target);
  }

  // optional uint64 anchored_phone_number_id = 88;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(88, this->_internal_anchored_phone_number_id(), target);
  }

  // optional uint32 ranked_matchmaking_ban_until_date = 89;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(89, this->_internal_ranked_matchmaking_ban_until_date(), target);
  }

  // optional uint32 recent_game_time_1 = 90;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(90, this->_internal_recent_game_time_1(), target);
  }

  // optional uint32 recent_game_time_2 = 91;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(91, this->_internal_recent_game_time_2(), target);
  }

  // optional uint32 recent_game_time_3 = 92;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(92, this->_internal_recent_game_time_3(), target);
  }

  // optional uint64 favorite_team_packed = 103;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(103, this->_internal_favorite_team_packed(), target);
  }

  // optional uint32 recent_report_time = 104;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(104, this->_internal_recent_report_time(), target);
  }

  // optional uint32 custom_game_disabled_until_date = 105;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(105, this->_internal_custom_game_disabled_until_date(), target);
  }

  // optional uint32 recent_win_time_1 = 106;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(106, this->_internal_recent_win_time_1(), target);
  }

  // optional uint32 recent_win_time_2 = 107;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(107, this->_internal_recent_win_time_2(), target);
  }

  // optional uint32 recent_win_time_3 = 108;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(108, this->_internal_recent_win_time_3(), target);
  }

  // optional uint32 coach_rating = 109;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(109, this->_internal_coach_rating(), target);
  }

  // optional uint32 queue_points = 114;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(114, this->_internal_queue_points(), target);
  }

  // repeated .CSODOTAGameAccountClient.RoleHandicap role_handicaps = 115;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_role_handicaps_size()); i < n; i++) {
    const auto& repfield = this->_internal_role_handicaps(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(115, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 event_mode_recent_time = 120;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(120, this->_internal_event_mode_recent_time(), target);
  }

  // optional uint32 mmr_recalibration_time = 121;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(121, this->_internal_mmr_recalibration_time(), target);
  }

  // optional uint32 prevent_new_player_chat_until_date = 122;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(122, this->_internal_prevent_new_player_chat_until_date(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSODOTAGameAccountClient)
  return target;
}

size_t CSODOTAGameAccountClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSODOTAGameAccountClient)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSODOTAGameAccountClient.RoleHandicap role_handicaps = 115;
  total_size += 2UL * this->_internal_role_handicaps_size();
  for (const auto& msg : this->_impl_.role_handicaps_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 account_id = 1 [(.key_field) = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 wins = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_wins());
    }

    // optional uint32 losses = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_losses());
    }

    // optional uint32 xp = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_xp());
    }

    // optional uint32 level = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
    }

    // optional uint32 initial_skill = 14;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_initial_skill());
    }

    // optional uint32 leaver_count = 15;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_leaver_count());
    }

    // optional uint32 low_priority_until_date = 18;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_low_priority_until_date());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 prevent_text_chat_until_date = 20;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_prevent_text_chat_until_date());
    }

    // optional uint32 prevent_voice_until_date = 21;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_prevent_voice_until_date());
    }

    // optional uint32 last_abandoned_game_date = 22;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_last_abandoned_game_date());
    }

    // optional uint32 leaver_penalty_count = 23;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_leaver_penalty_count());
    }

    // optional uint32 completed_game_streak = 24;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_completed_game_streak());
    }

    // optional uint32 account_disabled_until_date = 38;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_account_disabled_until_date());
    }

    // optional uint32 account_disabled_count = 39;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_account_disabled_count());
    }

    // optional uint32 match_disabled_until_date = 41;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_match_disabled_until_date());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 match_disabled_count = 42;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_match_disabled_count());
    }

    // optional uint32 shutdownlawterminatetimestamp = 47;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_shutdownlawterminatetimestamp());
    }

    // optional uint32 low_priority_games_remaining = 48;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_low_priority_games_remaining());
    }

    // optional uint32 competitive_rank = 49;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_competitive_rank());
    }

    // optional uint32 competitive_calibration_games_remaining = 51;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_competitive_calibration_games_remaining());
    }

    // optional uint32 recruitment_level = 55;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_recruitment_level());
    }

    // optional uint32 secondary_leaver_count = 58;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_secondary_leaver_count());
    }

    // optional uint32 last_secondary_abandoned_game_date = 59;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_last_secondary_abandoned_game_date());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 casual_games_played = 60;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_casual_games_played());
    }

    // optional uint32 solo_competitive_games_played = 61;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_solo_competitive_games_played());
    }

    // optional uint32 party_competitive_games_played = 62;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_party_competitive_games_played());
    }

    // optional bool has_new_notifications = 56;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional bool is_league_admin = 57;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

    // optional bool player_behavior_report_old_data = 73;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 1;
    }

    // optional uint32 casual_1v1_games_played = 65;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_casual_1v1_games_played());
    }

    // optional uint32 curr_all_hero_challenge_id = 67;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_curr_all_hero_challenge_id());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 play_time_points = 68;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_play_time_points());
    }

    // optional uint32 account_flags = 69;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_account_flags());
    }

    // optional uint32 play_time_level = 70;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_play_time_level());
    }

    // optional uint32 player_behavior_seq_num_last_report = 71;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_player_behavior_seq_num_last_report());
    }

    // optional uint32 player_behavior_score_last_report = 72;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_player_behavior_score_last_report());
    }

    // optional uint32 tourney_skill_level = 74;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tourney_skill_level());
    }

    // optional uint32 tourney_recent_participation_date = 85;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tourney_recent_participation_date());
    }

    // optional uint32 prevent_public_text_chat_until_date = 86;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_prevent_public_text_chat_until_date());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint64 anchored_phone_number_id = 88;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_anchored_phone_number_id());
    }

    // optional uint32 ranked_matchmaking_ban_until_date = 89;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_ranked_matchmaking_ban_until_date());
    }

    // optional uint32 recent_game_time_1 = 90;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_recent_game_time_1());
    }

    // optional uint32 recent_game_time_2 = 91;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_recent_game_time_2());
    }

    // optional uint32 recent_game_time_3 = 92;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_recent_game_time_3());
    }

    // optional uint64 favorite_team_packed = 103;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_favorite_team_packed());
    }

    // optional uint32 recent_report_time = 104;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_recent_report_time());
    }

    // optional uint32 custom_game_disabled_until_date = 105;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_custom_game_disabled_until_date());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 recent_win_time_1 = 106;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_recent_win_time_1());
    }

    // optional uint32 recent_win_time_2 = 107;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_recent_win_time_2());
    }

    // optional uint32 recent_win_time_3 = 108;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_recent_win_time_3());
    }

    // optional uint32 coach_rating = 109;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_coach_rating());
    }

    // optional uint32 queue_points = 114;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_queue_points());
    }

    // optional uint32 event_mode_recent_time = 120;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_event_mode_recent_time());
    }

    // optional uint32 mmr_recalibration_time = 121;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_mmr_recalibration_time());
    }

    // optional uint32 prevent_new_player_chat_until_date = 122;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_prevent_new_player_chat_until_date());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSODOTAGameAccountClient::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSODOTAGameAccountClient::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSODOTAGameAccountClient::GetClassData() const { return &_class_data_; }


void CSODOTAGameAccountClient::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSODOTAGameAccountClient*>(&to_msg);
  auto& from = static_cast<const CSODOTAGameAccountClient&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSODOTAGameAccountClient)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.role_handicaps_.MergeFrom(from._impl_.role_handicaps_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.wins_ = from._impl_.wins_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.losses_ = from._impl_.losses_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.xp_ = from._impl_.xp_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.initial_skill_ = from._impl_.initial_skill_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.leaver_count_ = from._impl_.leaver_count_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.low_priority_until_date_ = from._impl_.low_priority_until_date_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.prevent_text_chat_until_date_ = from._impl_.prevent_text_chat_until_date_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.prevent_voice_until_date_ = from._impl_.prevent_voice_until_date_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.last_abandoned_game_date_ = from._impl_.last_abandoned_game_date_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.leaver_penalty_count_ = from._impl_.leaver_penalty_count_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.completed_game_streak_ = from._impl_.completed_game_streak_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.account_disabled_until_date_ = from._impl_.account_disabled_until_date_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.account_disabled_count_ = from._impl_.account_disabled_count_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.match_disabled_until_date_ = from._impl_.match_disabled_until_date_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.match_disabled_count_ = from._impl_.match_disabled_count_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.shutdownlawterminatetimestamp_ = from._impl_.shutdownlawterminatetimestamp_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.low_priority_games_remaining_ = from._impl_.low_priority_games_remaining_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.competitive_rank_ = from._impl_.competitive_rank_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.competitive_calibration_games_remaining_ = from._impl_.competitive_calibration_games_remaining_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.recruitment_level_ = from._impl_.recruitment_level_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.secondary_leaver_count_ = from._impl_.secondary_leaver_count_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.last_secondary_abandoned_game_date_ = from._impl_.last_secondary_abandoned_game_date_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.casual_games_played_ = from._impl_.casual_games_played_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.solo_competitive_games_played_ = from._impl_.solo_competitive_games_played_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.party_competitive_games_played_ = from._impl_.party_competitive_games_played_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.has_new_notifications_ = from._impl_.has_new_notifications_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.is_league_admin_ = from._impl_.is_league_admin_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.player_behavior_report_old_data_ = from._impl_.player_behavior_report_old_data_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.casual_1v1_games_played_ = from._impl_.casual_1v1_games_played_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.curr_all_hero_challenge_id_ = from._impl_.curr_all_hero_challenge_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.play_time_points_ = from._impl_.play_time_points_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_flags_ = from._impl_.account_flags_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.play_time_level_ = from._impl_.play_time_level_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.player_behavior_seq_num_last_report_ = from._impl_.player_behavior_seq_num_last_report_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.player_behavior_score_last_report_ = from._impl_.player_behavior_score_last_report_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.tourney_skill_level_ = from._impl_.tourney_skill_level_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.tourney_recent_participation_date_ = from._impl_.tourney_recent_participation_date_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.prevent_public_text_chat_until_date_ = from._impl_.prevent_public_text_chat_until_date_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.anchored_phone_number_id_ = from._impl_.anchored_phone_number_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.ranked_matchmaking_ban_until_date_ = from._impl_.ranked_matchmaking_ban_until_date_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.recent_game_time_1_ = from._impl_.recent_game_time_1_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.recent_game_time_2_ = from._impl_.recent_game_time_2_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.recent_game_time_3_ = from._impl_.recent_game_time_3_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.favorite_team_packed_ = from._impl_.favorite_team_packed_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.recent_report_time_ = from._impl_.recent_report_time_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.custom_game_disabled_until_date_ = from._impl_.custom_game_disabled_until_date_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.recent_win_time_1_ = from._impl_.recent_win_time_1_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.recent_win_time_2_ = from._impl_.recent_win_time_2_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.recent_win_time_3_ = from._impl_.recent_win_time_3_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.coach_rating_ = from._impl_.coach_rating_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.queue_points_ = from._impl_.queue_points_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.event_mode_recent_time_ = from._impl_.event_mode_recent_time_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.mmr_recalibration_time_ = from._impl_.mmr_recalibration_time_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.prevent_new_player_chat_until_date_ = from._impl_.prevent_new_player_chat_until_date_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSODOTAGameAccountClient::CopyFrom(const CSODOTAGameAccountClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSODOTAGameAccountClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSODOTAGameAccountClient::IsInitialized() const {
  return true;
}

void CSODOTAGameAccountClient::InternalSwap(CSODOTAGameAccountClient* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  _impl_.role_handicaps_.InternalSwap(&other->_impl_.role_handicaps_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSODOTAGameAccountClient, _impl_.prevent_new_player_chat_until_date_)
      + sizeof(CSODOTAGameAccountClient::_impl_.prevent_new_player_chat_until_date_)
      - PROTOBUF_FIELD_OFFSET(CSODOTAGameAccountClient, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSODOTAGameAccountClient::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[1]);
}

// ===================================================================

class CSODOTAGameAccountPlus::_Internal {
 public:
  using HasBits = decltype(std::declval<CSODOTAGameAccountPlus>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_original_start_date(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_plus_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_plus_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_prepaid_time_start(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_prepaid_time_balance(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_next_payment_date(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_steam_agreement_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CSODOTAGameAccountPlus::CSODOTAGameAccountPlus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSODOTAGameAccountPlus)
}
CSODOTAGameAccountPlus::CSODOTAGameAccountPlus(const CSODOTAGameAccountPlus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSODOTAGameAccountPlus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.original_start_date_){}
    , decltype(_impl_.plus_flags_){}
    , decltype(_impl_.plus_status_){}
    , decltype(_impl_.prepaid_time_start_){}
    , decltype(_impl_.prepaid_time_balance_){}
    , decltype(_impl_.steam_agreement_id_){}
    , decltype(_impl_.next_payment_date_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.next_payment_date_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.next_payment_date_));
  // @@protoc_insertion_point(copy_constructor:CSODOTAGameAccountPlus)
}

inline void CSODOTAGameAccountPlus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.original_start_date_){0u}
    , decltype(_impl_.plus_flags_){0u}
    , decltype(_impl_.plus_status_){0u}
    , decltype(_impl_.prepaid_time_start_){0u}
    , decltype(_impl_.prepaid_time_balance_){0u}
    , decltype(_impl_.steam_agreement_id_){uint64_t{0u}}
    , decltype(_impl_.next_payment_date_){0u}
  };
}

CSODOTAGameAccountPlus::~CSODOTAGameAccountPlus() {
  // @@protoc_insertion_point(destructor:CSODOTAGameAccountPlus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSODOTAGameAccountPlus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSODOTAGameAccountPlus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSODOTAGameAccountPlus::Clear() {
// @@protoc_insertion_point(message_clear_start:CSODOTAGameAccountPlus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.next_payment_date_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.next_payment_date_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSODOTAGameAccountPlus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1 [(.key_field) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 original_start_date = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_original_start_date(&has_bits);
          _impl_.original_start_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 plus_flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_plus_flags(&has_bits);
          _impl_.plus_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 plus_status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_plus_status(&has_bits);
          _impl_.plus_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prepaid_time_start = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_prepaid_time_start(&has_bits);
          _impl_.prepaid_time_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prepaid_time_balance = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_prepaid_time_balance(&has_bits);
          _impl_.prepaid_time_balance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 next_payment_date = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_next_payment_date(&has_bits);
          _impl_.next_payment_date_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steam_agreement_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_steam_agreement_id(&has_bits);
          _impl_.steam_agreement_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSODOTAGameAccountPlus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSODOTAGameAccountPlus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1 [(.key_field) = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 original_start_date = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_original_start_date(), target);
  }

  // optional uint32 plus_flags = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_plus_flags(), target);
  }

  // optional uint32 plus_status = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_plus_status(), target);
  }

  // optional uint32 prepaid_time_start = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_prepaid_time_start(), target);
  }

  // optional uint32 prepaid_time_balance = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_prepaid_time_balance(), target);
  }

  // optional fixed32 next_payment_date = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_next_payment_date(), target);
  }

  // optional fixed64 steam_agreement_id = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(8, this->_internal_steam_agreement_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSODOTAGameAccountPlus)
  return target;
}

size_t CSODOTAGameAccountPlus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSODOTAGameAccountPlus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 account_id = 1 [(.key_field) = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 original_start_date = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_original_start_date());
    }

    // optional uint32 plus_flags = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_plus_flags());
    }

    // optional uint32 plus_status = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_plus_status());
    }

    // optional uint32 prepaid_time_start = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prepaid_time_start());
    }

    // optional uint32 prepaid_time_balance = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prepaid_time_balance());
    }

    // optional fixed64 steam_agreement_id = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional fixed32 next_payment_date = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSODOTAGameAccountPlus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSODOTAGameAccountPlus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSODOTAGameAccountPlus::GetClassData() const { return &_class_data_; }


void CSODOTAGameAccountPlus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSODOTAGameAccountPlus*>(&to_msg);
  auto& from = static_cast<const CSODOTAGameAccountPlus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSODOTAGameAccountPlus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.original_start_date_ = from._impl_.original_start_date_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.plus_flags_ = from._impl_.plus_flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.plus_status_ = from._impl_.plus_status_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.prepaid_time_start_ = from._impl_.prepaid_time_start_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.prepaid_time_balance_ = from._impl_.prepaid_time_balance_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.steam_agreement_id_ = from._impl_.steam_agreement_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.next_payment_date_ = from._impl_.next_payment_date_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSODOTAGameAccountPlus::CopyFrom(const CSODOTAGameAccountPlus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSODOTAGameAccountPlus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSODOTAGameAccountPlus::IsInitialized() const {
  return true;
}

void CSODOTAGameAccountPlus::InternalSwap(CSODOTAGameAccountPlus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSODOTAGameAccountPlus, _impl_.next_payment_date_)
      + sizeof(CSODOTAGameAccountPlus::_impl_.next_payment_date_)
      - PROTOBUF_FIELD_OFFSET(CSODOTAGameAccountPlus, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSODOTAGameAccountPlus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[2]);
}

// ===================================================================

class CMsgLobbyFeaturedGamemodeProgress_AccountProgress::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgLobbyFeaturedGamemodeProgress_AccountProgress>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_current_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgLobbyFeaturedGamemodeProgress_AccountProgress::CMsgLobbyFeaturedGamemodeProgress_AccountProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgLobbyFeaturedGamemodeProgress.AccountProgress)
}
CMsgLobbyFeaturedGamemodeProgress_AccountProgress::CMsgLobbyFeaturedGamemodeProgress_AccountProgress(const CMsgLobbyFeaturedGamemodeProgress_AccountProgress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgLobbyFeaturedGamemodeProgress_AccountProgress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.current_value_){}
    , decltype(_impl_.max_value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_value_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.max_value_));
  // @@protoc_insertion_point(copy_constructor:CMsgLobbyFeaturedGamemodeProgress.AccountProgress)
}

inline void CMsgLobbyFeaturedGamemodeProgress_AccountProgress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.current_value_){0u}
    , decltype(_impl_.max_value_){0u}
  };
}

CMsgLobbyFeaturedGamemodeProgress_AccountProgress::~CMsgLobbyFeaturedGamemodeProgress_AccountProgress() {
  // @@protoc_insertion_point(destructor:CMsgLobbyFeaturedGamemodeProgress.AccountProgress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgLobbyFeaturedGamemodeProgress_AccountProgress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgLobbyFeaturedGamemodeProgress_AccountProgress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgLobbyFeaturedGamemodeProgress_AccountProgress::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgLobbyFeaturedGamemodeProgress.AccountProgress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.max_value_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.max_value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgLobbyFeaturedGamemodeProgress_AccountProgress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 current_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_current_value(&has_bits);
          _impl_.current_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_value(&has_bits);
          _impl_.max_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgLobbyFeaturedGamemodeProgress_AccountProgress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgLobbyFeaturedGamemodeProgress.AccountProgress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 current_value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_current_value(), target);
  }

  // optional uint32 max_value = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_max_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgLobbyFeaturedGamemodeProgress.AccountProgress)
  return target;
}

size_t CMsgLobbyFeaturedGamemodeProgress_AccountProgress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgLobbyFeaturedGamemodeProgress.AccountProgress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 current_value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_current_value());
    }

    // optional uint32 max_value = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgLobbyFeaturedGamemodeProgress_AccountProgress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgLobbyFeaturedGamemodeProgress_AccountProgress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgLobbyFeaturedGamemodeProgress_AccountProgress::GetClassData() const { return &_class_data_; }


void CMsgLobbyFeaturedGamemodeProgress_AccountProgress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgLobbyFeaturedGamemodeProgress_AccountProgress*>(&to_msg);
  auto& from = static_cast<const CMsgLobbyFeaturedGamemodeProgress_AccountProgress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgLobbyFeaturedGamemodeProgress.AccountProgress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.current_value_ = from._impl_.current_value_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.max_value_ = from._impl_.max_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgLobbyFeaturedGamemodeProgress_AccountProgress::CopyFrom(const CMsgLobbyFeaturedGamemodeProgress_AccountProgress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgLobbyFeaturedGamemodeProgress.AccountProgress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgLobbyFeaturedGamemodeProgress_AccountProgress::IsInitialized() const {
  return true;
}

void CMsgLobbyFeaturedGamemodeProgress_AccountProgress::InternalSwap(CMsgLobbyFeaturedGamemodeProgress_AccountProgress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgLobbyFeaturedGamemodeProgress_AccountProgress, _impl_.max_value_)
      + sizeof(CMsgLobbyFeaturedGamemodeProgress_AccountProgress::_impl_.max_value_)
      - PROTOBUF_FIELD_OFFSET(CMsgLobbyFeaturedGamemodeProgress_AccountProgress, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgLobbyFeaturedGamemodeProgress_AccountProgress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[3]);
}

// ===================================================================

class CMsgLobbyFeaturedGamemodeProgress::_Internal {
 public:
};

CMsgLobbyFeaturedGamemodeProgress::CMsgLobbyFeaturedGamemodeProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgLobbyFeaturedGamemodeProgress)
}
CMsgLobbyFeaturedGamemodeProgress::CMsgLobbyFeaturedGamemodeProgress(const CMsgLobbyFeaturedGamemodeProgress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgLobbyFeaturedGamemodeProgress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accounts_){from._impl_.accounts_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgLobbyFeaturedGamemodeProgress)
}

inline void CMsgLobbyFeaturedGamemodeProgress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accounts_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgLobbyFeaturedGamemodeProgress::~CMsgLobbyFeaturedGamemodeProgress() {
  // @@protoc_insertion_point(destructor:CMsgLobbyFeaturedGamemodeProgress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgLobbyFeaturedGamemodeProgress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.accounts_.~RepeatedPtrField();
}

void CMsgLobbyFeaturedGamemodeProgress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgLobbyFeaturedGamemodeProgress::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgLobbyFeaturedGamemodeProgress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accounts_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgLobbyFeaturedGamemodeProgress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgLobbyFeaturedGamemodeProgress.AccountProgress accounts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_accounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgLobbyFeaturedGamemodeProgress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgLobbyFeaturedGamemodeProgress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgLobbyFeaturedGamemodeProgress.AccountProgress accounts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_accounts_size()); i < n; i++) {
    const auto& repfield = this->_internal_accounts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgLobbyFeaturedGamemodeProgress)
  return target;
}

size_t CMsgLobbyFeaturedGamemodeProgress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgLobbyFeaturedGamemodeProgress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgLobbyFeaturedGamemodeProgress.AccountProgress accounts = 1;
  total_size += 1UL * this->_internal_accounts_size();
  for (const auto& msg : this->_impl_.accounts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgLobbyFeaturedGamemodeProgress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgLobbyFeaturedGamemodeProgress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgLobbyFeaturedGamemodeProgress::GetClassData() const { return &_class_data_; }


void CMsgLobbyFeaturedGamemodeProgress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgLobbyFeaturedGamemodeProgress*>(&to_msg);
  auto& from = static_cast<const CMsgLobbyFeaturedGamemodeProgress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgLobbyFeaturedGamemodeProgress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.accounts_.MergeFrom(from._impl_.accounts_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgLobbyFeaturedGamemodeProgress::CopyFrom(const CMsgLobbyFeaturedGamemodeProgress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgLobbyFeaturedGamemodeProgress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgLobbyFeaturedGamemodeProgress::IsInitialized() const {
  return true;
}

void CMsgLobbyFeaturedGamemodeProgress::InternalSwap(CMsgLobbyFeaturedGamemodeProgress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.accounts_.InternalSwap(&other->_impl_.accounts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgLobbyFeaturedGamemodeProgress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[4]);
}

// ===================================================================

class CMsgBattleCupVictory::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgBattleCupVictory>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_win_date(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_valid_until(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_skill_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tournament_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_division_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_streak(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_trophy_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CMsgBattleCupVictory::CMsgBattleCupVictory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgBattleCupVictory)
}
CMsgBattleCupVictory::CMsgBattleCupVictory(const CMsgBattleCupVictory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgBattleCupVictory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.win_date_){}
    , decltype(_impl_.valid_until_){}
    , decltype(_impl_.skill_level_){}
    , decltype(_impl_.tournament_id_){}
    , decltype(_impl_.division_id_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.streak_){}
    , decltype(_impl_.trophy_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.trophy_id_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.trophy_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgBattleCupVictory)
}

inline void CMsgBattleCupVictory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.win_date_){0u}
    , decltype(_impl_.valid_until_){0u}
    , decltype(_impl_.skill_level_){0u}
    , decltype(_impl_.tournament_id_){0u}
    , decltype(_impl_.division_id_){0u}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.streak_){0u}
    , decltype(_impl_.trophy_id_){0u}
  };
}

CMsgBattleCupVictory::~CMsgBattleCupVictory() {
  // @@protoc_insertion_point(destructor:CMsgBattleCupVictory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgBattleCupVictory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgBattleCupVictory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgBattleCupVictory::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgBattleCupVictory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.streak_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.streak_));
  }
  _impl_.trophy_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgBattleCupVictory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 win_date = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_win_date(&has_bits);
          _impl_.win_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 valid_until = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_valid_until(&has_bits);
          _impl_.valid_until_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 skill_level = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_skill_level(&has_bits);
          _impl_.skill_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tournament_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_tournament_id(&has_bits);
          _impl_.tournament_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 division_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_division_id(&has_bits);
          _impl_.division_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 streak = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_streak(&has_bits);
          _impl_.streak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 trophy_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_trophy_id(&has_bits);
          _impl_.trophy_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgBattleCupVictory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgBattleCupVictory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 win_date = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_win_date(), target);
  }

  // optional uint32 valid_until = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_valid_until(), target);
  }

  // optional uint32 skill_level = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_skill_level(), target);
  }

  // optional uint32 tournament_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_tournament_id(), target);
  }

  // optional uint32 division_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_division_id(), target);
  }

  // optional uint32 team_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_team_id(), target);
  }

  // optional uint32 streak = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_streak(), target);
  }

  // optional uint32 trophy_id = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_trophy_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgBattleCupVictory)
  return target;
}

size_t CMsgBattleCupVictory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgBattleCupVictory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 win_date = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_win_date());
    }

    // optional uint32 valid_until = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_valid_until());
    }

    // optional uint32 skill_level = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_skill_level());
    }

    // optional uint32 tournament_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tournament_id());
    }

    // optional uint32 division_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_division_id());
    }

    // optional uint32 team_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint32 streak = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_streak());
    }

  }
  // optional uint32 trophy_id = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_trophy_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgBattleCupVictory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgBattleCupVictory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgBattleCupVictory::GetClassData() const { return &_class_data_; }


void CMsgBattleCupVictory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgBattleCupVictory*>(&to_msg);
  auto& from = static_cast<const CMsgBattleCupVictory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgBattleCupVictory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.win_date_ = from._impl_.win_date_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.valid_until_ = from._impl_.valid_until_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.skill_level_ = from._impl_.skill_level_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tournament_id_ = from._impl_.tournament_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.division_id_ = from._impl_.division_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.streak_ = from._impl_.streak_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_trophy_id(from._internal_trophy_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgBattleCupVictory::CopyFrom(const CMsgBattleCupVictory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgBattleCupVictory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgBattleCupVictory::IsInitialized() const {
  return true;
}

void CMsgBattleCupVictory::InternalSwap(CMsgBattleCupVictory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgBattleCupVictory, _impl_.trophy_id_)
      + sizeof(CMsgBattleCupVictory::_impl_.trophy_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgBattleCupVictory, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgBattleCupVictory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[5]);
}

// ===================================================================

class CMsgLobbyBattleCupVictoryList::_Internal {
 public:
};

CMsgLobbyBattleCupVictoryList::CMsgLobbyBattleCupVictoryList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgLobbyBattleCupVictoryList)
}
CMsgLobbyBattleCupVictoryList::CMsgLobbyBattleCupVictoryList(const CMsgLobbyBattleCupVictoryList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgLobbyBattleCupVictoryList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.winners_){from._impl_.winners_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgLobbyBattleCupVictoryList)
}

inline void CMsgLobbyBattleCupVictoryList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.winners_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgLobbyBattleCupVictoryList::~CMsgLobbyBattleCupVictoryList() {
  // @@protoc_insertion_point(destructor:CMsgLobbyBattleCupVictoryList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgLobbyBattleCupVictoryList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.winners_.~RepeatedPtrField();
}

void CMsgLobbyBattleCupVictoryList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgLobbyBattleCupVictoryList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgLobbyBattleCupVictoryList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.winners_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgLobbyBattleCupVictoryList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgBattleCupVictory winners = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_winners(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgLobbyBattleCupVictoryList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgLobbyBattleCupVictoryList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgBattleCupVictory winners = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_winners_size()); i < n; i++) {
    const auto& repfield = this->_internal_winners(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgLobbyBattleCupVictoryList)
  return target;
}

size_t CMsgLobbyBattleCupVictoryList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgLobbyBattleCupVictoryList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgBattleCupVictory winners = 1;
  total_size += 1UL * this->_internal_winners_size();
  for (const auto& msg : this->_impl_.winners_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgLobbyBattleCupVictoryList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgLobbyBattleCupVictoryList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgLobbyBattleCupVictoryList::GetClassData() const { return &_class_data_; }


void CMsgLobbyBattleCupVictoryList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgLobbyBattleCupVictoryList*>(&to_msg);
  auto& from = static_cast<const CMsgLobbyBattleCupVictoryList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgLobbyBattleCupVictoryList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.winners_.MergeFrom(from._impl_.winners_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgLobbyBattleCupVictoryList::CopyFrom(const CMsgLobbyBattleCupVictoryList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgLobbyBattleCupVictoryList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgLobbyBattleCupVictoryList::IsInitialized() const {
  return true;
}

void CMsgLobbyBattleCupVictoryList::InternalSwap(CMsgLobbyBattleCupVictoryList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.winners_.InternalSwap(&other->_impl_.winners_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgLobbyBattleCupVictoryList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[6]);
}

// ===================================================================

class CMsgDOTABroadcastNotification::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTABroadcastNotification>()._impl_._has_bits_);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTABroadcastNotification::CMsgDOTABroadcastNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTABroadcastNotification)
}
CMsgDOTABroadcastNotification::CMsgDOTABroadcastNotification(const CMsgDOTABroadcastNotification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTABroadcastNotification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgDOTABroadcastNotification)
}

inline void CMsgDOTABroadcastNotification::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTABroadcastNotification::~CMsgDOTABroadcastNotification() {
  // @@protoc_insertion_point(destructor:CMsgDOTABroadcastNotification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTABroadcastNotification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void CMsgDOTABroadcastNotification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTABroadcastNotification::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTABroadcastNotification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTABroadcastNotification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTABroadcastNotification.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTABroadcastNotification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTABroadcastNotification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string message = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTABroadcastNotification.message");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTABroadcastNotification)
  return target;
}

size_t CMsgDOTABroadcastNotification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTABroadcastNotification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTABroadcastNotification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTABroadcastNotification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTABroadcastNotification::GetClassData() const { return &_class_data_; }


void CMsgDOTABroadcastNotification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTABroadcastNotification*>(&to_msg);
  auto& from = static_cast<const CMsgDOTABroadcastNotification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTABroadcastNotification)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_message()) {
    _this->_internal_set_message(from._internal_message());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTABroadcastNotification::CopyFrom(const CMsgDOTABroadcastNotification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTABroadcastNotification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTABroadcastNotification::IsInitialized() const {
  return true;
}

void CMsgDOTABroadcastNotification::InternalSwap(CMsgDOTABroadcastNotification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTABroadcastNotification::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[7]);
}

// ===================================================================

class CProtoItemHeroStatue::_Internal {
 public:
  using HasBits = decltype(std::declval<CProtoItemHeroStatue>()._impl_._has_bits_);
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_status_effect_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sequence_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cycle(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_inscription(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tournament_drop(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CProtoItemHeroStatue::CProtoItemHeroStatue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CProtoItemHeroStatue)
}
CProtoItemHeroStatue::CProtoItemHeroStatue(const CProtoItemHeroStatue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CProtoItemHeroStatue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.wearable_){from._impl_.wearable_}
    , decltype(_impl_.style_){from._impl_.style_}
    , decltype(_impl_.sequence_name_){}
    , decltype(_impl_.inscription_){}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.status_effect_index_){}
    , decltype(_impl_.cycle_){}
    , decltype(_impl_.tournament_drop_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sequence_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sequence_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sequence_name()) {
    _this->_impl_.sequence_name_.Set(from._internal_sequence_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.inscription_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.inscription_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_inscription()) {
    _this->_impl_.inscription_.Set(from._internal_inscription(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.hero_id_, &from._impl_.hero_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tournament_drop_) -
    reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.tournament_drop_));
  // @@protoc_insertion_point(copy_constructor:CProtoItemHeroStatue)
}

inline void CProtoItemHeroStatue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.wearable_){arena}
    , decltype(_impl_.style_){arena}
    , decltype(_impl_.sequence_name_){}
    , decltype(_impl_.inscription_){}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.status_effect_index_){0u}
    , decltype(_impl_.cycle_){0}
    , decltype(_impl_.tournament_drop_){false}
  };
  _impl_.sequence_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sequence_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.inscription_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.inscription_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CProtoItemHeroStatue::~CProtoItemHeroStatue() {
  // @@protoc_insertion_point(destructor:CProtoItemHeroStatue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CProtoItemHeroStatue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.wearable_.~RepeatedField();
  _impl_.style_.~RepeatedField();
  _impl_.sequence_name_.Destroy();
  _impl_.inscription_.Destroy();
}

void CProtoItemHeroStatue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CProtoItemHeroStatue::Clear() {
// @@protoc_insertion_point(message_clear_start:CProtoItemHeroStatue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wearable_.Clear();
  _impl_.style_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.sequence_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.inscription_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.hero_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tournament_drop_) -
        reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.tournament_drop_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CProtoItemHeroStatue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 hero_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 status_effect_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_status_effect_index(&has_bits);
          _impl_.status_effect_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string sequence_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sequence_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CProtoItemHeroStatue.sequence_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional float cycle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_cycle(&has_bits);
          _impl_.cycle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 wearable = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_wearable(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_wearable(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string inscription = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_inscription();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CProtoItemHeroStatue.inscription");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 style = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_style(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_style(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool tournament_drop = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_tournament_drop(&has_bits);
          _impl_.tournament_drop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CProtoItemHeroStatue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CProtoItemHeroStatue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 hero_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hero_id(), target);
  }

  // optional uint32 status_effect_index = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_status_effect_index(), target);
  }

  // optional string sequence_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sequence_name().data(), static_cast<int>(this->_internal_sequence_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CProtoItemHeroStatue.sequence_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sequence_name(), target);
  }

  // optional float cycle = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_cycle(), target);
  }

  // repeated uint32 wearable = 5;
  for (int i = 0, n = this->_internal_wearable_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_wearable(i), target);
  }

  // optional string inscription = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_inscription().data(), static_cast<int>(this->_internal_inscription().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CProtoItemHeroStatue.inscription");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_inscription(), target);
  }

  // repeated uint32 style = 7;
  for (int i = 0, n = this->_internal_style_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_style(i), target);
  }

  // optional bool tournament_drop = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_tournament_drop(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CProtoItemHeroStatue)
  return target;
}

size_t CProtoItemHeroStatue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CProtoItemHeroStatue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 wearable = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.wearable_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_wearable_size());
    total_size += data_size;
  }

  // repeated uint32 style = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.style_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_style_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string sequence_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sequence_name());
    }

    // optional string inscription = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_inscription());
    }

    // optional uint32 hero_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional uint32 status_effect_index = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status_effect_index());
    }

    // optional float cycle = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional bool tournament_drop = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CProtoItemHeroStatue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CProtoItemHeroStatue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CProtoItemHeroStatue::GetClassData() const { return &_class_data_; }


void CProtoItemHeroStatue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CProtoItemHeroStatue*>(&to_msg);
  auto& from = static_cast<const CProtoItemHeroStatue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CProtoItemHeroStatue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.wearable_.MergeFrom(from._impl_.wearable_);
  _this->_impl_.style_.MergeFrom(from._impl_.style_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sequence_name(from._internal_sequence_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_inscription(from._internal_inscription());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.status_effect_index_ = from._impl_.status_effect_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.cycle_ = from._impl_.cycle_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.tournament_drop_ = from._impl_.tournament_drop_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CProtoItemHeroStatue::CopyFrom(const CProtoItemHeroStatue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CProtoItemHeroStatue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CProtoItemHeroStatue::IsInitialized() const {
  return true;
}

void CProtoItemHeroStatue::InternalSwap(CProtoItemHeroStatue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.wearable_.InternalSwap(&other->_impl_.wearable_);
  _impl_.style_.InternalSwap(&other->_impl_.style_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sequence_name_, lhs_arena,
      &other->_impl_.sequence_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.inscription_, lhs_arena,
      &other->_impl_.inscription_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CProtoItemHeroStatue, _impl_.tournament_drop_)
      + sizeof(CProtoItemHeroStatue::_impl_.tournament_drop_)
      - PROTOBUF_FIELD_OFFSET(CProtoItemHeroStatue, _impl_.hero_id_)>(
          reinterpret_cast<char*>(&_impl_.hero_id_),
          reinterpret_cast<char*>(&other->_impl_.hero_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CProtoItemHeroStatue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[8]);
}

// ===================================================================

class CMatchPlayerAbilityUpgrade::_Internal {
 public:
  using HasBits = decltype(std::declval<CMatchPlayerAbilityUpgrade>()._impl_._has_bits_);
  static void set_has_ability(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMatchPlayerAbilityUpgrade::CMatchPlayerAbilityUpgrade(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMatchPlayerAbilityUpgrade)
}
CMatchPlayerAbilityUpgrade::CMatchPlayerAbilityUpgrade(const CMatchPlayerAbilityUpgrade& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMatchPlayerAbilityUpgrade* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_){}
    , decltype(_impl_.ability_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.time_, &from._impl_.time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ability_) -
    reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.ability_));
  // @@protoc_insertion_point(copy_constructor:CMatchPlayerAbilityUpgrade)
}

inline void CMatchPlayerAbilityUpgrade::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_){0u}
    , decltype(_impl_.ability_){-1}
  };
}

CMatchPlayerAbilityUpgrade::~CMatchPlayerAbilityUpgrade() {
  // @@protoc_insertion_point(destructor:CMatchPlayerAbilityUpgrade)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMatchPlayerAbilityUpgrade::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMatchPlayerAbilityUpgrade::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMatchPlayerAbilityUpgrade::Clear() {
// @@protoc_insertion_point(message_clear_start:CMatchPlayerAbilityUpgrade)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.time_ = 0u;
    _impl_.ability_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMatchPlayerAbilityUpgrade::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 ability = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ability(&has_bits);
          _impl_.ability_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMatchPlayerAbilityUpgrade::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMatchPlayerAbilityUpgrade)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 ability = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_ability(), target);
  }

  // optional uint32 time = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMatchPlayerAbilityUpgrade)
  return target;
}

size_t CMatchPlayerAbilityUpgrade::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMatchPlayerAbilityUpgrade)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 time = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time());
    }

    // optional int32 ability = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ability());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMatchPlayerAbilityUpgrade::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMatchPlayerAbilityUpgrade::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMatchPlayerAbilityUpgrade::GetClassData() const { return &_class_data_; }


void CMatchPlayerAbilityUpgrade::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMatchPlayerAbilityUpgrade*>(&to_msg);
  auto& from = static_cast<const CMatchPlayerAbilityUpgrade&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMatchPlayerAbilityUpgrade)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ability_ = from._impl_.ability_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMatchPlayerAbilityUpgrade::CopyFrom(const CMatchPlayerAbilityUpgrade& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMatchPlayerAbilityUpgrade)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMatchPlayerAbilityUpgrade::IsInitialized() const {
  return true;
}

void CMatchPlayerAbilityUpgrade::InternalSwap(CMatchPlayerAbilityUpgrade* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.time_, other->_impl_.time_);
  swap(_impl_.ability_, other->_impl_.ability_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMatchPlayerAbilityUpgrade::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[9]);
}

// ===================================================================

class CMatchPlayerTimedStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMatchPlayerTimedStats>()._impl_._has_bits_);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_deaths(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_assists(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_net_worth(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_xp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_last_hits(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_denies(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_bounty_rune_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_range_creep_upgrade_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_observer_wards_dewarded(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_reliable_gold_earned(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_gold_loss_prevented(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_hero_kill_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_creep_kill_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_building_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_other_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_comeback_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_experimental_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_experimental2_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_creep_deny_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_tp_scrolls_purchased_1(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_tp_scrolls_purchased_2(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_tp_scrolls_purchased_3(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_tp_scrolls_purchased_4(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_tp_scrolls_purchased_5(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_neutral_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_courier_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_roshan_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_income_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_custom_stats_1(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_custom_stats_2(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_custom_stats_3(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_custom_stats_4(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_custom_stats_5(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_item_value(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_support_gold_spent(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_camps_stacked(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_wards_placed(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_triple_kills(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_rampages(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
};

CMatchPlayerTimedStats::CMatchPlayerTimedStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMatchPlayerTimedStats)
}
CMatchPlayerTimedStats::CMatchPlayerTimedStats(const CMatchPlayerTimedStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMatchPlayerTimedStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_){}
    , decltype(_impl_.kills_){}
    , decltype(_impl_.deaths_){}
    , decltype(_impl_.assists_){}
    , decltype(_impl_.net_worth_){}
    , decltype(_impl_.xp_){}
    , decltype(_impl_.last_hits_){}
    , decltype(_impl_.denies_){}
    , decltype(_impl_.bounty_rune_gold_){}
    , decltype(_impl_.range_creep_upgrade_gold_){}
    , decltype(_impl_.observer_wards_dewarded_){}
    , decltype(_impl_.reliable_gold_earned_){}
    , decltype(_impl_.gold_loss_prevented_){}
    , decltype(_impl_.hero_kill_gold_){}
    , decltype(_impl_.creep_kill_gold_){}
    , decltype(_impl_.building_gold_){}
    , decltype(_impl_.other_gold_){}
    , decltype(_impl_.comeback_gold_){}
    , decltype(_impl_.experimental_gold_){}
    , decltype(_impl_.experimental2_gold_){}
    , decltype(_impl_.creep_deny_gold_){}
    , decltype(_impl_.tp_scrolls_purchased_1_){}
    , decltype(_impl_.tp_scrolls_purchased_2_){}
    , decltype(_impl_.tp_scrolls_purchased_3_){}
    , decltype(_impl_.tp_scrolls_purchased_4_){}
    , decltype(_impl_.tp_scrolls_purchased_5_){}
    , decltype(_impl_.neutral_gold_){}
    , decltype(_impl_.courier_gold_){}
    , decltype(_impl_.roshan_gold_){}
    , decltype(_impl_.income_gold_){}
    , decltype(_impl_.custom_stats_1_){}
    , decltype(_impl_.custom_stats_2_){}
    , decltype(_impl_.custom_stats_3_){}
    , decltype(_impl_.custom_stats_4_){}
    , decltype(_impl_.custom_stats_5_){}
    , decltype(_impl_.item_value_){}
    , decltype(_impl_.support_gold_spent_){}
    , decltype(_impl_.camps_stacked_){}
    , decltype(_impl_.wards_placed_){}
    , decltype(_impl_.triple_kills_){}
    , decltype(_impl_.rampages_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.time_, &from._impl_.time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rampages_) -
    reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.rampages_));
  // @@protoc_insertion_point(copy_constructor:CMatchPlayerTimedStats)
}

inline void CMatchPlayerTimedStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_){0u}
    , decltype(_impl_.kills_){0u}
    , decltype(_impl_.deaths_){0u}
    , decltype(_impl_.assists_){0u}
    , decltype(_impl_.net_worth_){0u}
    , decltype(_impl_.xp_){0u}
    , decltype(_impl_.last_hits_){0u}
    , decltype(_impl_.denies_){0u}
    , decltype(_impl_.bounty_rune_gold_){0u}
    , decltype(_impl_.range_creep_upgrade_gold_){0u}
    , decltype(_impl_.observer_wards_dewarded_){0u}
    , decltype(_impl_.reliable_gold_earned_){0u}
    , decltype(_impl_.gold_loss_prevented_){0u}
    , decltype(_impl_.hero_kill_gold_){0u}
    , decltype(_impl_.creep_kill_gold_){0u}
    , decltype(_impl_.building_gold_){0u}
    , decltype(_impl_.other_gold_){0u}
    , decltype(_impl_.comeback_gold_){0u}
    , decltype(_impl_.experimental_gold_){0u}
    , decltype(_impl_.experimental2_gold_){0u}
    , decltype(_impl_.creep_deny_gold_){0u}
    , decltype(_impl_.tp_scrolls_purchased_1_){0u}
    , decltype(_impl_.tp_scrolls_purchased_2_){0u}
    , decltype(_impl_.tp_scrolls_purchased_3_){0u}
    , decltype(_impl_.tp_scrolls_purchased_4_){0u}
    , decltype(_impl_.tp_scrolls_purchased_5_){0u}
    , decltype(_impl_.neutral_gold_){0u}
    , decltype(_impl_.courier_gold_){0u}
    , decltype(_impl_.roshan_gold_){0u}
    , decltype(_impl_.income_gold_){0u}
    , decltype(_impl_.custom_stats_1_){0u}
    , decltype(_impl_.custom_stats_2_){0u}
    , decltype(_impl_.custom_stats_3_){0u}
    , decltype(_impl_.custom_stats_4_){0u}
    , decltype(_impl_.custom_stats_5_){0u}
    , decltype(_impl_.item_value_){0u}
    , decltype(_impl_.support_gold_spent_){0u}
    , decltype(_impl_.camps_stacked_){0u}
    , decltype(_impl_.wards_placed_){0u}
    , decltype(_impl_.triple_kills_){0u}
    , decltype(_impl_.rampages_){0u}
  };
}

CMatchPlayerTimedStats::~CMatchPlayerTimedStats() {
  // @@protoc_insertion_point(destructor:CMatchPlayerTimedStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMatchPlayerTimedStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMatchPlayerTimedStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMatchPlayerTimedStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMatchPlayerTimedStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.denies_) -
        reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.denies_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.bounty_rune_gold_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.building_gold_) -
        reinterpret_cast<char*>(&_impl_.bounty_rune_gold_)) + sizeof(_impl_.building_gold_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.other_gold_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tp_scrolls_purchased_3_) -
        reinterpret_cast<char*>(&_impl_.other_gold_)) + sizeof(_impl_.tp_scrolls_purchased_3_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.tp_scrolls_purchased_4_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.custom_stats_2_) -
        reinterpret_cast<char*>(&_impl_.tp_scrolls_purchased_4_)) + sizeof(_impl_.custom_stats_2_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.custom_stats_3_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.triple_kills_) -
        reinterpret_cast<char*>(&_impl_.custom_stats_3_)) + sizeof(_impl_.triple_kills_));
  }
  _impl_.rampages_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMatchPlayerTimedStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_time(&_impl_._has_bits_);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 kills = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_kills(&_impl_._has_bits_);
          _impl_.kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 deaths = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_deaths(&_impl_._has_bits_);
          _impl_.deaths_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assists = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_assists(&_impl_._has_bits_);
          _impl_.assists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 net_worth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_net_worth(&_impl_._has_bits_);
          _impl_.net_worth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 xp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_xp(&_impl_._has_bits_);
          _impl_.xp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_hits = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_last_hits(&_impl_._has_bits_);
          _impl_.last_hits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 denies = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_denies(&_impl_._has_bits_);
          _impl_.denies_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bounty_rune_gold = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_bounty_rune_gold(&_impl_._has_bits_);
          _impl_.bounty_rune_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 range_creep_upgrade_gold = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_range_creep_upgrade_gold(&_impl_._has_bits_);
          _impl_.range_creep_upgrade_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 observer_wards_dewarded = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_observer_wards_dewarded(&_impl_._has_bits_);
          _impl_.observer_wards_dewarded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 reliable_gold_earned = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_reliable_gold_earned(&_impl_._has_bits_);
          _impl_.reliable_gold_earned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gold_loss_prevented = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_gold_loss_prevented(&_impl_._has_bits_);
          _impl_.gold_loss_prevented_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_kill_gold = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_hero_kill_gold(&_impl_._has_bits_);
          _impl_.hero_kill_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 creep_kill_gold = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_creep_kill_gold(&_impl_._has_bits_);
          _impl_.creep_kill_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 building_gold = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_building_gold(&_impl_._has_bits_);
          _impl_.building_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 other_gold = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_other_gold(&_impl_._has_bits_);
          _impl_.other_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 comeback_gold = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_comeback_gold(&_impl_._has_bits_);
          _impl_.comeback_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 experimental_gold = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_experimental_gold(&_impl_._has_bits_);
          _impl_.experimental_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 experimental2_gold = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_experimental2_gold(&_impl_._has_bits_);
          _impl_.experimental2_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 creep_deny_gold = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_creep_deny_gold(&_impl_._has_bits_);
          _impl_.creep_deny_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tp_scrolls_purchased_1 = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_tp_scrolls_purchased_1(&_impl_._has_bits_);
          _impl_.tp_scrolls_purchased_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tp_scrolls_purchased_2 = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_tp_scrolls_purchased_2(&_impl_._has_bits_);
          _impl_.tp_scrolls_purchased_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tp_scrolls_purchased_3 = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_tp_scrolls_purchased_3(&_impl_._has_bits_);
          _impl_.tp_scrolls_purchased_3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tp_scrolls_purchased_4 = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_tp_scrolls_purchased_4(&_impl_._has_bits_);
          _impl_.tp_scrolls_purchased_4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tp_scrolls_purchased_5 = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_tp_scrolls_purchased_5(&_impl_._has_bits_);
          _impl_.tp_scrolls_purchased_5_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 neutral_gold = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_neutral_gold(&_impl_._has_bits_);
          _impl_.neutral_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 courier_gold = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_courier_gold(&_impl_._has_bits_);
          _impl_.courier_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 roshan_gold = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_roshan_gold(&_impl_._has_bits_);
          _impl_.roshan_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 income_gold = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_income_gold(&_impl_._has_bits_);
          _impl_.income_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 custom_stats_1 = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_custom_stats_1(&_impl_._has_bits_);
          _impl_.custom_stats_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 custom_stats_2 = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_custom_stats_2(&_impl_._has_bits_);
          _impl_.custom_stats_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 custom_stats_3 = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_custom_stats_3(&_impl_._has_bits_);
          _impl_.custom_stats_3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 custom_stats_4 = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_custom_stats_4(&_impl_._has_bits_);
          _impl_.custom_stats_4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 custom_stats_5 = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_custom_stats_5(&_impl_._has_bits_);
          _impl_.custom_stats_5_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 item_value = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_item_value(&_impl_._has_bits_);
          _impl_.item_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 support_gold_spent = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_support_gold_spent(&_impl_._has_bits_);
          _impl_.support_gold_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 camps_stacked = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_camps_stacked(&_impl_._has_bits_);
          _impl_.camps_stacked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 wards_placed = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_wards_placed(&_impl_._has_bits_);
          _impl_.wards_placed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 triple_kills = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_triple_kills(&_impl_._has_bits_);
          _impl_.triple_kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rampages = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_rampages(&_impl_._has_bits_);
          _impl_.rampages_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMatchPlayerTimedStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMatchPlayerTimedStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_time(), target);
  }

  // optional uint32 kills = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_kills(), target);
  }

  // optional uint32 deaths = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_deaths(), target);
  }

  // optional uint32 assists = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_assists(), target);
  }

  // optional uint32 net_worth = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_net_worth(), target);
  }

  // optional uint32 xp = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_xp(), target);
  }

  // optional uint32 last_hits = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_last_hits(), target);
  }

  // optional uint32 denies = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_denies(), target);
  }

  // optional uint32 bounty_rune_gold = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_bounty_rune_gold(), target);
  }

  // optional uint32 range_creep_upgrade_gold = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_range_creep_upgrade_gold(), target);
  }

  // optional uint32 observer_wards_dewarded = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_observer_wards_dewarded(), target);
  }

  // optional uint32 reliable_gold_earned = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_reliable_gold_earned(), target);
  }

  // optional uint32 gold_loss_prevented = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_gold_loss_prevented(), target);
  }

  // optional uint32 hero_kill_gold = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_hero_kill_gold(), target);
  }

  // optional uint32 creep_kill_gold = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_creep_kill_gold(), target);
  }

  // optional uint32 building_gold = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_building_gold(), target);
  }

  // optional uint32 other_gold = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_other_gold(), target);
  }

  // optional uint32 comeback_gold = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_comeback_gold(), target);
  }

  // optional uint32 experimental_gold = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_experimental_gold(), target);
  }

  // optional uint32 experimental2_gold = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_experimental2_gold(), target);
  }

  // optional uint32 creep_deny_gold = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_creep_deny_gold(), target);
  }

  // optional uint32 tp_scrolls_purchased_1 = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_tp_scrolls_purchased_1(), target);
  }

  // optional uint32 tp_scrolls_purchased_2 = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_tp_scrolls_purchased_2(), target);
  }

  // optional uint32 tp_scrolls_purchased_3 = 24;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_tp_scrolls_purchased_3(), target);
  }

  // optional uint32 tp_scrolls_purchased_4 = 25;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_tp_scrolls_purchased_4(), target);
  }

  // optional uint32 tp_scrolls_purchased_5 = 26;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(26, this->_internal_tp_scrolls_purchased_5(), target);
  }

  // optional uint32 neutral_gold = 27;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_neutral_gold(), target);
  }

  // optional uint32 courier_gold = 28;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_courier_gold(), target);
  }

  // optional uint32 roshan_gold = 29;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(29, this->_internal_roshan_gold(), target);
  }

  // optional uint32 income_gold = 30;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(30, this->_internal_income_gold(), target);
  }

  // optional uint32 custom_stats_1 = 31;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(31, this->_internal_custom_stats_1(), target);
  }

  // optional uint32 custom_stats_2 = 32;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(32, this->_internal_custom_stats_2(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 custom_stats_3 = 33;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(33, this->_internal_custom_stats_3(), target);
  }

  // optional uint32 custom_stats_4 = 34;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(34, this->_internal_custom_stats_4(), target);
  }

  // optional uint32 custom_stats_5 = 35;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_custom_stats_5(), target);
  }

  // optional uint32 item_value = 36;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(36, this->_internal_item_value(), target);
  }

  // optional uint32 support_gold_spent = 37;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(37, this->_internal_support_gold_spent(), target);
  }

  // optional uint32 camps_stacked = 38;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(38, this->_internal_camps_stacked(), target);
  }

  // optional uint32 wards_placed = 39;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(39, this->_internal_wards_placed(), target);
  }

  // optional uint32 triple_kills = 40;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(40, this->_internal_triple_kills(), target);
  }

  // optional uint32 rampages = 41;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(41, this->_internal_rampages(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMatchPlayerTimedStats)
  return target;
}

size_t CMatchPlayerTimedStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMatchPlayerTimedStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 time = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time());
    }

    // optional uint32 kills = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_kills());
    }

    // optional uint32 deaths = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_deaths());
    }

    // optional uint32 assists = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_assists());
    }

    // optional uint32 net_worth = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_net_worth());
    }

    // optional uint32 xp = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_xp());
    }

    // optional uint32 last_hits = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_hits());
    }

    // optional uint32 denies = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_denies());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 bounty_rune_gold = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bounty_rune_gold());
    }

    // optional uint32 range_creep_upgrade_gold = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_range_creep_upgrade_gold());
    }

    // optional uint32 observer_wards_dewarded = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_observer_wards_dewarded());
    }

    // optional uint32 reliable_gold_earned = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reliable_gold_earned());
    }

    // optional uint32 gold_loss_prevented = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gold_loss_prevented());
    }

    // optional uint32 hero_kill_gold = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_kill_gold());
    }

    // optional uint32 creep_kill_gold = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_creep_kill_gold());
    }

    // optional uint32 building_gold = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_building_gold());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 other_gold = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_other_gold());
    }

    // optional uint32 comeback_gold = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_comeback_gold());
    }

    // optional uint32 experimental_gold = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_experimental_gold());
    }

    // optional uint32 experimental2_gold = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_experimental2_gold());
    }

    // optional uint32 creep_deny_gold = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_creep_deny_gold());
    }

    // optional uint32 tp_scrolls_purchased_1 = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tp_scrolls_purchased_1());
    }

    // optional uint32 tp_scrolls_purchased_2 = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tp_scrolls_purchased_2());
    }

    // optional uint32 tp_scrolls_purchased_3 = 24;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tp_scrolls_purchased_3());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 tp_scrolls_purchased_4 = 25;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tp_scrolls_purchased_4());
    }

    // optional uint32 tp_scrolls_purchased_5 = 26;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tp_scrolls_purchased_5());
    }

    // optional uint32 neutral_gold = 27;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_neutral_gold());
    }

    // optional uint32 courier_gold = 28;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_courier_gold());
    }

    // optional uint32 roshan_gold = 29;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_roshan_gold());
    }

    // optional uint32 income_gold = 30;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_income_gold());
    }

    // optional uint32 custom_stats_1 = 31;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_custom_stats_1());
    }

    // optional uint32 custom_stats_2 = 32;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_custom_stats_2());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 custom_stats_3 = 33;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_custom_stats_3());
    }

    // optional uint32 custom_stats_4 = 34;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_custom_stats_4());
    }

    // optional uint32 custom_stats_5 = 35;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_custom_stats_5());
    }

    // optional uint32 item_value = 36;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_item_value());
    }

    // optional uint32 support_gold_spent = 37;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_support_gold_spent());
    }

    // optional uint32 camps_stacked = 38;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_camps_stacked());
    }

    // optional uint32 wards_placed = 39;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_wards_placed());
    }

    // optional uint32 triple_kills = 40;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_triple_kills());
    }

  }
  // optional uint32 rampages = 41;
  if (cached_has_bits & 0x00000100u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_rampages());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMatchPlayerTimedStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMatchPlayerTimedStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMatchPlayerTimedStats::GetClassData() const { return &_class_data_; }


void CMatchPlayerTimedStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMatchPlayerTimedStats*>(&to_msg);
  auto& from = static_cast<const CMatchPlayerTimedStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMatchPlayerTimedStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.kills_ = from._impl_.kills_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.deaths_ = from._impl_.deaths_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.assists_ = from._impl_.assists_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.net_worth_ = from._impl_.net_worth_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.xp_ = from._impl_.xp_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.last_hits_ = from._impl_.last_hits_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.denies_ = from._impl_.denies_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.bounty_rune_gold_ = from._impl_.bounty_rune_gold_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.range_creep_upgrade_gold_ = from._impl_.range_creep_upgrade_gold_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.observer_wards_dewarded_ = from._impl_.observer_wards_dewarded_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.reliable_gold_earned_ = from._impl_.reliable_gold_earned_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.gold_loss_prevented_ = from._impl_.gold_loss_prevented_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.hero_kill_gold_ = from._impl_.hero_kill_gold_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.creep_kill_gold_ = from._impl_.creep_kill_gold_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.building_gold_ = from._impl_.building_gold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.other_gold_ = from._impl_.other_gold_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.comeback_gold_ = from._impl_.comeback_gold_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.experimental_gold_ = from._impl_.experimental_gold_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.experimental2_gold_ = from._impl_.experimental2_gold_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.creep_deny_gold_ = from._impl_.creep_deny_gold_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.tp_scrolls_purchased_1_ = from._impl_.tp_scrolls_purchased_1_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.tp_scrolls_purchased_2_ = from._impl_.tp_scrolls_purchased_2_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.tp_scrolls_purchased_3_ = from._impl_.tp_scrolls_purchased_3_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.tp_scrolls_purchased_4_ = from._impl_.tp_scrolls_purchased_4_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.tp_scrolls_purchased_5_ = from._impl_.tp_scrolls_purchased_5_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.neutral_gold_ = from._impl_.neutral_gold_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.courier_gold_ = from._impl_.courier_gold_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.roshan_gold_ = from._impl_.roshan_gold_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.income_gold_ = from._impl_.income_gold_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.custom_stats_1_ = from._impl_.custom_stats_1_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.custom_stats_2_ = from._impl_.custom_stats_2_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.custom_stats_3_ = from._impl_.custom_stats_3_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.custom_stats_4_ = from._impl_.custom_stats_4_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.custom_stats_5_ = from._impl_.custom_stats_5_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.item_value_ = from._impl_.item_value_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.support_gold_spent_ = from._impl_.support_gold_spent_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.camps_stacked_ = from._impl_.camps_stacked_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.wards_placed_ = from._impl_.wards_placed_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.triple_kills_ = from._impl_.triple_kills_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_rampages(from._internal_rampages());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMatchPlayerTimedStats::CopyFrom(const CMatchPlayerTimedStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMatchPlayerTimedStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMatchPlayerTimedStats::IsInitialized() const {
  return true;
}

void CMatchPlayerTimedStats::InternalSwap(CMatchPlayerTimedStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMatchPlayerTimedStats, _impl_.rampages_)
      + sizeof(CMatchPlayerTimedStats::_impl_.rampages_)
      - PROTOBUF_FIELD_OFFSET(CMatchPlayerTimedStats, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMatchPlayerTimedStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[10]);
}

// ===================================================================

class CMatchTeamTimedStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMatchTeamTimedStats>()._impl_._has_bits_);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enemy_towers_killed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enemy_barracks_killed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enemy_towers_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_enemy_barracks_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMatchTeamTimedStats::CMatchTeamTimedStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMatchTeamTimedStats)
}
CMatchTeamTimedStats::CMatchTeamTimedStats(const CMatchTeamTimedStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMatchTeamTimedStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_){}
    , decltype(_impl_.enemy_towers_killed_){}
    , decltype(_impl_.enemy_barracks_killed_){}
    , decltype(_impl_.enemy_towers_status_){}
    , decltype(_impl_.enemy_barracks_status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.time_, &from._impl_.time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enemy_barracks_status_) -
    reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.enemy_barracks_status_));
  // @@protoc_insertion_point(copy_constructor:CMatchTeamTimedStats)
}

inline void CMatchTeamTimedStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_){0u}
    , decltype(_impl_.enemy_towers_killed_){0u}
    , decltype(_impl_.enemy_barracks_killed_){0u}
    , decltype(_impl_.enemy_towers_status_){0u}
    , decltype(_impl_.enemy_barracks_status_){0u}
  };
}

CMatchTeamTimedStats::~CMatchTeamTimedStats() {
  // @@protoc_insertion_point(destructor:CMatchTeamTimedStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMatchTeamTimedStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMatchTeamTimedStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMatchTeamTimedStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMatchTeamTimedStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.enemy_barracks_status_) -
        reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.enemy_barracks_status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMatchTeamTimedStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 enemy_towers_killed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_enemy_towers_killed(&has_bits);
          _impl_.enemy_towers_killed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 enemy_barracks_killed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_enemy_barracks_killed(&has_bits);
          _impl_.enemy_barracks_killed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 enemy_towers_status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_enemy_towers_status(&has_bits);
          _impl_.enemy_towers_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 enemy_barracks_status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_enemy_barracks_status(&has_bits);
          _impl_.enemy_barracks_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMatchTeamTimedStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMatchTeamTimedStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_time(), target);
  }

  // optional uint32 enemy_towers_killed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_enemy_towers_killed(), target);
  }

  // optional uint32 enemy_barracks_killed = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_enemy_barracks_killed(), target);
  }

  // optional uint32 enemy_towers_status = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_enemy_towers_status(), target);
  }

  // optional uint32 enemy_barracks_status = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_enemy_barracks_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMatchTeamTimedStats)
  return target;
}

size_t CMatchTeamTimedStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMatchTeamTimedStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 time = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time());
    }

    // optional uint32 enemy_towers_killed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_enemy_towers_killed());
    }

    // optional uint32 enemy_barracks_killed = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_enemy_barracks_killed());
    }

    // optional uint32 enemy_towers_status = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_enemy_towers_status());
    }

    // optional uint32 enemy_barracks_status = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_enemy_barracks_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMatchTeamTimedStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMatchTeamTimedStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMatchTeamTimedStats::GetClassData() const { return &_class_data_; }


void CMatchTeamTimedStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMatchTeamTimedStats*>(&to_msg);
  auto& from = static_cast<const CMatchTeamTimedStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMatchTeamTimedStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.enemy_towers_killed_ = from._impl_.enemy_towers_killed_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.enemy_barracks_killed_ = from._impl_.enemy_barracks_killed_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.enemy_towers_status_ = from._impl_.enemy_towers_status_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.enemy_barracks_status_ = from._impl_.enemy_barracks_status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMatchTeamTimedStats::CopyFrom(const CMatchTeamTimedStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMatchTeamTimedStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMatchTeamTimedStats::IsInitialized() const {
  return true;
}

void CMatchTeamTimedStats::InternalSwap(CMatchTeamTimedStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMatchTeamTimedStats, _impl_.enemy_barracks_status_)
      + sizeof(CMatchTeamTimedStats::_impl_.enemy_barracks_status_)
      - PROTOBUF_FIELD_OFFSET(CMatchTeamTimedStats, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMatchTeamTimedStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[11]);
}

// ===================================================================

class CMatchAdditionalUnitInventory::_Internal {
 public:
  using HasBits = decltype(std::declval<CMatchAdditionalUnitInventory>()._impl_._has_bits_);
  static void set_has_unit_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMatchAdditionalUnitInventory::CMatchAdditionalUnitInventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMatchAdditionalUnitInventory)
}
CMatchAdditionalUnitInventory::CMatchAdditionalUnitInventory(const CMatchAdditionalUnitInventory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMatchAdditionalUnitInventory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.unit_name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.unit_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unit_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_unit_name()) {
    _this->_impl_.unit_name_.Set(from._internal_unit_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMatchAdditionalUnitInventory)
}

inline void CMatchAdditionalUnitInventory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.unit_name_){}
  };
  _impl_.unit_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unit_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMatchAdditionalUnitInventory::~CMatchAdditionalUnitInventory() {
  // @@protoc_insertion_point(destructor:CMatchAdditionalUnitInventory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMatchAdditionalUnitInventory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedField();
  _impl_.unit_name_.Destroy();
}

void CMatchAdditionalUnitInventory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMatchAdditionalUnitInventory::Clear() {
// @@protoc_insertion_point(message_clear_start:CMatchAdditionalUnitInventory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.unit_name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMatchAdditionalUnitInventory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string unit_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_unit_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMatchAdditionalUnitInventory.unit_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated int32 items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_items(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_items(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMatchAdditionalUnitInventory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMatchAdditionalUnitInventory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string unit_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_unit_name().data(), static_cast<int>(this->_internal_unit_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMatchAdditionalUnitInventory.unit_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_unit_name(), target);
  }

  // repeated int32 items = 2;
  for (int i = 0, n = this->_internal_items_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_items(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMatchAdditionalUnitInventory)
  return target;
}

size_t CMatchAdditionalUnitInventory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMatchAdditionalUnitInventory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 items = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.items_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_items_size());
    total_size += data_size;
  }

  // optional string unit_name = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_unit_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMatchAdditionalUnitInventory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMatchAdditionalUnitInventory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMatchAdditionalUnitInventory::GetClassData() const { return &_class_data_; }


void CMatchAdditionalUnitInventory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMatchAdditionalUnitInventory*>(&to_msg);
  auto& from = static_cast<const CMatchAdditionalUnitInventory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMatchAdditionalUnitInventory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  if (from._internal_has_unit_name()) {
    _this->_internal_set_unit_name(from._internal_unit_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMatchAdditionalUnitInventory::CopyFrom(const CMatchAdditionalUnitInventory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMatchAdditionalUnitInventory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMatchAdditionalUnitInventory::IsInitialized() const {
  return true;
}

void CMatchAdditionalUnitInventory::InternalSwap(CMatchAdditionalUnitInventory* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.unit_name_, lhs_arena,
      &other->_impl_.unit_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMatchAdditionalUnitInventory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[12]);
}

// ===================================================================

class CMatchPlayerPermanentBuff::_Internal {
 public:
  using HasBits = decltype(std::declval<CMatchPlayerPermanentBuff>()._impl_._has_bits_);
  static void set_has_permanent_buff(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_stack_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_grant_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMatchPlayerPermanentBuff::CMatchPlayerPermanentBuff(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMatchPlayerPermanentBuff)
}
CMatchPlayerPermanentBuff::CMatchPlayerPermanentBuff(const CMatchPlayerPermanentBuff& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMatchPlayerPermanentBuff* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.permanent_buff_){}
    , decltype(_impl_.stack_count_){}
    , decltype(_impl_.grant_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.permanent_buff_, &from._impl_.permanent_buff_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.grant_time_) -
    reinterpret_cast<char*>(&_impl_.permanent_buff_)) + sizeof(_impl_.grant_time_));
  // @@protoc_insertion_point(copy_constructor:CMatchPlayerPermanentBuff)
}

inline void CMatchPlayerPermanentBuff::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.permanent_buff_){0u}
    , decltype(_impl_.stack_count_){0u}
    , decltype(_impl_.grant_time_){0u}
  };
}

CMatchPlayerPermanentBuff::~CMatchPlayerPermanentBuff() {
  // @@protoc_insertion_point(destructor:CMatchPlayerPermanentBuff)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMatchPlayerPermanentBuff::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMatchPlayerPermanentBuff::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMatchPlayerPermanentBuff::Clear() {
// @@protoc_insertion_point(message_clear_start:CMatchPlayerPermanentBuff)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.permanent_buff_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.grant_time_) -
        reinterpret_cast<char*>(&_impl_.permanent_buff_)) + sizeof(_impl_.grant_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMatchPlayerPermanentBuff::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 permanent_buff = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_permanent_buff(&has_bits);
          _impl_.permanent_buff_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stack_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_stack_count(&has_bits);
          _impl_.stack_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 grant_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_grant_time(&has_bits);
          _impl_.grant_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMatchPlayerPermanentBuff::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMatchPlayerPermanentBuff)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 permanent_buff = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_permanent_buff(), target);
  }

  // optional uint32 stack_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_stack_count(), target);
  }

  // optional uint32 grant_time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_grant_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMatchPlayerPermanentBuff)
  return target;
}

size_t CMatchPlayerPermanentBuff::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMatchPlayerPermanentBuff)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 permanent_buff = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_permanent_buff());
    }

    // optional uint32 stack_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stack_count());
    }

    // optional uint32 grant_time = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_grant_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMatchPlayerPermanentBuff::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMatchPlayerPermanentBuff::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMatchPlayerPermanentBuff::GetClassData() const { return &_class_data_; }


void CMatchPlayerPermanentBuff::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMatchPlayerPermanentBuff*>(&to_msg);
  auto& from = static_cast<const CMatchPlayerPermanentBuff&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMatchPlayerPermanentBuff)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.permanent_buff_ = from._impl_.permanent_buff_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.stack_count_ = from._impl_.stack_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.grant_time_ = from._impl_.grant_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMatchPlayerPermanentBuff::CopyFrom(const CMatchPlayerPermanentBuff& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMatchPlayerPermanentBuff)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMatchPlayerPermanentBuff::IsInitialized() const {
  return true;
}

void CMatchPlayerPermanentBuff::InternalSwap(CMatchPlayerPermanentBuff* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMatchPlayerPermanentBuff, _impl_.grant_time_)
      + sizeof(CMatchPlayerPermanentBuff::_impl_.grant_time_)
      - PROTOBUF_FIELD_OFFSET(CMatchPlayerPermanentBuff, _impl_.permanent_buff_)>(
          reinterpret_cast<char*>(&_impl_.permanent_buff_),
          reinterpret_cast<char*>(&other->_impl_.permanent_buff_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMatchPlayerPermanentBuff::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[13]);
}

// ===================================================================

class CMatchHeroSelectEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<CMatchHeroSelectEvent>()._impl_._has_bits_);
  static void set_has_is_pick(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMatchHeroSelectEvent::CMatchHeroSelectEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMatchHeroSelectEvent)
}
CMatchHeroSelectEvent::CMatchHeroSelectEvent(const CMatchHeroSelectEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMatchHeroSelectEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.is_pick_){}
    , decltype(_impl_.team_){}
    , decltype(_impl_.hero_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.is_pick_, &from._impl_.is_pick_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hero_id_) -
    reinterpret_cast<char*>(&_impl_.is_pick_)) + sizeof(_impl_.hero_id_));
  // @@protoc_insertion_point(copy_constructor:CMatchHeroSelectEvent)
}

inline void CMatchHeroSelectEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.is_pick_){false}
    , decltype(_impl_.team_){0u}
    , decltype(_impl_.hero_id_){0u}
  };
}

CMatchHeroSelectEvent::~CMatchHeroSelectEvent() {
  // @@protoc_insertion_point(destructor:CMatchHeroSelectEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMatchHeroSelectEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMatchHeroSelectEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMatchHeroSelectEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:CMatchHeroSelectEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.is_pick_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hero_id_) -
        reinterpret_cast<char*>(&_impl_.is_pick_)) + sizeof(_impl_.hero_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMatchHeroSelectEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_pick = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_pick(&has_bits);
          _impl_.is_pick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team(&has_bits);
          _impl_.team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMatchHeroSelectEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMatchHeroSelectEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_pick = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_pick(), target);
  }

  // optional uint32 team = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_team(), target);
  }

  // optional uint32 hero_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hero_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMatchHeroSelectEvent)
  return target;
}

size_t CMatchHeroSelectEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMatchHeroSelectEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool is_pick = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional uint32 team = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team());
    }

    // optional uint32 hero_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMatchHeroSelectEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMatchHeroSelectEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMatchHeroSelectEvent::GetClassData() const { return &_class_data_; }


void CMatchHeroSelectEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMatchHeroSelectEvent*>(&to_msg);
  auto& from = static_cast<const CMatchHeroSelectEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMatchHeroSelectEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.is_pick_ = from._impl_.is_pick_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.team_ = from._impl_.team_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMatchHeroSelectEvent::CopyFrom(const CMatchHeroSelectEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMatchHeroSelectEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMatchHeroSelectEvent::IsInitialized() const {
  return true;
}

void CMatchHeroSelectEvent::InternalSwap(CMatchHeroSelectEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMatchHeroSelectEvent, _impl_.hero_id_)
      + sizeof(CMatchHeroSelectEvent::_impl_.hero_id_)
      - PROTOBUF_FIELD_OFFSET(CMatchHeroSelectEvent, _impl_.is_pick_)>(
          reinterpret_cast<char*>(&_impl_.is_pick_),
          reinterpret_cast<char*>(&other->_impl_.is_pick_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMatchHeroSelectEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[14]);
}

// ===================================================================

class CMatchClip::_Internal {
 public:
  using HasBits = decltype(std::declval<CMatchClip>()._impl_._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_player_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_game_time_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_duration_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_camera_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMatchClip::CMatchClip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMatchClip)
}
CMatchClip::CMatchClip(const CMatchClip& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMatchClip* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.player_account_id_){}
    , decltype(_impl_.game_time_seconds_){}
    , decltype(_impl_.duration_seconds_){}
    , decltype(_impl_.player_id_){}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.camera_mode_){}
    , decltype(_impl_.ability_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comment()) {
    _this->_impl_.comment_.Set(from._internal_comment(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.match_id_, &from._impl_.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ability_id_) -
    reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.ability_id_));
  // @@protoc_insertion_point(copy_constructor:CMatchClip)
}

inline void CMatchClip::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.player_account_id_){0u}
    , decltype(_impl_.game_time_seconds_){0u}
    , decltype(_impl_.duration_seconds_){0u}
    , decltype(_impl_.player_id_){0u}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.camera_mode_){0u}
    , decltype(_impl_.ability_id_){-1}
  };
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMatchClip::~CMatchClip() {
  // @@protoc_insertion_point(destructor:CMatchClip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMatchClip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comment_.Destroy();
}

void CMatchClip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMatchClip::Clear() {
// @@protoc_insertion_point(message_clear_start:CMatchClip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comment_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.camera_mode_) -
        reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.camera_mode_));
  }
  _impl_.ability_id_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMatchClip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 match_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 player_account_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_player_account_id(&has_bits);
          _impl_.player_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 game_time_seconds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_game_time_seconds(&has_bits);
          _impl_.game_time_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 duration_seconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_duration_seconds(&has_bits);
          _impl_.duration_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 player_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ability_id = 7 [default = -1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_ability_id(&has_bits);
          _impl_.ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 camera_mode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_camera_mode(&has_bits);
          _impl_.camera_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string comment = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMatchClip.comment");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMatchClip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMatchClip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 match_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_match_id(), target);
  }

  // optional uint32 player_account_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_player_account_id(), target);
  }

  // optional uint32 game_time_seconds = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_game_time_seconds(), target);
  }

  // optional uint32 duration_seconds = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_duration_seconds(), target);
  }

  // optional uint32 player_id = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_player_id(), target);
  }

  // optional uint32 hero_id = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_hero_id(), target);
  }

  // optional int32 ability_id = 7 [default = -1];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_ability_id(), target);
  }

  // optional uint32 camera_mode = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_camera_mode(), target);
  }

  // optional string comment = 9;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMatchClip.comment");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_comment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMatchClip)
  return target;
}

size_t CMatchClip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMatchClip)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string comment = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comment());
    }

    // optional uint64 match_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 player_account_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_player_account_id());
    }

    // optional uint32 game_time_seconds = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_time_seconds());
    }

    // optional uint32 duration_seconds = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_duration_seconds());
    }

    // optional uint32 player_id = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_player_id());
    }

    // optional uint32 hero_id = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional uint32 camera_mode = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_camera_mode());
    }

  }
  // optional int32 ability_id = 7 [default = -1];
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ability_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMatchClip::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMatchClip::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMatchClip::GetClassData() const { return &_class_data_; }


void CMatchClip::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMatchClip*>(&to_msg);
  auto& from = static_cast<const CMatchClip&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMatchClip)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comment(from._internal_comment());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.player_account_id_ = from._impl_.player_account_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.game_time_seconds_ = from._impl_.game_time_seconds_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.duration_seconds_ = from._impl_.duration_seconds_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.player_id_ = from._impl_.player_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.camera_mode_ = from._impl_.camera_mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_ability_id(from._internal_ability_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMatchClip::CopyFrom(const CMatchClip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMatchClip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMatchClip::IsInitialized() const {
  return true;
}

void CMatchClip::InternalSwap(CMatchClip* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_, lhs_arena,
      &other->_impl_.comment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMatchClip, _impl_.camera_mode_)
      + sizeof(CMatchClip::_impl_.camera_mode_)
      - PROTOBUF_FIELD_OFFSET(CMatchClip, _impl_.match_id_)>(
          reinterpret_cast<char*>(&_impl_.match_id_),
          reinterpret_cast<char*>(&other->_impl_.match_id_));
  swap(_impl_.ability_id_, other->_impl_.ability_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMatchClip::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[15]);
}

// ===================================================================

class CPartySearchClientParty::_Internal {
 public:
  using HasBits = decltype(std::declval<CPartySearchClientParty>()._impl_._has_bits_);
  static void set_has_party_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_beacon_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CPartySearchClientParty::CPartySearchClientParty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CPartySearchClientParty)
}
CPartySearchClientParty::CPartySearchClientParty(const CPartySearchClientParty& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CPartySearchClientParty* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.party_members_){from._impl_.party_members_}
    , decltype(_impl_.party_id_){}
    , decltype(_impl_.beacon_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.party_id_, &from._impl_.party_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.beacon_type_) -
    reinterpret_cast<char*>(&_impl_.party_id_)) + sizeof(_impl_.beacon_type_));
  // @@protoc_insertion_point(copy_constructor:CPartySearchClientParty)
}

inline void CPartySearchClientParty::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.party_members_){arena}
    , decltype(_impl_.party_id_){uint64_t{0u}}
    , decltype(_impl_.beacon_type_){0}
  };
}

CPartySearchClientParty::~CPartySearchClientParty() {
  // @@protoc_insertion_point(destructor:CPartySearchClientParty)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CPartySearchClientParty::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.party_members_.~RepeatedField();
}

void CPartySearchClientParty::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CPartySearchClientParty::Clear() {
// @@protoc_insertion_point(message_clear_start:CPartySearchClientParty)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.party_members_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.party_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.beacon_type_) -
        reinterpret_cast<char*>(&_impl_.party_id_)) + sizeof(_impl_.beacon_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CPartySearchClientParty::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 party_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_party_id(&has_bits);
          _impl_.party_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 beacon_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_beacon_type(&has_bits);
          _impl_.beacon_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 party_members = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_party_members(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<29>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_party_members(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CPartySearchClientParty::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CPartySearchClientParty)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 party_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_party_id(), target);
  }

  // optional int32 beacon_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_beacon_type(), target);
  }

  // repeated fixed32 party_members = 3;
  for (int i = 0, n = this->_internal_party_members_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_party_members(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CPartySearchClientParty)
  return target;
}

size_t CPartySearchClientParty::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CPartySearchClientParty)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 party_members = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_party_members_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_party_members_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 party_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional int32 beacon_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_beacon_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CPartySearchClientParty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CPartySearchClientParty::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CPartySearchClientParty::GetClassData() const { return &_class_data_; }


void CPartySearchClientParty::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CPartySearchClientParty*>(&to_msg);
  auto& from = static_cast<const CPartySearchClientParty&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CPartySearchClientParty)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.party_members_.MergeFrom(from._impl_.party_members_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.party_id_ = from._impl_.party_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.beacon_type_ = from._impl_.beacon_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CPartySearchClientParty::CopyFrom(const CPartySearchClientParty& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CPartySearchClientParty)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CPartySearchClientParty::IsInitialized() const {
  return true;
}

void CPartySearchClientParty::InternalSwap(CPartySearchClientParty* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.party_members_.InternalSwap(&other->_impl_.party_members_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CPartySearchClientParty, _impl_.beacon_type_)
      + sizeof(CPartySearchClientParty::_impl_.beacon_type_)
      - PROTOBUF_FIELD_OFFSET(CPartySearchClientParty, _impl_.party_id_)>(
          reinterpret_cast<char*>(&_impl_.party_id_),
          reinterpret_cast<char*>(&other->_impl_.party_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CPartySearchClientParty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[16]);
}

// ===================================================================

class CMsgDOTAHasItemQuery::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAHasItemQuery>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTAHasItemQuery::CMsgDOTAHasItemQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAHasItemQuery)
}
CMsgDOTAHasItemQuery::CMsgDOTAHasItemQuery(const CMsgDOTAHasItemQuery& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAHasItemQuery* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.account_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.item_id_, &from._impl_.item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.account_id_) -
    reinterpret_cast<char*>(&_impl_.item_id_)) + sizeof(_impl_.account_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAHasItemQuery)
}

inline void CMsgDOTAHasItemQuery::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_id_){uint64_t{0u}}
    , decltype(_impl_.account_id_){0u}
  };
}

CMsgDOTAHasItemQuery::~CMsgDOTAHasItemQuery() {
  // @@protoc_insertion_point(destructor:CMsgDOTAHasItemQuery)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAHasItemQuery::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAHasItemQuery::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAHasItemQuery::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAHasItemQuery)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.account_id_) -
        reinterpret_cast<char*>(&_impl_.item_id_)) + sizeof(_impl_.account_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAHasItemQuery::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAHasItemQuery::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAHasItemQuery)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint64 item_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAHasItemQuery)
  return target;
}

size_t CMsgDOTAHasItemQuery::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAHasItemQuery)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 item_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAHasItemQuery::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAHasItemQuery::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAHasItemQuery::GetClassData() const { return &_class_data_; }


void CMsgDOTAHasItemQuery::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAHasItemQuery*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAHasItemQuery&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAHasItemQuery)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAHasItemQuery::CopyFrom(const CMsgDOTAHasItemQuery& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAHasItemQuery)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAHasItemQuery::IsInitialized() const {
  return true;
}

void CMsgDOTAHasItemQuery::InternalSwap(CMsgDOTAHasItemQuery* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAHasItemQuery, _impl_.account_id_)
      + sizeof(CMsgDOTAHasItemQuery::_impl_.account_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAHasItemQuery, _impl_.item_id_)>(
          reinterpret_cast<char*>(&_impl_.item_id_),
          reinterpret_cast<char*>(&other->_impl_.item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAHasItemQuery::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[17]);
}

// ===================================================================

class CMsgDOTAHasItemResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAHasItemResponse>()._impl_._has_bits_);
  static void set_has_has_item(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTAHasItemResponse::CMsgDOTAHasItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAHasItemResponse)
}
CMsgDOTAHasItemResponse::CMsgDOTAHasItemResponse(const CMsgDOTAHasItemResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAHasItemResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.has_item_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.has_item_ = from._impl_.has_item_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAHasItemResponse)
}

inline void CMsgDOTAHasItemResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.has_item_){false}
  };
}

CMsgDOTAHasItemResponse::~CMsgDOTAHasItemResponse() {
  // @@protoc_insertion_point(destructor:CMsgDOTAHasItemResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAHasItemResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAHasItemResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAHasItemResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAHasItemResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.has_item_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAHasItemResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool has_item = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_has_item(&has_bits);
          _impl_.has_item_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAHasItemResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAHasItemResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool has_item = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_has_item(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAHasItemResponse)
  return target;
}

size_t CMsgDOTAHasItemResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAHasItemResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool has_item = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAHasItemResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAHasItemResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAHasItemResponse::GetClassData() const { return &_class_data_; }


void CMsgDOTAHasItemResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAHasItemResponse*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAHasItemResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAHasItemResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_has_item()) {
    _this->_internal_set_has_item(from._internal_has_item());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAHasItemResponse::CopyFrom(const CMsgDOTAHasItemResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAHasItemResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAHasItemResponse::IsInitialized() const {
  return true;
}

void CMsgDOTAHasItemResponse::InternalSwap(CMsgDOTAHasItemResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.has_item_, other->_impl_.has_item_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAHasItemResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[18]);
}

// ===================================================================

class CMsgGCGetPlayerCardItemInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCGetPlayerCardItemInfo>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_all_for_event(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCGetPlayerCardItemInfo::CMsgGCGetPlayerCardItemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGetPlayerCardItemInfo)
}
CMsgGCGetPlayerCardItemInfo::CMsgGCGetPlayerCardItemInfo(const CMsgGCGetPlayerCardItemInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCGetPlayerCardItemInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_card_item_ids_){from._impl_.player_card_item_ids_}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.all_for_event_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.all_for_event_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.all_for_event_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCGetPlayerCardItemInfo)
}

inline void CMsgGCGetPlayerCardItemInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_card_item_ids_){arena}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.all_for_event_){0u}
  };
}

CMsgGCGetPlayerCardItemInfo::~CMsgGCGetPlayerCardItemInfo() {
  // @@protoc_insertion_point(destructor:CMsgGCGetPlayerCardItemInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGetPlayerCardItemInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.player_card_item_ids_.~RepeatedField();
}

void CMsgGCGetPlayerCardItemInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGetPlayerCardItemInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGetPlayerCardItemInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_card_item_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.all_for_event_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.all_for_event_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCGetPlayerCardItemInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 player_card_item_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_player_card_item_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_player_card_item_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 all_for_event = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_all_for_event(&has_bits);
          _impl_.all_for_event_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGetPlayerCardItemInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGetPlayerCardItemInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // repeated uint64 player_card_item_ids = 2;
  for (int i = 0, n = this->_internal_player_card_item_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_player_card_item_ids(i), target);
  }

  // optional uint32 all_for_event = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_all_for_event(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGetPlayerCardItemInfo)
  return target;
}

size_t CMsgGCGetPlayerCardItemInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGetPlayerCardItemInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 player_card_item_ids = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.player_card_item_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_player_card_item_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 all_for_event = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_all_for_event());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCGetPlayerCardItemInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCGetPlayerCardItemInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCGetPlayerCardItemInfo::GetClassData() const { return &_class_data_; }


void CMsgGCGetPlayerCardItemInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCGetPlayerCardItemInfo*>(&to_msg);
  auto& from = static_cast<const CMsgGCGetPlayerCardItemInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGetPlayerCardItemInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.player_card_item_ids_.MergeFrom(from._impl_.player_card_item_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.all_for_event_ = from._impl_.all_for_event_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCGetPlayerCardItemInfo::CopyFrom(const CMsgGCGetPlayerCardItemInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGetPlayerCardItemInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGetPlayerCardItemInfo::IsInitialized() const {
  return true;
}

void CMsgGCGetPlayerCardItemInfo::InternalSwap(CMsgGCGetPlayerCardItemInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.player_card_item_ids_.InternalSwap(&other->_impl_.player_card_item_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCGetPlayerCardItemInfo, _impl_.all_for_event_)
      + sizeof(CMsgGCGetPlayerCardItemInfo::_impl_.all_for_event_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCGetPlayerCardItemInfo, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCGetPlayerCardItemInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[19]);
}

// ===================================================================

class CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo>()._impl_._has_bits_);
  static void set_has_player_card_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_packed_bonuses(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo)
}
CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo(const CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_card_item_id_){}
    , decltype(_impl_.packed_bonuses_){}
    , decltype(_impl_.account_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.player_card_item_id_, &from._impl_.player_card_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.account_id_) -
    reinterpret_cast<char*>(&_impl_.player_card_item_id_)) + sizeof(_impl_.account_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo)
}

inline void CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_card_item_id_){uint64_t{0u}}
    , decltype(_impl_.packed_bonuses_){uint64_t{0u}}
    , decltype(_impl_.account_id_){0u}
  };
}

CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::~CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo() {
  // @@protoc_insertion_point(destructor:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.player_card_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.account_id_) -
        reinterpret_cast<char*>(&_impl_.player_card_item_id_)) + sizeof(_impl_.account_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 player_card_item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_card_item_id(&has_bits);
          _impl_.player_card_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 packed_bonuses = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_packed_bonuses(&has_bits);
          _impl_.packed_bonuses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 player_card_item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_player_card_item_id(), target);
  }

  // optional uint32 account_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_account_id(), target);
  }

  // optional uint64 packed_bonuses = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_packed_bonuses(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo)
  return target;
}

size_t CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 player_card_item_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_player_card_item_id());
    }

    // optional uint64 packed_bonuses = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_packed_bonuses());
    }

    // optional uint32 account_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::GetClassData() const { return &_class_data_; }


void CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo*>(&to_msg);
  auto& from = static_cast<const CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.player_card_item_id_ = from._impl_.player_card_item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.packed_bonuses_ = from._impl_.packed_bonuses_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::CopyFrom(const CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::IsInitialized() const {
  return true;
}

void CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::InternalSwap(CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo, _impl_.account_id_)
      + sizeof(CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::_impl_.account_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo, _impl_.player_card_item_id_)>(
          reinterpret_cast<char*>(&_impl_.player_card_item_id_),
          reinterpret_cast<char*>(&other->_impl_.player_card_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[20]);
}

// ===================================================================

class CMsgGCGetPlayerCardItemInfoResponse::_Internal {
 public:
};

CMsgGCGetPlayerCardItemInfoResponse::CMsgGCGetPlayerCardItemInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCGetPlayerCardItemInfoResponse)
}
CMsgGCGetPlayerCardItemInfoResponse::CMsgGCGetPlayerCardItemInfoResponse(const CMsgGCGetPlayerCardItemInfoResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCGetPlayerCardItemInfoResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.player_card_infos_){from._impl_.player_card_infos_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCGetPlayerCardItemInfoResponse)
}

inline void CMsgGCGetPlayerCardItemInfoResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.player_card_infos_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGCGetPlayerCardItemInfoResponse::~CMsgGCGetPlayerCardItemInfoResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCGetPlayerCardItemInfoResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCGetPlayerCardItemInfoResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.player_card_infos_.~RepeatedPtrField();
}

void CMsgGCGetPlayerCardItemInfoResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCGetPlayerCardItemInfoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCGetPlayerCardItemInfoResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_card_infos_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCGetPlayerCardItemInfoResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo player_card_infos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_player_card_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCGetPlayerCardItemInfoResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCGetPlayerCardItemInfoResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo player_card_infos = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_player_card_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_player_card_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCGetPlayerCardItemInfoResponse)
  return target;
}

size_t CMsgGCGetPlayerCardItemInfoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCGetPlayerCardItemInfoResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGCGetPlayerCardItemInfoResponse.PlayerCardInfo player_card_infos = 1;
  total_size += 1UL * this->_internal_player_card_infos_size();
  for (const auto& msg : this->_impl_.player_card_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCGetPlayerCardItemInfoResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCGetPlayerCardItemInfoResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCGetPlayerCardItemInfoResponse::GetClassData() const { return &_class_data_; }


void CMsgGCGetPlayerCardItemInfoResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCGetPlayerCardItemInfoResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCGetPlayerCardItemInfoResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCGetPlayerCardItemInfoResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.player_card_infos_.MergeFrom(from._impl_.player_card_infos_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCGetPlayerCardItemInfoResponse::CopyFrom(const CMsgGCGetPlayerCardItemInfoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCGetPlayerCardItemInfoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCGetPlayerCardItemInfoResponse::IsInitialized() const {
  return true;
}

void CMsgGCGetPlayerCardItemInfoResponse::InternalSwap(CMsgGCGetPlayerCardItemInfoResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.player_card_infos_.InternalSwap(&other->_impl_.player_card_infos_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCGetPlayerCardItemInfoResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[21]);
}

// ===================================================================

class CSODOTAMapLocationState::_Internal {
 public:
  using HasBits = decltype(std::declval<CSODOTAMapLocationState>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_location_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_completed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSODOTAMapLocationState::CSODOTAMapLocationState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSODOTAMapLocationState)
}
CSODOTAMapLocationState::CSODOTAMapLocationState(const CSODOTAMapLocationState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSODOTAMapLocationState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.location_id_){}
    , decltype(_impl_.completed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.completed_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.completed_));
  // @@protoc_insertion_point(copy_constructor:CSODOTAMapLocationState)
}

inline void CSODOTAMapLocationState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.location_id_){0}
    , decltype(_impl_.completed_){false}
  };
}

CSODOTAMapLocationState::~CSODOTAMapLocationState() {
  // @@protoc_insertion_point(destructor:CSODOTAMapLocationState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSODOTAMapLocationState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSODOTAMapLocationState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSODOTAMapLocationState::Clear() {
// @@protoc_insertion_point(message_clear_start:CSODOTAMapLocationState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.completed_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.completed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSODOTAMapLocationState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1 [(.key_field) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 location_id = 2 [(.key_field) = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_location_id(&has_bits);
          _impl_.location_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool completed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_completed(&has_bits);
          _impl_.completed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSODOTAMapLocationState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSODOTAMapLocationState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1 [(.key_field) = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional int32 location_id = 2 [(.key_field) = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_location_id(), target);
  }

  // optional bool completed = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_completed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSODOTAMapLocationState)
  return target;
}

size_t CSODOTAMapLocationState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSODOTAMapLocationState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 account_id = 1 [(.key_field) = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional int32 location_id = 2 [(.key_field) = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_location_id());
    }

    // optional bool completed = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSODOTAMapLocationState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSODOTAMapLocationState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSODOTAMapLocationState::GetClassData() const { return &_class_data_; }


void CSODOTAMapLocationState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSODOTAMapLocationState*>(&to_msg);
  auto& from = static_cast<const CSODOTAMapLocationState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSODOTAMapLocationState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.location_id_ = from._impl_.location_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.completed_ = from._impl_.completed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSODOTAMapLocationState::CopyFrom(const CSODOTAMapLocationState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSODOTAMapLocationState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSODOTAMapLocationState::IsInitialized() const {
  return true;
}

void CSODOTAMapLocationState::InternalSwap(CSODOTAMapLocationState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSODOTAMapLocationState, _impl_.completed_)
      + sizeof(CSODOTAMapLocationState::_impl_.completed_)
      - PROTOBUF_FIELD_OFFSET(CSODOTAMapLocationState, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSODOTAMapLocationState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[22]);
}

// ===================================================================

class CMsgLeagueAdminList::_Internal {
 public:
};

CMsgLeagueAdminList::CMsgLeagueAdminList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgLeagueAdminList)
}
CMsgLeagueAdminList::CMsgLeagueAdminList(const CMsgLeagueAdminList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgLeagueAdminList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_ids_){from._impl_.account_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgLeagueAdminList)
}

inline void CMsgLeagueAdminList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.account_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgLeagueAdminList::~CMsgLeagueAdminList() {
  // @@protoc_insertion_point(destructor:CMsgLeagueAdminList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgLeagueAdminList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_ids_.~RepeatedField();
}

void CMsgLeagueAdminList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgLeagueAdminList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgLeagueAdminList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_ids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgLeagueAdminList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 account_ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_account_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_account_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgLeagueAdminList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgLeagueAdminList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 account_ids = 1;
  for (int i = 0, n = this->_internal_account_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgLeagueAdminList)
  return target;
}

size_t CMsgLeagueAdminList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgLeagueAdminList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 account_ids = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.account_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_account_ids_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgLeagueAdminList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgLeagueAdminList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgLeagueAdminList::GetClassData() const { return &_class_data_; }


void CMsgLeagueAdminList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgLeagueAdminList*>(&to_msg);
  auto& from = static_cast<const CMsgLeagueAdminList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgLeagueAdminList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.account_ids_.MergeFrom(from._impl_.account_ids_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgLeagueAdminList::CopyFrom(const CMsgLeagueAdminList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgLeagueAdminList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgLeagueAdminList::IsInitialized() const {
  return true;
}

void CMsgLeagueAdminList::InternalSwap(CMsgLeagueAdminList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.account_ids_.InternalSwap(&other->_impl_.account_ids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgLeagueAdminList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[23]);
}

// ===================================================================

class CMsgDOTAProfileCard_Slot_Trophy::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAProfileCard_Slot_Trophy>()._impl_._has_bits_);
  static void set_has_trophy_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_trophy_score(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTAProfileCard_Slot_Trophy::CMsgDOTAProfileCard_Slot_Trophy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAProfileCard.Slot.Trophy)
}
CMsgDOTAProfileCard_Slot_Trophy::CMsgDOTAProfileCard_Slot_Trophy(const CMsgDOTAProfileCard_Slot_Trophy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAProfileCard_Slot_Trophy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trophy_id_){}
    , decltype(_impl_.trophy_score_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.trophy_id_, &from._impl_.trophy_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.trophy_score_) -
    reinterpret_cast<char*>(&_impl_.trophy_id_)) + sizeof(_impl_.trophy_score_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAProfileCard.Slot.Trophy)
}

inline void CMsgDOTAProfileCard_Slot_Trophy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trophy_id_){0u}
    , decltype(_impl_.trophy_score_){0u}
  };
}

CMsgDOTAProfileCard_Slot_Trophy::~CMsgDOTAProfileCard_Slot_Trophy() {
  // @@protoc_insertion_point(destructor:CMsgDOTAProfileCard.Slot.Trophy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAProfileCard_Slot_Trophy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAProfileCard_Slot_Trophy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAProfileCard_Slot_Trophy::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAProfileCard.Slot.Trophy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.trophy_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.trophy_score_) -
        reinterpret_cast<char*>(&_impl_.trophy_id_)) + sizeof(_impl_.trophy_score_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAProfileCard_Slot_Trophy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 trophy_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_trophy_id(&has_bits);
          _impl_.trophy_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 trophy_score = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_trophy_score(&has_bits);
          _impl_.trophy_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAProfileCard_Slot_Trophy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAProfileCard.Slot.Trophy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 trophy_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_trophy_id(), target);
  }

  // optional uint32 trophy_score = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_trophy_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAProfileCard.Slot.Trophy)
  return target;
}

size_t CMsgDOTAProfileCard_Slot_Trophy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAProfileCard.Slot.Trophy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 trophy_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_trophy_id());
    }

    // optional uint32 trophy_score = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_trophy_score());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAProfileCard_Slot_Trophy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAProfileCard_Slot_Trophy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAProfileCard_Slot_Trophy::GetClassData() const { return &_class_data_; }


void CMsgDOTAProfileCard_Slot_Trophy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAProfileCard_Slot_Trophy*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAProfileCard_Slot_Trophy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAProfileCard.Slot.Trophy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.trophy_id_ = from._impl_.trophy_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.trophy_score_ = from._impl_.trophy_score_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAProfileCard_Slot_Trophy::CopyFrom(const CMsgDOTAProfileCard_Slot_Trophy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAProfileCard.Slot.Trophy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAProfileCard_Slot_Trophy::IsInitialized() const {
  return true;
}

void CMsgDOTAProfileCard_Slot_Trophy::InternalSwap(CMsgDOTAProfileCard_Slot_Trophy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAProfileCard_Slot_Trophy, _impl_.trophy_score_)
      + sizeof(CMsgDOTAProfileCard_Slot_Trophy::_impl_.trophy_score_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAProfileCard_Slot_Trophy, _impl_.trophy_id_)>(
          reinterpret_cast<char*>(&_impl_.trophy_id_),
          reinterpret_cast<char*>(&other->_impl_.trophy_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAProfileCard_Slot_Trophy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[24]);
}

// ===================================================================

class CMsgDOTAProfileCard_Slot_Stat::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAProfileCard_Slot_Stat>()._impl_._has_bits_);
  static void set_has_stat_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stat_score(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTAProfileCard_Slot_Stat::CMsgDOTAProfileCard_Slot_Stat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAProfileCard.Slot.Stat)
}
CMsgDOTAProfileCard_Slot_Stat::CMsgDOTAProfileCard_Slot_Stat(const CMsgDOTAProfileCard_Slot_Stat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAProfileCard_Slot_Stat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stat_score_){}
    , decltype(_impl_.stat_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.stat_score_, &from._impl_.stat_score_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stat_id_) -
    reinterpret_cast<char*>(&_impl_.stat_score_)) + sizeof(_impl_.stat_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAProfileCard.Slot.Stat)
}

inline void CMsgDOTAProfileCard_Slot_Stat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stat_score_){0u}
    , decltype(_impl_.stat_id_){3}
  };
}

CMsgDOTAProfileCard_Slot_Stat::~CMsgDOTAProfileCard_Slot_Stat() {
  // @@protoc_insertion_point(destructor:CMsgDOTAProfileCard.Slot.Stat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAProfileCard_Slot_Stat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAProfileCard_Slot_Stat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAProfileCard_Slot_Stat::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAProfileCard.Slot.Stat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.stat_score_ = 0u;
    _impl_.stat_id_ = 3;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAProfileCard_Slot_Stat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgDOTAProfileCard.EStatID stat_id = 1 [default = k_eStat_Wins];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgDOTAProfileCard_EStatID_IsValid(val))) {
            _internal_set_stat_id(static_cast<::CMsgDOTAProfileCard_EStatID>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stat_score = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_stat_score(&has_bits);
          _impl_.stat_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAProfileCard_Slot_Stat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAProfileCard.Slot.Stat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgDOTAProfileCard.EStatID stat_id = 1 [default = k_eStat_Wins];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_stat_id(), target);
  }

  // optional uint32 stat_score = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_stat_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAProfileCard.Slot.Stat)
  return target;
}

size_t CMsgDOTAProfileCard_Slot_Stat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAProfileCard.Slot.Stat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 stat_score = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stat_score());
    }

    // optional .CMsgDOTAProfileCard.EStatID stat_id = 1 [default = k_eStat_Wins];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_stat_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAProfileCard_Slot_Stat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAProfileCard_Slot_Stat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAProfileCard_Slot_Stat::GetClassData() const { return &_class_data_; }


void CMsgDOTAProfileCard_Slot_Stat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAProfileCard_Slot_Stat*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAProfileCard_Slot_Stat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAProfileCard.Slot.Stat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.stat_score_ = from._impl_.stat_score_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.stat_id_ = from._impl_.stat_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAProfileCard_Slot_Stat::CopyFrom(const CMsgDOTAProfileCard_Slot_Stat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAProfileCard.Slot.Stat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAProfileCard_Slot_Stat::IsInitialized() const {
  return true;
}

void CMsgDOTAProfileCard_Slot_Stat::InternalSwap(CMsgDOTAProfileCard_Slot_Stat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.stat_score_, other->_impl_.stat_score_);
  swap(_impl_.stat_id_, other->_impl_.stat_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAProfileCard_Slot_Stat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[25]);
}

// ===================================================================

class CMsgDOTAProfileCard_Slot_Item::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAProfileCard_Slot_Item>()._impl_._has_bits_);
  static void set_has_serialized_item(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTAProfileCard_Slot_Item::CMsgDOTAProfileCard_Slot_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAProfileCard.Slot.Item)
}
CMsgDOTAProfileCard_Slot_Item::CMsgDOTAProfileCard_Slot_Item(const CMsgDOTAProfileCard_Slot_Item& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAProfileCard_Slot_Item* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.serialized_item_){}
    , decltype(_impl_.item_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.serialized_item_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_item_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialized_item()) {
    _this->_impl_.serialized_item_.Set(from._internal_serialized_item(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.item_id_ = from._impl_.item_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAProfileCard.Slot.Item)
}

inline void CMsgDOTAProfileCard_Slot_Item::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.serialized_item_){}
    , decltype(_impl_.item_id_){uint64_t{0u}}
  };
  _impl_.serialized_item_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_item_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTAProfileCard_Slot_Item::~CMsgDOTAProfileCard_Slot_Item() {
  // @@protoc_insertion_point(destructor:CMsgDOTAProfileCard.Slot.Item)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAProfileCard_Slot_Item::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.serialized_item_.Destroy();
}

void CMsgDOTAProfileCard_Slot_Item::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAProfileCard_Slot_Item::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAProfileCard.Slot.Item)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.serialized_item_.ClearNonDefaultToEmpty();
  }
  _impl_.item_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAProfileCard_Slot_Item::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes serialized_item = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_serialized_item();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAProfileCard_Slot_Item::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAProfileCard.Slot.Item)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes serialized_item = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_serialized_item(), target);
  }

  // optional uint64 item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAProfileCard.Slot.Item)
  return target;
}

size_t CMsgDOTAProfileCard_Slot_Item::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAProfileCard.Slot.Item)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes serialized_item = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serialized_item());
    }

    // optional uint64 item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAProfileCard_Slot_Item::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAProfileCard_Slot_Item::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAProfileCard_Slot_Item::GetClassData() const { return &_class_data_; }


void CMsgDOTAProfileCard_Slot_Item::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAProfileCard_Slot_Item*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAProfileCard_Slot_Item&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAProfileCard.Slot.Item)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_serialized_item(from._internal_serialized_item());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAProfileCard_Slot_Item::CopyFrom(const CMsgDOTAProfileCard_Slot_Item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAProfileCard.Slot.Item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAProfileCard_Slot_Item::IsInitialized() const {
  return true;
}

void CMsgDOTAProfileCard_Slot_Item::InternalSwap(CMsgDOTAProfileCard_Slot_Item* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serialized_item_, lhs_arena,
      &other->_impl_.serialized_item_, rhs_arena
  );
  swap(_impl_.item_id_, other->_impl_.item_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAProfileCard_Slot_Item::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[26]);
}

// ===================================================================

class CMsgDOTAProfileCard_Slot_Hero::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAProfileCard_Slot_Hero>()._impl_._has_bits_);
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hero_wins(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hero_losses(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDOTAProfileCard_Slot_Hero::CMsgDOTAProfileCard_Slot_Hero(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAProfileCard.Slot.Hero)
}
CMsgDOTAProfileCard_Slot_Hero::CMsgDOTAProfileCard_Slot_Hero(const CMsgDOTAProfileCard_Slot_Hero& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAProfileCard_Slot_Hero* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.hero_wins_){}
    , decltype(_impl_.hero_losses_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hero_id_, &from._impl_.hero_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hero_losses_) -
    reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.hero_losses_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAProfileCard.Slot.Hero)
}

inline void CMsgDOTAProfileCard_Slot_Hero::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.hero_wins_){0u}
    , decltype(_impl_.hero_losses_){0u}
  };
}

CMsgDOTAProfileCard_Slot_Hero::~CMsgDOTAProfileCard_Slot_Hero() {
  // @@protoc_insertion_point(destructor:CMsgDOTAProfileCard.Slot.Hero)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAProfileCard_Slot_Hero::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAProfileCard_Slot_Hero::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAProfileCard_Slot_Hero::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAProfileCard.Slot.Hero)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.hero_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hero_losses_) -
        reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.hero_losses_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAProfileCard_Slot_Hero::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 hero_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_wins = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hero_wins(&has_bits);
          _impl_.hero_wins_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_losses = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hero_losses(&has_bits);
          _impl_.hero_losses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAProfileCard_Slot_Hero::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAProfileCard.Slot.Hero)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 hero_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hero_id(), target);
  }

  // optional uint32 hero_wins = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hero_wins(), target);
  }

  // optional uint32 hero_losses = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hero_losses(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAProfileCard.Slot.Hero)
  return target;
}

size_t CMsgDOTAProfileCard_Slot_Hero::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAProfileCard.Slot.Hero)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 hero_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional uint32 hero_wins = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_wins());
    }

    // optional uint32 hero_losses = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_losses());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAProfileCard_Slot_Hero::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAProfileCard_Slot_Hero::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAProfileCard_Slot_Hero::GetClassData() const { return &_class_data_; }


void CMsgDOTAProfileCard_Slot_Hero::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAProfileCard_Slot_Hero*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAProfileCard_Slot_Hero&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAProfileCard.Slot.Hero)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hero_wins_ = from._impl_.hero_wins_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hero_losses_ = from._impl_.hero_losses_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAProfileCard_Slot_Hero::CopyFrom(const CMsgDOTAProfileCard_Slot_Hero& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAProfileCard.Slot.Hero)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAProfileCard_Slot_Hero::IsInitialized() const {
  return true;
}

void CMsgDOTAProfileCard_Slot_Hero::InternalSwap(CMsgDOTAProfileCard_Slot_Hero* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAProfileCard_Slot_Hero, _impl_.hero_losses_)
      + sizeof(CMsgDOTAProfileCard_Slot_Hero::_impl_.hero_losses_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAProfileCard_Slot_Hero, _impl_.hero_id_)>(
          reinterpret_cast<char*>(&_impl_.hero_id_),
          reinterpret_cast<char*>(&other->_impl_.hero_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAProfileCard_Slot_Hero::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[27]);
}

// ===================================================================

class CMsgDOTAProfileCard_Slot_Emoticon::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAProfileCard_Slot_Emoticon>()._impl_._has_bits_);
  static void set_has_emoticon_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTAProfileCard_Slot_Emoticon::CMsgDOTAProfileCard_Slot_Emoticon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAProfileCard.Slot.Emoticon)
}
CMsgDOTAProfileCard_Slot_Emoticon::CMsgDOTAProfileCard_Slot_Emoticon(const CMsgDOTAProfileCard_Slot_Emoticon& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAProfileCard_Slot_Emoticon* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.emoticon_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.emoticon_id_ = from._impl_.emoticon_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAProfileCard.Slot.Emoticon)
}

inline void CMsgDOTAProfileCard_Slot_Emoticon::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.emoticon_id_){0u}
  };
}

CMsgDOTAProfileCard_Slot_Emoticon::~CMsgDOTAProfileCard_Slot_Emoticon() {
  // @@protoc_insertion_point(destructor:CMsgDOTAProfileCard.Slot.Emoticon)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAProfileCard_Slot_Emoticon::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAProfileCard_Slot_Emoticon::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAProfileCard_Slot_Emoticon::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAProfileCard.Slot.Emoticon)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.emoticon_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAProfileCard_Slot_Emoticon::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 emoticon_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_emoticon_id(&has_bits);
          _impl_.emoticon_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAProfileCard_Slot_Emoticon::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAProfileCard.Slot.Emoticon)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 emoticon_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_emoticon_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAProfileCard.Slot.Emoticon)
  return target;
}

size_t CMsgDOTAProfileCard_Slot_Emoticon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAProfileCard.Slot.Emoticon)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 emoticon_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_emoticon_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAProfileCard_Slot_Emoticon::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAProfileCard_Slot_Emoticon::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAProfileCard_Slot_Emoticon::GetClassData() const { return &_class_data_; }


void CMsgDOTAProfileCard_Slot_Emoticon::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAProfileCard_Slot_Emoticon*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAProfileCard_Slot_Emoticon&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAProfileCard.Slot.Emoticon)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_emoticon_id()) {
    _this->_internal_set_emoticon_id(from._internal_emoticon_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAProfileCard_Slot_Emoticon::CopyFrom(const CMsgDOTAProfileCard_Slot_Emoticon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAProfileCard.Slot.Emoticon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAProfileCard_Slot_Emoticon::IsInitialized() const {
  return true;
}

void CMsgDOTAProfileCard_Slot_Emoticon::InternalSwap(CMsgDOTAProfileCard_Slot_Emoticon* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.emoticon_id_, other->_impl_.emoticon_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAProfileCard_Slot_Emoticon::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[28]);
}

// ===================================================================

class CMsgDOTAProfileCard_Slot_Team::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAProfileCard_Slot_Team>()._impl_._has_bits_);
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTAProfileCard_Slot_Team::CMsgDOTAProfileCard_Slot_Team(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAProfileCard.Slot.Team)
}
CMsgDOTAProfileCard_Slot_Team::CMsgDOTAProfileCard_Slot_Team(const CMsgDOTAProfileCard_Slot_Team& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAProfileCard_Slot_Team* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.team_id_ = from._impl_.team_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAProfileCard.Slot.Team)
}

inline void CMsgDOTAProfileCard_Slot_Team::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_id_){0u}
  };
}

CMsgDOTAProfileCard_Slot_Team::~CMsgDOTAProfileCard_Slot_Team() {
  // @@protoc_insertion_point(destructor:CMsgDOTAProfileCard.Slot.Team)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAProfileCard_Slot_Team::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAProfileCard_Slot_Team::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAProfileCard_Slot_Team::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAProfileCard.Slot.Team)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.team_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAProfileCard_Slot_Team::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 team_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAProfileCard_Slot_Team::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAProfileCard.Slot.Team)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 team_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_team_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAProfileCard.Slot.Team)
  return target;
}

size_t CMsgDOTAProfileCard_Slot_Team::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAProfileCard.Slot.Team)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 team_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAProfileCard_Slot_Team::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAProfileCard_Slot_Team::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAProfileCard_Slot_Team::GetClassData() const { return &_class_data_; }


void CMsgDOTAProfileCard_Slot_Team::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAProfileCard_Slot_Team*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAProfileCard_Slot_Team&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAProfileCard.Slot.Team)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_team_id()) {
    _this->_internal_set_team_id(from._internal_team_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAProfileCard_Slot_Team::CopyFrom(const CMsgDOTAProfileCard_Slot_Team& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAProfileCard.Slot.Team)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAProfileCard_Slot_Team::IsInitialized() const {
  return true;
}

void CMsgDOTAProfileCard_Slot_Team::InternalSwap(CMsgDOTAProfileCard_Slot_Team* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.team_id_, other->_impl_.team_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAProfileCard_Slot_Team::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[29]);
}

// ===================================================================

class CMsgDOTAProfileCard_Slot::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAProfileCard_Slot>()._impl_._has_bits_);
  static void set_has_slot_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::CMsgDOTAProfileCard_Slot_Trophy& trophy(const CMsgDOTAProfileCard_Slot* msg);
  static void set_has_trophy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgDOTAProfileCard_Slot_Stat& stat(const CMsgDOTAProfileCard_Slot* msg);
  static void set_has_stat(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgDOTAProfileCard_Slot_Item& item(const CMsgDOTAProfileCard_Slot* msg);
  static void set_has_item(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgDOTAProfileCard_Slot_Hero& hero(const CMsgDOTAProfileCard_Slot* msg);
  static void set_has_hero(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgDOTAProfileCard_Slot_Emoticon& emoticon(const CMsgDOTAProfileCard_Slot* msg);
  static void set_has_emoticon(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgDOTAProfileCard_Slot_Team& team(const CMsgDOTAProfileCard_Slot* msg);
  static void set_has_team(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::CMsgDOTAProfileCard_Slot_Trophy&
CMsgDOTAProfileCard_Slot::_Internal::trophy(const CMsgDOTAProfileCard_Slot* msg) {
  return *msg->_impl_.trophy_;
}
const ::CMsgDOTAProfileCard_Slot_Stat&
CMsgDOTAProfileCard_Slot::_Internal::stat(const CMsgDOTAProfileCard_Slot* msg) {
  return *msg->_impl_.stat_;
}
const ::CMsgDOTAProfileCard_Slot_Item&
CMsgDOTAProfileCard_Slot::_Internal::item(const CMsgDOTAProfileCard_Slot* msg) {
  return *msg->_impl_.item_;
}
const ::CMsgDOTAProfileCard_Slot_Hero&
CMsgDOTAProfileCard_Slot::_Internal::hero(const CMsgDOTAProfileCard_Slot* msg) {
  return *msg->_impl_.hero_;
}
const ::CMsgDOTAProfileCard_Slot_Emoticon&
CMsgDOTAProfileCard_Slot::_Internal::emoticon(const CMsgDOTAProfileCard_Slot* msg) {
  return *msg->_impl_.emoticon_;
}
const ::CMsgDOTAProfileCard_Slot_Team&
CMsgDOTAProfileCard_Slot::_Internal::team(const CMsgDOTAProfileCard_Slot* msg) {
  return *msg->_impl_.team_;
}
CMsgDOTAProfileCard_Slot::CMsgDOTAProfileCard_Slot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAProfileCard.Slot)
}
CMsgDOTAProfileCard_Slot::CMsgDOTAProfileCard_Slot(const CMsgDOTAProfileCard_Slot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAProfileCard_Slot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trophy_){nullptr}
    , decltype(_impl_.stat_){nullptr}
    , decltype(_impl_.item_){nullptr}
    , decltype(_impl_.hero_){nullptr}
    , decltype(_impl_.emoticon_){nullptr}
    , decltype(_impl_.team_){nullptr}
    , decltype(_impl_.slot_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_trophy()) {
    _this->_impl_.trophy_ = new ::CMsgDOTAProfileCard_Slot_Trophy(*from._impl_.trophy_);
  }
  if (from._internal_has_stat()) {
    _this->_impl_.stat_ = new ::CMsgDOTAProfileCard_Slot_Stat(*from._impl_.stat_);
  }
  if (from._internal_has_item()) {
    _this->_impl_.item_ = new ::CMsgDOTAProfileCard_Slot_Item(*from._impl_.item_);
  }
  if (from._internal_has_hero()) {
    _this->_impl_.hero_ = new ::CMsgDOTAProfileCard_Slot_Hero(*from._impl_.hero_);
  }
  if (from._internal_has_emoticon()) {
    _this->_impl_.emoticon_ = new ::CMsgDOTAProfileCard_Slot_Emoticon(*from._impl_.emoticon_);
  }
  if (from._internal_has_team()) {
    _this->_impl_.team_ = new ::CMsgDOTAProfileCard_Slot_Team(*from._impl_.team_);
  }
  _this->_impl_.slot_id_ = from._impl_.slot_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAProfileCard.Slot)
}

inline void CMsgDOTAProfileCard_Slot::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trophy_){nullptr}
    , decltype(_impl_.stat_){nullptr}
    , decltype(_impl_.item_){nullptr}
    , decltype(_impl_.hero_){nullptr}
    , decltype(_impl_.emoticon_){nullptr}
    , decltype(_impl_.team_){nullptr}
    , decltype(_impl_.slot_id_){0u}
  };
}

CMsgDOTAProfileCard_Slot::~CMsgDOTAProfileCard_Slot() {
  // @@protoc_insertion_point(destructor:CMsgDOTAProfileCard.Slot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAProfileCard_Slot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.trophy_;
  if (this != internal_default_instance()) delete _impl_.stat_;
  if (this != internal_default_instance()) delete _impl_.item_;
  if (this != internal_default_instance()) delete _impl_.hero_;
  if (this != internal_default_instance()) delete _impl_.emoticon_;
  if (this != internal_default_instance()) delete _impl_.team_;
}

void CMsgDOTAProfileCard_Slot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAProfileCard_Slot::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAProfileCard.Slot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.trophy_ != nullptr);
      _impl_.trophy_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.stat_ != nullptr);
      _impl_.stat_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.item_ != nullptr);
      _impl_.item_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.hero_ != nullptr);
      _impl_.hero_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.emoticon_ != nullptr);
      _impl_.emoticon_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.team_ != nullptr);
      _impl_.team_->Clear();
    }
  }
  _impl_.slot_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAProfileCard_Slot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 slot_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_slot_id(&has_bits);
          _impl_.slot_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAProfileCard.Slot.Trophy trophy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_trophy(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAProfileCard.Slot.Stat stat = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_stat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAProfileCard.Slot.Item item = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_item(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAProfileCard.Slot.Hero hero = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_hero(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAProfileCard.Slot.Emoticon emoticon = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_emoticon(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAProfileCard.Slot.Team team = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_team(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAProfileCard_Slot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAProfileCard.Slot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 slot_id = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_slot_id(), target);
  }

  // optional .CMsgDOTAProfileCard.Slot.Trophy trophy = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::trophy(this),
        _Internal::trophy(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgDOTAProfileCard.Slot.Stat stat = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::stat(this),
        _Internal::stat(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgDOTAProfileCard.Slot.Item item = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::item(this),
        _Internal::item(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgDOTAProfileCard.Slot.Hero hero = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::hero(this),
        _Internal::hero(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgDOTAProfileCard.Slot.Emoticon emoticon = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::emoticon(this),
        _Internal::emoticon(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgDOTAProfileCard.Slot.Team team = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::team(this),
        _Internal::team(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAProfileCard.Slot)
  return target;
}

size_t CMsgDOTAProfileCard_Slot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAProfileCard.Slot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .CMsgDOTAProfileCard.Slot.Trophy trophy = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trophy_);
    }

    // optional .CMsgDOTAProfileCard.Slot.Stat stat = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stat_);
    }

    // optional .CMsgDOTAProfileCard.Slot.Item item = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.item_);
    }

    // optional .CMsgDOTAProfileCard.Slot.Hero hero = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hero_);
    }

    // optional .CMsgDOTAProfileCard.Slot.Emoticon emoticon = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.emoticon_);
    }

    // optional .CMsgDOTAProfileCard.Slot.Team team = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.team_);
    }

    // optional uint32 slot_id = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_slot_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAProfileCard_Slot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAProfileCard_Slot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAProfileCard_Slot::GetClassData() const { return &_class_data_; }


void CMsgDOTAProfileCard_Slot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAProfileCard_Slot*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAProfileCard_Slot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAProfileCard.Slot)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_trophy()->::CMsgDOTAProfileCard_Slot_Trophy::MergeFrom(
          from._internal_trophy());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_stat()->::CMsgDOTAProfileCard_Slot_Stat::MergeFrom(
          from._internal_stat());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_item()->::CMsgDOTAProfileCard_Slot_Item::MergeFrom(
          from._internal_item());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_hero()->::CMsgDOTAProfileCard_Slot_Hero::MergeFrom(
          from._internal_hero());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_emoticon()->::CMsgDOTAProfileCard_Slot_Emoticon::MergeFrom(
          from._internal_emoticon());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_team()->::CMsgDOTAProfileCard_Slot_Team::MergeFrom(
          from._internal_team());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.slot_id_ = from._impl_.slot_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAProfileCard_Slot::CopyFrom(const CMsgDOTAProfileCard_Slot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAProfileCard.Slot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAProfileCard_Slot::IsInitialized() const {
  return true;
}

void CMsgDOTAProfileCard_Slot::InternalSwap(CMsgDOTAProfileCard_Slot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAProfileCard_Slot, _impl_.slot_id_)
      + sizeof(CMsgDOTAProfileCard_Slot::_impl_.slot_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAProfileCard_Slot, _impl_.trophy_)>(
          reinterpret_cast<char*>(&_impl_.trophy_),
          reinterpret_cast<char*>(&other->_impl_.trophy_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAProfileCard_Slot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[30]);
}

// ===================================================================

class CMsgDOTAProfileCard::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAProfileCard>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_badge_points(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_event_points(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgBattleCupVictory& recent_battle_cup_victory(const CMsgDOTAProfileCard* msg);
  static void set_has_recent_battle_cup_victory(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rank_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_leaderboard_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_plus_subscriber(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_plus_original_start_date(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_rank_tier_score(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_leaderboard_rank_core(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_favorite_team_packed(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_lifetime_games(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

const ::CMsgBattleCupVictory&
CMsgDOTAProfileCard::_Internal::recent_battle_cup_victory(const CMsgDOTAProfileCard* msg) {
  return *msg->_impl_.recent_battle_cup_victory_;
}
CMsgDOTAProfileCard::CMsgDOTAProfileCard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAProfileCard)
}
CMsgDOTAProfileCard::CMsgDOTAProfileCard(const CMsgDOTAProfileCard& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAProfileCard* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slots_){from._impl_.slots_}
    , decltype(_impl_.recent_battle_cup_victory_){nullptr}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.badge_points_){}
    , decltype(_impl_.event_points_){}
    , decltype(_impl_.event_id_){}
    , decltype(_impl_.rank_tier_){}
    , decltype(_impl_.leaderboard_rank_){}
    , decltype(_impl_.is_plus_subscriber_){}
    , decltype(_impl_.plus_original_start_date_){}
    , decltype(_impl_.rank_tier_score_){}
    , decltype(_impl_.leaderboard_rank_core_){}
    , decltype(_impl_.favorite_team_packed_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.lifetime_games_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_recent_battle_cup_victory()) {
    _this->_impl_.recent_battle_cup_victory_ = new ::CMsgBattleCupVictory(*from._impl_.recent_battle_cup_victory_);
  }
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lifetime_games_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.lifetime_games_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAProfileCard)
}

inline void CMsgDOTAProfileCard::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slots_){arena}
    , decltype(_impl_.recent_battle_cup_victory_){nullptr}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.badge_points_){0u}
    , decltype(_impl_.event_points_){0u}
    , decltype(_impl_.event_id_){0u}
    , decltype(_impl_.rank_tier_){0u}
    , decltype(_impl_.leaderboard_rank_){0u}
    , decltype(_impl_.is_plus_subscriber_){false}
    , decltype(_impl_.plus_original_start_date_){0u}
    , decltype(_impl_.rank_tier_score_){0u}
    , decltype(_impl_.leaderboard_rank_core_){0u}
    , decltype(_impl_.favorite_team_packed_){uint64_t{0u}}
    , decltype(_impl_.title_){0u}
    , decltype(_impl_.lifetime_games_){0u}
  };
}

CMsgDOTAProfileCard::~CMsgDOTAProfileCard() {
  // @@protoc_insertion_point(destructor:CMsgDOTAProfileCard)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAProfileCard::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.slots_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.recent_battle_cup_victory_;
}

void CMsgDOTAProfileCard::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAProfileCard::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAProfileCard)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.slots_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.recent_battle_cup_victory_ != nullptr);
    _impl_.recent_battle_cup_victory_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_plus_subscriber_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.is_plus_subscriber_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.plus_original_start_date_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.lifetime_games_) -
        reinterpret_cast<char*>(&_impl_.plus_original_start_date_)) + sizeof(_impl_.lifetime_games_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAProfileCard::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAProfileCard.Slot slots = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_slots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 badge_points = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_badge_points(&has_bits);
          _impl_.badge_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 event_points = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_event_points(&has_bits);
          _impl_.event_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 event_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_event_id(&has_bits);
          _impl_.event_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgBattleCupVictory recent_battle_cup_victory = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_recent_battle_cup_victory(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rank_tier = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_rank_tier(&has_bits);
          _impl_.rank_tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 leaderboard_rank = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_leaderboard_rank(&has_bits);
          _impl_.leaderboard_rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_plus_subscriber = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_is_plus_subscriber(&has_bits);
          _impl_.is_plus_subscriber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 plus_original_start_date = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_plus_original_start_date(&has_bits);
          _impl_.plus_original_start_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rank_tier_score = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_rank_tier_score(&has_bits);
          _impl_.rank_tier_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 leaderboard_rank_core = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_leaderboard_rank_core(&has_bits);
          _impl_.leaderboard_rank_core_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 title = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_title(&has_bits);
          _impl_.title_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 favorite_team_packed = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_favorite_team_packed(&has_bits);
          _impl_.favorite_team_packed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lifetime_games = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_lifetime_games(&has_bits);
          _impl_.lifetime_games_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAProfileCard::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAProfileCard)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // repeated .CMsgDOTAProfileCard.Slot slots = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_slots_size()); i < n; i++) {
    const auto& repfield = this->_internal_slots(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 badge_points = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_badge_points(), target);
  }

  // optional uint32 event_points = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_event_points(), target);
  }

  // optional uint32 event_id = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_event_id(), target);
  }

  // optional .CMsgBattleCupVictory recent_battle_cup_victory = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::recent_battle_cup_victory(this),
        _Internal::recent_battle_cup_victory(this).GetCachedSize(), target, stream);
  }

  // optional uint32 rank_tier = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_rank_tier(), target);
  }

  // optional uint32 leaderboard_rank = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_leaderboard_rank(), target);
  }

  // optional bool is_plus_subscriber = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_is_plus_subscriber(), target);
  }

  // optional uint32 plus_original_start_date = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_plus_original_start_date(), target);
  }

  // optional uint32 rank_tier_score = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_rank_tier_score(), target);
  }

  // optional uint32 leaderboard_rank_core = 17;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_leaderboard_rank_core(), target);
  }

  // optional uint32 title = 23;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_title(), target);
  }

  // optional uint64 favorite_team_packed = 24;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(24, this->_internal_favorite_team_packed(), target);
  }

  // optional uint32 lifetime_games = 25;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_lifetime_games(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAProfileCard)
  return target;
}

size_t CMsgDOTAProfileCard::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAProfileCard)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAProfileCard.Slot slots = 3;
  total_size += 1UL * this->_internal_slots_size();
  for (const auto& msg : this->_impl_.slots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgBattleCupVictory recent_battle_cup_victory = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recent_battle_cup_victory_);
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 badge_points = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_badge_points());
    }

    // optional uint32 event_points = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_event_points());
    }

    // optional uint32 event_id = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_event_id());
    }

    // optional uint32 rank_tier = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rank_tier());
    }

    // optional uint32 leaderboard_rank = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_leaderboard_rank());
    }

    // optional bool is_plus_subscriber = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional uint32 plus_original_start_date = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_plus_original_start_date());
    }

    // optional uint32 rank_tier_score = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rank_tier_score());
    }

    // optional uint32 leaderboard_rank_core = 17;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_leaderboard_rank_core());
    }

    // optional uint64 favorite_team_packed = 24;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_favorite_team_packed());
    }

    // optional uint32 title = 23;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_title());
    }

    // optional uint32 lifetime_games = 25;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_lifetime_games());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAProfileCard::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAProfileCard::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAProfileCard::GetClassData() const { return &_class_data_; }


void CMsgDOTAProfileCard::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAProfileCard*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAProfileCard&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAProfileCard)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.slots_.MergeFrom(from._impl_.slots_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_recent_battle_cup_victory()->::CMsgBattleCupVictory::MergeFrom(
          from._internal_recent_battle_cup_victory());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.badge_points_ = from._impl_.badge_points_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.event_points_ = from._impl_.event_points_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.rank_tier_ = from._impl_.rank_tier_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.leaderboard_rank_ = from._impl_.leaderboard_rank_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_plus_subscriber_ = from._impl_.is_plus_subscriber_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.plus_original_start_date_ = from._impl_.plus_original_start_date_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.rank_tier_score_ = from._impl_.rank_tier_score_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.leaderboard_rank_core_ = from._impl_.leaderboard_rank_core_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.favorite_team_packed_ = from._impl_.favorite_team_packed_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.title_ = from._impl_.title_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.lifetime_games_ = from._impl_.lifetime_games_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAProfileCard::CopyFrom(const CMsgDOTAProfileCard& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAProfileCard)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAProfileCard::IsInitialized() const {
  return true;
}

void CMsgDOTAProfileCard::InternalSwap(CMsgDOTAProfileCard* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.slots_.InternalSwap(&other->_impl_.slots_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAProfileCard, _impl_.lifetime_games_)
      + sizeof(CMsgDOTAProfileCard::_impl_.lifetime_games_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAProfileCard, _impl_.recent_battle_cup_victory_)>(
          reinterpret_cast<char*>(&_impl_.recent_battle_cup_victory_),
          reinterpret_cast<char*>(&other->_impl_.recent_battle_cup_victory_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAProfileCard::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[31]);
}

// ===================================================================

class CSODOTAPlayerChallenge::_Internal {
 public:
  using HasBits = decltype(std::declval<CSODOTAPlayerChallenge>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_slot_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_int_param_0(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_int_param_1(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_created_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_completed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_challenge_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_attempts(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_complete_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_quest_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_max_quest_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_instance_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_template_id(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
};

CSODOTAPlayerChallenge::CSODOTAPlayerChallenge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSODOTAPlayerChallenge)
}
CSODOTAPlayerChallenge::CSODOTAPlayerChallenge(const CSODOTAPlayerChallenge& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSODOTAPlayerChallenge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.event_id_){}
    , decltype(_impl_.slot_id_){}
    , decltype(_impl_.int_param_0_){}
    , decltype(_impl_.int_param_1_){}
    , decltype(_impl_.created_time_){}
    , decltype(_impl_.completed_){}
    , decltype(_impl_.sequence_id_){}
    , decltype(_impl_.challenge_tier_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.attempts_){}
    , decltype(_impl_.complete_limit_){}
    , decltype(_impl_.quest_rank_){}
    , decltype(_impl_.max_quest_rank_){}
    , decltype(_impl_.instance_id_){}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.template_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.template_id_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.template_id_));
  // @@protoc_insertion_point(copy_constructor:CSODOTAPlayerChallenge)
}

inline void CSODOTAPlayerChallenge::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.event_id_){0u}
    , decltype(_impl_.slot_id_){0u}
    , decltype(_impl_.int_param_0_){0u}
    , decltype(_impl_.int_param_1_){0u}
    , decltype(_impl_.created_time_){0u}
    , decltype(_impl_.completed_){0u}
    , decltype(_impl_.sequence_id_){0u}
    , decltype(_impl_.challenge_tier_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.attempts_){0u}
    , decltype(_impl_.complete_limit_){0u}
    , decltype(_impl_.quest_rank_){0u}
    , decltype(_impl_.max_quest_rank_){0u}
    , decltype(_impl_.instance_id_){0u}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.template_id_){0u}
  };
}

CSODOTAPlayerChallenge::~CSODOTAPlayerChallenge() {
  // @@protoc_insertion_point(destructor:CSODOTAPlayerChallenge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSODOTAPlayerChallenge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSODOTAPlayerChallenge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSODOTAPlayerChallenge::Clear() {
// @@protoc_insertion_point(message_clear_start:CSODOTAPlayerChallenge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sequence_id_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.sequence_id_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.challenge_tier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hero_id_) -
        reinterpret_cast<char*>(&_impl_.challenge_tier_)) + sizeof(_impl_.hero_id_));
  }
  _impl_.template_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSODOTAPlayerChallenge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1 [(.key_field) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 event_id = 2 [(.key_field) = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_event_id(&has_bits);
          _impl_.event_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 slot_id = 3 [(.key_field) = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_slot_id(&has_bits);
          _impl_.slot_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 int_param_0 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_int_param_0(&has_bits);
          _impl_.int_param_0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 int_param_1 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_int_param_1(&has_bits);
          _impl_.int_param_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 created_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_created_time(&has_bits);
          _impl_.created_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 completed = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_completed(&has_bits);
          _impl_.completed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sequence_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_sequence_id(&has_bits);
          _impl_.sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 challenge_tier = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_challenge_tier(&has_bits);
          _impl_.challenge_tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 attempts = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_attempts(&has_bits);
          _impl_.attempts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 complete_limit = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_complete_limit(&has_bits);
          _impl_.complete_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 quest_rank = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_quest_rank(&has_bits);
          _impl_.quest_rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_quest_rank = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_max_quest_rank(&has_bits);
          _impl_.max_quest_rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 instance_id = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_instance_id(&has_bits);
          _impl_.instance_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 template_id = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_template_id(&has_bits);
          _impl_.template_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSODOTAPlayerChallenge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSODOTAPlayerChallenge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1 [(.key_field) = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 event_id = 2 [(.key_field) = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_event_id(), target);
  }

  // optional uint32 slot_id = 3 [(.key_field) = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_slot_id(), target);
  }

  // optional uint32 int_param_0 = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_int_param_0(), target);
  }

  // optional uint32 int_param_1 = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_int_param_1(), target);
  }

  // optional uint32 created_time = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_created_time(), target);
  }

  // optional uint32 completed = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_completed(), target);
  }

  // optional uint32 sequence_id = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_sequence_id(), target);
  }

  // optional uint32 challenge_tier = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_challenge_tier(), target);
  }

  // optional uint32 flags = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_flags(), target);
  }

  // optional uint32 attempts = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_attempts(), target);
  }

  // optional uint32 complete_limit = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_complete_limit(), target);
  }

  // optional uint32 quest_rank = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_quest_rank(), target);
  }

  // optional uint32 max_quest_rank = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_max_quest_rank(), target);
  }

  // optional uint32 instance_id = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_instance_id(), target);
  }

  // optional uint32 hero_id = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_hero_id(), target);
  }

  // optional uint32 template_id = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_template_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSODOTAPlayerChallenge)
  return target;
}

size_t CSODOTAPlayerChallenge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSODOTAPlayerChallenge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 account_id = 1 [(.key_field) = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 event_id = 2 [(.key_field) = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_event_id());
    }

    // optional uint32 slot_id = 3 [(.key_field) = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_slot_id());
    }

    // optional uint32 int_param_0 = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_int_param_0());
    }

    // optional uint32 int_param_1 = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_int_param_1());
    }

    // optional uint32 created_time = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_created_time());
    }

    // optional uint32 completed = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_completed());
    }

    // optional uint32 sequence_id = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sequence_id());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 challenge_tier = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_challenge_tier());
    }

    // optional uint32 flags = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 attempts = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_attempts());
    }

    // optional uint32 complete_limit = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_complete_limit());
    }

    // optional uint32 quest_rank = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_quest_rank());
    }

    // optional uint32 max_quest_rank = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_quest_rank());
    }

    // optional uint32 instance_id = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_instance_id());
    }

    // optional uint32 hero_id = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_hero_id());
    }

  }
  // optional uint32 template_id = 18;
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_template_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSODOTAPlayerChallenge::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSODOTAPlayerChallenge::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSODOTAPlayerChallenge::GetClassData() const { return &_class_data_; }


void CSODOTAPlayerChallenge::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSODOTAPlayerChallenge*>(&to_msg);
  auto& from = static_cast<const CSODOTAPlayerChallenge&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSODOTAPlayerChallenge)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.slot_id_ = from._impl_.slot_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.int_param_0_ = from._impl_.int_param_0_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.int_param_1_ = from._impl_.int_param_1_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.created_time_ = from._impl_.created_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.completed_ = from._impl_.completed_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.sequence_id_ = from._impl_.sequence_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.challenge_tier_ = from._impl_.challenge_tier_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.attempts_ = from._impl_.attempts_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.complete_limit_ = from._impl_.complete_limit_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.quest_rank_ = from._impl_.quest_rank_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.max_quest_rank_ = from._impl_.max_quest_rank_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.instance_id_ = from._impl_.instance_id_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _this->_internal_set_template_id(from._internal_template_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSODOTAPlayerChallenge::CopyFrom(const CSODOTAPlayerChallenge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSODOTAPlayerChallenge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSODOTAPlayerChallenge::IsInitialized() const {
  return true;
}

void CSODOTAPlayerChallenge::InternalSwap(CSODOTAPlayerChallenge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSODOTAPlayerChallenge, _impl_.template_id_)
      + sizeof(CSODOTAPlayerChallenge::_impl_.template_id_)
      - PROTOBUF_FIELD_OFFSET(CSODOTAPlayerChallenge, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSODOTAPlayerChallenge::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[32]);
}

// ===================================================================

class CMsgClientToGCRerollPlayerChallenge::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCRerollPlayerChallenge>()._impl_._has_bits_);
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgClientToGCRerollPlayerChallenge::CMsgClientToGCRerollPlayerChallenge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCRerollPlayerChallenge)
}
CMsgClientToGCRerollPlayerChallenge::CMsgClientToGCRerollPlayerChallenge(const CMsgClientToGCRerollPlayerChallenge& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCRerollPlayerChallenge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_id_){}
    , decltype(_impl_.sequence_id_){}
    , decltype(_impl_.hero_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.event_id_, &from._impl_.event_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hero_id_) -
    reinterpret_cast<char*>(&_impl_.event_id_)) + sizeof(_impl_.hero_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCRerollPlayerChallenge)
}

inline void CMsgClientToGCRerollPlayerChallenge::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_id_){0}
    , decltype(_impl_.sequence_id_){0u}
    , decltype(_impl_.hero_id_){0u}
  };
}

CMsgClientToGCRerollPlayerChallenge::~CMsgClientToGCRerollPlayerChallenge() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCRerollPlayerChallenge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCRerollPlayerChallenge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCRerollPlayerChallenge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCRerollPlayerChallenge::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCRerollPlayerChallenge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.event_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hero_id_) -
        reinterpret_cast<char*>(&_impl_.event_id_)) + sizeof(_impl_.hero_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCRerollPlayerChallenge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EEvent_IsValid(val))) {
            _internal_set_event_id(static_cast<::EEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sequence_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sequence_id(&has_bits);
          _impl_.sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCRerollPlayerChallenge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCRerollPlayerChallenge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event_id(), target);
  }

  // optional uint32 sequence_id = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sequence_id(), target);
  }

  // optional uint32 hero_id = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_hero_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCRerollPlayerChallenge)
  return target;
}

size_t CMsgClientToGCRerollPlayerChallenge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCRerollPlayerChallenge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event_id());
    }

    // optional uint32 sequence_id = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sequence_id());
    }

    // optional uint32 hero_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCRerollPlayerChallenge::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCRerollPlayerChallenge::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCRerollPlayerChallenge::GetClassData() const { return &_class_data_; }


void CMsgClientToGCRerollPlayerChallenge::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCRerollPlayerChallenge*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCRerollPlayerChallenge&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCRerollPlayerChallenge)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sequence_id_ = from._impl_.sequence_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCRerollPlayerChallenge::CopyFrom(const CMsgClientToGCRerollPlayerChallenge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCRerollPlayerChallenge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCRerollPlayerChallenge::IsInitialized() const {
  return true;
}

void CMsgClientToGCRerollPlayerChallenge::InternalSwap(CMsgClientToGCRerollPlayerChallenge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCRerollPlayerChallenge, _impl_.hero_id_)
      + sizeof(CMsgClientToGCRerollPlayerChallenge::_impl_.hero_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCRerollPlayerChallenge, _impl_.event_id_)>(
          reinterpret_cast<char*>(&_impl_.event_id_),
          reinterpret_cast<char*>(&other->_impl_.event_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCRerollPlayerChallenge::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[33]);
}

// ===================================================================

class CMsgGCRerollPlayerChallengeResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCRerollPlayerChallengeResponse>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCRerollPlayerChallengeResponse::CMsgGCRerollPlayerChallengeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCRerollPlayerChallengeResponse)
}
CMsgGCRerollPlayerChallengeResponse::CMsgGCRerollPlayerChallengeResponse(const CMsgGCRerollPlayerChallengeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCRerollPlayerChallengeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCRerollPlayerChallengeResponse)
}

inline void CMsgGCRerollPlayerChallengeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

CMsgGCRerollPlayerChallengeResponse::~CMsgGCRerollPlayerChallengeResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCRerollPlayerChallengeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCRerollPlayerChallengeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCRerollPlayerChallengeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCRerollPlayerChallengeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCRerollPlayerChallengeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCRerollPlayerChallengeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgGCRerollPlayerChallengeResponse.EResult result = 1 [default = eResult_Success];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgGCRerollPlayerChallengeResponse_EResult_IsValid(val))) {
            _internal_set_result(static_cast<::CMsgGCRerollPlayerChallengeResponse_EResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCRerollPlayerChallengeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCRerollPlayerChallengeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgGCRerollPlayerChallengeResponse.EResult result = 1 [default = eResult_Success];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCRerollPlayerChallengeResponse)
  return target;
}

size_t CMsgGCRerollPlayerChallengeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCRerollPlayerChallengeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgGCRerollPlayerChallengeResponse.EResult result = 1 [default = eResult_Success];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCRerollPlayerChallengeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCRerollPlayerChallengeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCRerollPlayerChallengeResponse::GetClassData() const { return &_class_data_; }


void CMsgGCRerollPlayerChallengeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCRerollPlayerChallengeResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCRerollPlayerChallengeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCRerollPlayerChallengeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCRerollPlayerChallengeResponse::CopyFrom(const CMsgGCRerollPlayerChallengeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCRerollPlayerChallengeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCRerollPlayerChallengeResponse::IsInitialized() const {
  return true;
}

void CMsgGCRerollPlayerChallengeResponse::InternalSwap(CMsgGCRerollPlayerChallengeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCRerollPlayerChallengeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[34]);
}

// ===================================================================

class CMsgGCTopCustomGamesList::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCTopCustomGamesList>()._impl_._has_bits_);
  static void set_has_game_of_the_day(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCTopCustomGamesList::CMsgGCTopCustomGamesList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCTopCustomGamesList)
}
CMsgGCTopCustomGamesList::CMsgGCTopCustomGamesList(const CMsgGCTopCustomGamesList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCTopCustomGamesList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.top_custom_games_){from._impl_.top_custom_games_}
    , decltype(_impl_.game_of_the_day_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.game_of_the_day_ = from._impl_.game_of_the_day_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCTopCustomGamesList)
}

inline void CMsgGCTopCustomGamesList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.top_custom_games_){arena}
    , decltype(_impl_.game_of_the_day_){uint64_t{0u}}
  };
}

CMsgGCTopCustomGamesList::~CMsgGCTopCustomGamesList() {
  // @@protoc_insertion_point(destructor:CMsgGCTopCustomGamesList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCTopCustomGamesList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.top_custom_games_.~RepeatedField();
}

void CMsgGCTopCustomGamesList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCTopCustomGamesList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCTopCustomGamesList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.top_custom_games_.Clear();
  _impl_.game_of_the_day_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCTopCustomGamesList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 top_custom_games = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_top_custom_games(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_top_custom_games(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 game_of_the_day = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_game_of_the_day(&has_bits);
          _impl_.game_of_the_day_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCTopCustomGamesList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCTopCustomGamesList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 top_custom_games = 1;
  for (int i = 0, n = this->_internal_top_custom_games_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_top_custom_games(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 game_of_the_day = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_game_of_the_day(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCTopCustomGamesList)
  return target;
}

size_t CMsgGCTopCustomGamesList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCTopCustomGamesList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 top_custom_games = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.top_custom_games_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_top_custom_games_size());
    total_size += data_size;
  }

  // optional uint64 game_of_the_day = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_game_of_the_day());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCTopCustomGamesList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCTopCustomGamesList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCTopCustomGamesList::GetClassData() const { return &_class_data_; }


void CMsgGCTopCustomGamesList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCTopCustomGamesList*>(&to_msg);
  auto& from = static_cast<const CMsgGCTopCustomGamesList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCTopCustomGamesList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.top_custom_games_.MergeFrom(from._impl_.top_custom_games_);
  if (from._internal_has_game_of_the_day()) {
    _this->_internal_set_game_of_the_day(from._internal_game_of_the_day());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCTopCustomGamesList::CopyFrom(const CMsgGCTopCustomGamesList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCTopCustomGamesList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCTopCustomGamesList::IsInitialized() const {
  return true;
}

void CMsgGCTopCustomGamesList::InternalSwap(CMsgGCTopCustomGamesList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.top_custom_games_.InternalSwap(&other->_impl_.top_custom_games_);
  swap(_impl_.game_of_the_day_, other->_impl_.game_of_the_day_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCTopCustomGamesList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[35]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_TeamDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStats_TeamDetails>()._impl_._has_bits_);
  static void set_has_team_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_team_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_net_worth(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_only_team(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_cheers(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_team_logo_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDOTARealtimeGameStats_TeamDetails::CMsgDOTARealtimeGameStats_TeamDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.TeamDetails)
}
CMsgDOTARealtimeGameStats_TeamDetails::CMsgDOTARealtimeGameStats_TeamDetails(const CMsgDOTARealtimeGameStats_TeamDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_TeamDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.players_){from._impl_.players_}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_tag_){}
    , decltype(_impl_.team_logo_url_){}
    , decltype(_impl_.team_number_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.team_logo_){}
    , decltype(_impl_.score_){}
    , decltype(_impl_.only_team_){}
    , decltype(_impl_.cheers_){}
    , decltype(_impl_.net_worth_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_name()) {
    _this->_impl_.team_name_.Set(from._internal_team_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_tag()) {
    _this->_impl_.team_tag_.Set(from._internal_team_tag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_logo_url()) {
    _this->_impl_.team_logo_url_.Set(from._internal_team_logo_url(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.team_number_, &from._impl_.team_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.net_worth_) -
    reinterpret_cast<char*>(&_impl_.team_number_)) + sizeof(_impl_.net_worth_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.TeamDetails)
}

inline void CMsgDOTARealtimeGameStats_TeamDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.players_){arena}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_tag_){}
    , decltype(_impl_.team_logo_url_){}
    , decltype(_impl_.team_number_){0u}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.team_logo_){uint64_t{0u}}
    , decltype(_impl_.score_){0u}
    , decltype(_impl_.only_team_){false}
    , decltype(_impl_.cheers_){0u}
    , decltype(_impl_.net_worth_){0u}
  };
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTARealtimeGameStats_TeamDetails::~CMsgDOTARealtimeGameStats_TeamDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.TeamDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_TeamDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.players_.~RepeatedPtrField();
  _impl_.team_name_.Destroy();
  _impl_.team_tag_.Destroy();
  _impl_.team_logo_url_.Destroy();
}

void CMsgDOTARealtimeGameStats_TeamDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_TeamDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.TeamDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.players_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.team_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.team_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.team_logo_url_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.team_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.only_team_) -
        reinterpret_cast<char*>(&_impl_.team_number_)) + sizeof(_impl_.only_team_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.cheers_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.net_worth_) -
        reinterpret_cast<char*>(&_impl_.cheers_)) + sizeof(_impl_.net_worth_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_TeamDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 team_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_team_number(&has_bits);
          _impl_.team_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTARealtimeGameStats.TeamDetails.team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 team_logo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_team_logo(&has_bits);
          _impl_.team_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 score = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_score(&has_bits);
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.PlayerDetails players = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool only_team = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_only_team(&has_bits);
          _impl_.only_team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cheers = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_cheers(&has_bits);
          _impl_.cheers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 net_worth = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_net_worth(&has_bits);
          _impl_.net_worth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_tag = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_team_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTARealtimeGameStats.TeamDetails.team_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string team_logo_url = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_team_logo_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTARealtimeGameStats.TeamDetails.team_logo_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_TeamDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.TeamDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 team_number = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_team_number(), target);
  }

  // optional uint32 team_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_team_id(), target);
  }

  // optional string team_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_name().data(), static_cast<int>(this->_internal_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTARealtimeGameStats.TeamDetails.team_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_team_name(), target);
  }

  // optional fixed64 team_logo = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_team_logo(), target);
  }

  // optional uint32 score = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_score(), target);
  }

  // repeated .CMsgDOTARealtimeGameStats.PlayerDetails players = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool only_team = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_only_team(), target);
  }

  // optional uint32 cheers = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_cheers(), target);
  }

  // optional uint32 net_worth = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_net_worth(), target);
  }

  // optional string team_tag = 10;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_tag().data(), static_cast<int>(this->_internal_team_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTARealtimeGameStats.TeamDetails.team_tag");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_team_tag(), target);
  }

  // optional string team_logo_url = 11;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_logo_url().data(), static_cast<int>(this->_internal_team_logo_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTARealtimeGameStats.TeamDetails.team_logo_url");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_team_logo_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.TeamDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStats_TeamDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.TeamDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTARealtimeGameStats.PlayerDetails players = 6;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->_impl_.players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string team_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_name());
    }

    // optional string team_tag = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_tag());
    }

    // optional string team_logo_url = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_logo_url());
    }

    // optional uint32 team_number = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_number());
    }

    // optional uint32 team_id = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional fixed64 team_logo = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint32 score = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_score());
    }

    // optional bool only_team = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 cheers = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cheers());
    }

    // optional uint32 net_worth = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_net_worth());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_TeamDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_TeamDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_TeamDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_TeamDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_TeamDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_TeamDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.TeamDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_team_name(from._internal_team_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_team_tag(from._internal_team_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_team_logo_url(from._internal_team_logo_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_number_ = from._impl_.team_number_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.team_logo_ = from._impl_.team_logo_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.score_ = from._impl_.score_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.only_team_ = from._impl_.only_team_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.cheers_ = from._impl_.cheers_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.net_worth_ = from._impl_.net_worth_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_TeamDetails::CopyFrom(const CMsgDOTARealtimeGameStats_TeamDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.TeamDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_TeamDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_TeamDetails::InternalSwap(CMsgDOTARealtimeGameStats_TeamDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_name_, lhs_arena,
      &other->_impl_.team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_tag_, lhs_arena,
      &other->_impl_.team_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_logo_url_, lhs_arena,
      &other->_impl_.team_logo_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_TeamDetails, _impl_.net_worth_)
      + sizeof(CMsgDOTARealtimeGameStats_TeamDetails::_impl_.net_worth_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_TeamDetails, _impl_.team_number_)>(
          reinterpret_cast<char*>(&_impl_.team_number_),
          reinterpret_cast<char*>(&other->_impl_.team_number_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_TeamDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[36]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_ItemDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStats_ItemDetails>()._impl_._has_bits_);
  static void set_has_item_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sold(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stackcount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgDOTARealtimeGameStats_ItemDetails::CMsgDOTARealtimeGameStats_ItemDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.ItemDetails)
}
CMsgDOTARealtimeGameStats_ItemDetails::CMsgDOTARealtimeGameStats_ItemDetails(const CMsgDOTARealtimeGameStats_ItemDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_ItemDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.sold_){}
    , decltype(_impl_.stackcount_){}
    , decltype(_impl_.item_ability_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.time_, &from._impl_.time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_ability_id_) -
    reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.item_ability_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.ItemDetails)
}

inline void CMsgDOTARealtimeGameStats_ItemDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.time_){0}
    , decltype(_impl_.sold_){false}
    , decltype(_impl_.stackcount_){0u}
    , decltype(_impl_.item_ability_id_){-1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTARealtimeGameStats_ItemDetails::~CMsgDOTARealtimeGameStats_ItemDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.ItemDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_ItemDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgDOTARealtimeGameStats_ItemDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_ItemDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.ItemDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.stackcount_) -
        reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.stackcount_));
    _impl_.item_ability_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_ItemDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 item_ability_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_ability_id(&has_bits);
          _impl_.item_ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTARealtimeGameStats.ItemDetails.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool sold = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sold(&has_bits);
          _impl_.sold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stackcount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_stackcount(&has_bits);
          _impl_.stackcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_ItemDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.ItemDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 item_ability_id = 1 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_item_ability_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTARealtimeGameStats.ItemDetails.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional int32 time = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_time(), target);
  }

  // optional bool sold = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_sold(), target);
  }

  // optional uint32 stackcount = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_stackcount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.ItemDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStats_ItemDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.ItemDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 time = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_time());
    }

    // optional bool sold = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 stackcount = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stackcount());
    }

    // optional int32 item_ability_id = 1 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_ability_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_ItemDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_ItemDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_ItemDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_ItemDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_ItemDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_ItemDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.ItemDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sold_ = from._impl_.sold_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.stackcount_ = from._impl_.stackcount_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.item_ability_id_ = from._impl_.item_ability_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_ItemDetails::CopyFrom(const CMsgDOTARealtimeGameStats_ItemDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.ItemDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_ItemDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_ItemDetails::InternalSwap(CMsgDOTARealtimeGameStats_ItemDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_ItemDetails, _impl_.stackcount_)
      + sizeof(CMsgDOTARealtimeGameStats_ItemDetails::_impl_.stackcount_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_ItemDetails, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
  swap(_impl_.item_ability_id_, other->_impl_.item_ability_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_ItemDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[37]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_AbilityDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStats_AbilityDetails>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cooldown(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cooldown_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgDOTARealtimeGameStats_AbilityDetails::CMsgDOTARealtimeGameStats_AbilityDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.AbilityDetails)
}
CMsgDOTARealtimeGameStats_AbilityDetails::CMsgDOTARealtimeGameStats_AbilityDetails(const CMsgDOTARealtimeGameStats_AbilityDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_AbilityDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.cooldown_){}
    , decltype(_impl_.cooldown_max_){}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.id_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.AbilityDetails)
}

inline void CMsgDOTARealtimeGameStats_AbilityDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.level_){0u}
    , decltype(_impl_.cooldown_){0}
    , decltype(_impl_.cooldown_max_){0}
    , decltype(_impl_.id_){-1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTARealtimeGameStats_AbilityDetails::~CMsgDOTARealtimeGameStats_AbilityDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.AbilityDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_AbilityDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgDOTARealtimeGameStats_AbilityDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_AbilityDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.AbilityDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cooldown_max_) -
        reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.cooldown_max_));
    _impl_.id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_AbilityDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTARealtimeGameStats.AbilityDetails.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float cooldown = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_cooldown(&has_bits);
          _impl_.cooldown_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float cooldown_max = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_cooldown_max(&has_bits);
          _impl_.cooldown_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_AbilityDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.AbilityDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 id = 1 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTARealtimeGameStats.AbilityDetails.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional uint32 level = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_level(), target);
  }

  // optional float cooldown = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_cooldown(), target);
  }

  // optional float cooldown_max = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_cooldown_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.AbilityDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStats_AbilityDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.AbilityDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 level = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
    }

    // optional float cooldown = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float cooldown_max = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 id = 1 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_AbilityDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_AbilityDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_AbilityDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_AbilityDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_AbilityDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_AbilityDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.AbilityDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cooldown_ = from._impl_.cooldown_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.cooldown_max_ = from._impl_.cooldown_max_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_AbilityDetails::CopyFrom(const CMsgDOTARealtimeGameStats_AbilityDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.AbilityDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_AbilityDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_AbilityDetails::InternalSwap(CMsgDOTARealtimeGameStats_AbilityDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_AbilityDetails, _impl_.cooldown_max_)
      + sizeof(CMsgDOTARealtimeGameStats_AbilityDetails::_impl_.cooldown_max_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_AbilityDetails, _impl_.level_)>(
          reinterpret_cast<char*>(&_impl_.level_),
          reinterpret_cast<char*>(&other->_impl_.level_));
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_AbilityDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[38]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_HeroToHeroStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStats_HeroToHeroStats>()._impl_._has_bits_);
  static void set_has_victimid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_assists(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTARealtimeGameStats_HeroToHeroStats::CMsgDOTARealtimeGameStats_HeroToHeroStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.HeroToHeroStats)
}
CMsgDOTARealtimeGameStats_HeroToHeroStats::CMsgDOTARealtimeGameStats_HeroToHeroStats(const CMsgDOTARealtimeGameStats_HeroToHeroStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_HeroToHeroStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.kills_){}
    , decltype(_impl_.assists_){}
    , decltype(_impl_.victimid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.kills_, &from._impl_.kills_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.victimid_) -
    reinterpret_cast<char*>(&_impl_.kills_)) + sizeof(_impl_.victimid_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.HeroToHeroStats)
}

inline void CMsgDOTARealtimeGameStats_HeroToHeroStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.kills_){0u}
    , decltype(_impl_.assists_){0u}
    , decltype(_impl_.victimid_){-1}
  };
}

CMsgDOTARealtimeGameStats_HeroToHeroStats::~CMsgDOTARealtimeGameStats_HeroToHeroStats() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.HeroToHeroStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_HeroToHeroStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTARealtimeGameStats_HeroToHeroStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_HeroToHeroStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.HeroToHeroStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.kills_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.assists_) -
        reinterpret_cast<char*>(&_impl_.kills_)) + sizeof(_impl_.assists_));
    _impl_.victimid_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_HeroToHeroStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 victimid = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_victimid(&has_bits);
          _impl_.victimid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 kills = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_kills(&has_bits);
          _impl_.kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assists = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_assists(&has_bits);
          _impl_.assists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_HeroToHeroStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.HeroToHeroStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 victimid = 1 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_victimid(), target);
  }

  // optional uint32 kills = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_kills(), target);
  }

  // optional uint32 assists = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_assists(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.HeroToHeroStats)
  return target;
}

size_t CMsgDOTARealtimeGameStats_HeroToHeroStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.HeroToHeroStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 kills = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_kills());
    }

    // optional uint32 assists = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_assists());
    }

    // optional int32 victimid = 1 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_victimid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_HeroToHeroStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_HeroToHeroStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_HeroToHeroStats::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_HeroToHeroStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_HeroToHeroStats*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_HeroToHeroStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.HeroToHeroStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.kills_ = from._impl_.kills_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.assists_ = from._impl_.assists_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.victimid_ = from._impl_.victimid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_HeroToHeroStats::CopyFrom(const CMsgDOTARealtimeGameStats_HeroToHeroStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.HeroToHeroStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_HeroToHeroStats::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_HeroToHeroStats::InternalSwap(CMsgDOTARealtimeGameStats_HeroToHeroStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_HeroToHeroStats, _impl_.assists_)
      + sizeof(CMsgDOTARealtimeGameStats_HeroToHeroStats::_impl_.assists_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_HeroToHeroStats, _impl_.kills_)>(
          reinterpret_cast<char*>(&_impl_.kills_),
          reinterpret_cast<char*>(&other->_impl_.kills_));
  swap(_impl_.victimid_, other->_impl_.victimid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_HeroToHeroStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[39]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_AbilityList::_Internal {
 public:
};

CMsgDOTARealtimeGameStats_AbilityList::CMsgDOTARealtimeGameStats_AbilityList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.AbilityList)
}
CMsgDOTARealtimeGameStats_AbilityList::CMsgDOTARealtimeGameStats_AbilityList(const CMsgDOTARealtimeGameStats_AbilityList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_AbilityList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){from._impl_.id_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.AbilityList)
}

inline void CMsgDOTARealtimeGameStats_AbilityList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTARealtimeGameStats_AbilityList::~CMsgDOTARealtimeGameStats_AbilityList() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.AbilityList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_AbilityList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.~RepeatedField();
}

void CMsgDOTARealtimeGameStats_AbilityList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_AbilityList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.AbilityList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_AbilityList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_id(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_AbilityList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.AbilityList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 id = 1;
  for (int i = 0, n = this->_internal_id_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.AbilityList)
  return target;
}

size_t CMsgDOTARealtimeGameStats_AbilityList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.AbilityList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 id = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.id_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_id_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_AbilityList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_AbilityList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_AbilityList::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_AbilityList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_AbilityList*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_AbilityList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.AbilityList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.id_.MergeFrom(from._impl_.id_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_AbilityList::CopyFrom(const CMsgDOTARealtimeGameStats_AbilityList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.AbilityList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_AbilityList::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_AbilityList::InternalSwap(CMsgDOTARealtimeGameStats_AbilityList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.id_.InternalSwap(&other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_AbilityList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[40]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_PlayerDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStats_PlayerDetails>()._impl_._has_bits_);
  static void set_has_accountid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heroid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_healthpoints(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_maxhealthpoints(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_healthregenrate(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_manapoints(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_maxmanapoints(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_manaregenrate(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_base_strength(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_base_agility(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_base_intelligence(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_base_armor(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_base_movespeed(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_base_damage(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_strength(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_agility(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_intelligence(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_armor(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_movespeed(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_damage(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_hero_damage(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_tower_damage(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_kill_count(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_death_count(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_assists_count(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_denies_count(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_lh_count(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_hero_healing(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_gold_per_min(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_xp_per_min(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_net_gold(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_gold(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_respawn_time(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_ultimate_cooldown(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_has_buyback(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_has_ultimate(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_has_ultimate_mana(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
};

CMsgDOTARealtimeGameStats_PlayerDetails::CMsgDOTARealtimeGameStats_PlayerDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.PlayerDetails)
}
CMsgDOTARealtimeGameStats_PlayerDetails::CMsgDOTARealtimeGameStats_PlayerDetails(const CMsgDOTARealtimeGameStats_PlayerDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_PlayerDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.abilities_){from._impl_.abilities_}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.stashitems_){from._impl_.stashitems_}
    , decltype(_impl_.itemshoppinglist_){from._impl_.itemshoppinglist_}
    , decltype(_impl_.levelpoints_){from._impl_.levelpoints_}
    , decltype(_impl_.hero_to_hero_stats_){from._impl_.hero_to_hero_stats_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.accountid_){}
    , decltype(_impl_.team_){}
    , decltype(_impl_.heroid_){}
    , decltype(_impl_.healthpoints_){}
    , decltype(_impl_.maxhealthpoints_){}
    , decltype(_impl_.healthregenrate_){}
    , decltype(_impl_.manapoints_){}
    , decltype(_impl_.maxmanapoints_){}
    , decltype(_impl_.manaregenrate_){}
    , decltype(_impl_.base_strength_){}
    , decltype(_impl_.base_agility_){}
    , decltype(_impl_.base_intelligence_){}
    , decltype(_impl_.base_armor_){}
    , decltype(_impl_.base_movespeed_){}
    , decltype(_impl_.base_damage_){}
    , decltype(_impl_.strength_){}
    , decltype(_impl_.agility_){}
    , decltype(_impl_.intelligence_){}
    , decltype(_impl_.armor_){}
    , decltype(_impl_.movespeed_){}
    , decltype(_impl_.damage_){}
    , decltype(_impl_.hero_damage_){}
    , decltype(_impl_.tower_damage_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.kill_count_){}
    , decltype(_impl_.death_count_){}
    , decltype(_impl_.assists_count_){}
    , decltype(_impl_.denies_count_){}
    , decltype(_impl_.lh_count_){}
    , decltype(_impl_.hero_healing_){}
    , decltype(_impl_.gold_per_min_){}
    , decltype(_impl_.xp_per_min_){}
    , decltype(_impl_.net_gold_){}
    , decltype(_impl_.gold_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.respawn_time_){}
    , decltype(_impl_.ultimate_cooldown_){}
    , decltype(_impl_.has_buyback_){}
    , decltype(_impl_.has_ultimate_){}
    , decltype(_impl_.has_ultimate_mana_){}
    , decltype(_impl_.playerid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.playerid_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.playerid_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.PlayerDetails)
}

inline void CMsgDOTARealtimeGameStats_PlayerDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.abilities_){arena}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.stashitems_){arena}
    , decltype(_impl_.itemshoppinglist_){arena}
    , decltype(_impl_.levelpoints_){arena}
    , decltype(_impl_.hero_to_hero_stats_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.accountid_){0u}
    , decltype(_impl_.team_){0u}
    , decltype(_impl_.heroid_){0u}
    , decltype(_impl_.healthpoints_){0u}
    , decltype(_impl_.maxhealthpoints_){0u}
    , decltype(_impl_.healthregenrate_){0}
    , decltype(_impl_.manapoints_){0u}
    , decltype(_impl_.maxmanapoints_){0u}
    , decltype(_impl_.manaregenrate_){0}
    , decltype(_impl_.base_strength_){0u}
    , decltype(_impl_.base_agility_){0u}
    , decltype(_impl_.base_intelligence_){0u}
    , decltype(_impl_.base_armor_){0}
    , decltype(_impl_.base_movespeed_){0u}
    , decltype(_impl_.base_damage_){0u}
    , decltype(_impl_.strength_){0u}
    , decltype(_impl_.agility_){0u}
    , decltype(_impl_.intelligence_){0u}
    , decltype(_impl_.armor_){0}
    , decltype(_impl_.movespeed_){0u}
    , decltype(_impl_.damage_){0u}
    , decltype(_impl_.hero_damage_){0u}
    , decltype(_impl_.tower_damage_){0u}
    , decltype(_impl_.level_){0u}
    , decltype(_impl_.kill_count_){0u}
    , decltype(_impl_.death_count_){0u}
    , decltype(_impl_.assists_count_){0u}
    , decltype(_impl_.denies_count_){0u}
    , decltype(_impl_.lh_count_){0u}
    , decltype(_impl_.hero_healing_){0u}
    , decltype(_impl_.gold_per_min_){0u}
    , decltype(_impl_.xp_per_min_){0u}
    , decltype(_impl_.net_gold_){0u}
    , decltype(_impl_.gold_){0u}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.respawn_time_){0}
    , decltype(_impl_.ultimate_cooldown_){0u}
    , decltype(_impl_.has_buyback_){false}
    , decltype(_impl_.has_ultimate_){false}
    , decltype(_impl_.has_ultimate_mana_){false}
    , decltype(_impl_.playerid_){-1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTARealtimeGameStats_PlayerDetails::~CMsgDOTARealtimeGameStats_PlayerDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.PlayerDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_PlayerDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.abilities_.~RepeatedPtrField();
  _impl_.items_.~RepeatedPtrField();
  _impl_.stashitems_.~RepeatedPtrField();
  _impl_.itemshoppinglist_.~RepeatedPtrField();
  _impl_.levelpoints_.~RepeatedPtrField();
  _impl_.hero_to_hero_stats_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void CMsgDOTARealtimeGameStats_PlayerDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_PlayerDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.PlayerDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.abilities_.Clear();
  _impl_.items_.Clear();
  _impl_.stashitems_.Clear();
  _impl_.itemshoppinglist_.Clear();
  _impl_.levelpoints_.Clear();
  _impl_.hero_to_hero_stats_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.manapoints_) -
        reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.manapoints_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.maxmanapoints_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.base_damage_) -
        reinterpret_cast<char*>(&_impl_.maxmanapoints_)) + sizeof(_impl_.base_damage_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.strength_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tower_damage_) -
        reinterpret_cast<char*>(&_impl_.strength_)) + sizeof(_impl_.tower_damage_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gold_per_min_) -
        reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.gold_per_min_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.xp_per_min_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.has_buyback_) -
        reinterpret_cast<char*>(&_impl_.xp_per_min_)) + sizeof(_impl_.has_buyback_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.has_ultimate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.has_ultimate_mana_) -
        reinterpret_cast<char*>(&_impl_.has_ultimate_)) + sizeof(_impl_.has_ultimate_mana_));
    _impl_.playerid_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_PlayerDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 accountid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_accountid(&_impl_._has_bits_);
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 playerid = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&_impl_._has_bits_);
          _impl_.playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTARealtimeGameStats.PlayerDetails.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_team(&_impl_._has_bits_);
          _impl_.team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 heroid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_heroid(&_impl_._has_bits_);
          _impl_.heroid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 healthpoints = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_healthpoints(&_impl_._has_bits_);
          _impl_.healthpoints_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 maxhealthpoints = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_maxhealthpoints(&_impl_._has_bits_);
          _impl_.maxhealthpoints_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float healthregenrate = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_healthregenrate(&_impl_._has_bits_);
          _impl_.healthregenrate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 manapoints = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_manapoints(&_impl_._has_bits_);
          _impl_.manapoints_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 maxmanapoints = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_maxmanapoints(&_impl_._has_bits_);
          _impl_.maxmanapoints_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float manaregenrate = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_manaregenrate(&_impl_._has_bits_);
          _impl_.manaregenrate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 base_strength = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_base_strength(&_impl_._has_bits_);
          _impl_.base_strength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 base_agility = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_base_agility(&_impl_._has_bits_);
          _impl_.base_agility_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 base_intelligence = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_base_intelligence(&_impl_._has_bits_);
          _impl_.base_intelligence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 base_armor = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_base_armor(&_impl_._has_bits_);
          _impl_.base_armor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 base_movespeed = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_base_movespeed(&_impl_._has_bits_);
          _impl_.base_movespeed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 base_damage = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_base_damage(&_impl_._has_bits_);
          _impl_.base_damage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 strength = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_strength(&_impl_._has_bits_);
          _impl_.strength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 agility = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_agility(&_impl_._has_bits_);
          _impl_.agility_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 intelligence = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_intelligence(&_impl_._has_bits_);
          _impl_.intelligence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 armor = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_armor(&_impl_._has_bits_);
          _impl_.armor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 movespeed = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_movespeed(&_impl_._has_bits_);
          _impl_.movespeed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 damage = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_damage(&_impl_._has_bits_);
          _impl_.damage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_damage = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_hero_damage(&_impl_._has_bits_);
          _impl_.hero_damage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tower_damage = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_tower_damage(&_impl_._has_bits_);
          _impl_.tower_damage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.AbilityDetails abilities = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_abilities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<210>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_level(&_impl_._has_bits_);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 kill_count = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_kill_count(&_impl_._has_bits_);
          _impl_.kill_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 death_count = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_death_count(&_impl_._has_bits_);
          _impl_.death_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assists_count = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_assists_count(&_impl_._has_bits_);
          _impl_.assists_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 denies_count = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_denies_count(&_impl_._has_bits_);
          _impl_.denies_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lh_count = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_lh_count(&_impl_._has_bits_);
          _impl_.lh_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_healing = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero_healing(&_impl_._has_bits_);
          _impl_.hero_healing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gold_per_min = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gold_per_min(&_impl_._has_bits_);
          _impl_.gold_per_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 xp_per_min = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_xp_per_min(&_impl_._has_bits_);
          _impl_.xp_per_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 net_gold = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_net_gold(&_impl_._has_bits_);
          _impl_.net_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gold = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gold(&_impl_._has_bits_);
          _impl_.gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float x = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_x(&_impl_._has_bits_);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_y(&_impl_._has_bits_);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 respawn_time = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_respawn_time(&_impl_._has_bits_);
          _impl_.respawn_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ultimate_cooldown = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_ultimate_cooldown(&_impl_._has_bits_);
          _impl_.ultimate_cooldown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_buyback = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_has_buyback(&_impl_._has_bits_);
          _impl_.has_buyback_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.ItemDetails items = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<346>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.ItemDetails stashitems = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_stashitems(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<354>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.ItemDetails itemshoppinglist = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_itemshoppinglist(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<362>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.AbilityList levelpoints = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_levelpoints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<370>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.HeroToHeroStats hero_to_hero_stats = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_hero_to_hero_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<378>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool has_ultimate = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_has_ultimate(&_impl_._has_bits_);
          _impl_.has_ultimate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_ultimate_mana = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_has_ultimate_mana(&_impl_._has_bits_);
          _impl_.has_ultimate_mana_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_PlayerDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.PlayerDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 accountid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_accountid(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional int32 playerid = 2 [default = -1];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_playerid(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTARealtimeGameStats.PlayerDetails.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional uint32 team = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_team(), target);
  }

  // optional uint32 heroid = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_heroid(), target);
  }

  // optional uint32 healthpoints = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_healthpoints(), target);
  }

  // optional uint32 maxhealthpoints = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_maxhealthpoints(), target);
  }

  // optional float healthregenrate = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_healthregenrate(), target);
  }

  // optional uint32 manapoints = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_manapoints(), target);
  }

  // optional uint32 maxmanapoints = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_maxmanapoints(), target);
  }

  // optional float manaregenrate = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_manaregenrate(), target);
  }

  // optional uint32 base_strength = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_base_strength(), target);
  }

  // optional uint32 base_agility = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_base_agility(), target);
  }

  // optional uint32 base_intelligence = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_base_intelligence(), target);
  }

  // optional int32 base_armor = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_base_armor(), target);
  }

  // optional uint32 base_movespeed = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_base_movespeed(), target);
  }

  // optional uint32 base_damage = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_base_damage(), target);
  }

  // optional uint32 strength = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_strength(), target);
  }

  // optional uint32 agility = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_agility(), target);
  }

  // optional uint32 intelligence = 20;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_intelligence(), target);
  }

  // optional int32 armor = 21;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(21, this->_internal_armor(), target);
  }

  // optional uint32 movespeed = 22;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_movespeed(), target);
  }

  // optional uint32 damage = 23;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_damage(), target);
  }

  // optional uint32 hero_damage = 24;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_hero_damage(), target);
  }

  // optional uint32 tower_damage = 25;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_tower_damage(), target);
  }

  // repeated .CMsgDOTARealtimeGameStats.AbilityDetails abilities = 26;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_abilities_size()); i < n; i++) {
    const auto& repfield = this->_internal_abilities(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(26, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 level = 27;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_level(), target);
  }

  // optional uint32 kill_count = 28;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_kill_count(), target);
  }

  // optional uint32 death_count = 29;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(29, this->_internal_death_count(), target);
  }

  // optional uint32 assists_count = 30;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(30, this->_internal_assists_count(), target);
  }

  // optional uint32 denies_count = 31;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(31, this->_internal_denies_count(), target);
  }

  // optional uint32 lh_count = 32;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(32, this->_internal_lh_count(), target);
  }

  // optional uint32 hero_healing = 33;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(33, this->_internal_hero_healing(), target);
  }

  // optional uint32 gold_per_min = 34;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(34, this->_internal_gold_per_min(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 xp_per_min = 35;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_xp_per_min(), target);
  }

  // optional uint32 net_gold = 36;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(36, this->_internal_net_gold(), target);
  }

  // optional uint32 gold = 37;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(37, this->_internal_gold(), target);
  }

  // optional float x = 38;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(38, this->_internal_x(), target);
  }

  // optional float y = 39;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(39, this->_internal_y(), target);
  }

  // optional int32 respawn_time = 40;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(40, this->_internal_respawn_time(), target);
  }

  // optional uint32 ultimate_cooldown = 41;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(41, this->_internal_ultimate_cooldown(), target);
  }

  // optional bool has_buyback = 42;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(42, this->_internal_has_buyback(), target);
  }

  // repeated .CMsgDOTARealtimeGameStats.ItemDetails items = 43;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(43, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTARealtimeGameStats.ItemDetails stashitems = 44;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stashitems_size()); i < n; i++) {
    const auto& repfield = this->_internal_stashitems(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(44, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTARealtimeGameStats.ItemDetails itemshoppinglist = 45;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_itemshoppinglist_size()); i < n; i++) {
    const auto& repfield = this->_internal_itemshoppinglist(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(45, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTARealtimeGameStats.AbilityList levelpoints = 46;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_levelpoints_size()); i < n; i++) {
    const auto& repfield = this->_internal_levelpoints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(46, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTARealtimeGameStats.HeroToHeroStats hero_to_hero_stats = 47;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hero_to_hero_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_hero_to_hero_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(47, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool has_ultimate = 48;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(48, this->_internal_has_ultimate(), target);
  }

  // optional bool has_ultimate_mana = 49;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(49, this->_internal_has_ultimate_mana(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.PlayerDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStats_PlayerDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.PlayerDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTARealtimeGameStats.AbilityDetails abilities = 26;
  total_size += 2UL * this->_internal_abilities_size();
  for (const auto& msg : this->_impl_.abilities_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTARealtimeGameStats.ItemDetails items = 43;
  total_size += 2UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTARealtimeGameStats.ItemDetails stashitems = 44;
  total_size += 2UL * this->_internal_stashitems_size();
  for (const auto& msg : this->_impl_.stashitems_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTARealtimeGameStats.ItemDetails itemshoppinglist = 45;
  total_size += 2UL * this->_internal_itemshoppinglist_size();
  for (const auto& msg : this->_impl_.itemshoppinglist_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTARealtimeGameStats.AbilityList levelpoints = 46;
  total_size += 2UL * this->_internal_levelpoints_size();
  for (const auto& msg : this->_impl_.levelpoints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTARealtimeGameStats.HeroToHeroStats hero_to_hero_stats = 47;
  total_size += 2UL * this->_internal_hero_to_hero_stats_size();
  for (const auto& msg : this->_impl_.hero_to_hero_stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 accountid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_accountid());
    }

    // optional uint32 team = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team());
    }

    // optional uint32 heroid = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_heroid());
    }

    // optional uint32 healthpoints = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_healthpoints());
    }

    // optional uint32 maxhealthpoints = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxhealthpoints());
    }

    // optional float healthregenrate = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional uint32 manapoints = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_manapoints());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 maxmanapoints = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxmanapoints());
    }

    // optional float manaregenrate = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional uint32 base_strength = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_base_strength());
    }

    // optional uint32 base_agility = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_base_agility());
    }

    // optional uint32 base_intelligence = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_base_intelligence());
    }

    // optional int32 base_armor = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_base_armor());
    }

    // optional uint32 base_movespeed = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_base_movespeed());
    }

    // optional uint32 base_damage = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_base_damage());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 strength = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_strength());
    }

    // optional uint32 agility = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_agility());
    }

    // optional uint32 intelligence = 20;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_intelligence());
    }

    // optional int32 armor = 21;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_armor());
    }

    // optional uint32 movespeed = 22;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_movespeed());
    }

    // optional uint32 damage = 23;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_damage());
    }

    // optional uint32 hero_damage = 24;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_hero_damage());
    }

    // optional uint32 tower_damage = 25;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tower_damage());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 level = 27;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_level());
    }

    // optional uint32 kill_count = 28;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_kill_count());
    }

    // optional uint32 death_count = 29;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_death_count());
    }

    // optional uint32 assists_count = 30;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_assists_count());
    }

    // optional uint32 denies_count = 31;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_denies_count());
    }

    // optional uint32 lh_count = 32;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_lh_count());
    }

    // optional uint32 hero_healing = 33;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_hero_healing());
    }

    // optional uint32 gold_per_min = 34;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gold_per_min());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 xp_per_min = 35;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_xp_per_min());
    }

    // optional uint32 net_gold = 36;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_net_gold());
    }

    // optional uint32 gold = 37;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gold());
    }

    // optional float x = 38;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 4;
    }

    // optional float y = 39;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 4;
    }

    // optional int32 respawn_time = 40;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_respawn_time());
    }

    // optional uint32 ultimate_cooldown = 41;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_ultimate_cooldown());
    }

    // optional bool has_buyback = 42;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional bool has_ultimate = 48;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional bool has_ultimate_mana = 49;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional int32 playerid = 2 [default = -1];
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playerid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_PlayerDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_PlayerDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_PlayerDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_PlayerDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_PlayerDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_PlayerDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.PlayerDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.abilities_.MergeFrom(from._impl_.abilities_);
  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_impl_.stashitems_.MergeFrom(from._impl_.stashitems_);
  _this->_impl_.itemshoppinglist_.MergeFrom(from._impl_.itemshoppinglist_);
  _this->_impl_.levelpoints_.MergeFrom(from._impl_.levelpoints_);
  _this->_impl_.hero_to_hero_stats_.MergeFrom(from._impl_.hero_to_hero_stats_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.accountid_ = from._impl_.accountid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.team_ = from._impl_.team_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.heroid_ = from._impl_.heroid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.healthpoints_ = from._impl_.healthpoints_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.maxhealthpoints_ = from._impl_.maxhealthpoints_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.healthregenrate_ = from._impl_.healthregenrate_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.manapoints_ = from._impl_.manapoints_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.maxmanapoints_ = from._impl_.maxmanapoints_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.manaregenrate_ = from._impl_.manaregenrate_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.base_strength_ = from._impl_.base_strength_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.base_agility_ = from._impl_.base_agility_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.base_intelligence_ = from._impl_.base_intelligence_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.base_armor_ = from._impl_.base_armor_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.base_movespeed_ = from._impl_.base_movespeed_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.base_damage_ = from._impl_.base_damage_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.strength_ = from._impl_.strength_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.agility_ = from._impl_.agility_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.intelligence_ = from._impl_.intelligence_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.armor_ = from._impl_.armor_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.movespeed_ = from._impl_.movespeed_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.damage_ = from._impl_.damage_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.hero_damage_ = from._impl_.hero_damage_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.tower_damage_ = from._impl_.tower_damage_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.kill_count_ = from._impl_.kill_count_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.death_count_ = from._impl_.death_count_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.assists_count_ = from._impl_.assists_count_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.denies_count_ = from._impl_.denies_count_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.lh_count_ = from._impl_.lh_count_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.hero_healing_ = from._impl_.hero_healing_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.gold_per_min_ = from._impl_.gold_per_min_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.xp_per_min_ = from._impl_.xp_per_min_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.net_gold_ = from._impl_.net_gold_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.gold_ = from._impl_.gold_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.respawn_time_ = from._impl_.respawn_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.ultimate_cooldown_ = from._impl_.ultimate_cooldown_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.has_buyback_ = from._impl_.has_buyback_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.has_ultimate_ = from._impl_.has_ultimate_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.has_ultimate_mana_ = from._impl_.has_ultimate_mana_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.playerid_ = from._impl_.playerid_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_PlayerDetails::CopyFrom(const CMsgDOTARealtimeGameStats_PlayerDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.PlayerDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_PlayerDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_PlayerDetails::InternalSwap(CMsgDOTARealtimeGameStats_PlayerDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  _impl_.abilities_.InternalSwap(&other->_impl_.abilities_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  _impl_.stashitems_.InternalSwap(&other->_impl_.stashitems_);
  _impl_.itemshoppinglist_.InternalSwap(&other->_impl_.itemshoppinglist_);
  _impl_.levelpoints_.InternalSwap(&other->_impl_.levelpoints_);
  _impl_.hero_to_hero_stats_.InternalSwap(&other->_impl_.hero_to_hero_stats_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.has_ultimate_mana_)
      + sizeof(CMsgDOTARealtimeGameStats_PlayerDetails::_impl_.has_ultimate_mana_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_PlayerDetails, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
  swap(_impl_.playerid_, other->_impl_.playerid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_PlayerDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[41]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_BuildingDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStats_BuildingDetails>()._impl_._has_bits_);
  static void set_has_team(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_heading(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lane(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_destroyed(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgDOTARealtimeGameStats_BuildingDetails::CMsgDOTARealtimeGameStats_BuildingDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.BuildingDetails)
}
CMsgDOTARealtimeGameStats_BuildingDetails::CMsgDOTARealtimeGameStats_BuildingDetails(const CMsgDOTARealtimeGameStats_BuildingDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_BuildingDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_){}
    , decltype(_impl_.heading_){}
    , decltype(_impl_.lane_){}
    , decltype(_impl_.tier_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.destroyed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.team_, &from._impl_.team_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.destroyed_) -
    reinterpret_cast<char*>(&_impl_.team_)) + sizeof(_impl_.destroyed_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.BuildingDetails)
}

inline void CMsgDOTARealtimeGameStats_BuildingDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_){0u}
    , decltype(_impl_.heading_){0}
    , decltype(_impl_.lane_){0u}
    , decltype(_impl_.tier_){0u}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.destroyed_){false}
  };
}

CMsgDOTARealtimeGameStats_BuildingDetails::~CMsgDOTARealtimeGameStats_BuildingDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.BuildingDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_BuildingDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTARealtimeGameStats_BuildingDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_BuildingDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.BuildingDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.team_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.destroyed_) -
        reinterpret_cast<char*>(&_impl_.team_)) + sizeof(_impl_.destroyed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_BuildingDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 team = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team(&has_bits);
          _impl_.team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float heading = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_heading(&has_bits);
          _impl_.heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lane = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_lane(&has_bits);
          _impl_.lane_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_tier(&has_bits);
          _impl_.tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float x = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool destroyed = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_destroyed(&has_bits);
          _impl_.destroyed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_BuildingDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.BuildingDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 team = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_team(), target);
  }

  // optional float heading = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_heading(), target);
  }

  // optional uint32 lane = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_lane(), target);
  }

  // optional uint32 tier = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_tier(), target);
  }

  // optional uint32 type = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_type(), target);
  }

  // optional float x = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_x(), target);
  }

  // optional float y = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_y(), target);
  }

  // optional bool destroyed = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_destroyed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.BuildingDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStats_BuildingDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.BuildingDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 team = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team());
    }

    // optional float heading = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 lane = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lane());
    }

    // optional uint32 tier = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tier());
    }

    // optional uint32 type = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

    // optional float x = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float y = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional bool destroyed = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_BuildingDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_BuildingDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_BuildingDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_BuildingDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_BuildingDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_BuildingDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.BuildingDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.team_ = from._impl_.team_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.heading_ = from._impl_.heading_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lane_ = from._impl_.lane_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.tier_ = from._impl_.tier_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.destroyed_ = from._impl_.destroyed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_BuildingDetails::CopyFrom(const CMsgDOTARealtimeGameStats_BuildingDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.BuildingDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_BuildingDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_BuildingDetails::InternalSwap(CMsgDOTARealtimeGameStats_BuildingDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_BuildingDetails, _impl_.destroyed_)
      + sizeof(CMsgDOTARealtimeGameStats_BuildingDetails::_impl_.destroyed_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_BuildingDetails, _impl_.team_)>(
          reinterpret_cast<char*>(&_impl_.team_),
          reinterpret_cast<char*>(&other->_impl_.team_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_BuildingDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[42]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_KillDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStats_KillDetails>()._impl_._has_bits_);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_death_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_killer_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDOTARealtimeGameStats_KillDetails::CMsgDOTARealtimeGameStats_KillDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.KillDetails)
}
CMsgDOTARealtimeGameStats_KillDetails::CMsgDOTARealtimeGameStats_KillDetails(const CMsgDOTARealtimeGameStats_KillDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_KillDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.death_time_){}
    , decltype(_impl_.player_id_){}
    , decltype(_impl_.killer_player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.death_time_, &from._impl_.death_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.killer_player_id_) -
    reinterpret_cast<char*>(&_impl_.death_time_)) + sizeof(_impl_.killer_player_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.KillDetails)
}

inline void CMsgDOTARealtimeGameStats_KillDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.death_time_){0}
    , decltype(_impl_.player_id_){-1}
    , decltype(_impl_.killer_player_id_){-1}
  };
}

CMsgDOTARealtimeGameStats_KillDetails::~CMsgDOTARealtimeGameStats_KillDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.KillDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_KillDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTARealtimeGameStats_KillDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_KillDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.KillDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    _impl_.death_time_ = 0;
    _impl_.player_id_ = -1;
    _impl_.killer_player_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_KillDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 death_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_death_time(&has_bits);
          _impl_.death_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 killer_player_id = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_killer_player_id(&has_bits);
          _impl_.killer_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_KillDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.KillDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_id(), target);
  }

  // optional int32 death_time = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_death_time(), target);
  }

  // optional int32 killer_player_id = 3 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_killer_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.KillDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStats_KillDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.KillDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 death_time = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_death_time());
    }

    // optional int32 player_id = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
    }

    // optional int32 killer_player_id = 3 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_killer_player_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_KillDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_KillDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_KillDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_KillDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_KillDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_KillDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.KillDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.death_time_ = from._impl_.death_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.player_id_ = from._impl_.player_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.killer_player_id_ = from._impl_.killer_player_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_KillDetails::CopyFrom(const CMsgDOTARealtimeGameStats_KillDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.KillDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_KillDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_KillDetails::InternalSwap(CMsgDOTARealtimeGameStats_KillDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.death_time_, other->_impl_.death_time_);
  swap(_impl_.player_id_, other->_impl_.player_id_);
  swap(_impl_.killer_player_id_, other->_impl_.killer_player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_KillDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[43]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_BroadcasterDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStats_BroadcasterDetails>()._impl_._has_bits_);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTARealtimeGameStats_BroadcasterDetails::CMsgDOTARealtimeGameStats_BroadcasterDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.BroadcasterDetails)
}
CMsgDOTARealtimeGameStats_BroadcasterDetails::CMsgDOTARealtimeGameStats_BroadcasterDetails(const CMsgDOTARealtimeGameStats_BroadcasterDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_BroadcasterDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.player_id_ = from._impl_.player_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.BroadcasterDetails)
}

inline void CMsgDOTARealtimeGameStats_BroadcasterDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){-1}
  };
}

CMsgDOTARealtimeGameStats_BroadcasterDetails::~CMsgDOTARealtimeGameStats_BroadcasterDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.BroadcasterDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_BroadcasterDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTARealtimeGameStats_BroadcasterDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_BroadcasterDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.BroadcasterDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_id_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_BroadcasterDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_BroadcasterDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.BroadcasterDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.BroadcasterDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStats_BroadcasterDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.BroadcasterDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 player_id = 1 [default = -1];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_BroadcasterDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_BroadcasterDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_BroadcasterDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_BroadcasterDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_BroadcasterDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_BroadcasterDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.BroadcasterDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_player_id()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_BroadcasterDetails::CopyFrom(const CMsgDOTARealtimeGameStats_BroadcasterDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.BroadcasterDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_BroadcasterDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_BroadcasterDetails::InternalSwap(CMsgDOTARealtimeGameStats_BroadcasterDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.player_id_, other->_impl_.player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_BroadcasterDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[44]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_PickBanDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStats_PickBanDetails>()._impl_._has_bits_);
  static void set_has_hero(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTARealtimeGameStats_PickBanDetails::CMsgDOTARealtimeGameStats_PickBanDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.PickBanDetails)
}
CMsgDOTARealtimeGameStats_PickBanDetails::CMsgDOTARealtimeGameStats_PickBanDetails(const CMsgDOTARealtimeGameStats_PickBanDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_PickBanDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_){}
    , decltype(_impl_.team_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hero_, &from._impl_.hero_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.team_) -
    reinterpret_cast<char*>(&_impl_.hero_)) + sizeof(_impl_.team_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.PickBanDetails)
}

inline void CMsgDOTARealtimeGameStats_PickBanDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_){0u}
    , decltype(_impl_.team_){0u}
  };
}

CMsgDOTARealtimeGameStats_PickBanDetails::~CMsgDOTARealtimeGameStats_PickBanDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.PickBanDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_PickBanDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTARealtimeGameStats_PickBanDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_PickBanDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.PickBanDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.hero_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.team_) -
        reinterpret_cast<char*>(&_impl_.hero_)) + sizeof(_impl_.team_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_PickBanDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 hero = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero(&has_bits);
          _impl_.hero_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team(&has_bits);
          _impl_.team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_PickBanDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.PickBanDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 hero = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hero(), target);
  }

  // optional uint32 team = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_team(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.PickBanDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStats_PickBanDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.PickBanDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 hero = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero());
    }

    // optional uint32 team = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_PickBanDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_PickBanDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_PickBanDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_PickBanDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_PickBanDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_PickBanDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.PickBanDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.hero_ = from._impl_.hero_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.team_ = from._impl_.team_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_PickBanDetails::CopyFrom(const CMsgDOTARealtimeGameStats_PickBanDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.PickBanDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_PickBanDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_PickBanDetails::InternalSwap(CMsgDOTARealtimeGameStats_PickBanDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_PickBanDetails, _impl_.team_)
      + sizeof(CMsgDOTARealtimeGameStats_PickBanDetails::_impl_.team_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_PickBanDetails, _impl_.hero_)>(
          reinterpret_cast<char*>(&_impl_.hero_),
          reinterpret_cast<char*>(&other->_impl_.hero_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_PickBanDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[45]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_MatchDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStats_MatchDetails>()._impl_._has_bits_);
  static void set_has_server_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time_of_day(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_nightstalker_night(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_game_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_game_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_teamid_radiant(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_teamid_dire(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_game_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_league_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_single_team(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_cheers_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_lobby_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_start_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

CMsgDOTARealtimeGameStats_MatchDetails::CMsgDOTARealtimeGameStats_MatchDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.MatchDetails)
}
CMsgDOTARealtimeGameStats_MatchDetails::CMsgDOTARealtimeGameStats_MatchDetails(const CMsgDOTARealtimeGameStats_MatchDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_MatchDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.picks_){from._impl_.picks_}
    , decltype(_impl_.bans_){from._impl_.bans_}
    , decltype(_impl_.kills_){from._impl_.kills_}
    , decltype(_impl_.broadcasters_){from._impl_.broadcasters_}
    , decltype(_impl_.server_steam_id_){}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.time_of_day_){}
    , decltype(_impl_.game_time_){}
    , decltype(_impl_.teamid_radiant_){}
    , decltype(_impl_.teamid_dire_){}
    , decltype(_impl_.is_nightstalker_night_){}
    , decltype(_impl_.single_team_){}
    , decltype(_impl_.game_mode_){}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.cheers_peak_){}
    , decltype(_impl_.league_node_id_){}
    , decltype(_impl_.game_state_){}
    , decltype(_impl_.lobby_type_){}
    , decltype(_impl_.start_timestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.server_steam_id_, &from._impl_.server_steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.start_timestamp_) -
    reinterpret_cast<char*>(&_impl_.server_steam_id_)) + sizeof(_impl_.start_timestamp_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.MatchDetails)
}

inline void CMsgDOTARealtimeGameStats_MatchDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.picks_){arena}
    , decltype(_impl_.bans_){arena}
    , decltype(_impl_.kills_){arena}
    , decltype(_impl_.broadcasters_){arena}
    , decltype(_impl_.server_steam_id_){uint64_t{0u}}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.timestamp_){0u}
    , decltype(_impl_.time_of_day_){0}
    , decltype(_impl_.game_time_){0}
    , decltype(_impl_.teamid_radiant_){0u}
    , decltype(_impl_.teamid_dire_){0u}
    , decltype(_impl_.is_nightstalker_night_){false}
    , decltype(_impl_.single_team_){false}
    , decltype(_impl_.game_mode_){0u}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.cheers_peak_){0u}
    , decltype(_impl_.league_node_id_){0u}
    , decltype(_impl_.game_state_){0u}
    , decltype(_impl_.lobby_type_){0u}
    , decltype(_impl_.start_timestamp_){0u}
  };
}

CMsgDOTARealtimeGameStats_MatchDetails::~CMsgDOTARealtimeGameStats_MatchDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.MatchDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_MatchDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.picks_.~RepeatedPtrField();
  _impl_.bans_.~RepeatedPtrField();
  _impl_.kills_.~RepeatedPtrField();
  _impl_.broadcasters_.~RepeatedPtrField();
}

void CMsgDOTARealtimeGameStats_MatchDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_MatchDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.MatchDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.picks_.Clear();
  _impl_.bans_.Clear();
  _impl_.kills_.Clear();
  _impl_.broadcasters_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.server_steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_nightstalker_night_) -
        reinterpret_cast<char*>(&_impl_.server_steam_id_)) + sizeof(_impl_.is_nightstalker_night_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.single_team_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.start_timestamp_) -
        reinterpret_cast<char*>(&_impl_.single_team_)) + sizeof(_impl_.start_timestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_MatchDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 server_steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_server_steam_id(&has_bits);
          _impl_.server_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 match_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float time_of_day = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_time_of_day(&has_bits);
          _impl_.time_of_day_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_nightstalker_night = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_nightstalker_night(&has_bits);
          _impl_.is_nightstalker_night_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 game_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_game_time(&has_bits);
          _impl_.game_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 teamid_radiant = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_teamid_radiant(&has_bits);
          _impl_.teamid_radiant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 teamid_dire = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_teamid_dire(&has_bits);
          _impl_.teamid_dire_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.PickBanDetails picks = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_picks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.PickBanDetails bans = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bans(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.KillDetails kills = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_kills(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.BroadcasterDetails broadcasters = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_broadcasters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 game_mode = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_game_mode(&has_bits);
          _impl_.game_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league_id = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool single_team = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_single_team(&has_bits);
          _impl_.single_team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cheers_peak = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_cheers_peak(&has_bits);
          _impl_.cheers_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league_node_id = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_league_node_id(&has_bits);
          _impl_.league_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 game_state = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_game_state(&has_bits);
          _impl_.game_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lobby_type = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_lobby_type(&has_bits);
          _impl_.lobby_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start_timestamp = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_start_timestamp(&has_bits);
          _impl_.start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_MatchDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.MatchDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 server_steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_server_steam_id(), target);
  }

  // optional uint64 match_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_match_id(), target);
  }

  // optional uint32 timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_timestamp(), target);
  }

  // optional float time_of_day = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_time_of_day(), target);
  }

  // optional bool is_nightstalker_night = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_nightstalker_night(), target);
  }

  // optional int32 game_time = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_game_time(), target);
  }

  // optional uint32 teamid_radiant = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_teamid_radiant(), target);
  }

  // optional uint32 teamid_dire = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_teamid_dire(), target);
  }

  // repeated .CMsgDOTARealtimeGameStats.PickBanDetails picks = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_picks_size()); i < n; i++) {
    const auto& repfield = this->_internal_picks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTARealtimeGameStats.PickBanDetails bans = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bans_size()); i < n; i++) {
    const auto& repfield = this->_internal_bans(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTARealtimeGameStats.KillDetails kills = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_kills_size()); i < n; i++) {
    const auto& repfield = this->_internal_kills(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTARealtimeGameStats.BroadcasterDetails broadcasters = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_broadcasters_size()); i < n; i++) {
    const auto& repfield = this->_internal_broadcasters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 game_mode = 14;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_game_mode(), target);
  }

  // optional uint32 league_id = 15;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_league_id(), target);
  }

  // optional bool single_team = 16;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_single_team(), target);
  }

  // optional uint32 cheers_peak = 17;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_cheers_peak(), target);
  }

  // optional uint32 league_node_id = 18;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_league_node_id(), target);
  }

  // optional uint32 game_state = 19;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_game_state(), target);
  }

  // optional uint32 lobby_type = 20;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_lobby_type(), target);
  }

  // optional uint32 start_timestamp = 21;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_start_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.MatchDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStats_MatchDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.MatchDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTARealtimeGameStats.PickBanDetails picks = 10;
  total_size += 1UL * this->_internal_picks_size();
  for (const auto& msg : this->_impl_.picks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTARealtimeGameStats.PickBanDetails bans = 11;
  total_size += 1UL * this->_internal_bans_size();
  for (const auto& msg : this->_impl_.bans_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTARealtimeGameStats.KillDetails kills = 12;
  total_size += 1UL * this->_internal_kills_size();
  for (const auto& msg : this->_impl_.kills_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTARealtimeGameStats.BroadcasterDetails broadcasters = 13;
  total_size += 1UL * this->_internal_broadcasters_size();
  for (const auto& msg : this->_impl_.broadcasters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional fixed64 server_steam_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint64 match_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 timestamp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

    // optional float time_of_day = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 game_time = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_game_time());
    }

    // optional uint32 teamid_radiant = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_teamid_radiant());
    }

    // optional uint32 teamid_dire = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_teamid_dire());
    }

    // optional bool is_nightstalker_night = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool single_team = 16;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional uint32 game_mode = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_mode());
    }

    // optional uint32 league_id = 15;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional uint32 cheers_peak = 17;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_cheers_peak());
    }

    // optional uint32 league_node_id = 18;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_league_node_id());
    }

    // optional uint32 game_state = 19;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_game_state());
    }

    // optional uint32 lobby_type = 20;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_lobby_type());
    }

    // optional uint32 start_timestamp = 21;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_start_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_MatchDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_MatchDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_MatchDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_MatchDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_MatchDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_MatchDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.MatchDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.picks_.MergeFrom(from._impl_.picks_);
  _this->_impl_.bans_.MergeFrom(from._impl_.bans_);
  _this->_impl_.kills_.MergeFrom(from._impl_.kills_);
  _this->_impl_.broadcasters_.MergeFrom(from._impl_.broadcasters_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.server_steam_id_ = from._impl_.server_steam_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.time_of_day_ = from._impl_.time_of_day_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.game_time_ = from._impl_.game_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.teamid_radiant_ = from._impl_.teamid_radiant_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.teamid_dire_ = from._impl_.teamid_dire_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_nightstalker_night_ = from._impl_.is_nightstalker_night_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.single_team_ = from._impl_.single_team_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.game_mode_ = from._impl_.game_mode_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.cheers_peak_ = from._impl_.cheers_peak_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.league_node_id_ = from._impl_.league_node_id_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.game_state_ = from._impl_.game_state_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.lobby_type_ = from._impl_.lobby_type_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.start_timestamp_ = from._impl_.start_timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_MatchDetails::CopyFrom(const CMsgDOTARealtimeGameStats_MatchDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.MatchDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_MatchDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_MatchDetails::InternalSwap(CMsgDOTARealtimeGameStats_MatchDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.picks_.InternalSwap(&other->_impl_.picks_);
  _impl_.bans_.InternalSwap(&other->_impl_.bans_);
  _impl_.kills_.InternalSwap(&other->_impl_.kills_);
  _impl_.broadcasters_.InternalSwap(&other->_impl_.broadcasters_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_MatchDetails, _impl_.start_timestamp_)
      + sizeof(CMsgDOTARealtimeGameStats_MatchDetails::_impl_.start_timestamp_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats_MatchDetails, _impl_.server_steam_id_)>(
          reinterpret_cast<char*>(&_impl_.server_steam_id_),
          reinterpret_cast<char*>(&other->_impl_.server_steam_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_MatchDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[46]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_GraphData_LocationStats::_Internal {
 public:
};

CMsgDOTARealtimeGameStats_GraphData_LocationStats::CMsgDOTARealtimeGameStats_GraphData_LocationStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.GraphData.LocationStats)
}
CMsgDOTARealtimeGameStats_GraphData_LocationStats::CMsgDOTARealtimeGameStats_GraphData_LocationStats(const CMsgDOTARealtimeGameStats_GraphData_LocationStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_GraphData_LocationStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){from._impl_.stats_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.GraphData.LocationStats)
}

inline void CMsgDOTARealtimeGameStats_GraphData_LocationStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTARealtimeGameStats_GraphData_LocationStats::~CMsgDOTARealtimeGameStats_GraphData_LocationStats() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.GraphData.LocationStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_GraphData_LocationStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stats_.~RepeatedField();
}

void CMsgDOTARealtimeGameStats_GraphData_LocationStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_GraphData_LocationStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.GraphData.LocationStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stats_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_GraphData_LocationStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_stats(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_stats(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_GraphData_LocationStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.GraphData.LocationStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 stats = 1;
  for (int i = 0, n = this->_internal_stats_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_stats(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.GraphData.LocationStats)
  return target;
}

size_t CMsgDOTARealtimeGameStats_GraphData_LocationStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.GraphData.LocationStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 stats = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.stats_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_stats_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_GraphData_LocationStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_GraphData_LocationStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_GraphData_LocationStats::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_GraphData_LocationStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_GraphData_LocationStats*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_GraphData_LocationStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.GraphData.LocationStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stats_.MergeFrom(from._impl_.stats_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_GraphData_LocationStats::CopyFrom(const CMsgDOTARealtimeGameStats_GraphData_LocationStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.GraphData.LocationStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_GraphData_LocationStats::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_GraphData_LocationStats::InternalSwap(CMsgDOTARealtimeGameStats_GraphData_LocationStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.stats_.InternalSwap(&other->_impl_.stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_GraphData_LocationStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[47]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::_Internal {
 public:
};

CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats)
}
CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats(const CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.loc_stats_){from._impl_.loc_stats_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats)
}

inline void CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.loc_stats_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::~CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.loc_stats_.~RepeatedPtrField();
}

void CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.loc_stats_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTARealtimeGameStats.GraphData.LocationStats loc_stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_loc_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTARealtimeGameStats.GraphData.LocationStats loc_stats = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_loc_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_loc_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats)
  return target;
}

size_t CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTARealtimeGameStats.GraphData.LocationStats loc_stats = 1;
  total_size += 1UL * this->_internal_loc_stats_size();
  for (const auto& msg : this->_impl_.loc_stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.loc_stats_.MergeFrom(from._impl_.loc_stats_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::CopyFrom(const CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::InternalSwap(CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.loc_stats_.InternalSwap(&other->_impl_.loc_stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[48]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats_GraphData::_Internal {
 public:
};

CMsgDOTARealtimeGameStats_GraphData::CMsgDOTARealtimeGameStats_GraphData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats.GraphData)
}
CMsgDOTARealtimeGameStats_GraphData::CMsgDOTARealtimeGameStats_GraphData(const CMsgDOTARealtimeGameStats_GraphData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats_GraphData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.graph_gold_){from._impl_.graph_gold_}
    , decltype(_impl_.graph_xp_){from._impl_.graph_xp_}
    , decltype(_impl_.graph_kill_){from._impl_.graph_kill_}
    , decltype(_impl_.graph_tower_){from._impl_.graph_tower_}
    , decltype(_impl_.graph_rax_){from._impl_.graph_rax_}
    , decltype(_impl_.team_loc_stats_){from._impl_.team_loc_stats_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats.GraphData)
}

inline void CMsgDOTARealtimeGameStats_GraphData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.graph_gold_){arena}
    , decltype(_impl_.graph_xp_){arena}
    , decltype(_impl_.graph_kill_){arena}
    , decltype(_impl_.graph_tower_){arena}
    , decltype(_impl_.graph_rax_){arena}
    , decltype(_impl_.team_loc_stats_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTARealtimeGameStats_GraphData::~CMsgDOTARealtimeGameStats_GraphData() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats.GraphData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats_GraphData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.graph_gold_.~RepeatedField();
  _impl_.graph_xp_.~RepeatedField();
  _impl_.graph_kill_.~RepeatedField();
  _impl_.graph_tower_.~RepeatedField();
  _impl_.graph_rax_.~RepeatedField();
  _impl_.team_loc_stats_.~RepeatedPtrField();
}

void CMsgDOTARealtimeGameStats_GraphData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats_GraphData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats.GraphData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.graph_gold_.Clear();
  _impl_.graph_xp_.Clear();
  _impl_.graph_kill_.Clear();
  _impl_.graph_tower_.Clear();
  _impl_.graph_rax_.Clear();
  _impl_.team_loc_stats_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats_GraphData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 graph_gold = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_graph_gold(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_graph_gold(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 graph_xp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_graph_xp(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_graph_xp(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 graph_kill = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_graph_kill(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_graph_kill(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 graph_tower = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_graph_tower(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_graph_tower(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 graph_rax = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_graph_rax(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_graph_rax(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats team_loc_stats = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_team_loc_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats_GraphData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats.GraphData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 graph_gold = 1;
  for (int i = 0, n = this->_internal_graph_gold_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_graph_gold(i), target);
  }

  // repeated int32 graph_xp = 2;
  for (int i = 0, n = this->_internal_graph_xp_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_graph_xp(i), target);
  }

  // repeated int32 graph_kill = 3;
  for (int i = 0, n = this->_internal_graph_kill_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_graph_kill(i), target);
  }

  // repeated int32 graph_tower = 4;
  for (int i = 0, n = this->_internal_graph_tower_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_graph_tower(i), target);
  }

  // repeated int32 graph_rax = 5;
  for (int i = 0, n = this->_internal_graph_rax_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_graph_rax(i), target);
  }

  // repeated .CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats team_loc_stats = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_team_loc_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_team_loc_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats.GraphData)
  return target;
}

size_t CMsgDOTARealtimeGameStats_GraphData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats.GraphData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 graph_gold = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.graph_gold_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_graph_gold_size());
    total_size += data_size;
  }

  // repeated int32 graph_xp = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.graph_xp_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_graph_xp_size());
    total_size += data_size;
  }

  // repeated int32 graph_kill = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.graph_kill_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_graph_kill_size());
    total_size += data_size;
  }

  // repeated int32 graph_tower = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.graph_tower_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_graph_tower_size());
    total_size += data_size;
  }

  // repeated int32 graph_rax = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.graph_rax_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_graph_rax_size());
    total_size += data_size;
  }

  // repeated .CMsgDOTARealtimeGameStats.GraphData.TeamLocationStats team_loc_stats = 6;
  total_size += 1UL * this->_internal_team_loc_stats_size();
  for (const auto& msg : this->_impl_.team_loc_stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats_GraphData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats_GraphData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats_GraphData::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats_GraphData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats_GraphData*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats_GraphData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats.GraphData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.graph_gold_.MergeFrom(from._impl_.graph_gold_);
  _this->_impl_.graph_xp_.MergeFrom(from._impl_.graph_xp_);
  _this->_impl_.graph_kill_.MergeFrom(from._impl_.graph_kill_);
  _this->_impl_.graph_tower_.MergeFrom(from._impl_.graph_tower_);
  _this->_impl_.graph_rax_.MergeFrom(from._impl_.graph_rax_);
  _this->_impl_.team_loc_stats_.MergeFrom(from._impl_.team_loc_stats_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats_GraphData::CopyFrom(const CMsgDOTARealtimeGameStats_GraphData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats.GraphData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats_GraphData::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats_GraphData::InternalSwap(CMsgDOTARealtimeGameStats_GraphData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.graph_gold_.InternalSwap(&other->_impl_.graph_gold_);
  _impl_.graph_xp_.InternalSwap(&other->_impl_.graph_xp_);
  _impl_.graph_kill_.InternalSwap(&other->_impl_.graph_kill_);
  _impl_.graph_tower_.InternalSwap(&other->_impl_.graph_tower_);
  _impl_.graph_rax_.InternalSwap(&other->_impl_.graph_rax_);
  _impl_.team_loc_stats_.InternalSwap(&other->_impl_.team_loc_stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats_GraphData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[49]);
}

// ===================================================================

class CMsgDOTARealtimeGameStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStats>()._impl_._has_bits_);
  static const ::CMsgDOTARealtimeGameStats_MatchDetails& match(const CMsgDOTARealtimeGameStats* msg);
  static void set_has_match(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgDOTARealtimeGameStats_GraphData& graph_data(const CMsgDOTARealtimeGameStats* msg);
  static void set_has_graph_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_delta_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgDOTARealtimeGameStats_MatchDetails&
CMsgDOTARealtimeGameStats::_Internal::match(const CMsgDOTARealtimeGameStats* msg) {
  return *msg->_impl_.match_;
}
const ::CMsgDOTARealtimeGameStats_GraphData&
CMsgDOTARealtimeGameStats::_Internal::graph_data(const CMsgDOTARealtimeGameStats* msg) {
  return *msg->_impl_.graph_data_;
}
CMsgDOTARealtimeGameStats::CMsgDOTARealtimeGameStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStats)
}
CMsgDOTARealtimeGameStats::CMsgDOTARealtimeGameStats(const CMsgDOTARealtimeGameStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teams_){from._impl_.teams_}
    , decltype(_impl_.buildings_){from._impl_.buildings_}
    , decltype(_impl_.match_){nullptr}
    , decltype(_impl_.graph_data_){nullptr}
    , decltype(_impl_.delta_frame_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_match()) {
    _this->_impl_.match_ = new ::CMsgDOTARealtimeGameStats_MatchDetails(*from._impl_.match_);
  }
  if (from._internal_has_graph_data()) {
    _this->_impl_.graph_data_ = new ::CMsgDOTARealtimeGameStats_GraphData(*from._impl_.graph_data_);
  }
  _this->_impl_.delta_frame_ = from._impl_.delta_frame_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStats)
}

inline void CMsgDOTARealtimeGameStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teams_){arena}
    , decltype(_impl_.buildings_){arena}
    , decltype(_impl_.match_){nullptr}
    , decltype(_impl_.graph_data_){nullptr}
    , decltype(_impl_.delta_frame_){false}
  };
}

CMsgDOTARealtimeGameStats::~CMsgDOTARealtimeGameStats() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.teams_.~RepeatedPtrField();
  _impl_.buildings_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.match_;
  if (this != internal_default_instance()) delete _impl_.graph_data_;
}

void CMsgDOTARealtimeGameStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.teams_.Clear();
  _impl_.buildings_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.match_ != nullptr);
      _impl_.match_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.graph_data_ != nullptr);
      _impl_.graph_data_->Clear();
    }
  }
  _impl_.delta_frame_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgDOTARealtimeGameStats.MatchDetails match = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.TeamDetails teams = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_teams(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStats.BuildingDetails buildings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buildings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTARealtimeGameStats.GraphData graph_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_graph_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool delta_frame = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_delta_frame(&has_bits);
          _impl_.delta_frame_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgDOTARealtimeGameStats.MatchDetails match = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::match(this),
        _Internal::match(this).GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTARealtimeGameStats.TeamDetails teams = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_teams_size()); i < n; i++) {
    const auto& repfield = this->_internal_teams(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTARealtimeGameStats.BuildingDetails buildings = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buildings_size()); i < n; i++) {
    const auto& repfield = this->_internal_buildings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .CMsgDOTARealtimeGameStats.GraphData graph_data = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::graph_data(this),
        _Internal::graph_data(this).GetCachedSize(), target, stream);
  }

  // optional bool delta_frame = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_delta_frame(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStats)
  return target;
}

size_t CMsgDOTARealtimeGameStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTARealtimeGameStats.TeamDetails teams = 2;
  total_size += 1UL * this->_internal_teams_size();
  for (const auto& msg : this->_impl_.teams_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTARealtimeGameStats.BuildingDetails buildings = 3;
  total_size += 1UL * this->_internal_buildings_size();
  for (const auto& msg : this->_impl_.buildings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgDOTARealtimeGameStats.MatchDetails match = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.match_);
    }

    // optional .CMsgDOTARealtimeGameStats.GraphData graph_data = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.graph_data_);
    }

    // optional bool delta_frame = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStats::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStats*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.teams_.MergeFrom(from._impl_.teams_);
  _this->_impl_.buildings_.MergeFrom(from._impl_.buildings_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_match()->::CMsgDOTARealtimeGameStats_MatchDetails::MergeFrom(
          from._internal_match());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_graph_data()->::CMsgDOTARealtimeGameStats_GraphData::MergeFrom(
          from._internal_graph_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.delta_frame_ = from._impl_.delta_frame_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStats::CopyFrom(const CMsgDOTARealtimeGameStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStats::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStats::InternalSwap(CMsgDOTARealtimeGameStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.teams_.InternalSwap(&other->_impl_.teams_);
  _impl_.buildings_.InternalSwap(&other->_impl_.buildings_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats, _impl_.delta_frame_)
      + sizeof(CMsgDOTARealtimeGameStats::_impl_.delta_frame_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStats, _impl_.match_)>(
          reinterpret_cast<char*>(&_impl_.match_),
          reinterpret_cast<char*>(&other->_impl_.match_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[50]);
}

// ===================================================================

class CMsgDOTARealtimeGameStatsTerse_TeamDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStatsTerse_TeamDetails>()._impl_._has_bits_);
  static void set_has_team_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_net_worth(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_team_logo_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDOTARealtimeGameStatsTerse_TeamDetails::CMsgDOTARealtimeGameStatsTerse_TeamDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStatsTerse.TeamDetails)
}
CMsgDOTARealtimeGameStatsTerse_TeamDetails::CMsgDOTARealtimeGameStatsTerse_TeamDetails(const CMsgDOTARealtimeGameStatsTerse_TeamDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStatsTerse_TeamDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.players_){from._impl_.players_}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_tag_){}
    , decltype(_impl_.team_logo_url_){}
    , decltype(_impl_.team_number_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.team_logo_){}
    , decltype(_impl_.score_){}
    , decltype(_impl_.net_worth_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_name()) {
    _this->_impl_.team_name_.Set(from._internal_team_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_tag()) {
    _this->_impl_.team_tag_.Set(from._internal_team_tag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_team_logo_url()) {
    _this->_impl_.team_logo_url_.Set(from._internal_team_logo_url(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.team_number_, &from._impl_.team_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.net_worth_) -
    reinterpret_cast<char*>(&_impl_.team_number_)) + sizeof(_impl_.net_worth_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStatsTerse.TeamDetails)
}

inline void CMsgDOTARealtimeGameStatsTerse_TeamDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.players_){arena}
    , decltype(_impl_.team_name_){}
    , decltype(_impl_.team_tag_){}
    , decltype(_impl_.team_logo_url_){}
    , decltype(_impl_.team_number_){0u}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.team_logo_){uint64_t{0u}}
    , decltype(_impl_.score_){0u}
    , decltype(_impl_.net_worth_){0u}
  };
  _impl_.team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTARealtimeGameStatsTerse_TeamDetails::~CMsgDOTARealtimeGameStatsTerse_TeamDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStatsTerse.TeamDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStatsTerse_TeamDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.players_.~RepeatedPtrField();
  _impl_.team_name_.Destroy();
  _impl_.team_tag_.Destroy();
  _impl_.team_logo_url_.Destroy();
}

void CMsgDOTARealtimeGameStatsTerse_TeamDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStatsTerse_TeamDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStatsTerse.TeamDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.players_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.team_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.team_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.team_logo_url_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.team_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.net_worth_) -
        reinterpret_cast<char*>(&_impl_.team_number_)) + sizeof(_impl_.net_worth_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStatsTerse_TeamDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 team_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_team_number(&has_bits);
          _impl_.team_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 team_logo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_team_logo(&has_bits);
          _impl_.team_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 score = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_score(&has_bits);
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStatsTerse.PlayerDetails players = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 net_worth = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_net_worth(&has_bits);
          _impl_.net_worth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string team_tag = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_team_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string team_logo_url = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_team_logo_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_logo_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStatsTerse_TeamDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStatsTerse.TeamDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 team_number = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_team_number(), target);
  }

  // optional uint32 team_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_team_id(), target);
  }

  // optional string team_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_name().data(), static_cast<int>(this->_internal_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_team_name(), target);
  }

  // optional fixed64 team_logo = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_team_logo(), target);
  }

  // optional uint32 score = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_score(), target);
  }

  // repeated .CMsgDOTARealtimeGameStatsTerse.PlayerDetails players = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 net_worth = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_net_worth(), target);
  }

  // optional string team_tag = 8;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_tag().data(), static_cast<int>(this->_internal_team_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_tag");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_team_tag(), target);
  }

  // optional string team_logo_url = 9;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_team_logo_url().data(), static_cast<int>(this->_internal_team_logo_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTARealtimeGameStatsTerse.TeamDetails.team_logo_url");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_team_logo_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStatsTerse.TeamDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStatsTerse_TeamDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStatsTerse.TeamDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTARealtimeGameStatsTerse.PlayerDetails players = 6;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->_impl_.players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string team_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_name());
    }

    // optional string team_tag = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_tag());
    }

    // optional string team_logo_url = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_team_logo_url());
    }

    // optional uint32 team_number = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_number());
    }

    // optional uint32 team_id = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional fixed64 team_logo = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint32 score = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_score());
    }

    // optional uint32 net_worth = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_net_worth());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStatsTerse_TeamDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStatsTerse_TeamDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStatsTerse_TeamDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStatsTerse_TeamDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStatsTerse_TeamDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStatsTerse_TeamDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStatsTerse.TeamDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_team_name(from._internal_team_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_team_tag(from._internal_team_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_team_logo_url(from._internal_team_logo_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_number_ = from._impl_.team_number_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.team_logo_ = from._impl_.team_logo_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.score_ = from._impl_.score_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.net_worth_ = from._impl_.net_worth_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStatsTerse_TeamDetails::CopyFrom(const CMsgDOTARealtimeGameStatsTerse_TeamDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStatsTerse.TeamDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStatsTerse_TeamDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStatsTerse_TeamDetails::InternalSwap(CMsgDOTARealtimeGameStatsTerse_TeamDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_name_, lhs_arena,
      &other->_impl_.team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_tag_, lhs_arena,
      &other->_impl_.team_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.team_logo_url_, lhs_arena,
      &other->_impl_.team_logo_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStatsTerse_TeamDetails, _impl_.net_worth_)
      + sizeof(CMsgDOTARealtimeGameStatsTerse_TeamDetails::_impl_.net_worth_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStatsTerse_TeamDetails, _impl_.team_number_)>(
          reinterpret_cast<char*>(&_impl_.team_number_),
          reinterpret_cast<char*>(&other->_impl_.team_number_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStatsTerse_TeamDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[51]);
}

// ===================================================================

class CMsgDOTARealtimeGameStatsTerse_PlayerDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStatsTerse_PlayerDetails>()._impl_._has_bits_);
  static void set_has_accountid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heroid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_kill_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_death_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_assists_count(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_denies_count(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_lh_count(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_net_worth(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

CMsgDOTARealtimeGameStatsTerse_PlayerDetails::CMsgDOTARealtimeGameStatsTerse_PlayerDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStatsTerse.PlayerDetails)
}
CMsgDOTARealtimeGameStatsTerse_PlayerDetails::CMsgDOTARealtimeGameStatsTerse_PlayerDetails(const CMsgDOTARealtimeGameStatsTerse_PlayerDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStatsTerse_PlayerDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.abilities_){from._impl_.abilities_}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.accountid_){}
    , decltype(_impl_.team_){}
    , decltype(_impl_.heroid_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.kill_count_){}
    , decltype(_impl_.death_count_){}
    , decltype(_impl_.assists_count_){}
    , decltype(_impl_.denies_count_){}
    , decltype(_impl_.lh_count_){}
    , decltype(_impl_.gold_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.net_worth_){}
    , decltype(_impl_.playerid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.playerid_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.playerid_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStatsTerse.PlayerDetails)
}

inline void CMsgDOTARealtimeGameStatsTerse_PlayerDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.abilities_){arena}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.accountid_){0u}
    , decltype(_impl_.team_){0u}
    , decltype(_impl_.heroid_){0u}
    , decltype(_impl_.level_){0u}
    , decltype(_impl_.kill_count_){0u}
    , decltype(_impl_.death_count_){0u}
    , decltype(_impl_.assists_count_){0u}
    , decltype(_impl_.denies_count_){0u}
    , decltype(_impl_.lh_count_){0u}
    , decltype(_impl_.gold_){0u}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.net_worth_){0u}
    , decltype(_impl_.playerid_){-1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTARealtimeGameStatsTerse_PlayerDetails::~CMsgDOTARealtimeGameStatsTerse_PlayerDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStatsTerse.PlayerDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStatsTerse_PlayerDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.abilities_.~RepeatedField();
  _impl_.items_.~RepeatedField();
  _impl_.name_.Destroy();
}

void CMsgDOTARealtimeGameStatsTerse_PlayerDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStatsTerse_PlayerDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStatsTerse.PlayerDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.abilities_.Clear();
  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.assists_count_) -
        reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.assists_count_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.denies_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.net_worth_) -
        reinterpret_cast<char*>(&_impl_.denies_count_)) + sizeof(_impl_.net_worth_));
    _impl_.playerid_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStatsTerse_PlayerDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 accountid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_accountid(&has_bits);
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 playerid = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playerid(&has_bits);
          _impl_.playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTARealtimeGameStatsTerse.PlayerDetails.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_team(&has_bits);
          _impl_.team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 heroid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_heroid(&has_bits);
          _impl_.heroid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 kill_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_kill_count(&has_bits);
          _impl_.kill_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 death_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_death_count(&has_bits);
          _impl_.death_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assists_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_assists_count(&has_bits);
          _impl_.assists_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 denies_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_denies_count(&has_bits);
          _impl_.denies_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lh_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_lh_count(&has_bits);
          _impl_.lh_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gold = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_gold(&has_bits);
          _impl_.gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float x = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 net_worth = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_net_worth(&has_bits);
          _impl_.net_worth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 abilities = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_abilities(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<128>(ptr));
        } else if (static_cast<uint8_t>(tag) == 130) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_abilities(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 items = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_items(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<136>(ptr));
        } else if (static_cast<uint8_t>(tag) == 138) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_items(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStatsTerse_PlayerDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStatsTerse.PlayerDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 accountid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_accountid(), target);
  }

  // optional int32 playerid = 2 [default = -1];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_playerid(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTARealtimeGameStatsTerse.PlayerDetails.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional uint32 team = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_team(), target);
  }

  // optional uint32 heroid = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_heroid(), target);
  }

  // optional uint32 level = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_level(), target);
  }

  // optional uint32 kill_count = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_kill_count(), target);
  }

  // optional uint32 death_count = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_death_count(), target);
  }

  // optional uint32 assists_count = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_assists_count(), target);
  }

  // optional uint32 denies_count = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_denies_count(), target);
  }

  // optional uint32 lh_count = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_lh_count(), target);
  }

  // optional uint32 gold = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_gold(), target);
  }

  // optional float x = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_x(), target);
  }

  // optional float y = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_y(), target);
  }

  // optional uint32 net_worth = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_net_worth(), target);
  }

  // repeated int32 abilities = 16;
  for (int i = 0, n = this->_internal_abilities_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_abilities(i), target);
  }

  // repeated int32 items = 17;
  for (int i = 0, n = this->_internal_items_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_items(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStatsTerse.PlayerDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStatsTerse_PlayerDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStatsTerse.PlayerDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 abilities = 16;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.abilities_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_abilities_size());
    total_size += data_size;
  }

  // repeated int32 items = 17;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.items_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_items_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 accountid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_accountid());
    }

    // optional uint32 team = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team());
    }

    // optional uint32 heroid = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_heroid());
    }

    // optional uint32 level = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
    }

    // optional uint32 kill_count = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_kill_count());
    }

    // optional uint32 death_count = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_death_count());
    }

    // optional uint32 assists_count = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_assists_count());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional uint32 denies_count = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_denies_count());
    }

    // optional uint32 lh_count = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lh_count());
    }

    // optional uint32 gold = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gold());
    }

    // optional float x = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional float y = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional uint32 net_worth = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_net_worth());
    }

    // optional int32 playerid = 2 [default = -1];
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playerid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStatsTerse_PlayerDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStatsTerse_PlayerDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStatsTerse_PlayerDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStatsTerse_PlayerDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStatsTerse_PlayerDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStatsTerse_PlayerDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStatsTerse.PlayerDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.abilities_.MergeFrom(from._impl_.abilities_);
  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.accountid_ = from._impl_.accountid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.team_ = from._impl_.team_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.heroid_ = from._impl_.heroid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.kill_count_ = from._impl_.kill_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.death_count_ = from._impl_.death_count_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.assists_count_ = from._impl_.assists_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.denies_count_ = from._impl_.denies_count_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.lh_count_ = from._impl_.lh_count_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.gold_ = from._impl_.gold_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.net_worth_ = from._impl_.net_worth_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.playerid_ = from._impl_.playerid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStatsTerse_PlayerDetails::CopyFrom(const CMsgDOTARealtimeGameStatsTerse_PlayerDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStatsTerse.PlayerDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStatsTerse_PlayerDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStatsTerse_PlayerDetails::InternalSwap(CMsgDOTARealtimeGameStatsTerse_PlayerDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.abilities_.InternalSwap(&other->_impl_.abilities_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.net_worth_)
      + sizeof(CMsgDOTARealtimeGameStatsTerse_PlayerDetails::_impl_.net_worth_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStatsTerse_PlayerDetails, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
  swap(_impl_.playerid_, other->_impl_.playerid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStatsTerse_PlayerDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[52]);
}

// ===================================================================

class CMsgDOTARealtimeGameStatsTerse_BuildingDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStatsTerse_BuildingDetails>()._impl_._has_bits_);
  static void set_has_team(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_heading(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lane(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_destroyed(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgDOTARealtimeGameStatsTerse_BuildingDetails::CMsgDOTARealtimeGameStatsTerse_BuildingDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStatsTerse.BuildingDetails)
}
CMsgDOTARealtimeGameStatsTerse_BuildingDetails::CMsgDOTARealtimeGameStatsTerse_BuildingDetails(const CMsgDOTARealtimeGameStatsTerse_BuildingDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStatsTerse_BuildingDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_){}
    , decltype(_impl_.heading_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.lane_){}
    , decltype(_impl_.tier_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.destroyed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.team_, &from._impl_.team_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.destroyed_) -
    reinterpret_cast<char*>(&_impl_.team_)) + sizeof(_impl_.destroyed_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStatsTerse.BuildingDetails)
}

inline void CMsgDOTARealtimeGameStatsTerse_BuildingDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_){0u}
    , decltype(_impl_.heading_){0}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.lane_){0u}
    , decltype(_impl_.tier_){0u}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.destroyed_){false}
  };
}

CMsgDOTARealtimeGameStatsTerse_BuildingDetails::~CMsgDOTARealtimeGameStatsTerse_BuildingDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStatsTerse.BuildingDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStatsTerse_BuildingDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTARealtimeGameStatsTerse_BuildingDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStatsTerse_BuildingDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStatsTerse.BuildingDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.team_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.destroyed_) -
        reinterpret_cast<char*>(&_impl_.team_)) + sizeof(_impl_.destroyed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStatsTerse_BuildingDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 team = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_team(&has_bits);
          _impl_.team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float heading = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_heading(&has_bits);
          _impl_.heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lane = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_lane(&has_bits);
          _impl_.lane_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_tier(&has_bits);
          _impl_.tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float x = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool destroyed = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_destroyed(&has_bits);
          _impl_.destroyed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStatsTerse_BuildingDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStatsTerse.BuildingDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 team = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_team(), target);
  }

  // optional float heading = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_heading(), target);
  }

  // optional uint32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_type(), target);
  }

  // optional uint32 lane = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_lane(), target);
  }

  // optional uint32 tier = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_tier(), target);
  }

  // optional float x = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_x(), target);
  }

  // optional float y = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_y(), target);
  }

  // optional bool destroyed = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_destroyed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStatsTerse.BuildingDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStatsTerse_BuildingDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStatsTerse.BuildingDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 team = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team());
    }

    // optional float heading = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

    // optional uint32 lane = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lane());
    }

    // optional uint32 tier = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tier());
    }

    // optional float x = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float y = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional bool destroyed = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStatsTerse_BuildingDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStatsTerse_BuildingDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStatsTerse_BuildingDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStatsTerse_BuildingDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStatsTerse_BuildingDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStatsTerse_BuildingDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStatsTerse.BuildingDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.team_ = from._impl_.team_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.heading_ = from._impl_.heading_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.lane_ = from._impl_.lane_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tier_ = from._impl_.tier_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.destroyed_ = from._impl_.destroyed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStatsTerse_BuildingDetails::CopyFrom(const CMsgDOTARealtimeGameStatsTerse_BuildingDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStatsTerse.BuildingDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStatsTerse_BuildingDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStatsTerse_BuildingDetails::InternalSwap(CMsgDOTARealtimeGameStatsTerse_BuildingDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStatsTerse_BuildingDetails, _impl_.destroyed_)
      + sizeof(CMsgDOTARealtimeGameStatsTerse_BuildingDetails::_impl_.destroyed_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStatsTerse_BuildingDetails, _impl_.team_)>(
          reinterpret_cast<char*>(&_impl_.team_),
          reinterpret_cast<char*>(&other->_impl_.team_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStatsTerse_BuildingDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[53]);
}

// ===================================================================

class CMsgDOTARealtimeGameStatsTerse_PickBanDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStatsTerse_PickBanDetails>()._impl_._has_bits_);
  static void set_has_hero(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTARealtimeGameStatsTerse_PickBanDetails::CMsgDOTARealtimeGameStatsTerse_PickBanDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStatsTerse.PickBanDetails)
}
CMsgDOTARealtimeGameStatsTerse_PickBanDetails::CMsgDOTARealtimeGameStatsTerse_PickBanDetails(const CMsgDOTARealtimeGameStatsTerse_PickBanDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStatsTerse_PickBanDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_){}
    , decltype(_impl_.team_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hero_, &from._impl_.hero_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.team_) -
    reinterpret_cast<char*>(&_impl_.hero_)) + sizeof(_impl_.team_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStatsTerse.PickBanDetails)
}

inline void CMsgDOTARealtimeGameStatsTerse_PickBanDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_){0u}
    , decltype(_impl_.team_){0u}
  };
}

CMsgDOTARealtimeGameStatsTerse_PickBanDetails::~CMsgDOTARealtimeGameStatsTerse_PickBanDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStatsTerse.PickBanDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStatsTerse_PickBanDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTARealtimeGameStatsTerse_PickBanDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStatsTerse_PickBanDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStatsTerse.PickBanDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.hero_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.team_) -
        reinterpret_cast<char*>(&_impl_.hero_)) + sizeof(_impl_.team_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStatsTerse_PickBanDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 hero = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero(&has_bits);
          _impl_.hero_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team(&has_bits);
          _impl_.team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStatsTerse_PickBanDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStatsTerse.PickBanDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 hero = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hero(), target);
  }

  // optional uint32 team = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_team(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStatsTerse.PickBanDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStatsTerse_PickBanDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStatsTerse.PickBanDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 hero = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero());
    }

    // optional uint32 team = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStatsTerse_PickBanDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStatsTerse_PickBanDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStatsTerse_PickBanDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStatsTerse_PickBanDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStatsTerse_PickBanDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStatsTerse_PickBanDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStatsTerse.PickBanDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.hero_ = from._impl_.hero_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.team_ = from._impl_.team_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStatsTerse_PickBanDetails::CopyFrom(const CMsgDOTARealtimeGameStatsTerse_PickBanDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStatsTerse.PickBanDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStatsTerse_PickBanDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStatsTerse_PickBanDetails::InternalSwap(CMsgDOTARealtimeGameStatsTerse_PickBanDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStatsTerse_PickBanDetails, _impl_.team_)
      + sizeof(CMsgDOTARealtimeGameStatsTerse_PickBanDetails::_impl_.team_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStatsTerse_PickBanDetails, _impl_.hero_)>(
          reinterpret_cast<char*>(&_impl_.hero_),
          reinterpret_cast<char*>(&other->_impl_.hero_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStatsTerse_PickBanDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[54]);
}

// ===================================================================

class CMsgDOTARealtimeGameStatsTerse_MatchDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStatsTerse_MatchDetails>()._impl_._has_bits_);
  static void set_has_server_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_game_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_game_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_league_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_game_state(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_lobby_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_start_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

CMsgDOTARealtimeGameStatsTerse_MatchDetails::CMsgDOTARealtimeGameStatsTerse_MatchDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStatsTerse.MatchDetails)
}
CMsgDOTARealtimeGameStatsTerse_MatchDetails::CMsgDOTARealtimeGameStatsTerse_MatchDetails(const CMsgDOTARealtimeGameStatsTerse_MatchDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStatsTerse_MatchDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_broadcaster_account_ids_){from._impl_.steam_broadcaster_account_ids_}
    , decltype(_impl_.picks_){from._impl_.picks_}
    , decltype(_impl_.bans_){from._impl_.bans_}
    , decltype(_impl_.server_steam_id_){}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.game_time_){}
    , decltype(_impl_.game_mode_){}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.league_node_id_){}
    , decltype(_impl_.game_state_){}
    , decltype(_impl_.lobby_type_){}
    , decltype(_impl_.start_timestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.server_steam_id_, &from._impl_.server_steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.start_timestamp_) -
    reinterpret_cast<char*>(&_impl_.server_steam_id_)) + sizeof(_impl_.start_timestamp_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStatsTerse.MatchDetails)
}

inline void CMsgDOTARealtimeGameStatsTerse_MatchDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_broadcaster_account_ids_){arena}
    , decltype(_impl_.picks_){arena}
    , decltype(_impl_.bans_){arena}
    , decltype(_impl_.server_steam_id_){uint64_t{0u}}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.timestamp_){0u}
    , decltype(_impl_.game_time_){0}
    , decltype(_impl_.game_mode_){0u}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.league_node_id_){0u}
    , decltype(_impl_.game_state_){0u}
    , decltype(_impl_.lobby_type_){0u}
    , decltype(_impl_.start_timestamp_){0u}
  };
}

CMsgDOTARealtimeGameStatsTerse_MatchDetails::~CMsgDOTARealtimeGameStatsTerse_MatchDetails() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStatsTerse.MatchDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStatsTerse_MatchDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.steam_broadcaster_account_ids_.~RepeatedField();
  _impl_.picks_.~RepeatedPtrField();
  _impl_.bans_.~RepeatedPtrField();
}

void CMsgDOTARealtimeGameStatsTerse_MatchDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStatsTerse_MatchDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStatsTerse.MatchDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steam_broadcaster_account_ids_.Clear();
  _impl_.picks_.Clear();
  _impl_.bans_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.server_steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.game_state_) -
        reinterpret_cast<char*>(&_impl_.server_steam_id_)) + sizeof(_impl_.game_state_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.lobby_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.start_timestamp_) -
        reinterpret_cast<char*>(&_impl_.lobby_type_)) + sizeof(_impl_.start_timestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStatsTerse_MatchDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 server_steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_server_steam_id(&has_bits);
          _impl_.server_steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 match_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 game_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_game_time(&has_bits);
          _impl_.game_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 steam_broadcaster_account_ids = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_steam_broadcaster_account_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_steam_broadcaster_account_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 game_mode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_game_mode(&has_bits);
          _impl_.game_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league_node_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_league_node_id(&has_bits);
          _impl_.league_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 game_state = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_game_state(&has_bits);
          _impl_.game_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStatsTerse.PickBanDetails picks = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_picks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStatsTerse.PickBanDetails bans = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bans(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lobby_type = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_lobby_type(&has_bits);
          _impl_.lobby_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start_timestamp = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_start_timestamp(&has_bits);
          _impl_.start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStatsTerse_MatchDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStatsTerse.MatchDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 server_steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_server_steam_id(), target);
  }

  // optional uint64 match_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_match_id(), target);
  }

  // optional uint32 timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_timestamp(), target);
  }

  // optional int32 game_time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_game_time(), target);
  }

  // repeated uint32 steam_broadcaster_account_ids = 6;
  for (int i = 0, n = this->_internal_steam_broadcaster_account_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_steam_broadcaster_account_ids(i), target);
  }

  // optional uint32 game_mode = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_game_mode(), target);
  }

  // optional uint32 league_id = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_league_id(), target);
  }

  // optional uint32 league_node_id = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_league_node_id(), target);
  }

  // optional uint32 game_state = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_game_state(), target);
  }

  // repeated .CMsgDOTARealtimeGameStatsTerse.PickBanDetails picks = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_picks_size()); i < n; i++) {
    const auto& repfield = this->_internal_picks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTARealtimeGameStatsTerse.PickBanDetails bans = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bans_size()); i < n; i++) {
    const auto& repfield = this->_internal_bans(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 lobby_type = 13;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_lobby_type(), target);
  }

  // optional uint32 start_timestamp = 14;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_start_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStatsTerse.MatchDetails)
  return target;
}

size_t CMsgDOTARealtimeGameStatsTerse_MatchDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStatsTerse.MatchDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 steam_broadcaster_account_ids = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.steam_broadcaster_account_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_steam_broadcaster_account_ids_size());
    total_size += data_size;
  }

  // repeated .CMsgDOTARealtimeGameStatsTerse.PickBanDetails picks = 11;
  total_size += 1UL * this->_internal_picks_size();
  for (const auto& msg : this->_impl_.picks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTARealtimeGameStatsTerse.PickBanDetails bans = 12;
  total_size += 1UL * this->_internal_bans_size();
  for (const auto& msg : this->_impl_.bans_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional fixed64 server_steam_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint64 match_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 timestamp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

    // optional int32 game_time = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_game_time());
    }

    // optional uint32 game_mode = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_mode());
    }

    // optional uint32 league_id = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional uint32 league_node_id = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_node_id());
    }

    // optional uint32 game_state = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_state());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 lobby_type = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lobby_type());
    }

    // optional uint32 start_timestamp = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStatsTerse_MatchDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStatsTerse_MatchDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStatsTerse_MatchDetails::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStatsTerse_MatchDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStatsTerse_MatchDetails*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStatsTerse_MatchDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStatsTerse.MatchDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.steam_broadcaster_account_ids_.MergeFrom(from._impl_.steam_broadcaster_account_ids_);
  _this->_impl_.picks_.MergeFrom(from._impl_.picks_);
  _this->_impl_.bans_.MergeFrom(from._impl_.bans_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.server_steam_id_ = from._impl_.server_steam_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.game_time_ = from._impl_.game_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.game_mode_ = from._impl_.game_mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.league_node_id_ = from._impl_.league_node_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.game_state_ = from._impl_.game_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.lobby_type_ = from._impl_.lobby_type_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.start_timestamp_ = from._impl_.start_timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStatsTerse_MatchDetails::CopyFrom(const CMsgDOTARealtimeGameStatsTerse_MatchDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStatsTerse.MatchDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStatsTerse_MatchDetails::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStatsTerse_MatchDetails::InternalSwap(CMsgDOTARealtimeGameStatsTerse_MatchDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.steam_broadcaster_account_ids_.InternalSwap(&other->_impl_.steam_broadcaster_account_ids_);
  _impl_.picks_.InternalSwap(&other->_impl_.picks_);
  _impl_.bans_.InternalSwap(&other->_impl_.bans_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.start_timestamp_)
      + sizeof(CMsgDOTARealtimeGameStatsTerse_MatchDetails::_impl_.start_timestamp_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStatsTerse_MatchDetails, _impl_.server_steam_id_)>(
          reinterpret_cast<char*>(&_impl_.server_steam_id_),
          reinterpret_cast<char*>(&other->_impl_.server_steam_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStatsTerse_MatchDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[55]);
}

// ===================================================================

class CMsgDOTARealtimeGameStatsTerse_GraphData::_Internal {
 public:
};

CMsgDOTARealtimeGameStatsTerse_GraphData::CMsgDOTARealtimeGameStatsTerse_GraphData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStatsTerse.GraphData)
}
CMsgDOTARealtimeGameStatsTerse_GraphData::CMsgDOTARealtimeGameStatsTerse_GraphData(const CMsgDOTARealtimeGameStatsTerse_GraphData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStatsTerse_GraphData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.graph_gold_){from._impl_.graph_gold_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStatsTerse.GraphData)
}

inline void CMsgDOTARealtimeGameStatsTerse_GraphData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.graph_gold_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTARealtimeGameStatsTerse_GraphData::~CMsgDOTARealtimeGameStatsTerse_GraphData() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStatsTerse.GraphData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStatsTerse_GraphData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.graph_gold_.~RepeatedField();
}

void CMsgDOTARealtimeGameStatsTerse_GraphData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStatsTerse_GraphData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStatsTerse.GraphData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.graph_gold_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStatsTerse_GraphData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 graph_gold = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_graph_gold(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_graph_gold(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStatsTerse_GraphData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStatsTerse.GraphData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 graph_gold = 1;
  for (int i = 0, n = this->_internal_graph_gold_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_graph_gold(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStatsTerse.GraphData)
  return target;
}

size_t CMsgDOTARealtimeGameStatsTerse_GraphData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStatsTerse.GraphData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 graph_gold = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.graph_gold_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_graph_gold_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStatsTerse_GraphData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStatsTerse_GraphData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStatsTerse_GraphData::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStatsTerse_GraphData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStatsTerse_GraphData*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStatsTerse_GraphData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStatsTerse.GraphData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.graph_gold_.MergeFrom(from._impl_.graph_gold_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStatsTerse_GraphData::CopyFrom(const CMsgDOTARealtimeGameStatsTerse_GraphData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStatsTerse.GraphData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStatsTerse_GraphData::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStatsTerse_GraphData::InternalSwap(CMsgDOTARealtimeGameStatsTerse_GraphData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.graph_gold_.InternalSwap(&other->_impl_.graph_gold_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStatsTerse_GraphData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[56]);
}

// ===================================================================

class CMsgDOTARealtimeGameStatsTerse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTARealtimeGameStatsTerse>()._impl_._has_bits_);
  static const ::CMsgDOTARealtimeGameStatsTerse_MatchDetails& match(const CMsgDOTARealtimeGameStatsTerse* msg);
  static void set_has_match(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgDOTARealtimeGameStatsTerse_GraphData& graph_data(const CMsgDOTARealtimeGameStatsTerse* msg);
  static void set_has_graph_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_delta_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgDOTARealtimeGameStatsTerse_MatchDetails&
CMsgDOTARealtimeGameStatsTerse::_Internal::match(const CMsgDOTARealtimeGameStatsTerse* msg) {
  return *msg->_impl_.match_;
}
const ::CMsgDOTARealtimeGameStatsTerse_GraphData&
CMsgDOTARealtimeGameStatsTerse::_Internal::graph_data(const CMsgDOTARealtimeGameStatsTerse* msg) {
  return *msg->_impl_.graph_data_;
}
CMsgDOTARealtimeGameStatsTerse::CMsgDOTARealtimeGameStatsTerse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTARealtimeGameStatsTerse)
}
CMsgDOTARealtimeGameStatsTerse::CMsgDOTARealtimeGameStatsTerse(const CMsgDOTARealtimeGameStatsTerse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTARealtimeGameStatsTerse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teams_){from._impl_.teams_}
    , decltype(_impl_.buildings_){from._impl_.buildings_}
    , decltype(_impl_.match_){nullptr}
    , decltype(_impl_.graph_data_){nullptr}
    , decltype(_impl_.delta_frame_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_match()) {
    _this->_impl_.match_ = new ::CMsgDOTARealtimeGameStatsTerse_MatchDetails(*from._impl_.match_);
  }
  if (from._internal_has_graph_data()) {
    _this->_impl_.graph_data_ = new ::CMsgDOTARealtimeGameStatsTerse_GraphData(*from._impl_.graph_data_);
  }
  _this->_impl_.delta_frame_ = from._impl_.delta_frame_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTARealtimeGameStatsTerse)
}

inline void CMsgDOTARealtimeGameStatsTerse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teams_){arena}
    , decltype(_impl_.buildings_){arena}
    , decltype(_impl_.match_){nullptr}
    , decltype(_impl_.graph_data_){nullptr}
    , decltype(_impl_.delta_frame_){false}
  };
}

CMsgDOTARealtimeGameStatsTerse::~CMsgDOTARealtimeGameStatsTerse() {
  // @@protoc_insertion_point(destructor:CMsgDOTARealtimeGameStatsTerse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTARealtimeGameStatsTerse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.teams_.~RepeatedPtrField();
  _impl_.buildings_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.match_;
  if (this != internal_default_instance()) delete _impl_.graph_data_;
}

void CMsgDOTARealtimeGameStatsTerse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTARealtimeGameStatsTerse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTARealtimeGameStatsTerse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.teams_.Clear();
  _impl_.buildings_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.match_ != nullptr);
      _impl_.match_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.graph_data_ != nullptr);
      _impl_.graph_data_->Clear();
    }
  }
  _impl_.delta_frame_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTARealtimeGameStatsTerse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgDOTARealtimeGameStatsTerse.MatchDetails match = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStatsTerse.TeamDetails teams = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_teams(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTARealtimeGameStatsTerse.BuildingDetails buildings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buildings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTARealtimeGameStatsTerse.GraphData graph_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_graph_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool delta_frame = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_delta_frame(&has_bits);
          _impl_.delta_frame_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTARealtimeGameStatsTerse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTARealtimeGameStatsTerse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgDOTARealtimeGameStatsTerse.MatchDetails match = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::match(this),
        _Internal::match(this).GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTARealtimeGameStatsTerse.TeamDetails teams = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_teams_size()); i < n; i++) {
    const auto& repfield = this->_internal_teams(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDOTARealtimeGameStatsTerse.BuildingDetails buildings = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buildings_size()); i < n; i++) {
    const auto& repfield = this->_internal_buildings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .CMsgDOTARealtimeGameStatsTerse.GraphData graph_data = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::graph_data(this),
        _Internal::graph_data(this).GetCachedSize(), target, stream);
  }

  // optional bool delta_frame = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_delta_frame(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTARealtimeGameStatsTerse)
  return target;
}

size_t CMsgDOTARealtimeGameStatsTerse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTARealtimeGameStatsTerse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTARealtimeGameStatsTerse.TeamDetails teams = 2;
  total_size += 1UL * this->_internal_teams_size();
  for (const auto& msg : this->_impl_.teams_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTARealtimeGameStatsTerse.BuildingDetails buildings = 3;
  total_size += 1UL * this->_internal_buildings_size();
  for (const auto& msg : this->_impl_.buildings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgDOTARealtimeGameStatsTerse.MatchDetails match = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.match_);
    }

    // optional .CMsgDOTARealtimeGameStatsTerse.GraphData graph_data = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.graph_data_);
    }

    // optional bool delta_frame = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTARealtimeGameStatsTerse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTARealtimeGameStatsTerse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTARealtimeGameStatsTerse::GetClassData() const { return &_class_data_; }


void CMsgDOTARealtimeGameStatsTerse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTARealtimeGameStatsTerse*>(&to_msg);
  auto& from = static_cast<const CMsgDOTARealtimeGameStatsTerse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTARealtimeGameStatsTerse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.teams_.MergeFrom(from._impl_.teams_);
  _this->_impl_.buildings_.MergeFrom(from._impl_.buildings_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_match()->::CMsgDOTARealtimeGameStatsTerse_MatchDetails::MergeFrom(
          from._internal_match());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_graph_data()->::CMsgDOTARealtimeGameStatsTerse_GraphData::MergeFrom(
          from._internal_graph_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.delta_frame_ = from._impl_.delta_frame_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTARealtimeGameStatsTerse::CopyFrom(const CMsgDOTARealtimeGameStatsTerse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTARealtimeGameStatsTerse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTARealtimeGameStatsTerse::IsInitialized() const {
  return true;
}

void CMsgDOTARealtimeGameStatsTerse::InternalSwap(CMsgDOTARealtimeGameStatsTerse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.teams_.InternalSwap(&other->_impl_.teams_);
  _impl_.buildings_.InternalSwap(&other->_impl_.buildings_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStatsTerse, _impl_.delta_frame_)
      + sizeof(CMsgDOTARealtimeGameStatsTerse::_impl_.delta_frame_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTARealtimeGameStatsTerse, _impl_.match_)>(
          reinterpret_cast<char*>(&_impl_.match_),
          reinterpret_cast<char*>(&other->_impl_.match_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTARealtimeGameStatsTerse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[57]);
}

// ===================================================================

class CMsgDOTABroadcastTimelineEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTABroadcastTimelineEvent>()._impl_._has_bits_);
  static void set_has_event(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_string_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTABroadcastTimelineEvent::CMsgDOTABroadcastTimelineEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTABroadcastTimelineEvent)
}
CMsgDOTABroadcastTimelineEvent::CMsgDOTABroadcastTimelineEvent(const CMsgDOTABroadcastTimelineEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTABroadcastTimelineEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.string_data_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.data_){}
    , decltype(_impl_.event_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.string_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_string_data()) {
    _this->_impl_.string_data_.Set(from._internal_string_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.event_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.event_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTABroadcastTimelineEvent)
}

inline void CMsgDOTABroadcastTimelineEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.string_data_){}
    , decltype(_impl_.timestamp_){0u}
    , decltype(_impl_.data_){0u}
    , decltype(_impl_.event_){1}
  };
  _impl_.string_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTABroadcastTimelineEvent::~CMsgDOTABroadcastTimelineEvent() {
  // @@protoc_insertion_point(destructor:CMsgDOTABroadcastTimelineEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTABroadcastTimelineEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.string_data_.Destroy();
}

void CMsgDOTABroadcastTimelineEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTABroadcastTimelineEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTABroadcastTimelineEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.string_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.data_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.data_));
    _impl_.event_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTABroadcastTimelineEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EBroadcastTimelineEvent event = 1 [default = EBroadcastTimelineEvent_MatchStarted];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EBroadcastTimelineEvent_IsValid(val))) {
            _internal_set_event(static_cast<::EBroadcastTimelineEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_data(&has_bits);
          _impl_.data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string string_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_string_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTABroadcastTimelineEvent.string_data");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTABroadcastTimelineEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTABroadcastTimelineEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .EBroadcastTimelineEvent event = 1 [default = EBroadcastTimelineEvent_MatchStarted];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event(), target);
  }

  // optional fixed32 timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_timestamp(), target);
  }

  // optional uint32 data = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_data(), target);
  }

  // optional string string_data = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_string_data().data(), static_cast<int>(this->_internal_string_data().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTABroadcastTimelineEvent.string_data");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_string_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTABroadcastTimelineEvent)
  return target;
}

size_t CMsgDOTABroadcastTimelineEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTABroadcastTimelineEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string string_data = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_string_data());
    }

    // optional fixed32 timestamp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 data = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_data());
    }

    // optional .EBroadcastTimelineEvent event = 1 [default = EBroadcastTimelineEvent_MatchStarted];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTABroadcastTimelineEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTABroadcastTimelineEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTABroadcastTimelineEvent::GetClassData() const { return &_class_data_; }


void CMsgDOTABroadcastTimelineEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTABroadcastTimelineEvent*>(&to_msg);
  auto& from = static_cast<const CMsgDOTABroadcastTimelineEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTABroadcastTimelineEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_string_data(from._internal_string_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.data_ = from._impl_.data_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.event_ = from._impl_.event_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTABroadcastTimelineEvent::CopyFrom(const CMsgDOTABroadcastTimelineEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTABroadcastTimelineEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTABroadcastTimelineEvent::IsInitialized() const {
  return true;
}

void CMsgDOTABroadcastTimelineEvent::InternalSwap(CMsgDOTABroadcastTimelineEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.string_data_, lhs_arena,
      &other->_impl_.string_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTABroadcastTimelineEvent, _impl_.data_)
      + sizeof(CMsgDOTABroadcastTimelineEvent::_impl_.data_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTABroadcastTimelineEvent, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
  swap(_impl_.event_, other->_impl_.event_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTABroadcastTimelineEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[58]);
}

// ===================================================================

class CMsgGCToClientMatchGroupsVersion::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToClientMatchGroupsVersion>()._impl_._has_bits_);
  static void set_has_matchgroups_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGCToClientMatchGroupsVersion::CMsgGCToClientMatchGroupsVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToClientMatchGroupsVersion)
}
CMsgGCToClientMatchGroupsVersion::CMsgGCToClientMatchGroupsVersion(const CMsgGCToClientMatchGroupsVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToClientMatchGroupsVersion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.matchgroups_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.matchgroups_version_ = from._impl_.matchgroups_version_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCToClientMatchGroupsVersion)
}

inline void CMsgGCToClientMatchGroupsVersion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.matchgroups_version_){0u}
  };
}

CMsgGCToClientMatchGroupsVersion::~CMsgGCToClientMatchGroupsVersion() {
  // @@protoc_insertion_point(destructor:CMsgGCToClientMatchGroupsVersion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToClientMatchGroupsVersion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCToClientMatchGroupsVersion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToClientMatchGroupsVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToClientMatchGroupsVersion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matchgroups_version_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToClientMatchGroupsVersion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 matchgroups_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_matchgroups_version(&has_bits);
          _impl_.matchgroups_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToClientMatchGroupsVersion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToClientMatchGroupsVersion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 matchgroups_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_matchgroups_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToClientMatchGroupsVersion)
  return target;
}

size_t CMsgGCToClientMatchGroupsVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToClientMatchGroupsVersion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 matchgroups_version = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_matchgroups_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToClientMatchGroupsVersion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToClientMatchGroupsVersion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToClientMatchGroupsVersion::GetClassData() const { return &_class_data_; }


void CMsgGCToClientMatchGroupsVersion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToClientMatchGroupsVersion*>(&to_msg);
  auto& from = static_cast<const CMsgGCToClientMatchGroupsVersion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToClientMatchGroupsVersion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_matchgroups_version()) {
    _this->_internal_set_matchgroups_version(from._internal_matchgroups_version());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToClientMatchGroupsVersion::CopyFrom(const CMsgGCToClientMatchGroupsVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToClientMatchGroupsVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToClientMatchGroupsVersion::IsInitialized() const {
  return true;
}

void CMsgGCToClientMatchGroupsVersion::InternalSwap(CMsgGCToClientMatchGroupsVersion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.matchgroups_version_, other->_impl_.matchgroups_version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToClientMatchGroupsVersion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[59]);
}

// ===================================================================

class CMsgDOTASDOHeroStatsHistory::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTASDOHeroStatsHistory>()._impl_._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_game_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lobby_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_won(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_gpm(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_xpm(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_deaths(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_assists(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

CMsgDOTASDOHeroStatsHistory::CMsgDOTASDOHeroStatsHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTASDOHeroStatsHistory)
}
CMsgDOTASDOHeroStatsHistory::CMsgDOTASDOHeroStatsHistory(const CMsgDOTASDOHeroStatsHistory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTASDOHeroStatsHistory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.game_mode_){}
    , decltype(_impl_.lobby_type_){}
    , decltype(_impl_.start_time_){}
    , decltype(_impl_.won_){}
    , decltype(_impl_.gpm_){}
    , decltype(_impl_.xpm_){}
    , decltype(_impl_.kills_){}
    , decltype(_impl_.deaths_){}
    , decltype(_impl_.assists_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.match_id_, &from._impl_.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.assists_) -
    reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.assists_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTASDOHeroStatsHistory)
}

inline void CMsgDOTASDOHeroStatsHistory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.game_mode_){0u}
    , decltype(_impl_.lobby_type_){0u}
    , decltype(_impl_.start_time_){0u}
    , decltype(_impl_.won_){false}
    , decltype(_impl_.gpm_){0u}
    , decltype(_impl_.xpm_){0u}
    , decltype(_impl_.kills_){0u}
    , decltype(_impl_.deaths_){0u}
    , decltype(_impl_.assists_){0u}
  };
}

CMsgDOTASDOHeroStatsHistory::~CMsgDOTASDOHeroStatsHistory() {
  // @@protoc_insertion_point(destructor:CMsgDOTASDOHeroStatsHistory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTASDOHeroStatsHistory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTASDOHeroStatsHistory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTASDOHeroStatsHistory::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTASDOHeroStatsHistory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.kills_) -
        reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.kills_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.deaths_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.assists_) -
        reinterpret_cast<char*>(&_impl_.deaths_)) + sizeof(_impl_.assists_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTASDOHeroStatsHistory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 match_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 game_mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_game_mode(&has_bits);
          _impl_.game_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lobby_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lobby_type(&has_bits);
          _impl_.lobby_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_start_time(&has_bits);
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool won = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_won(&has_bits);
          _impl_.won_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gpm = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_gpm(&has_bits);
          _impl_.gpm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 xpm = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_xpm(&has_bits);
          _impl_.xpm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 kills = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_kills(&has_bits);
          _impl_.kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 deaths = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_deaths(&has_bits);
          _impl_.deaths_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assists = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_assists(&has_bits);
          _impl_.assists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTASDOHeroStatsHistory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTASDOHeroStatsHistory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 match_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_match_id(), target);
  }

  // optional uint32 game_mode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_game_mode(), target);
  }

  // optional uint32 lobby_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lobby_type(), target);
  }

  // optional uint32 start_time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_start_time(), target);
  }

  // optional bool won = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_won(), target);
  }

  // optional uint32 gpm = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_gpm(), target);
  }

  // optional uint32 xpm = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_xpm(), target);
  }

  // optional uint32 kills = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_kills(), target);
  }

  // optional uint32 deaths = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_deaths(), target);
  }

  // optional uint32 assists = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_assists(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTASDOHeroStatsHistory)
  return target;
}

size_t CMsgDOTASDOHeroStatsHistory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTASDOHeroStatsHistory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 match_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 game_mode = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_mode());
    }

    // optional uint32 lobby_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lobby_type());
    }

    // optional uint32 start_time = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_time());
    }

    // optional bool won = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint32 gpm = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gpm());
    }

    // optional uint32 xpm = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_xpm());
    }

    // optional uint32 kills = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_kills());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 deaths = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_deaths());
    }

    // optional uint32 assists = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_assists());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTASDOHeroStatsHistory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTASDOHeroStatsHistory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTASDOHeroStatsHistory::GetClassData() const { return &_class_data_; }


void CMsgDOTASDOHeroStatsHistory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTASDOHeroStatsHistory*>(&to_msg);
  auto& from = static_cast<const CMsgDOTASDOHeroStatsHistory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTASDOHeroStatsHistory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.game_mode_ = from._impl_.game_mode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lobby_type_ = from._impl_.lobby_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.start_time_ = from._impl_.start_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.won_ = from._impl_.won_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.gpm_ = from._impl_.gpm_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.xpm_ = from._impl_.xpm_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.kills_ = from._impl_.kills_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.deaths_ = from._impl_.deaths_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.assists_ = from._impl_.assists_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTASDOHeroStatsHistory::CopyFrom(const CMsgDOTASDOHeroStatsHistory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTASDOHeroStatsHistory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTASDOHeroStatsHistory::IsInitialized() const {
  return true;
}

void CMsgDOTASDOHeroStatsHistory::InternalSwap(CMsgDOTASDOHeroStatsHistory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTASDOHeroStatsHistory, _impl_.assists_)
      + sizeof(CMsgDOTASDOHeroStatsHistory::_impl_.assists_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTASDOHeroStatsHistory, _impl_.match_id_)>(
          reinterpret_cast<char*>(&_impl_.match_id_),
          reinterpret_cast<char*>(&other->_impl_.match_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTASDOHeroStatsHistory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[60]);
}

// ===================================================================

class CMsgPredictionChoice::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPredictionChoice>()._impl_._has_bits_);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_min_raw_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_raw_value(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgPredictionChoice::CMsgPredictionChoice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPredictionChoice)
}
CMsgPredictionChoice::CMsgPredictionChoice(const CMsgPredictionChoice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPredictionChoice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.min_raw_value_){}
    , decltype(_impl_.max_raw_value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.value_, &from._impl_.value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_raw_value_) -
    reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.max_raw_value_));
  // @@protoc_insertion_point(copy_constructor:CMsgPredictionChoice)
}

inline void CMsgPredictionChoice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){0u}
    , decltype(_impl_.min_raw_value_){0u}
    , decltype(_impl_.max_raw_value_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgPredictionChoice::~CMsgPredictionChoice() {
  // @@protoc_insertion_point(destructor:CMsgPredictionChoice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPredictionChoice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgPredictionChoice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPredictionChoice::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPredictionChoice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.max_raw_value_) -
        reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.max_raw_value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPredictionChoice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgPredictionChoice.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 min_raw_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_min_raw_value(&has_bits);
          _impl_.min_raw_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_raw_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_max_raw_value(&has_bits);
          _impl_.max_raw_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPredictionChoice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPredictionChoice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 value = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_value(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgPredictionChoice.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional uint32 min_raw_value = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_min_raw_value(), target);
  }

  // optional uint32 max_raw_value = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_max_raw_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPredictionChoice)
  return target;
}

size_t CMsgPredictionChoice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPredictionChoice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 value = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_value());
    }

    // optional uint32 min_raw_value = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_min_raw_value());
    }

    // optional uint32 max_raw_value = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_raw_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPredictionChoice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPredictionChoice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPredictionChoice::GetClassData() const { return &_class_data_; }


void CMsgPredictionChoice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPredictionChoice*>(&to_msg);
  auto& from = static_cast<const CMsgPredictionChoice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPredictionChoice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.min_raw_value_ = from._impl_.min_raw_value_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.max_raw_value_ = from._impl_.max_raw_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPredictionChoice::CopyFrom(const CMsgPredictionChoice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPredictionChoice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPredictionChoice::IsInitialized() const {
  return true;
}

void CMsgPredictionChoice::InternalSwap(CMsgPredictionChoice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPredictionChoice, _impl_.max_raw_value_)
      + sizeof(CMsgPredictionChoice::_impl_.max_raw_value_)
      - PROTOBUF_FIELD_OFFSET(CMsgPredictionChoice, _impl_.value_)>(
          reinterpret_cast<char*>(&_impl_.value_),
          reinterpret_cast<char*>(&other->_impl_.value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPredictionChoice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[61]);
}

// ===================================================================

class CMsgInGamePrediction_QueryKeyValues::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgInGamePrediction_QueryKeyValues>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgInGamePrediction_QueryKeyValues::CMsgInGamePrediction_QueryKeyValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgInGamePrediction.QueryKeyValues)
}
CMsgInGamePrediction_QueryKeyValues::CMsgInGamePrediction_QueryKeyValues(const CMsgInGamePrediction_QueryKeyValues& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgInGamePrediction_QueryKeyValues* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgInGamePrediction.QueryKeyValues)
}

inline void CMsgInGamePrediction_QueryKeyValues::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgInGamePrediction_QueryKeyValues::~CMsgInGamePrediction_QueryKeyValues() {
  // @@protoc_insertion_point(destructor:CMsgInGamePrediction.QueryKeyValues)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgInGamePrediction_QueryKeyValues::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void CMsgInGamePrediction_QueryKeyValues::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgInGamePrediction_QueryKeyValues::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgInGamePrediction.QueryKeyValues)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgInGamePrediction_QueryKeyValues::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgInGamePrediction.QueryKeyValues.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgInGamePrediction.QueryKeyValues.value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgInGamePrediction_QueryKeyValues::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgInGamePrediction.QueryKeyValues)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgInGamePrediction.QueryKeyValues.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgInGamePrediction.QueryKeyValues.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgInGamePrediction.QueryKeyValues)
  return target;
}

size_t CMsgInGamePrediction_QueryKeyValues::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgInGamePrediction.QueryKeyValues)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgInGamePrediction_QueryKeyValues::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgInGamePrediction_QueryKeyValues::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgInGamePrediction_QueryKeyValues::GetClassData() const { return &_class_data_; }


void CMsgInGamePrediction_QueryKeyValues::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgInGamePrediction_QueryKeyValues*>(&to_msg);
  auto& from = static_cast<const CMsgInGamePrediction_QueryKeyValues&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgInGamePrediction.QueryKeyValues)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgInGamePrediction_QueryKeyValues::CopyFrom(const CMsgInGamePrediction_QueryKeyValues& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgInGamePrediction.QueryKeyValues)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgInGamePrediction_QueryKeyValues::IsInitialized() const {
  return true;
}

void CMsgInGamePrediction_QueryKeyValues::InternalSwap(CMsgInGamePrediction_QueryKeyValues* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgInGamePrediction_QueryKeyValues::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[62]);
}

// ===================================================================

class CMsgInGamePrediction::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgInGamePrediction>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_question(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_query_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_answer_resolution_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_points_to_grant(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_reward_action(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_debug_force_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_raw_value_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

CMsgInGamePrediction::CMsgInGamePrediction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgInGamePrediction)
}
CMsgInGamePrediction::CMsgInGamePrediction(const CMsgInGamePrediction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgInGamePrediction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.choices_){from._impl_.choices_}
    , decltype(_impl_.required_heroes_){from._impl_.required_heroes_}
    , decltype(_impl_.query_values_){from._impl_.query_values_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.question_){}
    , decltype(_impl_.query_name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.group_){}
    , decltype(_impl_.answer_resolution_type_){}
    , decltype(_impl_.points_to_grant_){}
    , decltype(_impl_.reward_action_){}
    , decltype(_impl_.debug_force_selection_){}
    , decltype(_impl_.raw_value_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.question_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.question_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_question()) {
    _this->_impl_.question_.Set(from._internal_question(), 
      _this->GetArenaForAllocation());
  }
  _impl_.query_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.query_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_query_name()) {
    _this->_impl_.query_name_.Set(from._internal_query_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.raw_value_type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.raw_value_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgInGamePrediction)
}

inline void CMsgInGamePrediction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.choices_){arena}
    , decltype(_impl_.required_heroes_){arena}
    , decltype(_impl_.query_values_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.question_){}
    , decltype(_impl_.query_name_){}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.group_){0}
    , decltype(_impl_.answer_resolution_type_){0}
    , decltype(_impl_.points_to_grant_){0u}
    , decltype(_impl_.reward_action_){0u}
    , decltype(_impl_.debug_force_selection_){0u}
    , decltype(_impl_.raw_value_type_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.question_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.question_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.query_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.query_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgInGamePrediction::~CMsgInGamePrediction() {
  // @@protoc_insertion_point(destructor:CMsgInGamePrediction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgInGamePrediction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.choices_.~RepeatedPtrField();
  _impl_.required_heroes_.~RepeatedPtrField();
  _impl_.query_values_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.question_.Destroy();
  _impl_.query_name_.Destroy();
}

void CMsgInGamePrediction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgInGamePrediction::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgInGamePrediction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.choices_.Clear();
  _impl_.required_heroes_.Clear();
  _impl_.query_values_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.question_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.query_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.points_to_grant_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.points_to_grant_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.reward_action_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.raw_value_type_) -
        reinterpret_cast<char*>(&_impl_.reward_action_)) + sizeof(_impl_.raw_value_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgInGamePrediction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgInGamePrediction.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgInGamePrediction.EPredictionType type = 3 [default = Generic];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgInGamePrediction_EPredictionType_IsValid(val))) {
            _internal_set_type(static_cast<::CMsgInGamePrediction_EPredictionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgInGamePrediction.ERandomSelectionGroup_t group = 4 [default = EarlyGame];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgInGamePrediction_ERandomSelectionGroup_t_IsValid(val))) {
            _internal_set_group(static_cast<::CMsgInGamePrediction_ERandomSelectionGroup_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string question = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_question();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgInGamePrediction.question");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgPredictionChoice choices = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_choices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string required_heroes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_required_heroes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "CMsgInGamePrediction.required_heroes");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string query_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_query_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgInGamePrediction.query_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgInGamePrediction.QueryKeyValues query_values = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_query_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgInGamePrediction.EResolutionType_t answer_resolution_type = 10 [default = InvalidQuery];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgInGamePrediction_EResolutionType_t_IsValid(val))) {
            _internal_set_answer_resolution_type(static_cast<::CMsgInGamePrediction_EResolutionType_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 points_to_grant = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_points_to_grant(&has_bits);
          _impl_.points_to_grant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 reward_action = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_reward_action(&has_bits);
          _impl_.reward_action_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 debug_force_selection = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_debug_force_selection(&has_bits);
          _impl_.debug_force_selection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgInGamePrediction.ERawValueType_t raw_value_type = 14 [default = Number];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgInGamePrediction_ERawValueType_t_IsValid(val))) {
            _internal_set_raw_value_type(static_cast<::CMsgInGamePrediction_ERawValueType_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgInGamePrediction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgInGamePrediction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgInGamePrediction.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional .CMsgInGamePrediction.EPredictionType type = 3 [default = Generic];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // optional .CMsgInGamePrediction.ERandomSelectionGroup_t group = 4 [default = EarlyGame];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_group(), target);
  }

  // optional string question = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_question().data(), static_cast<int>(this->_internal_question().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgInGamePrediction.question");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_question(), target);
  }

  // repeated .CMsgPredictionChoice choices = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_choices_size()); i < n; i++) {
    const auto& repfield = this->_internal_choices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string required_heroes = 7;
  for (int i = 0, n = this->_internal_required_heroes_size(); i < n; i++) {
    const auto& s = this->_internal_required_heroes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgInGamePrediction.required_heroes");
    target = stream->WriteString(7, s, target);
  }

  // optional string query_name = 8;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_query_name().data(), static_cast<int>(this->_internal_query_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgInGamePrediction.query_name");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_query_name(), target);
  }

  // repeated .CMsgInGamePrediction.QueryKeyValues query_values = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_query_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_query_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .CMsgInGamePrediction.EResolutionType_t answer_resolution_type = 10 [default = InvalidQuery];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_answer_resolution_type(), target);
  }

  // optional uint32 points_to_grant = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_points_to_grant(), target);
  }

  // optional uint32 reward_action = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_reward_action(), target);
  }

  // optional uint32 debug_force_selection = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_debug_force_selection(), target);
  }

  // optional .CMsgInGamePrediction.ERawValueType_t raw_value_type = 14 [default = Number];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_raw_value_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgInGamePrediction)
  return target;
}

size_t CMsgInGamePrediction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgInGamePrediction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgPredictionChoice choices = 6;
  total_size += 1UL * this->_internal_choices_size();
  for (const auto& msg : this->_impl_.choices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string required_heroes = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.required_heroes_.size());
  for (int i = 0, n = _impl_.required_heroes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.required_heroes_.Get(i));
  }

  // repeated .CMsgInGamePrediction.QueryKeyValues query_values = 9;
  total_size += 1UL * this->_internal_query_values_size();
  for (const auto& msg : this->_impl_.query_values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string question = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_question());
    }

    // optional string query_name = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_query_name());
    }

    // optional uint32 id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional .CMsgInGamePrediction.EPredictionType type = 3 [default = Generic];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional .CMsgInGamePrediction.ERandomSelectionGroup_t group = 4 [default = EarlyGame];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_group());
    }

    // optional .CMsgInGamePrediction.EResolutionType_t answer_resolution_type = 10 [default = InvalidQuery];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_answer_resolution_type());
    }

    // optional uint32 points_to_grant = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_points_to_grant());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 reward_action = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reward_action());
    }

    // optional uint32 debug_force_selection = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_debug_force_selection());
    }

    // optional .CMsgInGamePrediction.ERawValueType_t raw_value_type = 14 [default = Number];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_raw_value_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgInGamePrediction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgInGamePrediction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgInGamePrediction::GetClassData() const { return &_class_data_; }


void CMsgInGamePrediction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgInGamePrediction*>(&to_msg);
  auto& from = static_cast<const CMsgInGamePrediction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgInGamePrediction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.choices_.MergeFrom(from._impl_.choices_);
  _this->_impl_.required_heroes_.MergeFrom(from._impl_.required_heroes_);
  _this->_impl_.query_values_.MergeFrom(from._impl_.query_values_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_question(from._internal_question());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_query_name(from._internal_query_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.group_ = from._impl_.group_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.answer_resolution_type_ = from._impl_.answer_resolution_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.points_to_grant_ = from._impl_.points_to_grant_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.reward_action_ = from._impl_.reward_action_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.debug_force_selection_ = from._impl_.debug_force_selection_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.raw_value_type_ = from._impl_.raw_value_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgInGamePrediction::CopyFrom(const CMsgInGamePrediction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgInGamePrediction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgInGamePrediction::IsInitialized() const {
  return true;
}

void CMsgInGamePrediction::InternalSwap(CMsgInGamePrediction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.choices_.InternalSwap(&other->_impl_.choices_);
  _impl_.required_heroes_.InternalSwap(&other->_impl_.required_heroes_);
  _impl_.query_values_.InternalSwap(&other->_impl_.query_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.question_, lhs_arena,
      &other->_impl_.question_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.query_name_, lhs_arena,
      &other->_impl_.query_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgInGamePrediction, _impl_.raw_value_type_)
      + sizeof(CMsgInGamePrediction::_impl_.raw_value_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgInGamePrediction, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgInGamePrediction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[63]);
}

// ===================================================================

class CMsgDOTASeasonPredictions_Prediction_Answers::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTASeasonPredictions_Prediction_Answers>()._impl_._has_bits_);
  static void set_has_answer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTASeasonPredictions_Prediction_Answers::CMsgDOTASeasonPredictions_Prediction_Answers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTASeasonPredictions.Prediction.Answers)
}
CMsgDOTASeasonPredictions_Prediction_Answers::CMsgDOTASeasonPredictions_Prediction_Answers(const CMsgDOTASeasonPredictions_Prediction_Answers& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTASeasonPredictions_Prediction_Answers* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.answer_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.answer_id_ = from._impl_.answer_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTASeasonPredictions.Prediction.Answers)
}

inline void CMsgDOTASeasonPredictions_Prediction_Answers::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.answer_id_){0u}
  };
}

CMsgDOTASeasonPredictions_Prediction_Answers::~CMsgDOTASeasonPredictions_Prediction_Answers() {
  // @@protoc_insertion_point(destructor:CMsgDOTASeasonPredictions.Prediction.Answers)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTASeasonPredictions_Prediction_Answers::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTASeasonPredictions_Prediction_Answers::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTASeasonPredictions_Prediction_Answers::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTASeasonPredictions.Prediction.Answers)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.answer_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTASeasonPredictions_Prediction_Answers::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 answer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_answer_id(&has_bits);
          _impl_.answer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTASeasonPredictions_Prediction_Answers::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTASeasonPredictions.Prediction.Answers)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 answer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_answer_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTASeasonPredictions.Prediction.Answers)
  return target;
}

size_t CMsgDOTASeasonPredictions_Prediction_Answers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTASeasonPredictions.Prediction.Answers)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 answer_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_answer_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTASeasonPredictions_Prediction_Answers::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTASeasonPredictions_Prediction_Answers::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTASeasonPredictions_Prediction_Answers::GetClassData() const { return &_class_data_; }


void CMsgDOTASeasonPredictions_Prediction_Answers::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTASeasonPredictions_Prediction_Answers*>(&to_msg);
  auto& from = static_cast<const CMsgDOTASeasonPredictions_Prediction_Answers&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTASeasonPredictions.Prediction.Answers)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_answer_id()) {
    _this->_internal_set_answer_id(from._internal_answer_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTASeasonPredictions_Prediction_Answers::CopyFrom(const CMsgDOTASeasonPredictions_Prediction_Answers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTASeasonPredictions.Prediction.Answers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTASeasonPredictions_Prediction_Answers::IsInitialized() const {
  return true;
}

void CMsgDOTASeasonPredictions_Prediction_Answers::InternalSwap(CMsgDOTASeasonPredictions_Prediction_Answers* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.answer_id_, other->_impl_.answer_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTASeasonPredictions_Prediction_Answers::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[64]);
}

// ===================================================================

class CMsgDOTASeasonPredictions_Prediction::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTASeasonPredictions_Prediction>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_question(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_selection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_start_date(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lock_date(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_reward(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_answer_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_answer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_query_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lock_on_selection_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_lock_on_selection_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_lock_on_selection_set(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_use_answer_value_ranges(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_reward_event(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

CMsgDOTASeasonPredictions_Prediction::CMsgDOTASeasonPredictions_Prediction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTASeasonPredictions.Prediction)
}
CMsgDOTASeasonPredictions_Prediction::CMsgDOTASeasonPredictions_Prediction(const CMsgDOTASeasonPredictions_Prediction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTASeasonPredictions_Prediction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.choices_){from._impl_.choices_}
    , decltype(_impl_.answers_){from._impl_.answers_}
    , decltype(_impl_.phases_){from._impl_.phases_}
    , decltype(_impl_.question_){}
    , decltype(_impl_.query_name_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.selection_id_){}
    , decltype(_impl_.start_date_){}
    , decltype(_impl_.lock_date_){}
    , decltype(_impl_.reward_){}
    , decltype(_impl_.answer_type_){}
    , decltype(_impl_.answer_id_){}
    , decltype(_impl_.lock_on_selection_id_){}
    , decltype(_impl_.lock_on_selection_value_){}
    , decltype(_impl_.lock_on_selection_set_){}
    , decltype(_impl_.use_answer_value_ranges_){}
    , decltype(_impl_.region_){}
    , decltype(_impl_.reward_event_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.question_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.question_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_question()) {
    _this->_impl_.question_.Set(from._internal_question(), 
      _this->GetArenaForAllocation());
  }
  _impl_.query_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.query_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_query_name()) {
    _this->_impl_.query_name_.Set(from._internal_query_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reward_event_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.reward_event_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTASeasonPredictions.Prediction)
}

inline void CMsgDOTASeasonPredictions_Prediction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.choices_){arena}
    , decltype(_impl_.answers_){arena}
    , decltype(_impl_.phases_){arena}
    , decltype(_impl_.question_){}
    , decltype(_impl_.query_name_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.selection_id_){0u}
    , decltype(_impl_.start_date_){0u}
    , decltype(_impl_.lock_date_){0u}
    , decltype(_impl_.reward_){0u}
    , decltype(_impl_.answer_type_){0}
    , decltype(_impl_.answer_id_){0u}
    , decltype(_impl_.lock_on_selection_id_){0u}
    , decltype(_impl_.lock_on_selection_value_){0u}
    , decltype(_impl_.lock_on_selection_set_){false}
    , decltype(_impl_.use_answer_value_ranges_){false}
    , decltype(_impl_.region_){0}
    , decltype(_impl_.reward_event_){0}
  };
  _impl_.question_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.question_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.query_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.query_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTASeasonPredictions_Prediction::~CMsgDOTASeasonPredictions_Prediction() {
  // @@protoc_insertion_point(destructor:CMsgDOTASeasonPredictions.Prediction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTASeasonPredictions_Prediction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.choices_.~RepeatedPtrField();
  _impl_.answers_.~RepeatedPtrField();
  _impl_.phases_.~RepeatedField();
  _impl_.question_.Destroy();
  _impl_.query_name_.Destroy();
}

void CMsgDOTASeasonPredictions_Prediction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTASeasonPredictions_Prediction::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTASeasonPredictions.Prediction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.choices_.Clear();
  _impl_.answers_.Clear();
  _impl_.phases_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.question_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.query_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.answer_type_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.answer_type_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.answer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.reward_event_) -
        reinterpret_cast<char*>(&_impl_.answer_id_)) + sizeof(_impl_.reward_event_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTASeasonPredictions_Prediction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgDOTASeasonPredictions.Prediction.EPredictionType type = 1 [default = Generic];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgDOTASeasonPredictions_Prediction_EPredictionType_IsValid(val))) {
            _internal_set_type(static_cast<::CMsgDOTASeasonPredictions_Prediction_EPredictionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string question = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_question();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTASeasonPredictions.Prediction.question");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgPredictionChoice choices = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_choices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_selection_id(&has_bits);
          _impl_.selection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start_date = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_start_date(&has_bits);
          _impl_.start_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lock_date = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_lock_date(&has_bits);
          _impl_.lock_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 reward = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_reward(&has_bits);
          _impl_.reward_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTASeasonPredictions.Prediction.EAnswerType answer_type = 8 [default = SingleInt];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgDOTASeasonPredictions_Prediction_EAnswerType_IsValid(val))) {
            _internal_set_answer_type(static_cast<::CMsgDOTASeasonPredictions_Prediction_EAnswerType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 answer_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_answer_id(&has_bits);
          _impl_.answer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTASeasonPredictions.Prediction.Answers answers = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_answers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string query_name = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_query_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTASeasonPredictions.Prediction.query_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lock_on_selection_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_lock_on_selection_id(&has_bits);
          _impl_.lock_on_selection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lock_on_selection_value = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_lock_on_selection_value(&has_bits);
          _impl_.lock_on_selection_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool lock_on_selection_set = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_lock_on_selection_set(&has_bits);
          _impl_.lock_on_selection_set_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_answer_value_ranges = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_use_answer_value_ranges(&has_bits);
          _impl_.use_answer_value_ranges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ELeagueRegion region = 17 [default = LEAGUE_REGION_UNSET];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELeagueRegion_IsValid(val))) {
            _internal_set_region(static_cast<::ELeagueRegion>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .ELeaguePhase phases = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          ptr -= 2;
          do {
            ptr += 2;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::ELeaguePhase_IsValid(val))) {
              _internal_add_phases(static_cast<::ELeaguePhase>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<144>(ptr));
        } else if (static_cast<uint8_t>(tag) == 146) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_phases(), ptr, ctx, ::ELeaguePhase_IsValid, &_internal_metadata_, 18);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EEvent reward_event = 19 [default = EVENT_ID_NONE];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EEvent_IsValid(val))) {
            _internal_set_reward_event(static_cast<::EEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTASeasonPredictions_Prediction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTASeasonPredictions.Prediction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgDOTASeasonPredictions.Prediction.EPredictionType type = 1 [default = Generic];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional string question = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_question().data(), static_cast<int>(this->_internal_question().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTASeasonPredictions.Prediction.question");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_question(), target);
  }

  // repeated .CMsgPredictionChoice choices = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_choices_size()); i < n; i++) {
    const auto& repfield = this->_internal_choices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 selection_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_selection_id(), target);
  }

  // optional uint32 start_date = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_start_date(), target);
  }

  // optional uint32 lock_date = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_lock_date(), target);
  }

  // optional uint32 reward = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_reward(), target);
  }

  // optional .CMsgDOTASeasonPredictions.Prediction.EAnswerType answer_type = 8 [default = SingleInt];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_answer_type(), target);
  }

  // optional uint32 answer_id = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_answer_id(), target);
  }

  // repeated .CMsgDOTASeasonPredictions.Prediction.Answers answers = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_answers_size()); i < n; i++) {
    const auto& repfield = this->_internal_answers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string query_name = 11;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_query_name().data(), static_cast<int>(this->_internal_query_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTASeasonPredictions.Prediction.query_name");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_query_name(), target);
  }

  // optional uint32 lock_on_selection_id = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_lock_on_selection_id(), target);
  }

  // optional uint32 lock_on_selection_value = 14;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_lock_on_selection_value(), target);
  }

  // optional bool lock_on_selection_set = 15;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_lock_on_selection_set(), target);
  }

  // optional bool use_answer_value_ranges = 16;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_use_answer_value_ranges(), target);
  }

  // optional .ELeagueRegion region = 17 [default = LEAGUE_REGION_UNSET];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      17, this->_internal_region(), target);
  }

  // repeated .ELeaguePhase phases = 18;
  for (int i = 0, n = this->_internal_phases_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        18, this->_internal_phases(i), target);
  }

  // optional .EEvent reward_event = 19 [default = EVENT_ID_NONE];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      19, this->_internal_reward_event(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTASeasonPredictions.Prediction)
  return target;
}

size_t CMsgDOTASeasonPredictions_Prediction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTASeasonPredictions.Prediction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgPredictionChoice choices = 3;
  total_size += 1UL * this->_internal_choices_size();
  for (const auto& msg : this->_impl_.choices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTASeasonPredictions.Prediction.Answers answers = 10;
  total_size += 1UL * this->_internal_answers_size();
  for (const auto& msg : this->_impl_.answers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ELeaguePhase phases = 18;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_phases_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_phases(static_cast<int>(i)));
    }
    total_size += (2UL * count) + data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string question = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_question());
    }

    // optional string query_name = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_query_name());
    }

    // optional .CMsgDOTASeasonPredictions.Prediction.EPredictionType type = 1 [default = Generic];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional uint32 selection_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_id());
    }

    // optional uint32 start_date = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_date());
    }

    // optional uint32 lock_date = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lock_date());
    }

    // optional uint32 reward = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reward());
    }

    // optional .CMsgDOTASeasonPredictions.Prediction.EAnswerType answer_type = 8 [default = SingleInt];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_answer_type());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional uint32 answer_id = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_answer_id());
    }

    // optional uint32 lock_on_selection_id = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lock_on_selection_id());
    }

    // optional uint32 lock_on_selection_value = 14;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lock_on_selection_value());
    }

    // optional bool lock_on_selection_set = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool use_answer_value_ranges = 16;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional .ELeagueRegion region = 17 [default = LEAGUE_REGION_UNSET];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_region());
    }

    // optional .EEvent reward_event = 19 [default = EVENT_ID_NONE];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_reward_event());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTASeasonPredictions_Prediction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTASeasonPredictions_Prediction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTASeasonPredictions_Prediction::GetClassData() const { return &_class_data_; }


void CMsgDOTASeasonPredictions_Prediction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTASeasonPredictions_Prediction*>(&to_msg);
  auto& from = static_cast<const CMsgDOTASeasonPredictions_Prediction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTASeasonPredictions.Prediction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.choices_.MergeFrom(from._impl_.choices_);
  _this->_impl_.answers_.MergeFrom(from._impl_.answers_);
  _this->_impl_.phases_.MergeFrom(from._impl_.phases_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_question(from._internal_question());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_query_name(from._internal_query_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.selection_id_ = from._impl_.selection_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.start_date_ = from._impl_.start_date_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.lock_date_ = from._impl_.lock_date_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.reward_ = from._impl_.reward_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.answer_type_ = from._impl_.answer_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.answer_id_ = from._impl_.answer_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.lock_on_selection_id_ = from._impl_.lock_on_selection_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.lock_on_selection_value_ = from._impl_.lock_on_selection_value_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.lock_on_selection_set_ = from._impl_.lock_on_selection_set_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.use_answer_value_ranges_ = from._impl_.use_answer_value_ranges_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.region_ = from._impl_.region_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.reward_event_ = from._impl_.reward_event_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTASeasonPredictions_Prediction::CopyFrom(const CMsgDOTASeasonPredictions_Prediction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTASeasonPredictions.Prediction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTASeasonPredictions_Prediction::IsInitialized() const {
  return true;
}

void CMsgDOTASeasonPredictions_Prediction::InternalSwap(CMsgDOTASeasonPredictions_Prediction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.choices_.InternalSwap(&other->_impl_.choices_);
  _impl_.answers_.InternalSwap(&other->_impl_.answers_);
  _impl_.phases_.InternalSwap(&other->_impl_.phases_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.question_, lhs_arena,
      &other->_impl_.question_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.query_name_, lhs_arena,
      &other->_impl_.query_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTASeasonPredictions_Prediction, _impl_.reward_event_)
      + sizeof(CMsgDOTASeasonPredictions_Prediction::_impl_.reward_event_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTASeasonPredictions_Prediction, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTASeasonPredictions_Prediction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[65]);
}

// ===================================================================

class CMsgDOTASeasonPredictions::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTASeasonPredictions>()._impl_._has_bits_);
  static void set_has_in_game_prediction_count_per_game(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_in_game_prediction_voting_period_minutes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTASeasonPredictions::CMsgDOTASeasonPredictions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTASeasonPredictions)
}
CMsgDOTASeasonPredictions::CMsgDOTASeasonPredictions(const CMsgDOTASeasonPredictions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTASeasonPredictions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.predictions_){from._impl_.predictions_}
    , decltype(_impl_.in_game_predictions_){from._impl_.in_game_predictions_}
    , decltype(_impl_.in_game_prediction_count_per_game_){}
    , decltype(_impl_.in_game_prediction_voting_period_minutes_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.in_game_prediction_count_per_game_, &from._impl_.in_game_prediction_count_per_game_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.in_game_prediction_voting_period_minutes_) -
    reinterpret_cast<char*>(&_impl_.in_game_prediction_count_per_game_)) + sizeof(_impl_.in_game_prediction_voting_period_minutes_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTASeasonPredictions)
}

inline void CMsgDOTASeasonPredictions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.predictions_){arena}
    , decltype(_impl_.in_game_predictions_){arena}
    , decltype(_impl_.in_game_prediction_count_per_game_){0u}
    , decltype(_impl_.in_game_prediction_voting_period_minutes_){0u}
  };
}

CMsgDOTASeasonPredictions::~CMsgDOTASeasonPredictions() {
  // @@protoc_insertion_point(destructor:CMsgDOTASeasonPredictions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTASeasonPredictions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.predictions_.~RepeatedPtrField();
  _impl_.in_game_predictions_.~RepeatedPtrField();
}

void CMsgDOTASeasonPredictions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTASeasonPredictions::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTASeasonPredictions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.predictions_.Clear();
  _impl_.in_game_predictions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.in_game_prediction_count_per_game_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.in_game_prediction_voting_period_minutes_) -
        reinterpret_cast<char*>(&_impl_.in_game_prediction_count_per_game_)) + sizeof(_impl_.in_game_prediction_voting_period_minutes_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTASeasonPredictions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTASeasonPredictions.Prediction predictions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_predictions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgInGamePrediction in_game_predictions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_in_game_predictions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 in_game_prediction_count_per_game = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_in_game_prediction_count_per_game(&has_bits);
          _impl_.in_game_prediction_count_per_game_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 in_game_prediction_voting_period_minutes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_in_game_prediction_voting_period_minutes(&has_bits);
          _impl_.in_game_prediction_voting_period_minutes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTASeasonPredictions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTASeasonPredictions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTASeasonPredictions.Prediction predictions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_predictions_size()); i < n; i++) {
    const auto& repfield = this->_internal_predictions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgInGamePrediction in_game_predictions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_in_game_predictions_size()); i < n; i++) {
    const auto& repfield = this->_internal_in_game_predictions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 in_game_prediction_count_per_game = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_in_game_prediction_count_per_game(), target);
  }

  // optional uint32 in_game_prediction_voting_period_minutes = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_in_game_prediction_voting_period_minutes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTASeasonPredictions)
  return target;
}

size_t CMsgDOTASeasonPredictions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTASeasonPredictions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTASeasonPredictions.Prediction predictions = 1;
  total_size += 1UL * this->_internal_predictions_size();
  for (const auto& msg : this->_impl_.predictions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgInGamePrediction in_game_predictions = 2;
  total_size += 1UL * this->_internal_in_game_predictions_size();
  for (const auto& msg : this->_impl_.in_game_predictions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 in_game_prediction_count_per_game = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_in_game_prediction_count_per_game());
    }

    // optional uint32 in_game_prediction_voting_period_minutes = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_in_game_prediction_voting_period_minutes());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTASeasonPredictions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTASeasonPredictions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTASeasonPredictions::GetClassData() const { return &_class_data_; }


void CMsgDOTASeasonPredictions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTASeasonPredictions*>(&to_msg);
  auto& from = static_cast<const CMsgDOTASeasonPredictions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTASeasonPredictions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.predictions_.MergeFrom(from._impl_.predictions_);
  _this->_impl_.in_game_predictions_.MergeFrom(from._impl_.in_game_predictions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.in_game_prediction_count_per_game_ = from._impl_.in_game_prediction_count_per_game_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.in_game_prediction_voting_period_minutes_ = from._impl_.in_game_prediction_voting_period_minutes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTASeasonPredictions::CopyFrom(const CMsgDOTASeasonPredictions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTASeasonPredictions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTASeasonPredictions::IsInitialized() const {
  return true;
}

void CMsgDOTASeasonPredictions::InternalSwap(CMsgDOTASeasonPredictions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.predictions_.InternalSwap(&other->_impl_.predictions_);
  _impl_.in_game_predictions_.InternalSwap(&other->_impl_.in_game_predictions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTASeasonPredictions, _impl_.in_game_prediction_voting_period_minutes_)
      + sizeof(CMsgDOTASeasonPredictions::_impl_.in_game_prediction_voting_period_minutes_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTASeasonPredictions, _impl_.in_game_prediction_count_per_game_)>(
          reinterpret_cast<char*>(&_impl_.in_game_prediction_count_per_game_),
          reinterpret_cast<char*>(&other->_impl_.in_game_prediction_count_per_game_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTASeasonPredictions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[66]);
}

// ===================================================================

class CMsgAvailablePredictions_MatchPrediction::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAvailablePredictions_MatchPrediction>()._impl_._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgAvailablePredictions_MatchPrediction::CMsgAvailablePredictions_MatchPrediction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAvailablePredictions.MatchPrediction)
}
CMsgAvailablePredictions_MatchPrediction::CMsgAvailablePredictions_MatchPrediction(const CMsgAvailablePredictions_MatchPrediction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgAvailablePredictions_MatchPrediction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.predictions_){from._impl_.predictions_}
    , decltype(_impl_.match_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.match_id_ = from._impl_.match_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgAvailablePredictions.MatchPrediction)
}

inline void CMsgAvailablePredictions_MatchPrediction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.predictions_){arena}
    , decltype(_impl_.match_id_){uint64_t{0u}}
  };
}

CMsgAvailablePredictions_MatchPrediction::~CMsgAvailablePredictions_MatchPrediction() {
  // @@protoc_insertion_point(destructor:CMsgAvailablePredictions.MatchPrediction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAvailablePredictions_MatchPrediction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.predictions_.~RepeatedPtrField();
}

void CMsgAvailablePredictions_MatchPrediction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAvailablePredictions_MatchPrediction::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAvailablePredictions.MatchPrediction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.predictions_.Clear();
  _impl_.match_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgAvailablePredictions_MatchPrediction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 match_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgInGamePrediction predictions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_predictions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAvailablePredictions_MatchPrediction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAvailablePredictions.MatchPrediction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 match_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_match_id(), target);
  }

  // repeated .CMsgInGamePrediction predictions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_predictions_size()); i < n; i++) {
    const auto& repfield = this->_internal_predictions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAvailablePredictions.MatchPrediction)
  return target;
}

size_t CMsgAvailablePredictions_MatchPrediction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAvailablePredictions.MatchPrediction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgInGamePrediction predictions = 2;
  total_size += 1UL * this->_internal_predictions_size();
  for (const auto& msg : this->_impl_.predictions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint64 match_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgAvailablePredictions_MatchPrediction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgAvailablePredictions_MatchPrediction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgAvailablePredictions_MatchPrediction::GetClassData() const { return &_class_data_; }


void CMsgAvailablePredictions_MatchPrediction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgAvailablePredictions_MatchPrediction*>(&to_msg);
  auto& from = static_cast<const CMsgAvailablePredictions_MatchPrediction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAvailablePredictions.MatchPrediction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.predictions_.MergeFrom(from._impl_.predictions_);
  if (from._internal_has_match_id()) {
    _this->_internal_set_match_id(from._internal_match_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgAvailablePredictions_MatchPrediction::CopyFrom(const CMsgAvailablePredictions_MatchPrediction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAvailablePredictions.MatchPrediction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAvailablePredictions_MatchPrediction::IsInitialized() const {
  return true;
}

void CMsgAvailablePredictions_MatchPrediction::InternalSwap(CMsgAvailablePredictions_MatchPrediction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.predictions_.InternalSwap(&other->_impl_.predictions_);
  swap(_impl_.match_id_, other->_impl_.match_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgAvailablePredictions_MatchPrediction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[67]);
}

// ===================================================================

class CMsgAvailablePredictions::_Internal {
 public:
};

CMsgAvailablePredictions::CMsgAvailablePredictions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAvailablePredictions)
}
CMsgAvailablePredictions::CMsgAvailablePredictions(const CMsgAvailablePredictions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgAvailablePredictions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.match_predictions_){from._impl_.match_predictions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgAvailablePredictions)
}

inline void CMsgAvailablePredictions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.match_predictions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgAvailablePredictions::~CMsgAvailablePredictions() {
  // @@protoc_insertion_point(destructor:CMsgAvailablePredictions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAvailablePredictions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.match_predictions_.~RepeatedPtrField();
}

void CMsgAvailablePredictions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAvailablePredictions::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAvailablePredictions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.match_predictions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgAvailablePredictions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgAvailablePredictions.MatchPrediction match_predictions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_match_predictions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAvailablePredictions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAvailablePredictions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgAvailablePredictions.MatchPrediction match_predictions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_match_predictions_size()); i < n; i++) {
    const auto& repfield = this->_internal_match_predictions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAvailablePredictions)
  return target;
}

size_t CMsgAvailablePredictions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAvailablePredictions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgAvailablePredictions.MatchPrediction match_predictions = 1;
  total_size += 1UL * this->_internal_match_predictions_size();
  for (const auto& msg : this->_impl_.match_predictions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgAvailablePredictions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgAvailablePredictions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgAvailablePredictions::GetClassData() const { return &_class_data_; }


void CMsgAvailablePredictions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgAvailablePredictions*>(&to_msg);
  auto& from = static_cast<const CMsgAvailablePredictions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAvailablePredictions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.match_predictions_.MergeFrom(from._impl_.match_predictions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgAvailablePredictions::CopyFrom(const CMsgAvailablePredictions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAvailablePredictions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAvailablePredictions::IsInitialized() const {
  return true;
}

void CMsgAvailablePredictions::InternalSwap(CMsgAvailablePredictions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.match_predictions_.InternalSwap(&other->_impl_.match_predictions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgAvailablePredictions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[68]);
}

// ===================================================================

class CMsgLeagueWatchedGames_Series::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgLeagueWatchedGames_Series>()._impl_._has_bits_);
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgLeagueWatchedGames_Series::CMsgLeagueWatchedGames_Series(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgLeagueWatchedGames.Series)
}
CMsgLeagueWatchedGames_Series::CMsgLeagueWatchedGames_Series(const CMsgLeagueWatchedGames_Series& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgLeagueWatchedGames_Series* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.game_){from._impl_.game_}
    , decltype(_impl_.node_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.node_id_ = from._impl_.node_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgLeagueWatchedGames.Series)
}

inline void CMsgLeagueWatchedGames_Series::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.game_){arena}
    , decltype(_impl_.node_id_){0u}
  };
}

CMsgLeagueWatchedGames_Series::~CMsgLeagueWatchedGames_Series() {
  // @@protoc_insertion_point(destructor:CMsgLeagueWatchedGames.Series)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgLeagueWatchedGames_Series::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.game_.~RepeatedField();
}

void CMsgLeagueWatchedGames_Series::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgLeagueWatchedGames_Series::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgLeagueWatchedGames.Series)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.game_.Clear();
  _impl_.node_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgLeagueWatchedGames_Series::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 node_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 game = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_game(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_game(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgLeagueWatchedGames_Series::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgLeagueWatchedGames.Series)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 node_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_node_id(), target);
  }

  // repeated uint32 game = 2;
  for (int i = 0, n = this->_internal_game_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_game(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgLeagueWatchedGames.Series)
  return target;
}

size_t CMsgLeagueWatchedGames_Series::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgLeagueWatchedGames.Series)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 game = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.game_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_game_size());
    total_size += data_size;
  }

  // optional uint32 node_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgLeagueWatchedGames_Series::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgLeagueWatchedGames_Series::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgLeagueWatchedGames_Series::GetClassData() const { return &_class_data_; }


void CMsgLeagueWatchedGames_Series::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgLeagueWatchedGames_Series*>(&to_msg);
  auto& from = static_cast<const CMsgLeagueWatchedGames_Series&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgLeagueWatchedGames.Series)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.game_.MergeFrom(from._impl_.game_);
  if (from._internal_has_node_id()) {
    _this->_internal_set_node_id(from._internal_node_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgLeagueWatchedGames_Series::CopyFrom(const CMsgLeagueWatchedGames_Series& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgLeagueWatchedGames.Series)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgLeagueWatchedGames_Series::IsInitialized() const {
  return true;
}

void CMsgLeagueWatchedGames_Series::InternalSwap(CMsgLeagueWatchedGames_Series* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.game_.InternalSwap(&other->_impl_.game_);
  swap(_impl_.node_id_, other->_impl_.node_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgLeagueWatchedGames_Series::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[69]);
}

// ===================================================================

class CMsgLeagueWatchedGames_League::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgLeagueWatchedGames_League>()._impl_._has_bits_);
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgLeagueWatchedGames_League::CMsgLeagueWatchedGames_League(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgLeagueWatchedGames.League)
}
CMsgLeagueWatchedGames_League::CMsgLeagueWatchedGames_League(const CMsgLeagueWatchedGames_League& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgLeagueWatchedGames_League* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.series_){from._impl_.series_}
    , decltype(_impl_.league_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.league_id_ = from._impl_.league_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgLeagueWatchedGames.League)
}

inline void CMsgLeagueWatchedGames_League::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.series_){arena}
    , decltype(_impl_.league_id_){0u}
  };
}

CMsgLeagueWatchedGames_League::~CMsgLeagueWatchedGames_League() {
  // @@protoc_insertion_point(destructor:CMsgLeagueWatchedGames.League)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgLeagueWatchedGames_League::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.series_.~RepeatedPtrField();
}

void CMsgLeagueWatchedGames_League::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgLeagueWatchedGames_League::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgLeagueWatchedGames.League)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.series_.Clear();
  _impl_.league_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgLeagueWatchedGames_League::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 league_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgLeagueWatchedGames.Series series = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_series(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgLeagueWatchedGames_League::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgLeagueWatchedGames.League)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 league_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_league_id(), target);
  }

  // repeated .CMsgLeagueWatchedGames.Series series = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_series_size()); i < n; i++) {
    const auto& repfield = this->_internal_series(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgLeagueWatchedGames.League)
  return target;
}

size_t CMsgLeagueWatchedGames_League::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgLeagueWatchedGames.League)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgLeagueWatchedGames.Series series = 2;
  total_size += 1UL * this->_internal_series_size();
  for (const auto& msg : this->_impl_.series_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 league_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgLeagueWatchedGames_League::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgLeagueWatchedGames_League::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgLeagueWatchedGames_League::GetClassData() const { return &_class_data_; }


void CMsgLeagueWatchedGames_League::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgLeagueWatchedGames_League*>(&to_msg);
  auto& from = static_cast<const CMsgLeagueWatchedGames_League&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgLeagueWatchedGames.League)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.series_.MergeFrom(from._impl_.series_);
  if (from._internal_has_league_id()) {
    _this->_internal_set_league_id(from._internal_league_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgLeagueWatchedGames_League::CopyFrom(const CMsgLeagueWatchedGames_League& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgLeagueWatchedGames.League)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgLeagueWatchedGames_League::IsInitialized() const {
  return true;
}

void CMsgLeagueWatchedGames_League::InternalSwap(CMsgLeagueWatchedGames_League* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.series_.InternalSwap(&other->_impl_.series_);
  swap(_impl_.league_id_, other->_impl_.league_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgLeagueWatchedGames_League::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[70]);
}

// ===================================================================

class CMsgLeagueWatchedGames::_Internal {
 public:
};

CMsgLeagueWatchedGames::CMsgLeagueWatchedGames(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgLeagueWatchedGames)
}
CMsgLeagueWatchedGames::CMsgLeagueWatchedGames(const CMsgLeagueWatchedGames& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgLeagueWatchedGames* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.leagues_){from._impl_.leagues_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgLeagueWatchedGames)
}

inline void CMsgLeagueWatchedGames::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.leagues_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgLeagueWatchedGames::~CMsgLeagueWatchedGames() {
  // @@protoc_insertion_point(destructor:CMsgLeagueWatchedGames)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgLeagueWatchedGames::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.leagues_.~RepeatedPtrField();
}

void CMsgLeagueWatchedGames::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgLeagueWatchedGames::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgLeagueWatchedGames)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.leagues_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgLeagueWatchedGames::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgLeagueWatchedGames.League leagues = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_leagues(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgLeagueWatchedGames::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgLeagueWatchedGames)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgLeagueWatchedGames.League leagues = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_leagues_size()); i < n; i++) {
    const auto& repfield = this->_internal_leagues(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgLeagueWatchedGames)
  return target;
}

size_t CMsgLeagueWatchedGames::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgLeagueWatchedGames)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgLeagueWatchedGames.League leagues = 1;
  total_size += 1UL * this->_internal_leagues_size();
  for (const auto& msg : this->_impl_.leagues_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgLeagueWatchedGames::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgLeagueWatchedGames::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgLeagueWatchedGames::GetClassData() const { return &_class_data_; }


void CMsgLeagueWatchedGames::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgLeagueWatchedGames*>(&to_msg);
  auto& from = static_cast<const CMsgLeagueWatchedGames&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgLeagueWatchedGames)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.leagues_.MergeFrom(from._impl_.leagues_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgLeagueWatchedGames::CopyFrom(const CMsgLeagueWatchedGames& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgLeagueWatchedGames)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgLeagueWatchedGames::IsInitialized() const {
  return true;
}

void CMsgLeagueWatchedGames::InternalSwap(CMsgLeagueWatchedGames* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.leagues_.InternalSwap(&other->_impl_.leagues_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgLeagueWatchedGames::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[71]);
}

// ===================================================================

class CMsgDOTAMatch_Player_CustomGameData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAMatch_Player_CustomGameData>()._impl_._has_bits_);
  static void set_has_dota_team(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_winner(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDOTAMatch_Player_CustomGameData::CMsgDOTAMatch_Player_CustomGameData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAMatch.Player.CustomGameData)
}
CMsgDOTAMatch_Player_CustomGameData::CMsgDOTAMatch_Player_CustomGameData(const CMsgDOTAMatch_Player_CustomGameData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAMatch_Player_CustomGameData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dota_team_){}
    , decltype(_impl_.winner_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.dota_team_, &from._impl_.dota_team_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.winner_) -
    reinterpret_cast<char*>(&_impl_.dota_team_)) + sizeof(_impl_.winner_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAMatch.Player.CustomGameData)
}

inline void CMsgDOTAMatch_Player_CustomGameData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dota_team_){0u}
    , decltype(_impl_.winner_){false}
  };
}

CMsgDOTAMatch_Player_CustomGameData::~CMsgDOTAMatch_Player_CustomGameData() {
  // @@protoc_insertion_point(destructor:CMsgDOTAMatch.Player.CustomGameData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAMatch_Player_CustomGameData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAMatch_Player_CustomGameData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAMatch_Player_CustomGameData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAMatch.Player.CustomGameData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.dota_team_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.winner_) -
        reinterpret_cast<char*>(&_impl_.dota_team_)) + sizeof(_impl_.winner_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAMatch_Player_CustomGameData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 dota_team = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dota_team(&has_bits);
          _impl_.dota_team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool winner = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_winner(&has_bits);
          _impl_.winner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAMatch_Player_CustomGameData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAMatch.Player.CustomGameData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 dota_team = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dota_team(), target);
  }

  // optional bool winner = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_winner(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAMatch.Player.CustomGameData)
  return target;
}

size_t CMsgDOTAMatch_Player_CustomGameData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAMatch.Player.CustomGameData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 dota_team = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dota_team());
    }

    // optional bool winner = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAMatch_Player_CustomGameData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAMatch_Player_CustomGameData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAMatch_Player_CustomGameData::GetClassData() const { return &_class_data_; }


void CMsgDOTAMatch_Player_CustomGameData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAMatch_Player_CustomGameData*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAMatch_Player_CustomGameData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAMatch.Player.CustomGameData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dota_team_ = from._impl_.dota_team_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.winner_ = from._impl_.winner_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAMatch_Player_CustomGameData::CopyFrom(const CMsgDOTAMatch_Player_CustomGameData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAMatch.Player.CustomGameData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAMatch_Player_CustomGameData::IsInitialized() const {
  return true;
}

void CMsgDOTAMatch_Player_CustomGameData::InternalSwap(CMsgDOTAMatch_Player_CustomGameData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAMatch_Player_CustomGameData, _impl_.winner_)
      + sizeof(CMsgDOTAMatch_Player_CustomGameData::_impl_.winner_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAMatch_Player_CustomGameData, _impl_.dota_team_)>(
          reinterpret_cast<char*>(&_impl_.dota_team_),
          reinterpret_cast<char*>(&other->_impl_.dota_team_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAMatch_Player_CustomGameData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[72]);
}

// ===================================================================

class CMsgDOTAMatch_Player_HeroDamageReceived::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAMatch_Player_HeroDamageReceived>()._impl_._has_bits_);
  static void set_has_pre_reduction(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_post_reduction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_damage_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDOTAMatch_Player_HeroDamageReceived::CMsgDOTAMatch_Player_HeroDamageReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAMatch.Player.HeroDamageReceived)
}
CMsgDOTAMatch_Player_HeroDamageReceived::CMsgDOTAMatch_Player_HeroDamageReceived(const CMsgDOTAMatch_Player_HeroDamageReceived& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAMatch_Player_HeroDamageReceived* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pre_reduction_){}
    , decltype(_impl_.post_reduction_){}
    , decltype(_impl_.damage_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.pre_reduction_, &from._impl_.pre_reduction_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.damage_type_) -
    reinterpret_cast<char*>(&_impl_.pre_reduction_)) + sizeof(_impl_.damage_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAMatch.Player.HeroDamageReceived)
}

inline void CMsgDOTAMatch_Player_HeroDamageReceived::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pre_reduction_){0u}
    , decltype(_impl_.post_reduction_){0u}
    , decltype(_impl_.damage_type_){0}
  };
}

CMsgDOTAMatch_Player_HeroDamageReceived::~CMsgDOTAMatch_Player_HeroDamageReceived() {
  // @@protoc_insertion_point(destructor:CMsgDOTAMatch.Player.HeroDamageReceived)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAMatch_Player_HeroDamageReceived::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAMatch_Player_HeroDamageReceived::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAMatch_Player_HeroDamageReceived::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAMatch.Player.HeroDamageReceived)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.pre_reduction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.damage_type_) -
        reinterpret_cast<char*>(&_impl_.pre_reduction_)) + sizeof(_impl_.damage_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAMatch_Player_HeroDamageReceived::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 pre_reduction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pre_reduction(&has_bits);
          _impl_.pre_reduction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 post_reduction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_post_reduction(&has_bits);
          _impl_.post_reduction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAMatch.Player.HeroDamageType damage_type = 3 [default = HERO_DAMAGE_PHYSICAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgDOTAMatch_Player_HeroDamageType_IsValid(val))) {
            _internal_set_damage_type(static_cast<::CMsgDOTAMatch_Player_HeroDamageType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAMatch_Player_HeroDamageReceived::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAMatch.Player.HeroDamageReceived)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 pre_reduction = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_pre_reduction(), target);
  }

  // optional uint32 post_reduction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_post_reduction(), target);
  }

  // optional .CMsgDOTAMatch.Player.HeroDamageType damage_type = 3 [default = HERO_DAMAGE_PHYSICAL];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_damage_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAMatch.Player.HeroDamageReceived)
  return target;
}

size_t CMsgDOTAMatch_Player_HeroDamageReceived::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAMatch.Player.HeroDamageReceived)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 pre_reduction = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pre_reduction());
    }

    // optional uint32 post_reduction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_post_reduction());
    }

    // optional .CMsgDOTAMatch.Player.HeroDamageType damage_type = 3 [default = HERO_DAMAGE_PHYSICAL];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_damage_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAMatch_Player_HeroDamageReceived::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAMatch_Player_HeroDamageReceived::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAMatch_Player_HeroDamageReceived::GetClassData() const { return &_class_data_; }


void CMsgDOTAMatch_Player_HeroDamageReceived::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAMatch_Player_HeroDamageReceived*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAMatch_Player_HeroDamageReceived&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAMatch.Player.HeroDamageReceived)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.pre_reduction_ = from._impl_.pre_reduction_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.post_reduction_ = from._impl_.post_reduction_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.damage_type_ = from._impl_.damage_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAMatch_Player_HeroDamageReceived::CopyFrom(const CMsgDOTAMatch_Player_HeroDamageReceived& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAMatch.Player.HeroDamageReceived)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAMatch_Player_HeroDamageReceived::IsInitialized() const {
  return true;
}

void CMsgDOTAMatch_Player_HeroDamageReceived::InternalSwap(CMsgDOTAMatch_Player_HeroDamageReceived* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAMatch_Player_HeroDamageReceived, _impl_.damage_type_)
      + sizeof(CMsgDOTAMatch_Player_HeroDamageReceived::_impl_.damage_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAMatch_Player_HeroDamageReceived, _impl_.pre_reduction_)>(
          reinterpret_cast<char*>(&_impl_.pre_reduction_),
          reinterpret_cast<char*>(&other->_impl_.pre_reduction_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAMatch_Player_HeroDamageReceived::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[73]);
}

// ===================================================================

class CMsgDOTAMatch_Player::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAMatch_Player>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_player_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_item_0(HasBits* has_bits) {
    (*has_bits)[1] |= 67108864u;
  }
  static void set_has_item_1(HasBits* has_bits) {
    (*has_bits)[1] |= 134217728u;
  }
  static void set_has_item_2(HasBits* has_bits) {
    (*has_bits)[1] |= 268435456u;
  }
  static void set_has_item_3(HasBits* has_bits) {
    (*has_bits)[1] |= 536870912u;
  }
  static void set_has_item_4(HasBits* has_bits) {
    (*has_bits)[1] |= 1073741824u;
  }
  static void set_has_item_5(HasBits* has_bits) {
    (*has_bits)[1] |= 2147483648u;
  }
  static void set_has_item_6(HasBits* has_bits) {
    (*has_bits)[2] |= 1u;
  }
  static void set_has_item_7(HasBits* has_bits) {
    (*has_bits)[2] |= 2u;
  }
  static void set_has_item_8(HasBits* has_bits) {
    (*has_bits)[2] |= 4u;
  }
  static void set_has_item_9(HasBits* has_bits) {
    (*has_bits)[2] |= 8u;
  }
  static void set_has_expected_team_contribution(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_scaled_metric(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_previous_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_rank_change(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_mmr_type(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static void set_has_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_deaths(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_assists(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_leaver_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_last_hits(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_denies(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_gold_per_min(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_xp_per_min(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_gold_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_hero_damage(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_tower_damage(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_hero_healing(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_time_last_seen(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_player_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_support_ability_value(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_feeding_detected(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_search_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_search_rank_uncertainty(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_rank_uncertainty_change(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_hero_play_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_party_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_scaled_hero_damage(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_scaled_tower_damage(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_scaled_hero_healing(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_scaled_kills(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_scaled_deaths(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_scaled_assists(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_claimed_farm_gold(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_support_gold(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_claimed_denies(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_claimed_misses(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_misses(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_pro_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_real_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgDOTAMatch_Player_CustomGameData& custom_game_data(const CMsgDOTAMatch_Player* msg);
  static void set_has_custom_game_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_active_plus_subscription(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_net_worth(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_bot_difficulty(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static void set_has_hero_pick_order(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static void set_has_hero_was_randomed(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_hero_was_dota_plus_suggestion(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_seconds_dead(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static void set_has_gold_lost_to_death(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static void set_has_lane_selection_flags(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static void set_has_bounty_runes(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static void set_has_outposts_captured(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static void set_has_team_number(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static void set_has_team_slot(HasBits* has_bits) {
    (*has_bits)[1] |= 33554432u;
  }
};

const ::CMsgDOTAMatch_Player_CustomGameData&
CMsgDOTAMatch_Player::_Internal::custom_game_data(const CMsgDOTAMatch_Player* msg) {
  return *msg->_impl_.custom_game_data_;
}
CMsgDOTAMatch_Player::CMsgDOTAMatch_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAMatch.Player)
}
CMsgDOTAMatch_Player::CMsgDOTAMatch_Player(const CMsgDOTAMatch_Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAMatch_Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ability_upgrades_){from._impl_.ability_upgrades_}
    , decltype(_impl_.additional_units_inventory_){from._impl_.additional_units_inventory_}
    , decltype(_impl_.permanent_buffs_){from._impl_.permanent_buffs_}
    , decltype(_impl_.hero_damage_received_){from._impl_.hero_damage_received_}
    , decltype(_impl_.hero_damage_dealt_){from._impl_.hero_damage_dealt_}
    , decltype(_impl_.player_name_){}
    , decltype(_impl_.pro_name_){}
    , decltype(_impl_.real_name_){}
    , decltype(_impl_.custom_game_data_){nullptr}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.player_slot_){}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.expected_team_contribution_){}
    , decltype(_impl_.scaled_metric_){}
    , decltype(_impl_.previous_rank_){}
    , decltype(_impl_.rank_change_){}
    , decltype(_impl_.kills_){}
    , decltype(_impl_.deaths_){}
    , decltype(_impl_.assists_){}
    , decltype(_impl_.leaver_status_){}
    , decltype(_impl_.gold_){}
    , decltype(_impl_.last_hits_){}
    , decltype(_impl_.denies_){}
    , decltype(_impl_.gold_per_min_){}
    , decltype(_impl_.xp_per_min_){}
    , decltype(_impl_.gold_spent_){}
    , decltype(_impl_.hero_damage_){}
    , decltype(_impl_.tower_damage_){}
    , decltype(_impl_.hero_healing_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.time_last_seen_){}
    , decltype(_impl_.support_ability_value_){}
    , decltype(_impl_.search_rank_){}
    , decltype(_impl_.search_rank_uncertainty_){}
    , decltype(_impl_.rank_uncertainty_change_){}
    , decltype(_impl_.party_id_){}
    , decltype(_impl_.hero_play_count_){}
    , decltype(_impl_.scaled_kills_){}
    , decltype(_impl_.scaled_deaths_){}
    , decltype(_impl_.scaled_assists_){}
    , decltype(_impl_.claimed_farm_gold_){}
    , decltype(_impl_.support_gold_){}
    , decltype(_impl_.claimed_denies_){}
    , decltype(_impl_.claimed_misses_){}
    , decltype(_impl_.misses_){}
    , decltype(_impl_.net_worth_){}
    , decltype(_impl_.scaled_hero_damage_){}
    , decltype(_impl_.feeding_detected_){}
    , decltype(_impl_.active_plus_subscription_){}
    , decltype(_impl_.hero_was_randomed_){}
    , decltype(_impl_.hero_was_dota_plus_suggestion_){}
    , decltype(_impl_.scaled_tower_damage_){}
    , decltype(_impl_.scaled_hero_healing_){}
    , decltype(_impl_.bot_difficulty_){}
    , decltype(_impl_.hero_pick_order_){}
    , decltype(_impl_.seconds_dead_){}
    , decltype(_impl_.gold_lost_to_death_){}
    , decltype(_impl_.mmr_type_){}
    , decltype(_impl_.lane_selection_flags_){}
    , decltype(_impl_.bounty_runes_){}
    , decltype(_impl_.outposts_captured_){}
    , decltype(_impl_.team_number_){}
    , decltype(_impl_.team_slot_){}
    , decltype(_impl_.item_0_){}
    , decltype(_impl_.item_1_){}
    , decltype(_impl_.item_2_){}
    , decltype(_impl_.item_3_){}
    , decltype(_impl_.item_4_){}
    , decltype(_impl_.item_5_){}
    , decltype(_impl_.item_6_){}
    , decltype(_impl_.item_7_){}
    , decltype(_impl_.item_8_){}
    , decltype(_impl_.item_9_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_player_name()) {
    _this->_impl_.player_name_.Set(from._internal_player_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pro_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pro_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pro_name()) {
    _this->_impl_.pro_name_.Set(from._internal_pro_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.real_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.real_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_real_name()) {
    _this->_impl_.real_name_.Set(from._internal_real_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_custom_game_data()) {
    _this->_impl_.custom_game_data_ = new ::CMsgDOTAMatch_Player_CustomGameData(*from._impl_.custom_game_data_);
  }
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_9_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.item_9_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAMatch.Player)
}

inline void CMsgDOTAMatch_Player::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ability_upgrades_){arena}
    , decltype(_impl_.additional_units_inventory_){arena}
    , decltype(_impl_.permanent_buffs_){arena}
    , decltype(_impl_.hero_damage_received_){arena}
    , decltype(_impl_.hero_damage_dealt_){arena}
    , decltype(_impl_.player_name_){}
    , decltype(_impl_.pro_name_){}
    , decltype(_impl_.real_name_){}
    , decltype(_impl_.custom_game_data_){nullptr}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.player_slot_){0u}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.expected_team_contribution_){0}
    , decltype(_impl_.scaled_metric_){0}
    , decltype(_impl_.previous_rank_){0u}
    , decltype(_impl_.rank_change_){0}
    , decltype(_impl_.kills_){0u}
    , decltype(_impl_.deaths_){0u}
    , decltype(_impl_.assists_){0u}
    , decltype(_impl_.leaver_status_){0u}
    , decltype(_impl_.gold_){0u}
    , decltype(_impl_.last_hits_){0u}
    , decltype(_impl_.denies_){0u}
    , decltype(_impl_.gold_per_min_){0u}
    , decltype(_impl_.xp_per_min_){0u}
    , decltype(_impl_.gold_spent_){0u}
    , decltype(_impl_.hero_damage_){0u}
    , decltype(_impl_.tower_damage_){0u}
    , decltype(_impl_.hero_healing_){0u}
    , decltype(_impl_.level_){0u}
    , decltype(_impl_.time_last_seen_){0u}
    , decltype(_impl_.support_ability_value_){0u}
    , decltype(_impl_.search_rank_){0u}
    , decltype(_impl_.search_rank_uncertainty_){0u}
    , decltype(_impl_.rank_uncertainty_change_){0}
    , decltype(_impl_.party_id_){uint64_t{0u}}
    , decltype(_impl_.hero_play_count_){0u}
    , decltype(_impl_.scaled_kills_){0}
    , decltype(_impl_.scaled_deaths_){0}
    , decltype(_impl_.scaled_assists_){0}
    , decltype(_impl_.claimed_farm_gold_){0u}
    , decltype(_impl_.support_gold_){0u}
    , decltype(_impl_.claimed_denies_){0u}
    , decltype(_impl_.claimed_misses_){0u}
    , decltype(_impl_.misses_){0u}
    , decltype(_impl_.net_worth_){0u}
    , decltype(_impl_.scaled_hero_damage_){0u}
    , decltype(_impl_.feeding_detected_){false}
    , decltype(_impl_.active_plus_subscription_){false}
    , decltype(_impl_.hero_was_randomed_){false}
    , decltype(_impl_.hero_was_dota_plus_suggestion_){false}
    , decltype(_impl_.scaled_tower_damage_){0u}
    , decltype(_impl_.scaled_hero_healing_){0u}
    , decltype(_impl_.bot_difficulty_){0u}
    , decltype(_impl_.hero_pick_order_){0u}
    , decltype(_impl_.seconds_dead_){0u}
    , decltype(_impl_.gold_lost_to_death_){0u}
    , decltype(_impl_.mmr_type_){0u}
    , decltype(_impl_.lane_selection_flags_){0u}
    , decltype(_impl_.bounty_runes_){0u}
    , decltype(_impl_.outposts_captured_){0u}
    , decltype(_impl_.team_number_){0}
    , decltype(_impl_.team_slot_){0u}
    , decltype(_impl_.item_0_){-1}
    , decltype(_impl_.item_1_){-1}
    , decltype(_impl_.item_2_){-1}
    , decltype(_impl_.item_3_){-1}
    , decltype(_impl_.item_4_){-1}
    , decltype(_impl_.item_5_){-1}
    , decltype(_impl_.item_6_){-1}
    , decltype(_impl_.item_7_){-1}
    , decltype(_impl_.item_8_){-1}
    , decltype(_impl_.item_9_){-1}
  };
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pro_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pro_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.real_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.real_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTAMatch_Player::~CMsgDOTAMatch_Player() {
  // @@protoc_insertion_point(destructor:CMsgDOTAMatch.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAMatch_Player::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ability_upgrades_.~RepeatedPtrField();
  _impl_.additional_units_inventory_.~RepeatedPtrField();
  _impl_.permanent_buffs_.~RepeatedPtrField();
  _impl_.hero_damage_received_.~RepeatedPtrField();
  _impl_.hero_damage_dealt_.~RepeatedPtrField();
  _impl_.player_name_.Destroy();
  _impl_.pro_name_.Destroy();
  _impl_.real_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.custom_game_data_;
}

void CMsgDOTAMatch_Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAMatch_Player::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAMatch.Player)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ability_upgrades_.Clear();
  _impl_.additional_units_inventory_.Clear();
  _impl_.permanent_buffs_.Clear();
  _impl_.hero_damage_received_.Clear();
  _impl_.hero_damage_dealt_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.player_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pro_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.real_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.custom_game_data_ != nullptr);
      _impl_.custom_game_data_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.expected_team_contribution_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.expected_team_contribution_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.scaled_metric_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gold_) -
        reinterpret_cast<char*>(&_impl_.scaled_metric_)) + sizeof(_impl_.gold_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.last_hits_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hero_healing_) -
        reinterpret_cast<char*>(&_impl_.last_hits_)) + sizeof(_impl_.hero_healing_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hero_play_count_) -
        reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.hero_play_count_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.scaled_kills_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.misses_) -
        reinterpret_cast<char*>(&_impl_.scaled_kills_)) + sizeof(_impl_.misses_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.net_worth_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.scaled_hero_healing_) -
        reinterpret_cast<char*>(&_impl_.net_worth_)) + sizeof(_impl_.scaled_hero_healing_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.bot_difficulty_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.outposts_captured_) -
        reinterpret_cast<char*>(&_impl_.bot_difficulty_)) + sizeof(_impl_.outposts_captured_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.team_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.team_slot_) -
        reinterpret_cast<char*>(&_impl_.team_number_)) + sizeof(_impl_.team_slot_));
    _impl_.item_0_ = -1;
    _impl_.item_1_ = -1;
    _impl_.item_2_ = -1;
    _impl_.item_3_ = -1;
    _impl_.item_4_ = -1;
    _impl_.item_5_ = -1;
  }
  cached_has_bits = _impl_._has_bits_[2];
  if (cached_has_bits & 0x0000000fu) {
    _impl_.item_6_ = -1;
    _impl_.item_7_ = -1;
    _impl_.item_8_ = -1;
    _impl_.item_9_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAMatch_Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&_impl_._has_bits_);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 player_slot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_player_slot(&_impl_._has_bits_);
          _impl_.player_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hero_id(&_impl_._has_bits_);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_0 = 4 [default = -1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_item_0(&_impl_._has_bits_);
          _impl_.item_0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_1 = 5 [default = -1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_item_1(&_impl_._has_bits_);
          _impl_.item_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_2 = 6 [default = -1];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_item_2(&_impl_._has_bits_);
          _impl_.item_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_3 = 7 [default = -1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_item_3(&_impl_._has_bits_);
          _impl_.item_3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_4 = 8 [default = -1];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_item_4(&_impl_._has_bits_);
          _impl_.item_4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_5 = 9 [default = -1];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_item_5(&_impl_._has_bits_);
          _impl_.item_5_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float expected_team_contribution = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_expected_team_contribution(&_impl_._has_bits_);
          _impl_.expected_team_contribution_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float scaled_metric = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_scaled_metric(&_impl_._has_bits_);
          _impl_.scaled_metric_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 previous_rank = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_previous_rank(&_impl_._has_bits_);
          _impl_.previous_rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 rank_change = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_rank_change(&_impl_._has_bits_);
          _impl_.rank_change_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 kills = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_kills(&_impl_._has_bits_);
          _impl_.kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 deaths = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_deaths(&_impl_._has_bits_);
          _impl_.deaths_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assists = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_assists(&_impl_._has_bits_);
          _impl_.assists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 leaver_status = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_leaver_status(&_impl_._has_bits_);
          _impl_.leaver_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gold = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_gold(&_impl_._has_bits_);
          _impl_.gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_hits = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_last_hits(&_impl_._has_bits_);
          _impl_.last_hits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 denies = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_denies(&_impl_._has_bits_);
          _impl_.denies_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gold_per_min = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_gold_per_min(&_impl_._has_bits_);
          _impl_.gold_per_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 xp_per_min = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_xp_per_min(&_impl_._has_bits_);
          _impl_.xp_per_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gold_spent = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_gold_spent(&_impl_._has_bits_);
          _impl_.gold_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_damage = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_hero_damage(&_impl_._has_bits_);
          _impl_.hero_damage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tower_damage = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_tower_damage(&_impl_._has_bits_);
          _impl_.tower_damage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_healing = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_hero_healing(&_impl_._has_bits_);
          _impl_.hero_healing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_level(&_impl_._has_bits_);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_last_seen = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_time_last_seen(&_impl_._has_bits_);
          _impl_.time_last_seen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string player_name = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          auto str = _internal_mutable_player_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.Player.player_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 support_ability_value = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_support_ability_value(&_impl_._has_bits_);
          _impl_.support_ability_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool feeding_detected = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_feeding_detected(&_impl_._has_bits_);
          _impl_.feeding_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 search_rank = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_search_rank(&_impl_._has_bits_);
          _impl_.search_rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 search_rank_uncertainty = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_search_rank_uncertainty(&_impl_._has_bits_);
          _impl_.search_rank_uncertainty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rank_uncertainty_change = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rank_uncertainty_change(&_impl_._has_bits_);
          _impl_.rank_uncertainty_change_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_play_count = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_hero_play_count(&_impl_._has_bits_);
          _impl_.hero_play_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 party_id = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_party_id(&_impl_._has_bits_);
          _impl_.party_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional float scaled_kills = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_scaled_kills(&_impl_._has_bits_);
          _impl_.scaled_kills_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float scaled_deaths = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_scaled_deaths(&_impl_._has_bits_);
          _impl_.scaled_deaths_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float scaled_assists = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_scaled_assists(&_impl_._has_bits_);
          _impl_.scaled_assists_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 claimed_farm_gold = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_claimed_farm_gold(&_impl_._has_bits_);
          _impl_.claimed_farm_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 support_gold = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_support_gold(&_impl_._has_bits_);
          _impl_.support_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 claimed_denies = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_claimed_denies(&_impl_._has_bits_);
          _impl_.claimed_denies_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 claimed_misses = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_claimed_misses(&_impl_._has_bits_);
          _impl_.claimed_misses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 misses = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_misses(&_impl_._has_bits_);
          _impl_.misses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMatchPlayerAbilityUpgrade ability_upgrades = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_ability_upgrades(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<378>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMatchAdditionalUnitInventory additional_units_inventory = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_additional_units_inventory(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<386>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAMatch.Player.CustomGameData custom_game_data = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom_game_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool active_plus_subscription = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_active_plus_subscription(&_impl_._has_bits_);
          _impl_.active_plus_subscription_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 net_worth = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_net_worth(&_impl_._has_bits_);
          _impl_.net_worth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 scaled_hero_damage = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_scaled_hero_damage(&_impl_._has_bits_);
          _impl_.scaled_hero_damage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 scaled_tower_damage = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_scaled_tower_damage(&_impl_._has_bits_);
          _impl_.scaled_tower_damage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 scaled_hero_healing = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_scaled_hero_healing(&_impl_._has_bits_);
          _impl_.scaled_hero_healing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMatchPlayerPermanentBuff permanent_buffs = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_permanent_buffs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<458>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bot_difficulty = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_bot_difficulty(&_impl_._has_bits_);
          _impl_.bot_difficulty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_6 = 59 [default = -1];
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_item_6(&_impl_._has_bits_);
          _impl_.item_6_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_7 = 60 [default = -1];
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_item_7(&_impl_._has_bits_);
          _impl_.item_7_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_8 = 61 [default = -1];
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_item_8(&_impl_._has_bits_);
          _impl_.item_8_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_pick_order = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_hero_pick_order(&_impl_._has_bits_);
          _impl_.hero_pick_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hero_was_randomed = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_hero_was_randomed(&_impl_._has_bits_);
          _impl_.hero_was_randomed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAMatch.Player.HeroDamageReceived hero_damage_received = 67;
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_hero_damage_received(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<538>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool hero_was_dota_plus_suggestion = 69;
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_hero_was_dota_plus_suggestion(&_impl_._has_bits_);
          _impl_.hero_was_dota_plus_suggestion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seconds_dead = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_seconds_dead(&_impl_._has_bits_);
          _impl_.seconds_dead_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gold_lost_to_death = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_gold_lost_to_death(&_impl_._has_bits_);
          _impl_.gold_lost_to_death_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string pro_name = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_pro_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.Player.pro_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string real_name = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_real_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.Player.real_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mmr_type = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_mmr_type(&_impl_._has_bits_);
          _impl_.mmr_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lane_selection_flags = 75;
      case 75:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_lane_selection_flags(&_impl_._has_bits_);
          _impl_.lane_selection_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_9 = 76 [default = -1];
      case 76:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_item_9(&_impl_._has_bits_);
          _impl_.item_9_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bounty_runes = 77;
      case 77:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_bounty_runes(&_impl_._has_bits_);
          _impl_.bounty_runes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 outposts_captured = 78;
      case 78:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_outposts_captured(&_impl_._has_bits_);
          _impl_.outposts_captured_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAMatch.Player.HeroDamageReceived hero_damage_dealt = 79;
      case 79:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_hero_damage_dealt(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<634>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .DOTA_GC_TEAM team_number = 80 [default = DOTA_GC_TEAM_GOOD_GUYS];
      case 80:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::DOTA_GC_TEAM_IsValid(val))) {
            _internal_set_team_number(static_cast<::DOTA_GC_TEAM>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(80, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_slot = 81;
      case 81:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_team_slot(&_impl_._has_bits_);
          _impl_.team_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAMatch_Player::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAMatch.Player)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 player_slot = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_player_slot(), target);
  }

  // optional uint32 hero_id = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hero_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional int32 item_0 = 4 [default = -1];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_item_0(), target);
  }

  // optional int32 item_1 = 5 [default = -1];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_item_1(), target);
  }

  // optional int32 item_2 = 6 [default = -1];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_item_2(), target);
  }

  // optional int32 item_3 = 7 [default = -1];
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_item_3(), target);
  }

  // optional int32 item_4 = 8 [default = -1];
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_item_4(), target);
  }

  // optional int32 item_5 = 9 [default = -1];
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_item_5(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional float expected_team_contribution = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_expected_team_contribution(), target);
  }

  // optional float scaled_metric = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_scaled_metric(), target);
  }

  // optional uint32 previous_rank = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_previous_rank(), target);
  }

  // optional sint32 rank_change = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(13, this->_internal_rank_change(), target);
  }

  // optional uint32 kills = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_kills(), target);
  }

  // optional uint32 deaths = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_deaths(), target);
  }

  // optional uint32 assists = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_assists(), target);
  }

  // optional uint32 leaver_status = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_leaver_status(), target);
  }

  // optional uint32 gold = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_gold(), target);
  }

  // optional uint32 last_hits = 19;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_last_hits(), target);
  }

  // optional uint32 denies = 20;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_denies(), target);
  }

  // optional uint32 gold_per_min = 21;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_gold_per_min(), target);
  }

  // optional uint32 xp_per_min = 22;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_xp_per_min(), target);
  }

  // optional uint32 gold_spent = 23;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_gold_spent(), target);
  }

  // optional uint32 hero_damage = 24;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_hero_damage(), target);
  }

  // optional uint32 tower_damage = 25;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_tower_damage(), target);
  }

  // optional uint32 hero_healing = 26;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(26, this->_internal_hero_healing(), target);
  }

  // optional uint32 level = 27;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_level(), target);
  }

  // optional uint32 time_last_seen = 28;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_time_last_seen(), target);
  }

  // optional string player_name = 29;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_player_name().data(), static_cast<int>(this->_internal_player_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.Player.player_name");
    target = stream->WriteStringMaybeAliased(
        29, this->_internal_player_name(), target);
  }

  // optional uint32 support_ability_value = 30;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(30, this->_internal_support_ability_value(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool feeding_detected = 32;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(32, this->_internal_feeding_detected(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 search_rank = 34;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(34, this->_internal_search_rank(), target);
  }

  // optional uint32 search_rank_uncertainty = 35;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_search_rank_uncertainty(), target);
  }

  // optional int32 rank_uncertainty_change = 36;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(36, this->_internal_rank_uncertainty_change(), target);
  }

  // optional uint32 hero_play_count = 37;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(37, this->_internal_hero_play_count(), target);
  }

  // optional fixed64 party_id = 38;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(38, this->_internal_party_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional float scaled_kills = 39;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(39, this->_internal_scaled_kills(), target);
  }

  // optional float scaled_deaths = 40;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(40, this->_internal_scaled_deaths(), target);
  }

  // optional float scaled_assists = 41;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(41, this->_internal_scaled_assists(), target);
  }

  // optional uint32 claimed_farm_gold = 42;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(42, this->_internal_claimed_farm_gold(), target);
  }

  // optional uint32 support_gold = 43;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(43, this->_internal_support_gold(), target);
  }

  // optional uint32 claimed_denies = 44;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(44, this->_internal_claimed_denies(), target);
  }

  // optional uint32 claimed_misses = 45;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(45, this->_internal_claimed_misses(), target);
  }

  // optional uint32 misses = 46;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(46, this->_internal_misses(), target);
  }

  // repeated .CMatchPlayerAbilityUpgrade ability_upgrades = 47;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ability_upgrades_size()); i < n; i++) {
    const auto& repfield = this->_internal_ability_upgrades(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(47, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMatchAdditionalUnitInventory additional_units_inventory = 48;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_units_inventory_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_units_inventory(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(48, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgDOTAMatch.Player.CustomGameData custom_game_data = 50;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(50, _Internal::custom_game_data(this),
        _Internal::custom_game_data(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool active_plus_subscription = 51;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(51, this->_internal_active_plus_subscription(), target);
  }

  // optional uint32 net_worth = 52;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(52, this->_internal_net_worth(), target);
  }

  // optional uint32 scaled_hero_damage = 54;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(54, this->_internal_scaled_hero_damage(), target);
  }

  // optional uint32 scaled_tower_damage = 55;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(55, this->_internal_scaled_tower_damage(), target);
  }

  // optional uint32 scaled_hero_healing = 56;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(56, this->_internal_scaled_hero_healing(), target);
  }

  // repeated .CMatchPlayerPermanentBuff permanent_buffs = 57;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_permanent_buffs_size()); i < n; i++) {
    const auto& repfield = this->_internal_permanent_buffs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(57, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 bot_difficulty = 58;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(58, this->_internal_bot_difficulty(), target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional int32 item_6 = 59 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(59, this->_internal_item_6(), target);
  }

  // optional int32 item_7 = 60 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(60, this->_internal_item_7(), target);
  }

  // optional int32 item_8 = 61 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(61, this->_internal_item_8(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 hero_pick_order = 63;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(63, this->_internal_hero_pick_order(), target);
  }

  // optional bool hero_was_randomed = 64;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(64, this->_internal_hero_was_randomed(), target);
  }

  // repeated .CMsgDOTAMatch.Player.HeroDamageReceived hero_damage_received = 67;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hero_damage_received_size()); i < n; i++) {
    const auto& repfield = this->_internal_hero_damage_received(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(67, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool hero_was_dota_plus_suggestion = 69;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(69, this->_internal_hero_was_dota_plus_suggestion(), target);
  }

  // optional uint32 seconds_dead = 70;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(70, this->_internal_seconds_dead(), target);
  }

  // optional uint32 gold_lost_to_death = 71;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(71, this->_internal_gold_lost_to_death(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string pro_name = 72;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pro_name().data(), static_cast<int>(this->_internal_pro_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.Player.pro_name");
    target = stream->WriteStringMaybeAliased(
        72, this->_internal_pro_name(), target);
  }

  // optional string real_name = 73;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_real_name().data(), static_cast<int>(this->_internal_real_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.Player.real_name");
    target = stream->WriteStringMaybeAliased(
        73, this->_internal_real_name(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 mmr_type = 74;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(74, this->_internal_mmr_type(), target);
  }

  // optional uint32 lane_selection_flags = 75;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(75, this->_internal_lane_selection_flags(), target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional int32 item_9 = 76 [default = -1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(76, this->_internal_item_9(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 bounty_runes = 77;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(77, this->_internal_bounty_runes(), target);
  }

  // optional uint32 outposts_captured = 78;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(78, this->_internal_outposts_captured(), target);
  }

  // repeated .CMsgDOTAMatch.Player.HeroDamageReceived hero_damage_dealt = 79;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hero_damage_dealt_size()); i < n; i++) {
    const auto& repfield = this->_internal_hero_damage_dealt(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(79, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .DOTA_GC_TEAM team_number = 80 [default = DOTA_GC_TEAM_GOOD_GUYS];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      80, this->_internal_team_number(), target);
  }

  // optional uint32 team_slot = 81;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(81, this->_internal_team_slot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAMatch.Player)
  return target;
}

size_t CMsgDOTAMatch_Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAMatch.Player)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMatchPlayerAbilityUpgrade ability_upgrades = 47;
  total_size += 2UL * this->_internal_ability_upgrades_size();
  for (const auto& msg : this->_impl_.ability_upgrades_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMatchAdditionalUnitInventory additional_units_inventory = 48;
  total_size += 2UL * this->_internal_additional_units_inventory_size();
  for (const auto& msg : this->_impl_.additional_units_inventory_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMatchPlayerPermanentBuff permanent_buffs = 57;
  total_size += 2UL * this->_internal_permanent_buffs_size();
  for (const auto& msg : this->_impl_.permanent_buffs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTAMatch.Player.HeroDamageReceived hero_damage_received = 67;
  total_size += 2UL * this->_internal_hero_damage_received_size();
  for (const auto& msg : this->_impl_.hero_damage_received_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTAMatch.Player.HeroDamageReceived hero_damage_dealt = 79;
  total_size += 2UL * this->_internal_hero_damage_dealt_size();
  for (const auto& msg : this->_impl_.hero_damage_dealt_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string player_name = 29;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_player_name());
    }

    // optional string pro_name = 72;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pro_name());
    }

    // optional string real_name = 73;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_real_name());
    }

    // optional .CMsgDOTAMatch.Player.CustomGameData custom_game_data = 50;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.custom_game_data_);
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 player_slot = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_player_slot());
    }

    // optional uint32 hero_id = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional float expected_team_contribution = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float scaled_metric = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional uint32 previous_rank = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_previous_rank());
    }

    // optional sint32 rank_change = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_rank_change());
    }

    // optional uint32 kills = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_kills());
    }

    // optional uint32 deaths = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_deaths());
    }

    // optional uint32 assists = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_assists());
    }

    // optional uint32 leaver_status = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_leaver_status());
    }

    // optional uint32 gold = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gold());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 last_hits = 19;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_last_hits());
    }

    // optional uint32 denies = 20;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_denies());
    }

    // optional uint32 gold_per_min = 21;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gold_per_min());
    }

    // optional uint32 xp_per_min = 22;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_xp_per_min());
    }

    // optional uint32 gold_spent = 23;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gold_spent());
    }

    // optional uint32 hero_damage = 24;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_hero_damage());
    }

    // optional uint32 tower_damage = 25;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tower_damage());
    }

    // optional uint32 hero_healing = 26;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_hero_healing());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 level = 27;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_level());
    }

    // optional uint32 time_last_seen = 28;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_time_last_seen());
    }

    // optional uint32 support_ability_value = 30;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_support_ability_value());
    }

    // optional uint32 search_rank = 34;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_search_rank());
    }

    // optional uint32 search_rank_uncertainty = 35;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_search_rank_uncertainty());
    }

    // optional int32 rank_uncertainty_change = 36;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_rank_uncertainty_change());
    }

    // optional fixed64 party_id = 38;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 8;
    }

    // optional uint32 hero_play_count = 37;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_hero_play_count());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional float scaled_kills = 39;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 4;
    }

    // optional float scaled_deaths = 40;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 4;
    }

    // optional float scaled_assists = 41;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 4;
    }

    // optional uint32 claimed_farm_gold = 42;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_claimed_farm_gold());
    }

    // optional uint32 support_gold = 43;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_support_gold());
    }

    // optional uint32 claimed_denies = 44;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_claimed_denies());
    }

    // optional uint32 claimed_misses = 45;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_claimed_misses());
    }

    // optional uint32 misses = 46;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_misses());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 net_worth = 52;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_net_worth());
    }

    // optional uint32 scaled_hero_damage = 54;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_scaled_hero_damage());
    }

    // optional bool feeding_detected = 32;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional bool active_plus_subscription = 51;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional bool hero_was_randomed = 64;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool hero_was_dota_plus_suggestion = 69;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional uint32 scaled_tower_damage = 55;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_scaled_tower_damage());
    }

    // optional uint32 scaled_hero_healing = 56;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_scaled_hero_healing());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 bot_difficulty = 58;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_bot_difficulty());
    }

    // optional uint32 hero_pick_order = 63;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_hero_pick_order());
    }

    // optional uint32 seconds_dead = 70;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_seconds_dead());
    }

    // optional uint32 gold_lost_to_death = 71;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gold_lost_to_death());
    }

    // optional uint32 mmr_type = 74;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_mmr_type());
    }

    // optional uint32 lane_selection_flags = 75;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_lane_selection_flags());
    }

    // optional uint32 bounty_runes = 77;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_bounty_runes());
    }

    // optional uint32 outposts_captured = 78;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_outposts_captured());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .DOTA_GC_TEAM team_number = 80 [default = DOTA_GC_TEAM_GOOD_GUYS];
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_team_number());
    }

    // optional uint32 team_slot = 81;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_team_slot());
    }

    // optional int32 item_0 = 4 [default = -1];
    if (cached_has_bits & 0x04000000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_0());
    }

    // optional int32 item_1 = 5 [default = -1];
    if (cached_has_bits & 0x08000000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_1());
    }

    // optional int32 item_2 = 6 [default = -1];
    if (cached_has_bits & 0x10000000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_2());
    }

    // optional int32 item_3 = 7 [default = -1];
    if (cached_has_bits & 0x20000000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_3());
    }

    // optional int32 item_4 = 8 [default = -1];
    if (cached_has_bits & 0x40000000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_4());
    }

    // optional int32 item_5 = 9 [default = -1];
    if (cached_has_bits & 0x80000000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_5());
    }

  }
  cached_has_bits = _impl_._has_bits_[2];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 item_6 = 59 [default = -1];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_item_6());
    }

    // optional int32 item_7 = 60 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_item_7());
    }

    // optional int32 item_8 = 61 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_item_8());
    }

    // optional int32 item_9 = 76 [default = -1];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_item_9());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAMatch_Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAMatch_Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAMatch_Player::GetClassData() const { return &_class_data_; }


void CMsgDOTAMatch_Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAMatch_Player*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAMatch_Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAMatch.Player)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ability_upgrades_.MergeFrom(from._impl_.ability_upgrades_);
  _this->_impl_.additional_units_inventory_.MergeFrom(from._impl_.additional_units_inventory_);
  _this->_impl_.permanent_buffs_.MergeFrom(from._impl_.permanent_buffs_);
  _this->_impl_.hero_damage_received_.MergeFrom(from._impl_.hero_damage_received_);
  _this->_impl_.hero_damage_dealt_.MergeFrom(from._impl_.hero_damage_dealt_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_player_name(from._internal_player_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pro_name(from._internal_pro_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_real_name(from._internal_real_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_custom_game_data()->::CMsgDOTAMatch_Player_CustomGameData::MergeFrom(
          from._internal_custom_game_data());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.player_slot_ = from._impl_.player_slot_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.expected_team_contribution_ = from._impl_.expected_team_contribution_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.scaled_metric_ = from._impl_.scaled_metric_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.previous_rank_ = from._impl_.previous_rank_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.rank_change_ = from._impl_.rank_change_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.kills_ = from._impl_.kills_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.deaths_ = from._impl_.deaths_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.assists_ = from._impl_.assists_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.leaver_status_ = from._impl_.leaver_status_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.gold_ = from._impl_.gold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.last_hits_ = from._impl_.last_hits_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.denies_ = from._impl_.denies_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.gold_per_min_ = from._impl_.gold_per_min_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.xp_per_min_ = from._impl_.xp_per_min_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.gold_spent_ = from._impl_.gold_spent_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.hero_damage_ = from._impl_.hero_damage_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.tower_damage_ = from._impl_.tower_damage_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.hero_healing_ = from._impl_.hero_healing_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.time_last_seen_ = from._impl_.time_last_seen_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.support_ability_value_ = from._impl_.support_ability_value_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.search_rank_ = from._impl_.search_rank_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.search_rank_uncertainty_ = from._impl_.search_rank_uncertainty_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.rank_uncertainty_change_ = from._impl_.rank_uncertainty_change_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.party_id_ = from._impl_.party_id_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.hero_play_count_ = from._impl_.hero_play_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.scaled_kills_ = from._impl_.scaled_kills_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.scaled_deaths_ = from._impl_.scaled_deaths_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.scaled_assists_ = from._impl_.scaled_assists_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.claimed_farm_gold_ = from._impl_.claimed_farm_gold_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.support_gold_ = from._impl_.support_gold_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.claimed_denies_ = from._impl_.claimed_denies_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.claimed_misses_ = from._impl_.claimed_misses_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.misses_ = from._impl_.misses_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.net_worth_ = from._impl_.net_worth_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.scaled_hero_damage_ = from._impl_.scaled_hero_damage_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.feeding_detected_ = from._impl_.feeding_detected_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.active_plus_subscription_ = from._impl_.active_plus_subscription_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.hero_was_randomed_ = from._impl_.hero_was_randomed_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.hero_was_dota_plus_suggestion_ = from._impl_.hero_was_dota_plus_suggestion_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.scaled_tower_damage_ = from._impl_.scaled_tower_damage_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.scaled_hero_healing_ = from._impl_.scaled_hero_healing_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.bot_difficulty_ = from._impl_.bot_difficulty_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.hero_pick_order_ = from._impl_.hero_pick_order_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.seconds_dead_ = from._impl_.seconds_dead_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.gold_lost_to_death_ = from._impl_.gold_lost_to_death_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.mmr_type_ = from._impl_.mmr_type_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.lane_selection_flags_ = from._impl_.lane_selection_flags_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.bounty_runes_ = from._impl_.bounty_runes_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.outposts_captured_ = from._impl_.outposts_captured_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.team_number_ = from._impl_.team_number_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.team_slot_ = from._impl_.team_slot_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.item_0_ = from._impl_.item_0_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.item_1_ = from._impl_.item_1_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.item_2_ = from._impl_.item_2_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.item_3_ = from._impl_.item_3_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.item_4_ = from._impl_.item_4_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.item_5_ = from._impl_.item_5_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[2];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.item_6_ = from._impl_.item_6_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_7_ = from._impl_.item_7_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_8_ = from._impl_.item_8_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.item_9_ = from._impl_.item_9_;
    }
    _this->_impl_._has_bits_[2] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAMatch_Player::CopyFrom(const CMsgDOTAMatch_Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAMatch.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAMatch_Player::IsInitialized() const {
  return true;
}

void CMsgDOTAMatch_Player::InternalSwap(CMsgDOTAMatch_Player* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  swap(_impl_._has_bits_[2], other->_impl_._has_bits_[2]);
  _impl_.ability_upgrades_.InternalSwap(&other->_impl_.ability_upgrades_);
  _impl_.additional_units_inventory_.InternalSwap(&other->_impl_.additional_units_inventory_);
  _impl_.permanent_buffs_.InternalSwap(&other->_impl_.permanent_buffs_);
  _impl_.hero_damage_received_.InternalSwap(&other->_impl_.hero_damage_received_);
  _impl_.hero_damage_dealt_.InternalSwap(&other->_impl_.hero_damage_dealt_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.player_name_, lhs_arena,
      &other->_impl_.player_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pro_name_, lhs_arena,
      &other->_impl_.pro_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.real_name_, lhs_arena,
      &other->_impl_.real_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAMatch_Player, _impl_.team_slot_)
      + sizeof(CMsgDOTAMatch_Player::_impl_.team_slot_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAMatch_Player, _impl_.custom_game_data_)>(
          reinterpret_cast<char*>(&_impl_.custom_game_data_),
          reinterpret_cast<char*>(&other->_impl_.custom_game_data_));
  swap(_impl_.item_0_, other->_impl_.item_0_);
  swap(_impl_.item_1_, other->_impl_.item_1_);
  swap(_impl_.item_2_, other->_impl_.item_2_);
  swap(_impl_.item_3_, other->_impl_.item_3_);
  swap(_impl_.item_4_, other->_impl_.item_4_);
  swap(_impl_.item_5_, other->_impl_.item_5_);
  swap(_impl_.item_6_, other->_impl_.item_6_);
  swap(_impl_.item_7_, other->_impl_.item_7_);
  swap(_impl_.item_8_, other->_impl_.item_8_);
  swap(_impl_.item_9_, other->_impl_.item_9_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAMatch_Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[74]);
}

// ===================================================================

class CMsgDOTAMatch_BroadcasterInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAMatch_BroadcasterInfo>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTAMatch_BroadcasterInfo::CMsgDOTAMatch_BroadcasterInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAMatch.BroadcasterInfo)
}
CMsgDOTAMatch_BroadcasterInfo::CMsgDOTAMatch_BroadcasterInfo(const CMsgDOTAMatch_BroadcasterInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAMatch_BroadcasterInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.account_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.account_id_ = from._impl_.account_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAMatch.BroadcasterInfo)
}

inline void CMsgDOTAMatch_BroadcasterInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.account_id_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTAMatch_BroadcasterInfo::~CMsgDOTAMatch_BroadcasterInfo() {
  // @@protoc_insertion_point(destructor:CMsgDOTAMatch.BroadcasterInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAMatch_BroadcasterInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgDOTAMatch_BroadcasterInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAMatch_BroadcasterInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAMatch.BroadcasterInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.account_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAMatch_BroadcasterInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.BroadcasterInfo.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAMatch_BroadcasterInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAMatch.BroadcasterInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.BroadcasterInfo.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAMatch.BroadcasterInfo)
  return target;
}

size_t CMsgDOTAMatch_BroadcasterInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAMatch.BroadcasterInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAMatch_BroadcasterInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAMatch_BroadcasterInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAMatch_BroadcasterInfo::GetClassData() const { return &_class_data_; }


void CMsgDOTAMatch_BroadcasterInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAMatch_BroadcasterInfo*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAMatch_BroadcasterInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAMatch.BroadcasterInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAMatch_BroadcasterInfo::CopyFrom(const CMsgDOTAMatch_BroadcasterInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAMatch.BroadcasterInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAMatch_BroadcasterInfo::IsInitialized() const {
  return true;
}

void CMsgDOTAMatch_BroadcasterInfo::InternalSwap(CMsgDOTAMatch_BroadcasterInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.account_id_, other->_impl_.account_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAMatch_BroadcasterInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[75]);
}

// ===================================================================

class CMsgDOTAMatch_BroadcasterChannel::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAMatch_BroadcasterChannel>()._impl_._has_bits_);
  static void set_has_country_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_language_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgDOTAMatch_BroadcasterChannel::CMsgDOTAMatch_BroadcasterChannel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAMatch.BroadcasterChannel)
}
CMsgDOTAMatch_BroadcasterChannel::CMsgDOTAMatch_BroadcasterChannel(const CMsgDOTAMatch_BroadcasterChannel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAMatch_BroadcasterChannel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.broadcaster_infos_){from._impl_.broadcaster_infos_}
    , decltype(_impl_.country_code_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.language_code_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country_code()) {
    _this->_impl_.country_code_.Set(from._internal_country_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language_code()) {
    _this->_impl_.language_code_.Set(from._internal_language_code(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAMatch.BroadcasterChannel)
}

inline void CMsgDOTAMatch_BroadcasterChannel::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.broadcaster_infos_){arena}
    , decltype(_impl_.country_code_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.language_code_){}
  };
  _impl_.country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTAMatch_BroadcasterChannel::~CMsgDOTAMatch_BroadcasterChannel() {
  // @@protoc_insertion_point(destructor:CMsgDOTAMatch.BroadcasterChannel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAMatch_BroadcasterChannel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.broadcaster_infos_.~RepeatedPtrField();
  _impl_.country_code_.Destroy();
  _impl_.description_.Destroy();
  _impl_.language_code_.Destroy();
}

void CMsgDOTAMatch_BroadcasterChannel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAMatch_BroadcasterChannel::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAMatch.BroadcasterChannel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.broadcaster_infos_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.country_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.language_code_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAMatch_BroadcasterChannel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string country_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_country_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.BroadcasterChannel.country_code");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.BroadcasterChannel.description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAMatch.BroadcasterInfo broadcaster_infos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_broadcaster_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string language_code = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_language_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.BroadcasterChannel.language_code");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAMatch_BroadcasterChannel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAMatch.BroadcasterChannel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string country_code = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_country_code().data(), static_cast<int>(this->_internal_country_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.BroadcasterChannel.country_code");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_country_code(), target);
  }

  // optional string description = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.BroadcasterChannel.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // repeated .CMsgDOTAMatch.BroadcasterInfo broadcaster_infos = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_broadcaster_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_broadcaster_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string language_code = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language_code().data(), static_cast<int>(this->_internal_language_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.BroadcasterChannel.language_code");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_language_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAMatch.BroadcasterChannel)
  return target;
}

size_t CMsgDOTAMatch_BroadcasterChannel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAMatch.BroadcasterChannel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAMatch.BroadcasterInfo broadcaster_infos = 3;
  total_size += 1UL * this->_internal_broadcaster_infos_size();
  for (const auto& msg : this->_impl_.broadcaster_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string country_code = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country_code());
    }

    // optional string description = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string language_code = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language_code());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAMatch_BroadcasterChannel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAMatch_BroadcasterChannel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAMatch_BroadcasterChannel::GetClassData() const { return &_class_data_; }


void CMsgDOTAMatch_BroadcasterChannel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAMatch_BroadcasterChannel*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAMatch_BroadcasterChannel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAMatch.BroadcasterChannel)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.broadcaster_infos_.MergeFrom(from._impl_.broadcaster_infos_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_country_code(from._internal_country_code());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_language_code(from._internal_language_code());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAMatch_BroadcasterChannel::CopyFrom(const CMsgDOTAMatch_BroadcasterChannel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAMatch.BroadcasterChannel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAMatch_BroadcasterChannel::IsInitialized() const {
  return true;
}

void CMsgDOTAMatch_BroadcasterChannel::InternalSwap(CMsgDOTAMatch_BroadcasterChannel* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.broadcaster_infos_.InternalSwap(&other->_impl_.broadcaster_infos_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.country_code_, lhs_arena,
      &other->_impl_.country_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_code_, lhs_arena,
      &other->_impl_.language_code_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAMatch_BroadcasterChannel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[76]);
}

// ===================================================================

class CMsgDOTAMatch_Coach::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAMatch_Coach>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_coach_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coach_rating(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_coach_team(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_coach_party_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_private_coach(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CMsgDOTAMatch_Coach::CMsgDOTAMatch_Coach(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAMatch.Coach)
}
CMsgDOTAMatch_Coach::CMsgDOTAMatch_Coach(const CMsgDOTAMatch_Coach& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAMatch_Coach* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.coach_name_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.coach_rating_){}
    , decltype(_impl_.coach_party_id_){}
    , decltype(_impl_.coach_team_){}
    , decltype(_impl_.is_private_coach_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.coach_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.coach_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coach_name()) {
    _this->_impl_.coach_name_.Set(from._internal_coach_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_private_coach_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.is_private_coach_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAMatch.Coach)
}

inline void CMsgDOTAMatch_Coach::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.coach_name_){}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.coach_rating_){0u}
    , decltype(_impl_.coach_party_id_){uint64_t{0u}}
    , decltype(_impl_.coach_team_){0u}
    , decltype(_impl_.is_private_coach_){false}
  };
  _impl_.coach_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.coach_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTAMatch_Coach::~CMsgDOTAMatch_Coach() {
  // @@protoc_insertion_point(destructor:CMsgDOTAMatch.Coach)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAMatch_Coach::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.coach_name_.Destroy();
}

void CMsgDOTAMatch_Coach::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAMatch_Coach::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAMatch.Coach)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.coach_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_private_coach_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.is_private_coach_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAMatch_Coach::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string coach_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_coach_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.Coach.coach_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 coach_rating = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_coach_rating(&has_bits);
          _impl_.coach_rating_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 coach_team = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_coach_team(&has_bits);
          _impl_.coach_team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 coach_party_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_coach_party_id(&has_bits);
          _impl_.coach_party_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_private_coach = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_private_coach(&has_bits);
          _impl_.is_private_coach_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAMatch_Coach::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAMatch.Coach)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional string coach_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coach_name().data(), static_cast<int>(this->_internal_coach_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.Coach.coach_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_coach_name(), target);
  }

  // optional uint32 coach_rating = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_coach_rating(), target);
  }

  // optional uint32 coach_team = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_coach_team(), target);
  }

  // optional uint64 coach_party_id = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_coach_party_id(), target);
  }

  // optional bool is_private_coach = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_private_coach(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAMatch.Coach)
  return target;
}

size_t CMsgDOTAMatch_Coach::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAMatch.Coach)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string coach_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coach_name());
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 coach_rating = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_coach_rating());
    }

    // optional uint64 coach_party_id = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_coach_party_id());
    }

    // optional uint32 coach_team = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_coach_team());
    }

    // optional bool is_private_coach = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAMatch_Coach::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAMatch_Coach::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAMatch_Coach::GetClassData() const { return &_class_data_; }


void CMsgDOTAMatch_Coach::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAMatch_Coach*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAMatch_Coach&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAMatch.Coach)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_coach_name(from._internal_coach_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.coach_rating_ = from._impl_.coach_rating_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.coach_party_id_ = from._impl_.coach_party_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.coach_team_ = from._impl_.coach_team_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_private_coach_ = from._impl_.is_private_coach_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAMatch_Coach::CopyFrom(const CMsgDOTAMatch_Coach& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAMatch.Coach)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAMatch_Coach::IsInitialized() const {
  return true;
}

void CMsgDOTAMatch_Coach::InternalSwap(CMsgDOTAMatch_Coach* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.coach_name_, lhs_arena,
      &other->_impl_.coach_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAMatch_Coach, _impl_.is_private_coach_)
      + sizeof(CMsgDOTAMatch_Coach::_impl_.is_private_coach_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAMatch_Coach, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAMatch_Coach::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[77]);
}

// ===================================================================

class CMsgDOTAMatch_CustomGameData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAMatch_CustomGameData>()._impl_._has_bits_);
  static void set_has_custom_game_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_map_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTAMatch_CustomGameData::CMsgDOTAMatch_CustomGameData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAMatch.CustomGameData)
}
CMsgDOTAMatch_CustomGameData::CMsgDOTAMatch_CustomGameData(const CMsgDOTAMatch_CustomGameData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAMatch_CustomGameData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.map_name_){}
    , decltype(_impl_.custom_game_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.map_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_map_name()) {
    _this->_impl_.map_name_.Set(from._internal_map_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.custom_game_id_ = from._impl_.custom_game_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAMatch.CustomGameData)
}

inline void CMsgDOTAMatch_CustomGameData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.map_name_){}
    , decltype(_impl_.custom_game_id_){uint64_t{0u}}
  };
  _impl_.map_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTAMatch_CustomGameData::~CMsgDOTAMatch_CustomGameData() {
  // @@protoc_insertion_point(destructor:CMsgDOTAMatch.CustomGameData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAMatch_CustomGameData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.map_name_.Destroy();
}

void CMsgDOTAMatch_CustomGameData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAMatch_CustomGameData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAMatch.CustomGameData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.map_name_.ClearNonDefaultToEmpty();
  }
  _impl_.custom_game_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAMatch_CustomGameData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 custom_game_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_custom_game_id(&has_bits);
          _impl_.custom_game_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string map_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_map_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.CustomGameData.map_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAMatch_CustomGameData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAMatch.CustomGameData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 custom_game_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_custom_game_id(), target);
  }

  // optional string map_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_map_name().data(), static_cast<int>(this->_internal_map_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.CustomGameData.map_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_map_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAMatch.CustomGameData)
  return target;
}

size_t CMsgDOTAMatch_CustomGameData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAMatch.CustomGameData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string map_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_map_name());
    }

    // optional uint64 custom_game_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_custom_game_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAMatch_CustomGameData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAMatch_CustomGameData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAMatch_CustomGameData::GetClassData() const { return &_class_data_; }


void CMsgDOTAMatch_CustomGameData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAMatch_CustomGameData*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAMatch_CustomGameData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAMatch.CustomGameData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_map_name(from._internal_map_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.custom_game_id_ = from._impl_.custom_game_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAMatch_CustomGameData::CopyFrom(const CMsgDOTAMatch_CustomGameData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAMatch.CustomGameData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAMatch_CustomGameData::IsInitialized() const {
  return true;
}

void CMsgDOTAMatch_CustomGameData::InternalSwap(CMsgDOTAMatch_CustomGameData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.map_name_, lhs_arena,
      &other->_impl_.map_name_, rhs_arena
  );
  swap(_impl_.custom_game_id_, other->_impl_.custom_game_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAMatch_CustomGameData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[78]);
}

// ===================================================================

class CMsgDOTAMatch::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAMatch>()._impl_._has_bits_);
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_starttime(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_cluster(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_first_blood_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_replay_salt(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_server_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_server_port(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_lobby_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_human_players(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_average_skill(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_game_balance(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_radiant_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_dire_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_leagueid(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_radiant_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dire_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_radiant_team_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_dire_team_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_radiant_team_logo_url(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dire_team_logo_url(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_radiant_team_complete(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_dire_team_complete(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_positive_votes(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_negative_votes(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_game_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_match_seq_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_replay_state(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_radiant_guild_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_dire_guild_id(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_radiant_team_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dire_team_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_series_id(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_series_type(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_engine(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static const ::CMsgDOTAMatch_CustomGameData& custom_game_data(const CMsgDOTAMatch* msg);
  static void set_has_custom_game_data(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_match_flags(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_private_metadata_key(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_radiant_team_score(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_dire_team_score(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_match_outcome(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_tournament_id(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_tournament_round(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_pre_game_duration(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
};

const ::CMsgDOTAMatch_CustomGameData&
CMsgDOTAMatch::_Internal::custom_game_data(const CMsgDOTAMatch* msg) {
  return *msg->_impl_.custom_game_data_;
}
CMsgDOTAMatch::CMsgDOTAMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAMatch)
}
CMsgDOTAMatch::CMsgDOTAMatch(const CMsgDOTAMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAMatch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.players_){from._impl_.players_}
    , decltype(_impl_.tower_status_){from._impl_.tower_status_}
    , decltype(_impl_.barracks_status_){from._impl_.barracks_status_}
    , decltype(_impl_.picks_bans_){from._impl_.picks_bans_}
    , decltype(_impl_.broadcaster_channels_){from._impl_.broadcaster_channels_}
    , decltype(_impl_.coaches_){from._impl_.coaches_}
    , decltype(_impl_.radiant_team_name_){}
    , decltype(_impl_.dire_team_name_){}
    , decltype(_impl_.radiant_team_tag_){}
    , decltype(_impl_.dire_team_tag_){}
    , decltype(_impl_.radiant_team_logo_url_){}
    , decltype(_impl_.dire_team_logo_url_){}
    , decltype(_impl_.custom_game_data_){nullptr}
    , decltype(_impl_.duration_){}
    , decltype(_impl_.starttime_){}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.cluster_){}
    , decltype(_impl_.first_blood_time_){}
    , decltype(_impl_.replay_salt_){}
    , decltype(_impl_.server_ip_){}
    , decltype(_impl_.server_port_){}
    , decltype(_impl_.lobby_type_){}
    , decltype(_impl_.human_players_){}
    , decltype(_impl_.average_skill_){}
    , decltype(_impl_.game_balance_){}
    , decltype(_impl_.radiant_team_id_){}
    , decltype(_impl_.dire_team_id_){}
    , decltype(_impl_.leagueid_){}
    , decltype(_impl_.radiant_team_logo_){}
    , decltype(_impl_.dire_team_logo_){}
    , decltype(_impl_.radiant_team_complete_){}
    , decltype(_impl_.dire_team_complete_){}
    , decltype(_impl_.positive_votes_){}
    , decltype(_impl_.negative_votes_){}
    , decltype(_impl_.game_mode_){}
    , decltype(_impl_.replay_state_){}
    , decltype(_impl_.match_seq_num_){}
    , decltype(_impl_.radiant_guild_id_){}
    , decltype(_impl_.dire_guild_id_){}
    , decltype(_impl_.series_id_){}
    , decltype(_impl_.series_type_){}
    , decltype(_impl_.engine_){}
    , decltype(_impl_.match_flags_){}
    , decltype(_impl_.private_metadata_key_){}
    , decltype(_impl_.radiant_team_score_){}
    , decltype(_impl_.dire_team_score_){}
    , decltype(_impl_.match_outcome_){}
    , decltype(_impl_.tournament_id_){}
    , decltype(_impl_.tournament_round_){}
    , decltype(_impl_.pre_game_duration_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.radiant_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.radiant_team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_radiant_team_name()) {
    _this->_impl_.radiant_team_name_.Set(from._internal_radiant_team_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dire_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dire_team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dire_team_name()) {
    _this->_impl_.dire_team_name_.Set(from._internal_dire_team_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.radiant_team_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.radiant_team_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_radiant_team_tag()) {
    _this->_impl_.radiant_team_tag_.Set(from._internal_radiant_team_tag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dire_team_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dire_team_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dire_team_tag()) {
    _this->_impl_.dire_team_tag_.Set(from._internal_dire_team_tag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.radiant_team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.radiant_team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_radiant_team_logo_url()) {
    _this->_impl_.radiant_team_logo_url_.Set(from._internal_radiant_team_logo_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dire_team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dire_team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dire_team_logo_url()) {
    _this->_impl_.dire_team_logo_url_.Set(from._internal_dire_team_logo_url(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_custom_game_data()) {
    _this->_impl_.custom_game_data_ = new ::CMsgDOTAMatch_CustomGameData(*from._impl_.custom_game_data_);
  }
  ::memcpy(&_impl_.duration_, &from._impl_.duration_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pre_game_duration_) -
    reinterpret_cast<char*>(&_impl_.duration_)) + sizeof(_impl_.pre_game_duration_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAMatch)
}

inline void CMsgDOTAMatch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.players_){arena}
    , decltype(_impl_.tower_status_){arena}
    , decltype(_impl_.barracks_status_){arena}
    , decltype(_impl_.picks_bans_){arena}
    , decltype(_impl_.broadcaster_channels_){arena}
    , decltype(_impl_.coaches_){arena}
    , decltype(_impl_.radiant_team_name_){}
    , decltype(_impl_.dire_team_name_){}
    , decltype(_impl_.radiant_team_tag_){}
    , decltype(_impl_.dire_team_tag_){}
    , decltype(_impl_.radiant_team_logo_url_){}
    , decltype(_impl_.dire_team_logo_url_){}
    , decltype(_impl_.custom_game_data_){nullptr}
    , decltype(_impl_.duration_){0u}
    , decltype(_impl_.starttime_){0u}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.cluster_){0u}
    , decltype(_impl_.first_blood_time_){0u}
    , decltype(_impl_.replay_salt_){0u}
    , decltype(_impl_.server_ip_){0u}
    , decltype(_impl_.server_port_){0u}
    , decltype(_impl_.lobby_type_){0u}
    , decltype(_impl_.human_players_){0u}
    , decltype(_impl_.average_skill_){0u}
    , decltype(_impl_.game_balance_){0}
    , decltype(_impl_.radiant_team_id_){0u}
    , decltype(_impl_.dire_team_id_){0u}
    , decltype(_impl_.leagueid_){0u}
    , decltype(_impl_.radiant_team_logo_){uint64_t{0u}}
    , decltype(_impl_.dire_team_logo_){uint64_t{0u}}
    , decltype(_impl_.radiant_team_complete_){0u}
    , decltype(_impl_.dire_team_complete_){0u}
    , decltype(_impl_.positive_votes_){0u}
    , decltype(_impl_.negative_votes_){0u}
    , decltype(_impl_.game_mode_){0}
    , decltype(_impl_.replay_state_){0}
    , decltype(_impl_.match_seq_num_){uint64_t{0u}}
    , decltype(_impl_.radiant_guild_id_){0u}
    , decltype(_impl_.dire_guild_id_){0u}
    , decltype(_impl_.series_id_){0u}
    , decltype(_impl_.series_type_){0u}
    , decltype(_impl_.engine_){0u}
    , decltype(_impl_.match_flags_){0u}
    , decltype(_impl_.private_metadata_key_){0u}
    , decltype(_impl_.radiant_team_score_){0u}
    , decltype(_impl_.dire_team_score_){0u}
    , decltype(_impl_.match_outcome_){0}
    , decltype(_impl_.tournament_id_){0u}
    , decltype(_impl_.tournament_round_){0u}
    , decltype(_impl_.pre_game_duration_){0u}
  };
  _impl_.radiant_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.radiant_team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dire_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dire_team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.radiant_team_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.radiant_team_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dire_team_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dire_team_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.radiant_team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.radiant_team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dire_team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dire_team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTAMatch::~CMsgDOTAMatch() {
  // @@protoc_insertion_point(destructor:CMsgDOTAMatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.players_.~RepeatedPtrField();
  _impl_.tower_status_.~RepeatedField();
  _impl_.barracks_status_.~RepeatedField();
  _impl_.picks_bans_.~RepeatedPtrField();
  _impl_.broadcaster_channels_.~RepeatedPtrField();
  _impl_.coaches_.~RepeatedPtrField();
  _impl_.radiant_team_name_.Destroy();
  _impl_.dire_team_name_.Destroy();
  _impl_.radiant_team_tag_.Destroy();
  _impl_.dire_team_tag_.Destroy();
  _impl_.radiant_team_logo_url_.Destroy();
  _impl_.dire_team_logo_url_.Destroy();
  if (this != internal_default_instance()) delete _impl_.custom_game_data_;
}

void CMsgDOTAMatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.players_.Clear();
  _impl_.tower_status_.Clear();
  _impl_.barracks_status_.Clear();
  _impl_.picks_bans_.Clear();
  _impl_.broadcaster_channels_.Clear();
  _impl_.coaches_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.radiant_team_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.dire_team_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.radiant_team_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.dire_team_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.radiant_team_logo_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.dire_team_logo_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.custom_game_data_ != nullptr);
      _impl_.custom_game_data_->Clear();
    }
  }
  _impl_.duration_ = 0u;
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.starttime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.lobby_type_) -
        reinterpret_cast<char*>(&_impl_.starttime_)) + sizeof(_impl_.lobby_type_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.human_players_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dire_team_logo_) -
        reinterpret_cast<char*>(&_impl_.human_players_)) + sizeof(_impl_.dire_team_logo_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.radiant_team_complete_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.radiant_guild_id_) -
        reinterpret_cast<char*>(&_impl_.radiant_team_complete_)) + sizeof(_impl_.radiant_guild_id_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dire_guild_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dire_team_score_) -
        reinterpret_cast<char*>(&_impl_.dire_guild_id_)) + sizeof(_impl_.dire_team_score_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.match_outcome_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pre_game_duration_) -
        reinterpret_cast<char*>(&_impl_.match_outcome_)) + sizeof(_impl_.pre_game_duration_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAMatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 duration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_duration(&_impl_._has_bits_);
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 starttime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_starttime(&_impl_._has_bits_);
          _impl_.starttime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAMatch.Player players = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 match_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_match_id(&_impl_._has_bits_);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 tower_status = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_tower_status(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_tower_status(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 barracks_status = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_barracks_status(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<72>(ptr));
        } else if (static_cast<uint8_t>(tag) == 74) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_barracks_status(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cluster = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_cluster(&_impl_._has_bits_);
          _impl_.cluster_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 first_blood_time = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_first_blood_time(&_impl_._has_bits_);
          _impl_.first_blood_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 replay_salt = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_replay_salt(&_impl_._has_bits_);
          _impl_.replay_salt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 server_ip = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_server_ip(&_impl_._has_bits_);
          _impl_.server_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_port = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_server_port(&_impl_._has_bits_);
          _impl_.server_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lobby_type = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_lobby_type(&_impl_._has_bits_);
          _impl_.lobby_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 human_players = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_human_players(&_impl_._has_bits_);
          _impl_.human_players_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 average_skill = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_average_skill(&_impl_._has_bits_);
          _impl_.average_skill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float game_balance = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _Internal::set_has_game_balance(&_impl_._has_bits_);
          _impl_.game_balance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 radiant_team_id = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_radiant_team_id(&_impl_._has_bits_);
          _impl_.radiant_team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dire_team_id = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_dire_team_id(&_impl_._has_bits_);
          _impl_.dire_team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 leagueid = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_leagueid(&_impl_._has_bits_);
          _impl_.leagueid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string radiant_team_name = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_radiant_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.radiant_team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string dire_team_name = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          auto str = _internal_mutable_dire_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.dire_team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 radiant_team_logo = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_radiant_team_logo(&_impl_._has_bits_);
          _impl_.radiant_team_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 dire_team_logo = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_dire_team_logo(&_impl_._has_bits_);
          _impl_.dire_team_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 radiant_team_complete = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_radiant_team_complete(&_impl_._has_bits_);
          _impl_.radiant_team_complete_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dire_team_complete = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_dire_team_complete(&_impl_._has_bits_);
          _impl_.dire_team_complete_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 positive_votes = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_positive_votes(&_impl_._has_bits_);
          _impl_.positive_votes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 negative_votes = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_negative_votes(&_impl_._has_bits_);
          _impl_.negative_votes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .DOTA_GameMode game_mode = 31 [default = DOTA_GAMEMODE_NONE];
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::DOTA_GameMode_IsValid(val))) {
            _internal_set_game_mode(static_cast<::DOTA_GameMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(31, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .CMatchHeroSelectEvent picks_bans = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_picks_bans(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<258>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 match_seq_num = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_match_seq_num(&_impl_._has_bits_);
          _impl_.match_seq_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAMatch.ReplayState replay_state = 34 [default = REPLAY_AVAILABLE];
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgDOTAMatch_ReplayState_IsValid(val))) {
            _internal_set_replay_state(static_cast<::CMsgDOTAMatch_ReplayState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(34, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 radiant_guild_id = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_radiant_guild_id(&_impl_._has_bits_);
          _impl_.radiant_guild_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dire_guild_id = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dire_guild_id(&_impl_._has_bits_);
          _impl_.dire_guild_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string radiant_team_tag = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_radiant_team_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.radiant_team_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string dire_team_tag = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_dire_team_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.dire_team_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 series_id = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_series_id(&_impl_._has_bits_);
          _impl_.series_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 series_type = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_series_type(&_impl_._has_bits_);
          _impl_.series_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAMatch.BroadcasterChannel broadcaster_channels = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_broadcaster_channels(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<346>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 engine = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_engine(&_impl_._has_bits_);
          _impl_.engine_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAMatch.CustomGameData custom_game_data = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom_game_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 match_flags = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_match_flags(&_impl_._has_bits_);
          _impl_.match_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 private_metadata_key = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_private_metadata_key(&_impl_._has_bits_);
          _impl_.private_metadata_key_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 radiant_team_score = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_radiant_team_score(&_impl_._has_bits_);
          _impl_.radiant_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dire_team_score = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_dire_team_score(&_impl_._has_bits_);
          _impl_.dire_team_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EMatchOutcome match_outcome = 50 [default = k_EMatchOutcome_Unknown];
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EMatchOutcome_IsValid(val))) {
            _internal_set_match_outcome(static_cast<::EMatchOutcome>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(50, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tournament_id = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_tournament_id(&_impl_._has_bits_);
          _impl_.tournament_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tournament_round = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_tournament_round(&_impl_._has_bits_);
          _impl_.tournament_round_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pre_game_duration = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_pre_game_duration(&_impl_._has_bits_);
          _impl_.pre_game_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string radiant_team_logo_url = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_radiant_team_logo_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.radiant_team_logo_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string dire_team_logo_url = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_dire_team_logo_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatch.dire_team_logo_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAMatch.Coach coaches = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_coaches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<458>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 duration = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_duration(), target);
  }

  // optional fixed32 starttime = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_starttime(), target);
  }

  // repeated .CMsgDOTAMatch.Player players = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 match_id = 6;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_match_id(), target);
  }

  // repeated uint32 tower_status = 8;
  for (int i = 0, n = this->_internal_tower_status_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_tower_status(i), target);
  }

  // repeated uint32 barracks_status = 9;
  for (int i = 0, n = this->_internal_barracks_status_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_barracks_status(i), target);
  }

  // optional uint32 cluster = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_cluster(), target);
  }

  // optional uint32 first_blood_time = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_first_blood_time(), target);
  }

  // optional fixed32 replay_salt = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(13, this->_internal_replay_salt(), target);
  }

  // optional fixed32 server_ip = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(14, this->_internal_server_ip(), target);
  }

  // optional uint32 server_port = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_server_port(), target);
  }

  // optional uint32 lobby_type = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_lobby_type(), target);
  }

  // optional uint32 human_players = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_human_players(), target);
  }

  // optional uint32 average_skill = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_average_skill(), target);
  }

  // optional float game_balance = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(19, this->_internal_game_balance(), target);
  }

  // optional uint32 radiant_team_id = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_radiant_team_id(), target);
  }

  // optional uint32 dire_team_id = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_dire_team_id(), target);
  }

  // optional uint32 leagueid = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_leagueid(), target);
  }

  // optional string radiant_team_name = 23;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_radiant_team_name().data(), static_cast<int>(this->_internal_radiant_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.radiant_team_name");
    target = stream->WriteStringMaybeAliased(
        23, this->_internal_radiant_team_name(), target);
  }

  // optional string dire_team_name = 24;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dire_team_name().data(), static_cast<int>(this->_internal_dire_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.dire_team_name");
    target = stream->WriteStringMaybeAliased(
        24, this->_internal_dire_team_name(), target);
  }

  // optional uint64 radiant_team_logo = 25;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(25, this->_internal_radiant_team_logo(), target);
  }

  // optional uint64 dire_team_logo = 26;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(26, this->_internal_dire_team_logo(), target);
  }

  // optional uint32 radiant_team_complete = 27;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_radiant_team_complete(), target);
  }

  // optional uint32 dire_team_complete = 28;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_dire_team_complete(), target);
  }

  // optional uint32 positive_votes = 29;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(29, this->_internal_positive_votes(), target);
  }

  // optional uint32 negative_votes = 30;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(30, this->_internal_negative_votes(), target);
  }

  // optional .DOTA_GameMode game_mode = 31 [default = DOTA_GAMEMODE_NONE];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      31, this->_internal_game_mode(), target);
  }

  // repeated .CMatchHeroSelectEvent picks_bans = 32;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_picks_bans_size()); i < n; i++) {
    const auto& repfield = this->_internal_picks_bans(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(32, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 match_seq_num = 33;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(33, this->_internal_match_seq_num(), target);
  }

  // optional .CMsgDOTAMatch.ReplayState replay_state = 34 [default = REPLAY_AVAILABLE];
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      34, this->_internal_replay_state(), target);
  }

  // optional uint32 radiant_guild_id = 35;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_radiant_guild_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 dire_guild_id = 36;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(36, this->_internal_dire_guild_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string radiant_team_tag = 37;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_radiant_team_tag().data(), static_cast<int>(this->_internal_radiant_team_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.radiant_team_tag");
    target = stream->WriteStringMaybeAliased(
        37, this->_internal_radiant_team_tag(), target);
  }

  // optional string dire_team_tag = 38;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dire_team_tag().data(), static_cast<int>(this->_internal_dire_team_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.dire_team_tag");
    target = stream->WriteStringMaybeAliased(
        38, this->_internal_dire_team_tag(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 series_id = 39;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(39, this->_internal_series_id(), target);
  }

  // optional uint32 series_type = 40;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(40, this->_internal_series_type(), target);
  }

  // repeated .CMsgDOTAMatch.BroadcasterChannel broadcaster_channels = 43;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_broadcaster_channels_size()); i < n; i++) {
    const auto& repfield = this->_internal_broadcaster_channels(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(43, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 engine = 44;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(44, this->_internal_engine(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgDOTAMatch.CustomGameData custom_game_data = 45;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(45, _Internal::custom_game_data(this),
        _Internal::custom_game_data(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 match_flags = 46;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(46, this->_internal_match_flags(), target);
  }

  // optional fixed32 private_metadata_key = 47;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(47, this->_internal_private_metadata_key(), target);
  }

  // optional uint32 radiant_team_score = 48;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(48, this->_internal_radiant_team_score(), target);
  }

  // optional uint32 dire_team_score = 49;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(49, this->_internal_dire_team_score(), target);
  }

  // optional .EMatchOutcome match_outcome = 50 [default = k_EMatchOutcome_Unknown];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      50, this->_internal_match_outcome(), target);
  }

  // optional uint32 tournament_id = 51;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(51, this->_internal_tournament_id(), target);
  }

  // optional uint32 tournament_round = 52;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(52, this->_internal_tournament_round(), target);
  }

  // optional uint32 pre_game_duration = 53;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(53, this->_internal_pre_game_duration(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string radiant_team_logo_url = 54;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_radiant_team_logo_url().data(), static_cast<int>(this->_internal_radiant_team_logo_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.radiant_team_logo_url");
    target = stream->WriteStringMaybeAliased(
        54, this->_internal_radiant_team_logo_url(), target);
  }

  // optional string dire_team_logo_url = 55;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dire_team_logo_url().data(), static_cast<int>(this->_internal_dire_team_logo_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatch.dire_team_logo_url");
    target = stream->WriteStringMaybeAliased(
        55, this->_internal_dire_team_logo_url(), target);
  }

  // repeated .CMsgDOTAMatch.Coach coaches = 57;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_coaches_size()); i < n; i++) {
    const auto& repfield = this->_internal_coaches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(57, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAMatch)
  return target;
}

size_t CMsgDOTAMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAMatch.Player players = 5;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->_impl_.players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 tower_status = 8;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.tower_status_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_tower_status_size());
    total_size += data_size;
  }

  // repeated uint32 barracks_status = 9;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.barracks_status_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_barracks_status_size());
    total_size += data_size;
  }

  // repeated .CMatchHeroSelectEvent picks_bans = 32;
  total_size += 2UL * this->_internal_picks_bans_size();
  for (const auto& msg : this->_impl_.picks_bans_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTAMatch.BroadcasterChannel broadcaster_channels = 43;
  total_size += 2UL * this->_internal_broadcaster_channels_size();
  for (const auto& msg : this->_impl_.broadcaster_channels_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDOTAMatch.Coach coaches = 57;
  total_size += 2UL * this->_internal_coaches_size();
  for (const auto& msg : this->_impl_.coaches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string radiant_team_name = 23;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_radiant_team_name());
    }

    // optional string dire_team_name = 24;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dire_team_name());
    }

    // optional string radiant_team_tag = 37;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_radiant_team_tag());
    }

    // optional string dire_team_tag = 38;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dire_team_tag());
    }

    // optional string radiant_team_logo_url = 54;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_radiant_team_logo_url());
    }

    // optional string dire_team_logo_url = 55;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dire_team_logo_url());
    }

    // optional .CMsgDOTAMatch.CustomGameData custom_game_data = 45;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.custom_game_data_);
    }

    // optional uint32 duration = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_duration());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional fixed32 starttime = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional uint64 match_id = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 cluster = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cluster());
    }

    // optional uint32 first_blood_time = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_first_blood_time());
    }

    // optional fixed32 replay_salt = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional fixed32 server_ip = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional uint32 server_port = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_port());
    }

    // optional uint32 lobby_type = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_lobby_type());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 human_players = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_human_players());
    }

    // optional uint32 average_skill = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_average_skill());
    }

    // optional float game_balance = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 4;
    }

    // optional uint32 radiant_team_id = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_radiant_team_id());
    }

    // optional uint32 dire_team_id = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_dire_team_id());
    }

    // optional uint32 leagueid = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_leagueid());
    }

    // optional uint64 radiant_team_logo = 25;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_radiant_team_logo());
    }

    // optional uint64 dire_team_logo = 26;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_dire_team_logo());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 radiant_team_complete = 27;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_radiant_team_complete());
    }

    // optional uint32 dire_team_complete = 28;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_dire_team_complete());
    }

    // optional uint32 positive_votes = 29;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_positive_votes());
    }

    // optional uint32 negative_votes = 30;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_negative_votes());
    }

    // optional .DOTA_GameMode game_mode = 31 [default = DOTA_GAMEMODE_NONE];
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_game_mode());
    }

    // optional .CMsgDOTAMatch.ReplayState replay_state = 34 [default = REPLAY_AVAILABLE];
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_replay_state());
    }

    // optional uint64 match_seq_num = 33;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_match_seq_num());
    }

    // optional uint32 radiant_guild_id = 35;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_radiant_guild_id());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 dire_guild_id = 36;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_dire_guild_id());
    }

    // optional uint32 series_id = 39;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_series_id());
    }

    // optional uint32 series_type = 40;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_series_type());
    }

    // optional uint32 engine = 44;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_engine());
    }

    // optional uint32 match_flags = 46;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_match_flags());
    }

    // optional fixed32 private_metadata_key = 47;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 4;
    }

    // optional uint32 radiant_team_score = 48;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_radiant_team_score());
    }

    // optional uint32 dire_team_score = 49;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_dire_team_score());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional .EMatchOutcome match_outcome = 50 [default = k_EMatchOutcome_Unknown];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_match_outcome());
    }

    // optional uint32 tournament_id = 51;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tournament_id());
    }

    // optional uint32 tournament_round = 52;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tournament_round());
    }

    // optional uint32 pre_game_duration = 53;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_pre_game_duration());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAMatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAMatch::GetClassData() const { return &_class_data_; }


void CMsgDOTAMatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAMatch*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAMatch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAMatch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  _this->_impl_.tower_status_.MergeFrom(from._impl_.tower_status_);
  _this->_impl_.barracks_status_.MergeFrom(from._impl_.barracks_status_);
  _this->_impl_.picks_bans_.MergeFrom(from._impl_.picks_bans_);
  _this->_impl_.broadcaster_channels_.MergeFrom(from._impl_.broadcaster_channels_);
  _this->_impl_.coaches_.MergeFrom(from._impl_.coaches_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_radiant_team_name(from._internal_radiant_team_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_dire_team_name(from._internal_dire_team_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_radiant_team_tag(from._internal_radiant_team_tag());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_dire_team_tag(from._internal_dire_team_tag());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_radiant_team_logo_url(from._internal_radiant_team_logo_url());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_dire_team_logo_url(from._internal_dire_team_logo_url());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_custom_game_data()->::CMsgDOTAMatch_CustomGameData::MergeFrom(
          from._internal_custom_game_data());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.duration_ = from._impl_.duration_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.starttime_ = from._impl_.starttime_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.cluster_ = from._impl_.cluster_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.first_blood_time_ = from._impl_.first_blood_time_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.replay_salt_ = from._impl_.replay_salt_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.server_ip_ = from._impl_.server_ip_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.server_port_ = from._impl_.server_port_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.lobby_type_ = from._impl_.lobby_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.human_players_ = from._impl_.human_players_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.average_skill_ = from._impl_.average_skill_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.game_balance_ = from._impl_.game_balance_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.radiant_team_id_ = from._impl_.radiant_team_id_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.dire_team_id_ = from._impl_.dire_team_id_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.leagueid_ = from._impl_.leagueid_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.radiant_team_logo_ = from._impl_.radiant_team_logo_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.dire_team_logo_ = from._impl_.dire_team_logo_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.radiant_team_complete_ = from._impl_.radiant_team_complete_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.dire_team_complete_ = from._impl_.dire_team_complete_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.positive_votes_ = from._impl_.positive_votes_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.negative_votes_ = from._impl_.negative_votes_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.game_mode_ = from._impl_.game_mode_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.replay_state_ = from._impl_.replay_state_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.match_seq_num_ = from._impl_.match_seq_num_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.radiant_guild_id_ = from._impl_.radiant_guild_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dire_guild_id_ = from._impl_.dire_guild_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.series_id_ = from._impl_.series_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.series_type_ = from._impl_.series_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.engine_ = from._impl_.engine_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.match_flags_ = from._impl_.match_flags_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.private_metadata_key_ = from._impl_.private_metadata_key_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.radiant_team_score_ = from._impl_.radiant_team_score_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.dire_team_score_ = from._impl_.dire_team_score_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.match_outcome_ = from._impl_.match_outcome_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.tournament_id_ = from._impl_.tournament_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.tournament_round_ = from._impl_.tournament_round_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.pre_game_duration_ = from._impl_.pre_game_duration_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAMatch::CopyFrom(const CMsgDOTAMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAMatch::IsInitialized() const {
  return true;
}

void CMsgDOTAMatch::InternalSwap(CMsgDOTAMatch* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
  _impl_.tower_status_.InternalSwap(&other->_impl_.tower_status_);
  _impl_.barracks_status_.InternalSwap(&other->_impl_.barracks_status_);
  _impl_.picks_bans_.InternalSwap(&other->_impl_.picks_bans_);
  _impl_.broadcaster_channels_.InternalSwap(&other->_impl_.broadcaster_channels_);
  _impl_.coaches_.InternalSwap(&other->_impl_.coaches_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.radiant_team_name_, lhs_arena,
      &other->_impl_.radiant_team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dire_team_name_, lhs_arena,
      &other->_impl_.dire_team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.radiant_team_tag_, lhs_arena,
      &other->_impl_.radiant_team_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dire_team_tag_, lhs_arena,
      &other->_impl_.dire_team_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.radiant_team_logo_url_, lhs_arena,
      &other->_impl_.radiant_team_logo_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dire_team_logo_url_, lhs_arena,
      &other->_impl_.dire_team_logo_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAMatch, _impl_.pre_game_duration_)
      + sizeof(CMsgDOTAMatch::_impl_.pre_game_duration_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAMatch, _impl_.custom_game_data_)>(
          reinterpret_cast<char*>(&_impl_.custom_game_data_),
          reinterpret_cast<char*>(&other->_impl_.custom_game_data_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAMatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[79]);
}

// ===================================================================

class CMsgPlayerCard_StatModifier::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPlayerCard_StatModifier>()._impl_._has_bits_);
  static void set_has_stat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgPlayerCard_StatModifier::CMsgPlayerCard_StatModifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPlayerCard.StatModifier)
}
CMsgPlayerCard_StatModifier::CMsgPlayerCard_StatModifier(const CMsgPlayerCard_StatModifier& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPlayerCard_StatModifier* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stat_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.stat_, &from._impl_.stat_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.stat_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:CMsgPlayerCard.StatModifier)
}

inline void CMsgPlayerCard_StatModifier::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stat_){0u}
    , decltype(_impl_.value_){0u}
  };
}

CMsgPlayerCard_StatModifier::~CMsgPlayerCard_StatModifier() {
  // @@protoc_insertion_point(destructor:CMsgPlayerCard.StatModifier)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPlayerCard_StatModifier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgPlayerCard_StatModifier::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPlayerCard_StatModifier::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPlayerCard.StatModifier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.stat_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.value_) -
        reinterpret_cast<char*>(&_impl_.stat_)) + sizeof(_impl_.value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPlayerCard_StatModifier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 stat = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_stat(&has_bits);
          _impl_.stat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPlayerCard_StatModifier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPlayerCard.StatModifier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 stat = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_stat(), target);
  }

  // optional uint32 value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPlayerCard.StatModifier)
  return target;
}

size_t CMsgPlayerCard_StatModifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPlayerCard.StatModifier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 stat = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stat());
    }

    // optional uint32 value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPlayerCard_StatModifier::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPlayerCard_StatModifier::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPlayerCard_StatModifier::GetClassData() const { return &_class_data_; }


void CMsgPlayerCard_StatModifier::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPlayerCard_StatModifier*>(&to_msg);
  auto& from = static_cast<const CMsgPlayerCard_StatModifier&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPlayerCard.StatModifier)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.stat_ = from._impl_.stat_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPlayerCard_StatModifier::CopyFrom(const CMsgPlayerCard_StatModifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPlayerCard.StatModifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPlayerCard_StatModifier::IsInitialized() const {
  return true;
}

void CMsgPlayerCard_StatModifier::InternalSwap(CMsgPlayerCard_StatModifier* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPlayerCard_StatModifier, _impl_.value_)
      + sizeof(CMsgPlayerCard_StatModifier::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(CMsgPlayerCard_StatModifier, _impl_.stat_)>(
          reinterpret_cast<char*>(&_impl_.stat_),
          reinterpret_cast<char*>(&other->_impl_.stat_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPlayerCard_StatModifier::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[80]);
}

// ===================================================================

class CMsgPlayerCard::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPlayerCard>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgPlayerCard::CMsgPlayerCard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPlayerCard)
}
CMsgPlayerCard::CMsgPlayerCard(const CMsgPlayerCard& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPlayerCard* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stat_modifier_){from._impl_.stat_modifier_}
    , decltype(_impl_.account_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.account_id_ = from._impl_.account_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgPlayerCard)
}

inline void CMsgPlayerCard::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stat_modifier_){arena}
    , decltype(_impl_.account_id_){0u}
  };
}

CMsgPlayerCard::~CMsgPlayerCard() {
  // @@protoc_insertion_point(destructor:CMsgPlayerCard)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPlayerCard::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stat_modifier_.~RepeatedPtrField();
}

void CMsgPlayerCard::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPlayerCard::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPlayerCard)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stat_modifier_.Clear();
  _impl_.account_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPlayerCard::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgPlayerCard.StatModifier stat_modifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stat_modifier(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPlayerCard::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPlayerCard)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // repeated .CMsgPlayerCard.StatModifier stat_modifier = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stat_modifier_size()); i < n; i++) {
    const auto& repfield = this->_internal_stat_modifier(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPlayerCard)
  return target;
}

size_t CMsgPlayerCard::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPlayerCard)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgPlayerCard.StatModifier stat_modifier = 2;
  total_size += 1UL * this->_internal_stat_modifier_size();
  for (const auto& msg : this->_impl_.stat_modifier_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 account_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPlayerCard::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPlayerCard::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPlayerCard::GetClassData() const { return &_class_data_; }


void CMsgPlayerCard::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPlayerCard*>(&to_msg);
  auto& from = static_cast<const CMsgPlayerCard&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPlayerCard)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stat_modifier_.MergeFrom(from._impl_.stat_modifier_);
  if (from._internal_has_account_id()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPlayerCard::CopyFrom(const CMsgPlayerCard& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPlayerCard)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPlayerCard::IsInitialized() const {
  return true;
}

void CMsgPlayerCard::InternalSwap(CMsgPlayerCard* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.stat_modifier_.InternalSwap(&other->_impl_.stat_modifier_);
  swap(_impl_.account_id_, other->_impl_.account_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPlayerCard::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[81]);
}

// ===================================================================

class CMsgDOTAFantasyPlayerStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAFantasyPlayerStats>()._impl_._has_bits_);
  static void set_has_player_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_match_completed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_delay(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_series_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_series_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_deaths(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_cs(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_gpm(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_tower_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_roshan_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_teamfight_participation(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_wards_placed(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_camps_stacked(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_runes_grabbed(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_first_blood(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_stuns(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
};

CMsgDOTAFantasyPlayerStats::CMsgDOTAFantasyPlayerStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAFantasyPlayerStats)
}
CMsgDOTAFantasyPlayerStats::CMsgDOTAFantasyPlayerStats(const CMsgDOTAFantasyPlayerStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAFantasyPlayerStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.player_account_id_){}
    , decltype(_impl_.match_completed_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.delay_){}
    , decltype(_impl_.series_id_){}
    , decltype(_impl_.series_type_){}
    , decltype(_impl_.kills_){}
    , decltype(_impl_.deaths_){}
    , decltype(_impl_.cs_){}
    , decltype(_impl_.gpm_){}
    , decltype(_impl_.tower_kills_){}
    , decltype(_impl_.roshan_kills_){}
    , decltype(_impl_.teamfight_participation_){}
    , decltype(_impl_.wards_placed_){}
    , decltype(_impl_.camps_stacked_){}
    , decltype(_impl_.runes_grabbed_){}
    , decltype(_impl_.first_blood_){}
    , decltype(_impl_.stuns_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.match_id_, &from._impl_.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stuns_) -
    reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.stuns_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAFantasyPlayerStats)
}

inline void CMsgDOTAFantasyPlayerStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.player_account_id_){0u}
    , decltype(_impl_.match_completed_){false}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.delay_){0u}
    , decltype(_impl_.series_id_){0u}
    , decltype(_impl_.series_type_){0u}
    , decltype(_impl_.kills_){0u}
    , decltype(_impl_.deaths_){0u}
    , decltype(_impl_.cs_){0u}
    , decltype(_impl_.gpm_){0}
    , decltype(_impl_.tower_kills_){0u}
    , decltype(_impl_.roshan_kills_){0u}
    , decltype(_impl_.teamfight_participation_){0}
    , decltype(_impl_.wards_placed_){0u}
    , decltype(_impl_.camps_stacked_){0u}
    , decltype(_impl_.runes_grabbed_){0u}
    , decltype(_impl_.first_blood_){0u}
    , decltype(_impl_.stuns_){0}
  };
}

CMsgDOTAFantasyPlayerStats::~CMsgDOTAFantasyPlayerStats() {
  // @@protoc_insertion_point(destructor:CMsgDOTAFantasyPlayerStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAFantasyPlayerStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTAFantasyPlayerStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAFantasyPlayerStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAFantasyPlayerStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.series_type_) -
        reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.series_type_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.kills_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.wards_placed_) -
        reinterpret_cast<char*>(&_impl_.kills_)) + sizeof(_impl_.wards_placed_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&_impl_.camps_stacked_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.stuns_) -
        reinterpret_cast<char*>(&_impl_.camps_stacked_)) + sizeof(_impl_.stuns_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAFantasyPlayerStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 player_account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_account_id(&has_bits);
          _impl_.player_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 match_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool match_completed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_match_completed(&has_bits);
          _impl_.match_completed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 delay = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_delay(&has_bits);
          _impl_.delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 series_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_series_id(&has_bits);
          _impl_.series_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 series_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_series_type(&has_bits);
          _impl_.series_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 kills = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_kills(&has_bits);
          _impl_.kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 deaths = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_deaths(&has_bits);
          _impl_.deaths_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cs = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_cs(&has_bits);
          _impl_.cs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float gpm = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_gpm(&has_bits);
          _impl_.gpm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tower_kills = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_tower_kills(&has_bits);
          _impl_.tower_kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 roshan_kills = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_roshan_kills(&has_bits);
          _impl_.roshan_kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float teamfight_participation = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_teamfight_participation(&has_bits);
          _impl_.teamfight_participation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 wards_placed = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_wards_placed(&has_bits);
          _impl_.wards_placed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 camps_stacked = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_camps_stacked(&has_bits);
          _impl_.camps_stacked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 runes_grabbed = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_runes_grabbed(&has_bits);
          _impl_.runes_grabbed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 first_blood = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_first_blood(&has_bits);
          _impl_.first_blood_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float stuns = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          _Internal::set_has_stuns(&has_bits);
          _impl_.stuns_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAFantasyPlayerStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAFantasyPlayerStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 player_account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_player_account_id(), target);
  }

  // optional uint64 match_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_match_id(), target);
  }

  // optional bool match_completed = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_match_completed(), target);
  }

  // optional uint32 team_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_team_id(), target);
  }

  // optional uint32 league_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_league_id(), target);
  }

  // optional uint32 delay = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_delay(), target);
  }

  // optional uint32 series_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_series_id(), target);
  }

  // optional uint32 series_type = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_series_type(), target);
  }

  // optional uint32 kills = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_kills(), target);
  }

  // optional uint32 deaths = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_deaths(), target);
  }

  // optional uint32 cs = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_cs(), target);
  }

  // optional float gpm = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_gpm(), target);
  }

  // optional uint32 tower_kills = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_tower_kills(), target);
  }

  // optional uint32 roshan_kills = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_roshan_kills(), target);
  }

  // optional float teamfight_participation = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_teamfight_participation(), target);
  }

  // optional uint32 wards_placed = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_wards_placed(), target);
  }

  // optional uint32 camps_stacked = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_camps_stacked(), target);
  }

  // optional uint32 runes_grabbed = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_runes_grabbed(), target);
  }

  // optional uint32 first_blood = 20;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_first_blood(), target);
  }

  // optional float stuns = 21;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(21, this->_internal_stuns(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAFantasyPlayerStats)
  return target;
}

size_t CMsgDOTAFantasyPlayerStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAFantasyPlayerStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 match_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 player_account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_player_account_id());
    }

    // optional bool match_completed = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 team_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional uint32 league_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional uint32 delay = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_delay());
    }

    // optional uint32 series_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_series_id());
    }

    // optional uint32 series_type = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_series_type());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 kills = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_kills());
    }

    // optional uint32 deaths = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_deaths());
    }

    // optional uint32 cs = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cs());
    }

    // optional float gpm = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional uint32 tower_kills = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tower_kills());
    }

    // optional uint32 roshan_kills = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_roshan_kills());
    }

    // optional float teamfight_participation = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 4;
    }

    // optional uint32 wards_placed = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_wards_placed());
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional uint32 camps_stacked = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_camps_stacked());
    }

    // optional uint32 runes_grabbed = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_runes_grabbed());
    }

    // optional uint32 first_blood = 20;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_first_blood());
    }

    // optional float stuns = 21;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAFantasyPlayerStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAFantasyPlayerStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAFantasyPlayerStats::GetClassData() const { return &_class_data_; }


void CMsgDOTAFantasyPlayerStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAFantasyPlayerStats*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAFantasyPlayerStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAFantasyPlayerStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.player_account_id_ = from._impl_.player_account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.match_completed_ = from._impl_.match_completed_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.delay_ = from._impl_.delay_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.series_id_ = from._impl_.series_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.series_type_ = from._impl_.series_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.kills_ = from._impl_.kills_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.deaths_ = from._impl_.deaths_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.cs_ = from._impl_.cs_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.gpm_ = from._impl_.gpm_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.tower_kills_ = from._impl_.tower_kills_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.roshan_kills_ = from._impl_.roshan_kills_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.teamfight_participation_ = from._impl_.teamfight_participation_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.wards_placed_ = from._impl_.wards_placed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.camps_stacked_ = from._impl_.camps_stacked_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.runes_grabbed_ = from._impl_.runes_grabbed_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.first_blood_ = from._impl_.first_blood_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.stuns_ = from._impl_.stuns_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAFantasyPlayerStats::CopyFrom(const CMsgDOTAFantasyPlayerStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAFantasyPlayerStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAFantasyPlayerStats::IsInitialized() const {
  return true;
}

void CMsgDOTAFantasyPlayerStats::InternalSwap(CMsgDOTAFantasyPlayerStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyPlayerStats, _impl_.stuns_)
      + sizeof(CMsgDOTAFantasyPlayerStats::_impl_.stuns_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAFantasyPlayerStats, _impl_.match_id_)>(
          reinterpret_cast<char*>(&_impl_.match_id_),
          reinterpret_cast<char*>(&other->_impl_.match_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAFantasyPlayerStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[82]);
}

// ===================================================================

class CMsgDOTAFantasyPlayerMatchStats::_Internal {
 public:
};

CMsgDOTAFantasyPlayerMatchStats::CMsgDOTAFantasyPlayerMatchStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAFantasyPlayerMatchStats)
}
CMsgDOTAFantasyPlayerMatchStats::CMsgDOTAFantasyPlayerMatchStats(const CMsgDOTAFantasyPlayerMatchStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAFantasyPlayerMatchStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.matches_){from._impl_.matches_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAFantasyPlayerMatchStats)
}

inline void CMsgDOTAFantasyPlayerMatchStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.matches_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgDOTAFantasyPlayerMatchStats::~CMsgDOTAFantasyPlayerMatchStats() {
  // @@protoc_insertion_point(destructor:CMsgDOTAFantasyPlayerMatchStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAFantasyPlayerMatchStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.matches_.~RepeatedPtrField();
}

void CMsgDOTAFantasyPlayerMatchStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAFantasyPlayerMatchStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAFantasyPlayerMatchStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matches_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAFantasyPlayerMatchStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTAFantasyPlayerStats matches = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAFantasyPlayerMatchStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAFantasyPlayerMatchStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTAFantasyPlayerStats matches = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_matches_size()); i < n; i++) {
    const auto& repfield = this->_internal_matches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAFantasyPlayerMatchStats)
  return target;
}

size_t CMsgDOTAFantasyPlayerMatchStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAFantasyPlayerMatchStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAFantasyPlayerStats matches = 1;
  total_size += 1UL * this->_internal_matches_size();
  for (const auto& msg : this->_impl_.matches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAFantasyPlayerMatchStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAFantasyPlayerMatchStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAFantasyPlayerMatchStats::GetClassData() const { return &_class_data_; }


void CMsgDOTAFantasyPlayerMatchStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAFantasyPlayerMatchStats*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAFantasyPlayerMatchStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAFantasyPlayerMatchStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.matches_.MergeFrom(from._impl_.matches_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAFantasyPlayerMatchStats::CopyFrom(const CMsgDOTAFantasyPlayerMatchStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAFantasyPlayerMatchStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAFantasyPlayerMatchStats::IsInitialized() const {
  return true;
}

void CMsgDOTAFantasyPlayerMatchStats::InternalSwap(CMsgDOTAFantasyPlayerMatchStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.matches_.InternalSwap(&other->_impl_.matches_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAFantasyPlayerMatchStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[83]);
}

// ===================================================================

class CMsgDOTABotDebugInfo_Bot_Mode::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTABotDebugInfo_Bot_Mode>()._impl_._has_bits_);
  static void set_has_mode_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_desire(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_target_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_target_x(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_target_y(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_z(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgDOTABotDebugInfo_Bot_Mode::CMsgDOTABotDebugInfo_Bot_Mode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTABotDebugInfo.Bot.Mode)
}
CMsgDOTABotDebugInfo_Bot_Mode::CMsgDOTABotDebugInfo_Bot_Mode(const CMsgDOTABotDebugInfo_Bot_Mode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTABotDebugInfo_Bot_Mode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_id_){}
    , decltype(_impl_.desire_){}
    , decltype(_impl_.target_x_){}
    , decltype(_impl_.target_y_){}
    , decltype(_impl_.target_z_){}
    , decltype(_impl_.target_entity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.mode_id_, &from._impl_.mode_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_entity_) -
    reinterpret_cast<char*>(&_impl_.mode_id_)) + sizeof(_impl_.target_entity_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTABotDebugInfo.Bot.Mode)
}

inline void CMsgDOTABotDebugInfo_Bot_Mode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_id_){0u}
    , decltype(_impl_.desire_){0}
    , decltype(_impl_.target_x_){0u}
    , decltype(_impl_.target_y_){0u}
    , decltype(_impl_.target_z_){0u}
    , decltype(_impl_.target_entity_){-1}
  };
}

CMsgDOTABotDebugInfo_Bot_Mode::~CMsgDOTABotDebugInfo_Bot_Mode() {
  // @@protoc_insertion_point(destructor:CMsgDOTABotDebugInfo.Bot.Mode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTABotDebugInfo_Bot_Mode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDOTABotDebugInfo_Bot_Mode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTABotDebugInfo_Bot_Mode::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTABotDebugInfo.Bot.Mode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.mode_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.target_z_) -
        reinterpret_cast<char*>(&_impl_.mode_id_)) + sizeof(_impl_.target_z_));
    _impl_.target_entity_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTABotDebugInfo_Bot_Mode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 mode_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_mode_id(&has_bits);
          _impl_.mode_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float desire = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_desire(&has_bits);
          _impl_.desire_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_entity = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_target_entity(&has_bits);
          _impl_.target_entity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 target_x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_target_x(&has_bits);
          _impl_.target_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 target_y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_target_y(&has_bits);
          _impl_.target_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 target_z = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_target_z(&has_bits);
          _impl_.target_z_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTABotDebugInfo_Bot_Mode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTABotDebugInfo.Bot.Mode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 mode_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_mode_id(), target);
  }

  // optional float desire = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_desire(), target);
  }

  // optional int32 target_entity = 3 [default = -1];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_target_entity(), target);
  }

  // optional uint32 target_x = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_target_x(), target);
  }

  // optional uint32 target_y = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_target_y(), target);
  }

  // optional uint32 target_z = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_target_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTABotDebugInfo.Bot.Mode)
  return target;
}

size_t CMsgDOTABotDebugInfo_Bot_Mode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTABotDebugInfo.Bot.Mode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint32 mode_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode_id());
    }

    // optional float desire = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 target_x = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_target_x());
    }

    // optional uint32 target_y = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_target_y());
    }

    // optional uint32 target_z = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_target_z());
    }

    // optional int32 target_entity = 3 [default = -1];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_entity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTABotDebugInfo_Bot_Mode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTABotDebugInfo_Bot_Mode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTABotDebugInfo_Bot_Mode::GetClassData() const { return &_class_data_; }


void CMsgDOTABotDebugInfo_Bot_Mode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTABotDebugInfo_Bot_Mode*>(&to_msg);
  auto& from = static_cast<const CMsgDOTABotDebugInfo_Bot_Mode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTABotDebugInfo.Bot.Mode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.mode_id_ = from._impl_.mode_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.desire_ = from._impl_.desire_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.target_x_ = from._impl_.target_x_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.target_y_ = from._impl_.target_y_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.target_z_ = from._impl_.target_z_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.target_entity_ = from._impl_.target_entity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTABotDebugInfo_Bot_Mode::CopyFrom(const CMsgDOTABotDebugInfo_Bot_Mode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTABotDebugInfo.Bot.Mode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTABotDebugInfo_Bot_Mode::IsInitialized() const {
  return true;
}

void CMsgDOTABotDebugInfo_Bot_Mode::InternalSwap(CMsgDOTABotDebugInfo_Bot_Mode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTABotDebugInfo_Bot_Mode, _impl_.target_z_)
      + sizeof(CMsgDOTABotDebugInfo_Bot_Mode::_impl_.target_z_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTABotDebugInfo_Bot_Mode, _impl_.mode_id_)>(
          reinterpret_cast<char*>(&_impl_.mode_id_),
          reinterpret_cast<char*>(&other->_impl_.mode_id_));
  swap(_impl_.target_entity_, other->_impl_.target_entity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTABotDebugInfo_Bot_Mode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[84]);
}

// ===================================================================

class CMsgDOTABotDebugInfo_Bot_Action::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTABotDebugInfo_Bot_Action>()._impl_._has_bits_);
  static void set_has_action_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_action_target(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTABotDebugInfo_Bot_Action::CMsgDOTABotDebugInfo_Bot_Action(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTABotDebugInfo.Bot.Action)
}
CMsgDOTABotDebugInfo_Bot_Action::CMsgDOTABotDebugInfo_Bot_Action(const CMsgDOTABotDebugInfo_Bot_Action& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTABotDebugInfo_Bot_Action* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.action_target_){}
    , decltype(_impl_.action_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.action_target_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_target_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_action_target()) {
    _this->_impl_.action_target_.Set(from._internal_action_target(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.action_id_ = from._impl_.action_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTABotDebugInfo.Bot.Action)
}

inline void CMsgDOTABotDebugInfo_Bot_Action::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.action_target_){}
    , decltype(_impl_.action_id_){0u}
  };
  _impl_.action_target_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_target_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTABotDebugInfo_Bot_Action::~CMsgDOTABotDebugInfo_Bot_Action() {
  // @@protoc_insertion_point(destructor:CMsgDOTABotDebugInfo.Bot.Action)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTABotDebugInfo_Bot_Action::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.action_target_.Destroy();
}

void CMsgDOTABotDebugInfo_Bot_Action::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTABotDebugInfo_Bot_Action::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTABotDebugInfo.Bot.Action)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.action_target_.ClearNonDefaultToEmpty();
  }
  _impl_.action_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTABotDebugInfo_Bot_Action::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 action_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_action_id(&has_bits);
          _impl_.action_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string action_target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_action_target();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTABotDebugInfo.Bot.Action.action_target");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTABotDebugInfo_Bot_Action::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTABotDebugInfo.Bot.Action)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 action_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_action_id(), target);
  }

  // optional string action_target = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_action_target().data(), static_cast<int>(this->_internal_action_target().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTABotDebugInfo.Bot.Action.action_target");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_action_target(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTABotDebugInfo.Bot.Action)
  return target;
}

size_t CMsgDOTABotDebugInfo_Bot_Action::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTABotDebugInfo.Bot.Action)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string action_target = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_action_target());
    }

    // optional uint32 action_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_action_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTABotDebugInfo_Bot_Action::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTABotDebugInfo_Bot_Action::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTABotDebugInfo_Bot_Action::GetClassData() const { return &_class_data_; }


void CMsgDOTABotDebugInfo_Bot_Action::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTABotDebugInfo_Bot_Action*>(&to_msg);
  auto& from = static_cast<const CMsgDOTABotDebugInfo_Bot_Action&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTABotDebugInfo.Bot.Action)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_action_target(from._internal_action_target());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.action_id_ = from._impl_.action_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTABotDebugInfo_Bot_Action::CopyFrom(const CMsgDOTABotDebugInfo_Bot_Action& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTABotDebugInfo.Bot.Action)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTABotDebugInfo_Bot_Action::IsInitialized() const {
  return true;
}

void CMsgDOTABotDebugInfo_Bot_Action::InternalSwap(CMsgDOTABotDebugInfo_Bot_Action* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.action_target_, lhs_arena,
      &other->_impl_.action_target_, rhs_arena
  );
  swap(_impl_.action_id_, other->_impl_.action_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTABotDebugInfo_Bot_Action::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[85]);
}

// ===================================================================

class CMsgDOTABotDebugInfo_Bot::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTABotDebugInfo_Bot>()._impl_._has_bits_);
  static void set_has_player_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_difficulty(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_power_current(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_power_max(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_move_target_x(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_move_target_y(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_move_target_z(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_active_mode_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_execution_time(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::CMsgDOTABotDebugInfo_Bot_Action& action(const CMsgDOTABotDebugInfo_Bot* msg);
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgDOTABotDebugInfo_Bot_Action&
CMsgDOTABotDebugInfo_Bot::_Internal::action(const CMsgDOTABotDebugInfo_Bot* msg) {
  return *msg->_impl_.action_;
}
CMsgDOTABotDebugInfo_Bot::CMsgDOTABotDebugInfo_Bot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTABotDebugInfo.Bot)
}
CMsgDOTABotDebugInfo_Bot::CMsgDOTABotDebugInfo_Bot(const CMsgDOTABotDebugInfo_Bot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTABotDebugInfo_Bot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.modes_){from._impl_.modes_}
    , decltype(_impl_.action_){nullptr}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.difficulty_){}
    , decltype(_impl_.power_current_){}
    , decltype(_impl_.power_max_){}
    , decltype(_impl_.move_target_x_){}
    , decltype(_impl_.move_target_y_){}
    , decltype(_impl_.move_target_z_){}
    , decltype(_impl_.active_mode_id_){}
    , decltype(_impl_.execution_time_){}
    , decltype(_impl_.player_owner_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_action()) {
    _this->_impl_.action_ = new ::CMsgDOTABotDebugInfo_Bot_Action(*from._impl_.action_);
  }
  ::memcpy(&_impl_.hero_id_, &from._impl_.hero_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_owner_id_) -
    reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.player_owner_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTABotDebugInfo.Bot)
}

inline void CMsgDOTABotDebugInfo_Bot::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.modes_){arena}
    , decltype(_impl_.action_){nullptr}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.difficulty_){0u}
    , decltype(_impl_.power_current_){0u}
    , decltype(_impl_.power_max_){0u}
    , decltype(_impl_.move_target_x_){0u}
    , decltype(_impl_.move_target_y_){0u}
    , decltype(_impl_.move_target_z_){0u}
    , decltype(_impl_.active_mode_id_){0u}
    , decltype(_impl_.execution_time_){0}
    , decltype(_impl_.player_owner_id_){-1}
  };
}

CMsgDOTABotDebugInfo_Bot::~CMsgDOTABotDebugInfo_Bot() {
  // @@protoc_insertion_point(destructor:CMsgDOTABotDebugInfo.Bot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTABotDebugInfo_Bot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.modes_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.action_;
}

void CMsgDOTABotDebugInfo_Bot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTABotDebugInfo_Bot::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTABotDebugInfo.Bot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.modes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.action_ != nullptr);
    _impl_.action_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.hero_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.move_target_z_) -
        reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.move_target_z_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.active_mode_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.execution_time_) -
        reinterpret_cast<char*>(&_impl_.active_mode_id_)) + sizeof(_impl_.execution_time_));
    _impl_.player_owner_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTABotDebugInfo_Bot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_owner_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_owner_id(&has_bits);
          _impl_.player_owner_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 difficulty = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_difficulty(&has_bits);
          _impl_.difficulty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 power_current = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_power_current(&has_bits);
          _impl_.power_current_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 power_max = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_power_max(&has_bits);
          _impl_.power_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 move_target_x = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_move_target_x(&has_bits);
          _impl_.move_target_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 move_target_y = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_move_target_y(&has_bits);
          _impl_.move_target_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 move_target_z = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_move_target_z(&has_bits);
          _impl_.move_target_z_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 active_mode_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_active_mode_id(&has_bits);
          _impl_.active_mode_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float execution_time = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_execution_time(&has_bits);
          _impl_.execution_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTABotDebugInfo.Bot.Mode modes = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_modes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTABotDebugInfo.Bot.Action action = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_action(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTABotDebugInfo_Bot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTABotDebugInfo.Bot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_owner_id = 1 [default = -1];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_owner_id(), target);
  }

  // optional uint32 hero_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hero_id(), target);
  }

  // optional uint32 difficulty = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_difficulty(), target);
  }

  // optional uint32 power_current = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_power_current(), target);
  }

  // optional uint32 power_max = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_power_max(), target);
  }

  // optional uint32 move_target_x = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_move_target_x(), target);
  }

  // optional uint32 move_target_y = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_move_target_y(), target);
  }

  // optional uint32 move_target_z = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_move_target_z(), target);
  }

  // optional uint32 active_mode_id = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_active_mode_id(), target);
  }

  // optional float execution_time = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_execution_time(), target);
  }

  // repeated .CMsgDOTABotDebugInfo.Bot.Mode modes = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_modes_size()); i < n; i++) {
    const auto& repfield = this->_internal_modes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .CMsgDOTABotDebugInfo.Bot.Action action = 12;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::action(this),
        _Internal::action(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTABotDebugInfo.Bot)
  return target;
}

size_t CMsgDOTABotDebugInfo_Bot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTABotDebugInfo.Bot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTABotDebugInfo.Bot.Mode modes = 11;
  total_size += 1UL * this->_internal_modes_size();
  for (const auto& msg : this->_impl_.modes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgDOTABotDebugInfo.Bot.Action action = 12;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.action_);
    }

    // optional uint32 hero_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional uint32 difficulty = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_difficulty());
    }

    // optional uint32 power_current = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_power_current());
    }

    // optional uint32 power_max = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_power_max());
    }

    // optional uint32 move_target_x = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_move_target_x());
    }

    // optional uint32 move_target_y = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_move_target_y());
    }

    // optional uint32 move_target_z = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_move_target_z());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 active_mode_id = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_active_mode_id());
    }

    // optional float execution_time = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional int32 player_owner_id = 1 [default = -1];
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_owner_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTABotDebugInfo_Bot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTABotDebugInfo_Bot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTABotDebugInfo_Bot::GetClassData() const { return &_class_data_; }


void CMsgDOTABotDebugInfo_Bot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTABotDebugInfo_Bot*>(&to_msg);
  auto& from = static_cast<const CMsgDOTABotDebugInfo_Bot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTABotDebugInfo.Bot)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.modes_.MergeFrom(from._impl_.modes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_action()->::CMsgDOTABotDebugInfo_Bot_Action::MergeFrom(
          from._internal_action());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.difficulty_ = from._impl_.difficulty_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.power_current_ = from._impl_.power_current_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.power_max_ = from._impl_.power_max_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.move_target_x_ = from._impl_.move_target_x_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.move_target_y_ = from._impl_.move_target_y_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.move_target_z_ = from._impl_.move_target_z_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.active_mode_id_ = from._impl_.active_mode_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.execution_time_ = from._impl_.execution_time_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.player_owner_id_ = from._impl_.player_owner_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTABotDebugInfo_Bot::CopyFrom(const CMsgDOTABotDebugInfo_Bot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTABotDebugInfo.Bot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTABotDebugInfo_Bot::IsInitialized() const {
  return true;
}

void CMsgDOTABotDebugInfo_Bot::InternalSwap(CMsgDOTABotDebugInfo_Bot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.modes_.InternalSwap(&other->_impl_.modes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTABotDebugInfo_Bot, _impl_.execution_time_)
      + sizeof(CMsgDOTABotDebugInfo_Bot::_impl_.execution_time_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTABotDebugInfo_Bot, _impl_.action_)>(
          reinterpret_cast<char*>(&_impl_.action_),
          reinterpret_cast<char*>(&other->_impl_.action_));
  swap(_impl_.player_owner_id_, other->_impl_.player_owner_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTABotDebugInfo_Bot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[86]);
}

// ===================================================================

class CMsgDOTABotDebugInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTABotDebugInfo>()._impl_._has_bits_);
  static void set_has_desire_push_lane_top(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_desire_push_lane_mid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_desire_push_lane_bot(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_desire_defend_lane_top(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_desire_defend_lane_mid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_desire_defend_lane_bot(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_desire_farm_lane_top(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_desire_farm_lane_mid(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_desire_farm_lane_bot(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_desire_farm_roshan(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_execution_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

CMsgDOTABotDebugInfo::CMsgDOTABotDebugInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTABotDebugInfo)
}
CMsgDOTABotDebugInfo::CMsgDOTABotDebugInfo(const CMsgDOTABotDebugInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTABotDebugInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bots_){from._impl_.bots_}
    , decltype(_impl_.rune_status_){from._impl_.rune_status_}
    , decltype(_impl_.desire_push_lane_top_){}
    , decltype(_impl_.desire_push_lane_mid_){}
    , decltype(_impl_.desire_push_lane_bot_){}
    , decltype(_impl_.desire_defend_lane_top_){}
    , decltype(_impl_.desire_defend_lane_mid_){}
    , decltype(_impl_.desire_defend_lane_bot_){}
    , decltype(_impl_.desire_farm_lane_top_){}
    , decltype(_impl_.desire_farm_lane_mid_){}
    , decltype(_impl_.desire_farm_lane_bot_){}
    , decltype(_impl_.desire_farm_roshan_){}
    , decltype(_impl_.execution_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.desire_push_lane_top_, &from._impl_.desire_push_lane_top_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.execution_time_) -
    reinterpret_cast<char*>(&_impl_.desire_push_lane_top_)) + sizeof(_impl_.execution_time_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTABotDebugInfo)
}

inline void CMsgDOTABotDebugInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bots_){arena}
    , decltype(_impl_.rune_status_){arena}
    , decltype(_impl_.desire_push_lane_top_){0}
    , decltype(_impl_.desire_push_lane_mid_){0}
    , decltype(_impl_.desire_push_lane_bot_){0}
    , decltype(_impl_.desire_defend_lane_top_){0}
    , decltype(_impl_.desire_defend_lane_mid_){0}
    , decltype(_impl_.desire_defend_lane_bot_){0}
    , decltype(_impl_.desire_farm_lane_top_){0}
    , decltype(_impl_.desire_farm_lane_mid_){0}
    , decltype(_impl_.desire_farm_lane_bot_){0}
    , decltype(_impl_.desire_farm_roshan_){0}
    , decltype(_impl_.execution_time_){0}
  };
}

CMsgDOTABotDebugInfo::~CMsgDOTABotDebugInfo() {
  // @@protoc_insertion_point(destructor:CMsgDOTABotDebugInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTABotDebugInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bots_.~RepeatedPtrField();
  _impl_.rune_status_.~RepeatedField();
}

void CMsgDOTABotDebugInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTABotDebugInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTABotDebugInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bots_.Clear();
  _impl_.rune_status_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.desire_push_lane_top_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.desire_farm_lane_mid_) -
        reinterpret_cast<char*>(&_impl_.desire_push_lane_top_)) + sizeof(_impl_.desire_farm_lane_mid_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.desire_farm_lane_bot_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.execution_time_) -
        reinterpret_cast<char*>(&_impl_.desire_farm_lane_bot_)) + sizeof(_impl_.execution_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTABotDebugInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgDOTABotDebugInfo.Bot bots = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional float desire_push_lane_top = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_desire_push_lane_top(&has_bits);
          _impl_.desire_push_lane_top_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float desire_push_lane_mid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_desire_push_lane_mid(&has_bits);
          _impl_.desire_push_lane_mid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float desire_push_lane_bot = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_desire_push_lane_bot(&has_bits);
          _impl_.desire_push_lane_bot_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float desire_defend_lane_top = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_desire_defend_lane_top(&has_bits);
          _impl_.desire_defend_lane_top_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float desire_defend_lane_mid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_desire_defend_lane_mid(&has_bits);
          _impl_.desire_defend_lane_mid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float desire_defend_lane_bot = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_desire_defend_lane_bot(&has_bits);
          _impl_.desire_defend_lane_bot_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float desire_farm_lane_top = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_desire_farm_lane_top(&has_bits);
          _impl_.desire_farm_lane_top_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float desire_farm_lane_mid = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_desire_farm_lane_mid(&has_bits);
          _impl_.desire_farm_lane_mid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float desire_farm_lane_bot = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_desire_farm_lane_bot(&has_bits);
          _impl_.desire_farm_lane_bot_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float desire_farm_roshan = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_desire_farm_roshan(&has_bits);
          _impl_.desire_farm_roshan_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float execution_time = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_execution_time(&has_bits);
          _impl_.execution_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 rune_status = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_rune_status(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<104>(ptr));
        } else if (static_cast<uint8_t>(tag) == 106) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_rune_status(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTABotDebugInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTABotDebugInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgDOTABotDebugInfo.Bot bots = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bots_size()); i < n; i++) {
    const auto& repfield = this->_internal_bots(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional float desire_push_lane_top = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_desire_push_lane_top(), target);
  }

  // optional float desire_push_lane_mid = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_desire_push_lane_mid(), target);
  }

  // optional float desire_push_lane_bot = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_desire_push_lane_bot(), target);
  }

  // optional float desire_defend_lane_top = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_desire_defend_lane_top(), target);
  }

  // optional float desire_defend_lane_mid = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_desire_defend_lane_mid(), target);
  }

  // optional float desire_defend_lane_bot = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_desire_defend_lane_bot(), target);
  }

  // optional float desire_farm_lane_top = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_desire_farm_lane_top(), target);
  }

  // optional float desire_farm_lane_mid = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_desire_farm_lane_mid(), target);
  }

  // optional float desire_farm_lane_bot = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_desire_farm_lane_bot(), target);
  }

  // optional float desire_farm_roshan = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_desire_farm_roshan(), target);
  }

  // optional float execution_time = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_execution_time(), target);
  }

  // repeated uint32 rune_status = 13;
  for (int i = 0, n = this->_internal_rune_status_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_rune_status(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTABotDebugInfo)
  return target;
}

size_t CMsgDOTABotDebugInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTABotDebugInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTABotDebugInfo.Bot bots = 1;
  total_size += 1UL * this->_internal_bots_size();
  for (const auto& msg : this->_impl_.bots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 rune_status = 13;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.rune_status_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_rune_status_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float desire_push_lane_top = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float desire_push_lane_mid = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float desire_push_lane_bot = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float desire_defend_lane_top = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float desire_defend_lane_mid = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float desire_defend_lane_bot = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float desire_farm_lane_top = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float desire_farm_lane_mid = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional float desire_farm_lane_bot = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float desire_farm_roshan = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float execution_time = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTABotDebugInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTABotDebugInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTABotDebugInfo::GetClassData() const { return &_class_data_; }


void CMsgDOTABotDebugInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTABotDebugInfo*>(&to_msg);
  auto& from = static_cast<const CMsgDOTABotDebugInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTABotDebugInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bots_.MergeFrom(from._impl_.bots_);
  _this->_impl_.rune_status_.MergeFrom(from._impl_.rune_status_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.desire_push_lane_top_ = from._impl_.desire_push_lane_top_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.desire_push_lane_mid_ = from._impl_.desire_push_lane_mid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.desire_push_lane_bot_ = from._impl_.desire_push_lane_bot_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.desire_defend_lane_top_ = from._impl_.desire_defend_lane_top_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.desire_defend_lane_mid_ = from._impl_.desire_defend_lane_mid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.desire_defend_lane_bot_ = from._impl_.desire_defend_lane_bot_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.desire_farm_lane_top_ = from._impl_.desire_farm_lane_top_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.desire_farm_lane_mid_ = from._impl_.desire_farm_lane_mid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.desire_farm_lane_bot_ = from._impl_.desire_farm_lane_bot_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.desire_farm_roshan_ = from._impl_.desire_farm_roshan_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.execution_time_ = from._impl_.execution_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTABotDebugInfo::CopyFrom(const CMsgDOTABotDebugInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTABotDebugInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTABotDebugInfo::IsInitialized() const {
  return true;
}

void CMsgDOTABotDebugInfo::InternalSwap(CMsgDOTABotDebugInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.bots_.InternalSwap(&other->_impl_.bots_);
  _impl_.rune_status_.InternalSwap(&other->_impl_.rune_status_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTABotDebugInfo, _impl_.execution_time_)
      + sizeof(CMsgDOTABotDebugInfo::_impl_.execution_time_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTABotDebugInfo, _impl_.desire_push_lane_top_)>(
          reinterpret_cast<char*>(&_impl_.desire_push_lane_top_),
          reinterpret_cast<char*>(&other->_impl_.desire_push_lane_top_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTABotDebugInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[87]);
}

// ===================================================================

class CMsgSuccessfulHero::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSuccessfulHero>()._impl_._has_bits_);
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_win_percent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_longest_streak(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgSuccessfulHero::CMsgSuccessfulHero(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgSuccessfulHero)
}
CMsgSuccessfulHero::CMsgSuccessfulHero(const CMsgSuccessfulHero& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgSuccessfulHero* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.win_percent_){}
    , decltype(_impl_.longest_streak_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hero_id_, &from._impl_.hero_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.longest_streak_) -
    reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.longest_streak_));
  // @@protoc_insertion_point(copy_constructor:CMsgSuccessfulHero)
}

inline void CMsgSuccessfulHero::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.win_percent_){0}
    , decltype(_impl_.longest_streak_){0u}
  };
}

CMsgSuccessfulHero::~CMsgSuccessfulHero() {
  // @@protoc_insertion_point(destructor:CMsgSuccessfulHero)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgSuccessfulHero::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSuccessfulHero::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgSuccessfulHero::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSuccessfulHero)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.hero_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.longest_streak_) -
        reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.longest_streak_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSuccessfulHero::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 hero_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float win_percent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_win_percent(&has_bits);
          _impl_.win_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 longest_streak = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_longest_streak(&has_bits);
          _impl_.longest_streak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSuccessfulHero::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSuccessfulHero)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 hero_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hero_id(), target);
  }

  // optional float win_percent = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_win_percent(), target);
  }

  // optional uint32 longest_streak = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_longest_streak(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSuccessfulHero)
  return target;
}

size_t CMsgSuccessfulHero::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSuccessfulHero)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 hero_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional float win_percent = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 longest_streak = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_longest_streak());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSuccessfulHero::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgSuccessfulHero::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSuccessfulHero::GetClassData() const { return &_class_data_; }


void CMsgSuccessfulHero::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgSuccessfulHero*>(&to_msg);
  auto& from = static_cast<const CMsgSuccessfulHero&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgSuccessfulHero)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.win_percent_ = from._impl_.win_percent_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.longest_streak_ = from._impl_.longest_streak_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSuccessfulHero::CopyFrom(const CMsgSuccessfulHero& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSuccessfulHero)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSuccessfulHero::IsInitialized() const {
  return true;
}

void CMsgSuccessfulHero::InternalSwap(CMsgSuccessfulHero* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSuccessfulHero, _impl_.longest_streak_)
      + sizeof(CMsgSuccessfulHero::_impl_.longest_streak_)
      - PROTOBUF_FIELD_OFFSET(CMsgSuccessfulHero, _impl_.hero_id_)>(
          reinterpret_cast<char*>(&_impl_.hero_id_),
          reinterpret_cast<char*>(&other->_impl_.hero_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSuccessfulHero::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[88]);
}

// ===================================================================

class CMsgRecentMatchInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRecentMatchInfo>()._impl_._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_game_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_deaths(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_assists(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_player_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_match_outcome(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_lobby_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_team_number(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

CMsgRecentMatchInfo::CMsgRecentMatchInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgRecentMatchInfo)
}
CMsgRecentMatchInfo::CMsgRecentMatchInfo(const CMsgRecentMatchInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgRecentMatchInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.game_mode_){}
    , decltype(_impl_.kills_){}
    , decltype(_impl_.deaths_){}
    , decltype(_impl_.assists_){}
    , decltype(_impl_.duration_){}
    , decltype(_impl_.player_slot_){}
    , decltype(_impl_.match_outcome_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.lobby_type_){}
    , decltype(_impl_.team_number_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.match_id_, &from._impl_.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.team_number_) -
    reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.team_number_));
  // @@protoc_insertion_point(copy_constructor:CMsgRecentMatchInfo)
}

inline void CMsgRecentMatchInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.game_mode_){0}
    , decltype(_impl_.kills_){0u}
    , decltype(_impl_.deaths_){0u}
    , decltype(_impl_.assists_){0u}
    , decltype(_impl_.duration_){0u}
    , decltype(_impl_.player_slot_){0u}
    , decltype(_impl_.match_outcome_){0}
    , decltype(_impl_.timestamp_){0u}
    , decltype(_impl_.lobby_type_){0u}
    , decltype(_impl_.team_number_){0u}
  };
}

CMsgRecentMatchInfo::~CMsgRecentMatchInfo() {
  // @@protoc_insertion_point(destructor:CMsgRecentMatchInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgRecentMatchInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgRecentMatchInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgRecentMatchInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRecentMatchInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.match_outcome_) -
        reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.match_outcome_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.team_number_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.team_number_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRecentMatchInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 match_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .DOTA_GameMode game_mode = 2 [default = DOTA_GAMEMODE_NONE];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::DOTA_GameMode_IsValid(val))) {
            _internal_set_game_mode(static_cast<::DOTA_GameMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 kills = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_kills(&has_bits);
          _impl_.kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 deaths = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_deaths(&has_bits);
          _impl_.deaths_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assists = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_assists(&has_bits);
          _impl_.assists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 duration = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_duration(&has_bits);
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 player_slot = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_player_slot(&has_bits);
          _impl_.player_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EMatchOutcome match_outcome = 8 [default = k_EMatchOutcome_Unknown];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EMatchOutcome_IsValid(val))) {
            _internal_set_match_outcome(static_cast<::EMatchOutcome>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lobby_type = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_lobby_type(&has_bits);
          _impl_.lobby_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_number = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_team_number(&has_bits);
          _impl_.team_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRecentMatchInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRecentMatchInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 match_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_match_id(), target);
  }

  // optional .DOTA_GameMode game_mode = 2 [default = DOTA_GAMEMODE_NONE];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_game_mode(), target);
  }

  // optional uint32 kills = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_kills(), target);
  }

  // optional uint32 deaths = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_deaths(), target);
  }

  // optional uint32 assists = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_assists(), target);
  }

  // optional uint32 duration = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_duration(), target);
  }

  // optional uint32 player_slot = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_player_slot(), target);
  }

  // optional .EMatchOutcome match_outcome = 8 [default = k_EMatchOutcome_Unknown];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_match_outcome(), target);
  }

  // optional uint32 timestamp = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_timestamp(), target);
  }

  // optional uint32 lobby_type = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_lobby_type(), target);
  }

  // optional uint32 team_number = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_team_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRecentMatchInfo)
  return target;
}

size_t CMsgRecentMatchInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRecentMatchInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 match_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional .DOTA_GameMode game_mode = 2 [default = DOTA_GAMEMODE_NONE];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_game_mode());
    }

    // optional uint32 kills = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_kills());
    }

    // optional uint32 deaths = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_deaths());
    }

    // optional uint32 assists = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_assists());
    }

    // optional uint32 duration = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_duration());
    }

    // optional uint32 player_slot = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_player_slot());
    }

    // optional .EMatchOutcome match_outcome = 8 [default = k_EMatchOutcome_Unknown];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_match_outcome());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 timestamp = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

    // optional uint32 lobby_type = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lobby_type());
    }

    // optional uint32 team_number = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_number());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRecentMatchInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgRecentMatchInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRecentMatchInfo::GetClassData() const { return &_class_data_; }


void CMsgRecentMatchInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgRecentMatchInfo*>(&to_msg);
  auto& from = static_cast<const CMsgRecentMatchInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgRecentMatchInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.game_mode_ = from._impl_.game_mode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.kills_ = from._impl_.kills_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.deaths_ = from._impl_.deaths_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.assists_ = from._impl_.assists_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.duration_ = from._impl_.duration_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.player_slot_ = from._impl_.player_slot_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.match_outcome_ = from._impl_.match_outcome_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.lobby_type_ = from._impl_.lobby_type_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.team_number_ = from._impl_.team_number_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRecentMatchInfo::CopyFrom(const CMsgRecentMatchInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRecentMatchInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRecentMatchInfo::IsInitialized() const {
  return true;
}

void CMsgRecentMatchInfo::InternalSwap(CMsgRecentMatchInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRecentMatchInfo, _impl_.team_number_)
      + sizeof(CMsgRecentMatchInfo::_impl_.team_number_)
      - PROTOBUF_FIELD_OFFSET(CMsgRecentMatchInfo, _impl_.match_id_)>(
          reinterpret_cast<char*>(&_impl_.match_id_),
          reinterpret_cast<char*>(&other->_impl_.match_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRecentMatchInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[89]);
}

// ===================================================================

class CMsgMatchTips_SingleTip::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgMatchTips_SingleTip>()._impl_._has_bits_);
  static void set_has_source_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_target_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tip_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgMatchTips_SingleTip::CMsgMatchTips_SingleTip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMatchTips.SingleTip)
}
CMsgMatchTips_SingleTip::CMsgMatchTips_SingleTip(const CMsgMatchTips_SingleTip& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMatchTips_SingleTip* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.source_account_id_){}
    , decltype(_impl_.target_account_id_){}
    , decltype(_impl_.tip_amount_){}
    , decltype(_impl_.event_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.source_account_id_, &from._impl_.source_account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.event_id_) -
    reinterpret_cast<char*>(&_impl_.source_account_id_)) + sizeof(_impl_.event_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgMatchTips.SingleTip)
}

inline void CMsgMatchTips_SingleTip::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.source_account_id_){0u}
    , decltype(_impl_.target_account_id_){0u}
    , decltype(_impl_.tip_amount_){0u}
    , decltype(_impl_.event_id_){0}
  };
}

CMsgMatchTips_SingleTip::~CMsgMatchTips_SingleTip() {
  // @@protoc_insertion_point(destructor:CMsgMatchTips.SingleTip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMatchTips_SingleTip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgMatchTips_SingleTip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMatchTips_SingleTip::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMatchTips.SingleTip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.source_account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.event_id_) -
        reinterpret_cast<char*>(&_impl_.source_account_id_)) + sizeof(_impl_.event_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMatchTips_SingleTip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 source_account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_source_account_id(&has_bits);
          _impl_.source_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 target_account_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_target_account_id(&has_bits);
          _impl_.target_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tip_amount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_tip_amount(&has_bits);
          _impl_.tip_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EEvent event_id = 4 [default = EVENT_ID_NONE];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EEvent_IsValid(val))) {
            _internal_set_event_id(static_cast<::EEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMatchTips_SingleTip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMatchTips.SingleTip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 source_account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_source_account_id(), target);
  }

  // optional uint32 target_account_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_target_account_id(), target);
  }

  // optional uint32 tip_amount = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_tip_amount(), target);
  }

  // optional .EEvent event_id = 4 [default = EVENT_ID_NONE];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_event_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMatchTips.SingleTip)
  return target;
}

size_t CMsgMatchTips_SingleTip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMatchTips.SingleTip)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 source_account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_source_account_id());
    }

    // optional uint32 target_account_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_target_account_id());
    }

    // optional uint32 tip_amount = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tip_amount());
    }

    // optional .EEvent event_id = 4 [default = EVENT_ID_NONE];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMatchTips_SingleTip::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMatchTips_SingleTip::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMatchTips_SingleTip::GetClassData() const { return &_class_data_; }


void CMsgMatchTips_SingleTip::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMatchTips_SingleTip*>(&to_msg);
  auto& from = static_cast<const CMsgMatchTips_SingleTip&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMatchTips.SingleTip)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.source_account_id_ = from._impl_.source_account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_account_id_ = from._impl_.target_account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tip_amount_ = from._impl_.tip_amount_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMatchTips_SingleTip::CopyFrom(const CMsgMatchTips_SingleTip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMatchTips.SingleTip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMatchTips_SingleTip::IsInitialized() const {
  return true;
}

void CMsgMatchTips_SingleTip::InternalSwap(CMsgMatchTips_SingleTip* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgMatchTips_SingleTip, _impl_.event_id_)
      + sizeof(CMsgMatchTips_SingleTip::_impl_.event_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgMatchTips_SingleTip, _impl_.source_account_id_)>(
          reinterpret_cast<char*>(&_impl_.source_account_id_),
          reinterpret_cast<char*>(&other->_impl_.source_account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMatchTips_SingleTip::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[90]);
}

// ===================================================================

class CMsgMatchTips::_Internal {
 public:
};

CMsgMatchTips::CMsgMatchTips(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMatchTips)
}
CMsgMatchTips::CMsgMatchTips(const CMsgMatchTips& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMatchTips* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tips_){from._impl_.tips_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgMatchTips)
}

inline void CMsgMatchTips::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tips_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgMatchTips::~CMsgMatchTips() {
  // @@protoc_insertion_point(destructor:CMsgMatchTips)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMatchTips::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tips_.~RepeatedPtrField();
}

void CMsgMatchTips::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMatchTips::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMatchTips)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tips_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMatchTips::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgMatchTips.SingleTip tips = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tips(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMatchTips::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMatchTips)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgMatchTips.SingleTip tips = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tips_size()); i < n; i++) {
    const auto& repfield = this->_internal_tips(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMatchTips)
  return target;
}

size_t CMsgMatchTips::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMatchTips)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgMatchTips.SingleTip tips = 2;
  total_size += 1UL * this->_internal_tips_size();
  for (const auto& msg : this->_impl_.tips_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMatchTips::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMatchTips::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMatchTips::GetClassData() const { return &_class_data_; }


void CMsgMatchTips::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMatchTips*>(&to_msg);
  auto& from = static_cast<const CMsgMatchTips&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMatchTips)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tips_.MergeFrom(from._impl_.tips_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMatchTips::CopyFrom(const CMsgMatchTips& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMatchTips)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMatchTips::IsInitialized() const {
  return true;
}

void CMsgMatchTips::InternalSwap(CMsgMatchTips* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tips_.InternalSwap(&other->_impl_.tips_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMatchTips::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[91]);
}

// ===================================================================

class CMsgDOTAMatchMinimal_Player::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAMatchMinimal_Player>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_deaths(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_assists(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_player_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pro_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_team_number(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CMsgDOTAMatchMinimal_Player::CMsgDOTAMatchMinimal_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAMatchMinimal.Player)
}
CMsgDOTAMatchMinimal_Player::CMsgDOTAMatchMinimal_Player(const CMsgDOTAMatchMinimal_Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAMatchMinimal_Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.pro_name_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.kills_){}
    , decltype(_impl_.deaths_){}
    , decltype(_impl_.assists_){}
    , decltype(_impl_.player_slot_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.team_number_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pro_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pro_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pro_name()) {
    _this->_impl_.pro_name_.Set(from._internal_pro_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.team_number_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.team_number_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAMatchMinimal.Player)
}

inline void CMsgDOTAMatchMinimal_Player::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.pro_name_){}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.kills_){0u}
    , decltype(_impl_.deaths_){0u}
    , decltype(_impl_.assists_){0u}
    , decltype(_impl_.player_slot_){0u}
    , decltype(_impl_.level_){0u}
    , decltype(_impl_.team_number_){0}
  };
  _impl_.pro_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pro_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTAMatchMinimal_Player::~CMsgDOTAMatchMinimal_Player() {
  // @@protoc_insertion_point(destructor:CMsgDOTAMatchMinimal.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAMatchMinimal_Player::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedField();
  _impl_.pro_name_.Destroy();
}

void CMsgDOTAMatchMinimal_Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAMatchMinimal_Player::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAMatchMinimal.Player)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.pro_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.level_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.level_));
  }
  _impl_.team_number_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAMatchMinimal_Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 kills = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_kills(&has_bits);
          _impl_.kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 deaths = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_deaths(&has_bits);
          _impl_.deaths_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assists = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_assists(&has_bits);
          _impl_.assists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 items = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_items(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_items(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 player_slot = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_player_slot(&has_bits);
          _impl_.player_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string pro_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_pro_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatchMinimal.Player.pro_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .DOTA_GC_TEAM team_number = 10 [default = DOTA_GC_TEAM_GOOD_GUYS];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::DOTA_GC_TEAM_IsValid(val))) {
            _internal_set_team_number(static_cast<::DOTA_GC_TEAM>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAMatchMinimal_Player::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAMatchMinimal.Player)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 hero_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hero_id(), target);
  }

  // optional uint32 kills = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_kills(), target);
  }

  // optional uint32 deaths = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_deaths(), target);
  }

  // optional uint32 assists = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_assists(), target);
  }

  // repeated int32 items = 6;
  for (int i = 0, n = this->_internal_items_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_items(i), target);
  }

  // optional uint32 player_slot = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_player_slot(), target);
  }

  // optional string pro_name = 8;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pro_name().data(), static_cast<int>(this->_internal_pro_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatchMinimal.Player.pro_name");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_pro_name(), target);
  }

  // optional uint32 level = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_level(), target);
  }

  // optional .DOTA_GC_TEAM team_number = 10 [default = DOTA_GC_TEAM_GOOD_GUYS];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_team_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAMatchMinimal.Player)
  return target;
}

size_t CMsgDOTAMatchMinimal_Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAMatchMinimal.Player)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 items = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.items_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_items_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string pro_name = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pro_name());
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 hero_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional uint32 kills = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_kills());
    }

    // optional uint32 deaths = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_deaths());
    }

    // optional uint32 assists = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_assists());
    }

    // optional uint32 player_slot = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_player_slot());
    }

    // optional uint32 level = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
    }

  }
  // optional .DOTA_GC_TEAM team_number = 10 [default = DOTA_GC_TEAM_GOOD_GUYS];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_team_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAMatchMinimal_Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAMatchMinimal_Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAMatchMinimal_Player::GetClassData() const { return &_class_data_; }


void CMsgDOTAMatchMinimal_Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAMatchMinimal_Player*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAMatchMinimal_Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAMatchMinimal.Player)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_pro_name(from._internal_pro_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.kills_ = from._impl_.kills_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.deaths_ = from._impl_.deaths_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.assists_ = from._impl_.assists_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.player_slot_ = from._impl_.player_slot_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_team_number(from._internal_team_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAMatchMinimal_Player::CopyFrom(const CMsgDOTAMatchMinimal_Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAMatchMinimal.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAMatchMinimal_Player::IsInitialized() const {
  return true;
}

void CMsgDOTAMatchMinimal_Player::InternalSwap(CMsgDOTAMatchMinimal_Player* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pro_name_, lhs_arena,
      &other->_impl_.pro_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAMatchMinimal_Player, _impl_.team_number_)
      + sizeof(CMsgDOTAMatchMinimal_Player::_impl_.team_number_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAMatchMinimal_Player, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAMatchMinimal_Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[92]);
}

// ===================================================================

class CMsgDOTAMatchMinimal_Tourney::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAMatchMinimal_Tourney>()._impl_._has_bits_);
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_series_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_series_game(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_weekend_tourney_tournament_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_weekend_tourney_season_trophy_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_weekend_tourney_division(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_weekend_tourney_skill_level(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_radiant_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_radiant_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_radiant_team_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_radiant_team_logo_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dire_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_dire_team_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dire_team_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_dire_team_logo_url(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgDOTAMatchMinimal_Tourney::CMsgDOTAMatchMinimal_Tourney(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAMatchMinimal.Tourney)
}
CMsgDOTAMatchMinimal_Tourney::CMsgDOTAMatchMinimal_Tourney(const CMsgDOTAMatchMinimal_Tourney& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAMatchMinimal_Tourney* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.radiant_team_name_){}
    , decltype(_impl_.dire_team_name_){}
    , decltype(_impl_.radiant_team_logo_url_){}
    , decltype(_impl_.dire_team_logo_url_){}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.radiant_team_id_){}
    , decltype(_impl_.radiant_team_logo_){}
    , decltype(_impl_.dire_team_id_){}
    , decltype(_impl_.series_type_){}
    , decltype(_impl_.dire_team_logo_){}
    , decltype(_impl_.series_game_){}
    , decltype(_impl_.weekend_tourney_tournament_id_){}
    , decltype(_impl_.weekend_tourney_season_trophy_id_){}
    , decltype(_impl_.weekend_tourney_division_){}
    , decltype(_impl_.weekend_tourney_skill_level_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.radiant_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.radiant_team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_radiant_team_name()) {
    _this->_impl_.radiant_team_name_.Set(from._internal_radiant_team_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dire_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dire_team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dire_team_name()) {
    _this->_impl_.dire_team_name_.Set(from._internal_dire_team_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.radiant_team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.radiant_team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_radiant_team_logo_url()) {
    _this->_impl_.radiant_team_logo_url_.Set(from._internal_radiant_team_logo_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dire_team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dire_team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dire_team_logo_url()) {
    _this->_impl_.dire_team_logo_url_.Set(from._internal_dire_team_logo_url(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.league_id_, &from._impl_.league_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.weekend_tourney_skill_level_) -
    reinterpret_cast<char*>(&_impl_.league_id_)) + sizeof(_impl_.weekend_tourney_skill_level_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAMatchMinimal.Tourney)
}

inline void CMsgDOTAMatchMinimal_Tourney::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.radiant_team_name_){}
    , decltype(_impl_.dire_team_name_){}
    , decltype(_impl_.radiant_team_logo_url_){}
    , decltype(_impl_.dire_team_logo_url_){}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.radiant_team_id_){0u}
    , decltype(_impl_.radiant_team_logo_){uint64_t{0u}}
    , decltype(_impl_.dire_team_id_){0u}
    , decltype(_impl_.series_type_){0u}
    , decltype(_impl_.dire_team_logo_){uint64_t{0u}}
    , decltype(_impl_.series_game_){0u}
    , decltype(_impl_.weekend_tourney_tournament_id_){0u}
    , decltype(_impl_.weekend_tourney_season_trophy_id_){0u}
    , decltype(_impl_.weekend_tourney_division_){0u}
    , decltype(_impl_.weekend_tourney_skill_level_){0u}
  };
  _impl_.radiant_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.radiant_team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dire_team_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dire_team_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.radiant_team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.radiant_team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dire_team_logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dire_team_logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTAMatchMinimal_Tourney::~CMsgDOTAMatchMinimal_Tourney() {
  // @@protoc_insertion_point(destructor:CMsgDOTAMatchMinimal.Tourney)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAMatchMinimal_Tourney::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.radiant_team_name_.Destroy();
  _impl_.dire_team_name_.Destroy();
  _impl_.radiant_team_logo_url_.Destroy();
  _impl_.dire_team_logo_url_.Destroy();
}

void CMsgDOTAMatchMinimal_Tourney::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAMatchMinimal_Tourney::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAMatchMinimal.Tourney)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.radiant_team_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.dire_team_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.radiant_team_logo_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.dire_team_logo_url_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.league_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dire_team_id_) -
        reinterpret_cast<char*>(&_impl_.league_id_)) + sizeof(_impl_.dire_team_id_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.series_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.weekend_tourney_skill_level_) -
        reinterpret_cast<char*>(&_impl_.series_type_)) + sizeof(_impl_.weekend_tourney_skill_level_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAMatchMinimal_Tourney::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 league_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 radiant_team_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_radiant_team_id(&has_bits);
          _impl_.radiant_team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string radiant_team_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_radiant_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatchMinimal.Tourney.radiant_team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 radiant_team_logo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_radiant_team_logo(&has_bits);
          _impl_.radiant_team_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dire_team_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_dire_team_id(&has_bits);
          _impl_.dire_team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string dire_team_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_dire_team_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatchMinimal.Tourney.dire_team_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 dire_team_logo = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_dire_team_logo(&has_bits);
          _impl_.dire_team_logo_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 series_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_series_type(&has_bits);
          _impl_.series_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 series_game = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_series_game(&has_bits);
          _impl_.series_game_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 weekend_tourney_tournament_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_weekend_tourney_tournament_id(&has_bits);
          _impl_.weekend_tourney_tournament_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 weekend_tourney_season_trophy_id = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_weekend_tourney_season_trophy_id(&has_bits);
          _impl_.weekend_tourney_season_trophy_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 weekend_tourney_division = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_weekend_tourney_division(&has_bits);
          _impl_.weekend_tourney_division_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 weekend_tourney_skill_level = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_weekend_tourney_skill_level(&has_bits);
          _impl_.weekend_tourney_skill_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string radiant_team_logo_url = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_radiant_team_logo_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatchMinimal.Tourney.radiant_team_logo_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string dire_team_logo_url = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_dire_team_logo_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTAMatchMinimal.Tourney.dire_team_logo_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAMatchMinimal_Tourney::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAMatchMinimal.Tourney)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 league_id = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_league_id(), target);
  }

  // optional uint32 radiant_team_id = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_radiant_team_id(), target);
  }

  // optional string radiant_team_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_radiant_team_name().data(), static_cast<int>(this->_internal_radiant_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatchMinimal.Tourney.radiant_team_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_radiant_team_name(), target);
  }

  // optional fixed64 radiant_team_logo = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_radiant_team_logo(), target);
  }

  // optional uint32 dire_team_id = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_dire_team_id(), target);
  }

  // optional string dire_team_name = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dire_team_name().data(), static_cast<int>(this->_internal_dire_team_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatchMinimal.Tourney.dire_team_name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_dire_team_name(), target);
  }

  // optional fixed64 dire_team_logo = 7;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(7, this->_internal_dire_team_logo(), target);
  }

  // optional uint32 series_type = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_series_type(), target);
  }

  // optional uint32 series_game = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_series_game(), target);
  }

  // optional uint32 weekend_tourney_tournament_id = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_weekend_tourney_tournament_id(), target);
  }

  // optional uint32 weekend_tourney_season_trophy_id = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_weekend_tourney_season_trophy_id(), target);
  }

  // optional uint32 weekend_tourney_division = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_weekend_tourney_division(), target);
  }

  // optional uint32 weekend_tourney_skill_level = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_weekend_tourney_skill_level(), target);
  }

  // optional string radiant_team_logo_url = 14;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_radiant_team_logo_url().data(), static_cast<int>(this->_internal_radiant_team_logo_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatchMinimal.Tourney.radiant_team_logo_url");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_radiant_team_logo_url(), target);
  }

  // optional string dire_team_logo_url = 15;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dire_team_logo_url().data(), static_cast<int>(this->_internal_dire_team_logo_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTAMatchMinimal.Tourney.dire_team_logo_url");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_dire_team_logo_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAMatchMinimal.Tourney)
  return target;
}

size_t CMsgDOTAMatchMinimal_Tourney::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAMatchMinimal.Tourney)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string radiant_team_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_radiant_team_name());
    }

    // optional string dire_team_name = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dire_team_name());
    }

    // optional string radiant_team_logo_url = 14;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_radiant_team_logo_url());
    }

    // optional string dire_team_logo_url = 15;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dire_team_logo_url());
    }

    // optional uint32 league_id = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional uint32 radiant_team_id = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_radiant_team_id());
    }

    // optional fixed64 radiant_team_logo = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional uint32 dire_team_id = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dire_team_id());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional uint32 series_type = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_series_type());
    }

    // optional fixed64 dire_team_logo = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional uint32 series_game = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_series_game());
    }

    // optional uint32 weekend_tourney_tournament_id = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_weekend_tourney_tournament_id());
    }

    // optional uint32 weekend_tourney_season_trophy_id = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_weekend_tourney_season_trophy_id());
    }

    // optional uint32 weekend_tourney_division = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_weekend_tourney_division());
    }

    // optional uint32 weekend_tourney_skill_level = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_weekend_tourney_skill_level());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAMatchMinimal_Tourney::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAMatchMinimal_Tourney::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAMatchMinimal_Tourney::GetClassData() const { return &_class_data_; }


void CMsgDOTAMatchMinimal_Tourney::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAMatchMinimal_Tourney*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAMatchMinimal_Tourney&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAMatchMinimal.Tourney)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_radiant_team_name(from._internal_radiant_team_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_dire_team_name(from._internal_dire_team_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_radiant_team_logo_url(from._internal_radiant_team_logo_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_dire_team_logo_url(from._internal_dire_team_logo_url());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.radiant_team_id_ = from._impl_.radiant_team_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.radiant_team_logo_ = from._impl_.radiant_team_logo_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.dire_team_id_ = from._impl_.dire_team_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.series_type_ = from._impl_.series_type_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.dire_team_logo_ = from._impl_.dire_team_logo_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.series_game_ = from._impl_.series_game_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.weekend_tourney_tournament_id_ = from._impl_.weekend_tourney_tournament_id_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.weekend_tourney_season_trophy_id_ = from._impl_.weekend_tourney_season_trophy_id_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.weekend_tourney_division_ = from._impl_.weekend_tourney_division_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.weekend_tourney_skill_level_ = from._impl_.weekend_tourney_skill_level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAMatchMinimal_Tourney::CopyFrom(const CMsgDOTAMatchMinimal_Tourney& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAMatchMinimal.Tourney)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAMatchMinimal_Tourney::IsInitialized() const {
  return true;
}

void CMsgDOTAMatchMinimal_Tourney::InternalSwap(CMsgDOTAMatchMinimal_Tourney* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.radiant_team_name_, lhs_arena,
      &other->_impl_.radiant_team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dire_team_name_, lhs_arena,
      &other->_impl_.dire_team_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.radiant_team_logo_url_, lhs_arena,
      &other->_impl_.radiant_team_logo_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dire_team_logo_url_, lhs_arena,
      &other->_impl_.dire_team_logo_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAMatchMinimal_Tourney, _impl_.weekend_tourney_skill_level_)
      + sizeof(CMsgDOTAMatchMinimal_Tourney::_impl_.weekend_tourney_skill_level_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAMatchMinimal_Tourney, _impl_.league_id_)>(
          reinterpret_cast<char*>(&_impl_.league_id_),
          reinterpret_cast<char*>(&other->_impl_.league_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAMatchMinimal_Tourney::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[93]);
}

// ===================================================================

class CMsgDOTAMatchMinimal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTAMatchMinimal>()._impl_._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_game_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgDOTAMatchMinimal_Tourney& tourney(const CMsgDOTAMatchMinimal* msg);
  static void set_has_tourney(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_match_outcome(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_radiant_score(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_dire_score(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_lobby_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::CMsgDOTAMatchMinimal_Tourney&
CMsgDOTAMatchMinimal::_Internal::tourney(const CMsgDOTAMatchMinimal* msg) {
  return *msg->_impl_.tourney_;
}
CMsgDOTAMatchMinimal::CMsgDOTAMatchMinimal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTAMatchMinimal)
}
CMsgDOTAMatchMinimal::CMsgDOTAMatchMinimal(const CMsgDOTAMatchMinimal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTAMatchMinimal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.players_){from._impl_.players_}
    , decltype(_impl_.tourney_){nullptr}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.start_time_){}
    , decltype(_impl_.duration_){}
    , decltype(_impl_.game_mode_){}
    , decltype(_impl_.match_outcome_){}
    , decltype(_impl_.radiant_score_){}
    , decltype(_impl_.dire_score_){}
    , decltype(_impl_.lobby_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tourney()) {
    _this->_impl_.tourney_ = new ::CMsgDOTAMatchMinimal_Tourney(*from._impl_.tourney_);
  }
  ::memcpy(&_impl_.match_id_, &from._impl_.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lobby_type_) -
    reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.lobby_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTAMatchMinimal)
}

inline void CMsgDOTAMatchMinimal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.players_){arena}
    , decltype(_impl_.tourney_){nullptr}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.start_time_){0u}
    , decltype(_impl_.duration_){0u}
    , decltype(_impl_.game_mode_){0}
    , decltype(_impl_.match_outcome_){0}
    , decltype(_impl_.radiant_score_){0u}
    , decltype(_impl_.dire_score_){0u}
    , decltype(_impl_.lobby_type_){0u}
  };
}

CMsgDOTAMatchMinimal::~CMsgDOTAMatchMinimal() {
  // @@protoc_insertion_point(destructor:CMsgDOTAMatchMinimal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTAMatchMinimal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.players_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.tourney_;
}

void CMsgDOTAMatchMinimal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTAMatchMinimal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTAMatchMinimal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.players_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.tourney_ != nullptr);
    _impl_.tourney_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dire_score_) -
        reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.dire_score_));
  }
  _impl_.lobby_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTAMatchMinimal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 match_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 start_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_start_time(&has_bits);
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 duration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_duration(&has_bits);
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .DOTA_GameMode game_mode = 4 [default = DOTA_GAMEMODE_NONE];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::DOTA_GameMode_IsValid(val))) {
            _internal_set_game_mode(static_cast<::DOTA_GameMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDOTAMatchMinimal.Player players = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAMatchMinimal.Tourney tourney = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_tourney(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EMatchOutcome match_outcome = 8 [default = k_EMatchOutcome_Unknown];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EMatchOutcome_IsValid(val))) {
            _internal_set_match_outcome(static_cast<::EMatchOutcome>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 radiant_score = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_radiant_score(&has_bits);
          _impl_.radiant_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dire_score = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_dire_score(&has_bits);
          _impl_.dire_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lobby_type = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_lobby_type(&has_bits);
          _impl_.lobby_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTAMatchMinimal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTAMatchMinimal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 match_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_match_id(), target);
  }

  // optional fixed32 start_time = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_start_time(), target);
  }

  // optional uint32 duration = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_duration(), target);
  }

  // optional .DOTA_GameMode game_mode = 4 [default = DOTA_GAMEMODE_NONE];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_game_mode(), target);
  }

  // repeated .CMsgDOTAMatchMinimal.Player players = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .CMsgDOTAMatchMinimal.Tourney tourney = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::tourney(this),
        _Internal::tourney(this).GetCachedSize(), target, stream);
  }

  // optional .EMatchOutcome match_outcome = 8 [default = k_EMatchOutcome_Unknown];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_match_outcome(), target);
  }

  // optional uint32 radiant_score = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_radiant_score(), target);
  }

  // optional uint32 dire_score = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_dire_score(), target);
  }

  // optional uint32 lobby_type = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_lobby_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTAMatchMinimal)
  return target;
}

size_t CMsgDOTAMatchMinimal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTAMatchMinimal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDOTAMatchMinimal.Player players = 6;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->_impl_.players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgDOTAMatchMinimal.Tourney tourney = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tourney_);
    }

    // optional uint64 match_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional fixed32 start_time = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 duration = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_duration());
    }

    // optional .DOTA_GameMode game_mode = 4 [default = DOTA_GAMEMODE_NONE];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_game_mode());
    }

    // optional .EMatchOutcome match_outcome = 8 [default = k_EMatchOutcome_Unknown];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_match_outcome());
    }

    // optional uint32 radiant_score = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_radiant_score());
    }

    // optional uint32 dire_score = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dire_score());
    }

  }
  // optional uint32 lobby_type = 11;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lobby_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTAMatchMinimal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTAMatchMinimal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTAMatchMinimal::GetClassData() const { return &_class_data_; }


void CMsgDOTAMatchMinimal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTAMatchMinimal*>(&to_msg);
  auto& from = static_cast<const CMsgDOTAMatchMinimal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTAMatchMinimal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tourney()->::CMsgDOTAMatchMinimal_Tourney::MergeFrom(
          from._internal_tourney());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.start_time_ = from._impl_.start_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.duration_ = from._impl_.duration_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.game_mode_ = from._impl_.game_mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.match_outcome_ = from._impl_.match_outcome_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.radiant_score_ = from._impl_.radiant_score_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.dire_score_ = from._impl_.dire_score_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_lobby_type(from._internal_lobby_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTAMatchMinimal::CopyFrom(const CMsgDOTAMatchMinimal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTAMatchMinimal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTAMatchMinimal::IsInitialized() const {
  return true;
}

void CMsgDOTAMatchMinimal::InternalSwap(CMsgDOTAMatchMinimal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTAMatchMinimal, _impl_.lobby_type_)
      + sizeof(CMsgDOTAMatchMinimal::_impl_.lobby_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTAMatchMinimal, _impl_.tourney_)>(
          reinterpret_cast<char*>(&_impl_.tourney_),
          reinterpret_cast<char*>(&other->_impl_.tourney_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTAMatchMinimal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[94]);
}

// ===================================================================

class CMsgConsumableUsage::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgConsumableUsage>()._impl_._has_bits_);
  static void set_has_item_def(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_quantity_change(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgConsumableUsage::CMsgConsumableUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgConsumableUsage)
}
CMsgConsumableUsage::CMsgConsumableUsage(const CMsgConsumableUsage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgConsumableUsage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_def_){}
    , decltype(_impl_.quantity_change_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.item_def_, &from._impl_.item_def_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.quantity_change_) -
    reinterpret_cast<char*>(&_impl_.item_def_)) + sizeof(_impl_.quantity_change_));
  // @@protoc_insertion_point(copy_constructor:CMsgConsumableUsage)
}

inline void CMsgConsumableUsage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_def_){0u}
    , decltype(_impl_.quantity_change_){0}
  };
}

CMsgConsumableUsage::~CMsgConsumableUsage() {
  // @@protoc_insertion_point(destructor:CMsgConsumableUsage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgConsumableUsage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgConsumableUsage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgConsumableUsage::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgConsumableUsage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.item_def_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.quantity_change_) -
        reinterpret_cast<char*>(&_impl_.item_def_)) + sizeof(_impl_.quantity_change_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgConsumableUsage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 item_def = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_def(&has_bits);
          _impl_.item_def_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 quantity_change = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_quantity_change(&has_bits);
          _impl_.quantity_change_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgConsumableUsage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgConsumableUsage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 item_def = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_item_def(), target);
  }

  // optional int32 quantity_change = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_quantity_change(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgConsumableUsage)
  return target;
}

size_t CMsgConsumableUsage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgConsumableUsage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 item_def = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_item_def());
    }

    // optional int32 quantity_change = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_quantity_change());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgConsumableUsage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgConsumableUsage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgConsumableUsage::GetClassData() const { return &_class_data_; }


void CMsgConsumableUsage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgConsumableUsage*>(&to_msg);
  auto& from = static_cast<const CMsgConsumableUsage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgConsumableUsage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.item_def_ = from._impl_.item_def_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.quantity_change_ = from._impl_.quantity_change_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgConsumableUsage::CopyFrom(const CMsgConsumableUsage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgConsumableUsage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgConsumableUsage::IsInitialized() const {
  return true;
}

void CMsgConsumableUsage::InternalSwap(CMsgConsumableUsage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgConsumableUsage, _impl_.quantity_change_)
      + sizeof(CMsgConsumableUsage::_impl_.quantity_change_)
      - PROTOBUF_FIELD_OFFSET(CMsgConsumableUsage, _impl_.item_def_)>(
          reinterpret_cast<char*>(&_impl_.item_def_),
          reinterpret_cast<char*>(&other->_impl_.item_def_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgConsumableUsage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[95]);
}

// ===================================================================

class CMsgMatchConsumableUsage_PlayerUsage::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgMatchConsumableUsage_PlayerUsage>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgMatchConsumableUsage_PlayerUsage::CMsgMatchConsumableUsage_PlayerUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMatchConsumableUsage.PlayerUsage)
}
CMsgMatchConsumableUsage_PlayerUsage::CMsgMatchConsumableUsage_PlayerUsage(const CMsgMatchConsumableUsage_PlayerUsage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMatchConsumableUsage_PlayerUsage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.consumables_used_){from._impl_.consumables_used_}
    , decltype(_impl_.account_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.account_id_ = from._impl_.account_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgMatchConsumableUsage.PlayerUsage)
}

inline void CMsgMatchConsumableUsage_PlayerUsage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.consumables_used_){arena}
    , decltype(_impl_.account_id_){0u}
  };
}

CMsgMatchConsumableUsage_PlayerUsage::~CMsgMatchConsumableUsage_PlayerUsage() {
  // @@protoc_insertion_point(destructor:CMsgMatchConsumableUsage.PlayerUsage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMatchConsumableUsage_PlayerUsage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.consumables_used_.~RepeatedPtrField();
}

void CMsgMatchConsumableUsage_PlayerUsage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMatchConsumableUsage_PlayerUsage::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMatchConsumableUsage.PlayerUsage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.consumables_used_.Clear();
  _impl_.account_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMatchConsumableUsage_PlayerUsage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgConsumableUsage consumables_used = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_consumables_used(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMatchConsumableUsage_PlayerUsage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMatchConsumableUsage.PlayerUsage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // repeated .CMsgConsumableUsage consumables_used = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_consumables_used_size()); i < n; i++) {
    const auto& repfield = this->_internal_consumables_used(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMatchConsumableUsage.PlayerUsage)
  return target;
}

size_t CMsgMatchConsumableUsage_PlayerUsage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMatchConsumableUsage.PlayerUsage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgConsumableUsage consumables_used = 2;
  total_size += 1UL * this->_internal_consumables_used_size();
  for (const auto& msg : this->_impl_.consumables_used_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 account_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMatchConsumableUsage_PlayerUsage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMatchConsumableUsage_PlayerUsage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMatchConsumableUsage_PlayerUsage::GetClassData() const { return &_class_data_; }


void CMsgMatchConsumableUsage_PlayerUsage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMatchConsumableUsage_PlayerUsage*>(&to_msg);
  auto& from = static_cast<const CMsgMatchConsumableUsage_PlayerUsage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMatchConsumableUsage.PlayerUsage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.consumables_used_.MergeFrom(from._impl_.consumables_used_);
  if (from._internal_has_account_id()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMatchConsumableUsage_PlayerUsage::CopyFrom(const CMsgMatchConsumableUsage_PlayerUsage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMatchConsumableUsage.PlayerUsage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMatchConsumableUsage_PlayerUsage::IsInitialized() const {
  return true;
}

void CMsgMatchConsumableUsage_PlayerUsage::InternalSwap(CMsgMatchConsumableUsage_PlayerUsage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.consumables_used_.InternalSwap(&other->_impl_.consumables_used_);
  swap(_impl_.account_id_, other->_impl_.account_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMatchConsumableUsage_PlayerUsage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[96]);
}

// ===================================================================

class CMsgMatchConsumableUsage::_Internal {
 public:
};

CMsgMatchConsumableUsage::CMsgMatchConsumableUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMatchConsumableUsage)
}
CMsgMatchConsumableUsage::CMsgMatchConsumableUsage(const CMsgMatchConsumableUsage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMatchConsumableUsage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.player_consumables_used_){from._impl_.player_consumables_used_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgMatchConsumableUsage)
}

inline void CMsgMatchConsumableUsage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.player_consumables_used_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgMatchConsumableUsage::~CMsgMatchConsumableUsage() {
  // @@protoc_insertion_point(destructor:CMsgMatchConsumableUsage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMatchConsumableUsage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.player_consumables_used_.~RepeatedPtrField();
}

void CMsgMatchConsumableUsage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMatchConsumableUsage::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMatchConsumableUsage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_consumables_used_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMatchConsumableUsage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgMatchConsumableUsage.PlayerUsage player_consumables_used = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_player_consumables_used(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMatchConsumableUsage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMatchConsumableUsage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgMatchConsumableUsage.PlayerUsage player_consumables_used = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_player_consumables_used_size()); i < n; i++) {
    const auto& repfield = this->_internal_player_consumables_used(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMatchConsumableUsage)
  return target;
}

size_t CMsgMatchConsumableUsage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMatchConsumableUsage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgMatchConsumableUsage.PlayerUsage player_consumables_used = 1;
  total_size += 1UL * this->_internal_player_consumables_used_size();
  for (const auto& msg : this->_impl_.player_consumables_used_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMatchConsumableUsage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMatchConsumableUsage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMatchConsumableUsage::GetClassData() const { return &_class_data_; }


void CMsgMatchConsumableUsage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMatchConsumableUsage*>(&to_msg);
  auto& from = static_cast<const CMsgMatchConsumableUsage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMatchConsumableUsage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.player_consumables_used_.MergeFrom(from._impl_.player_consumables_used_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMatchConsumableUsage::CopyFrom(const CMsgMatchConsumableUsage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMatchConsumableUsage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMatchConsumableUsage::IsInitialized() const {
  return true;
}

void CMsgMatchConsumableUsage::InternalSwap(CMsgMatchConsumableUsage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.player_consumables_used_.InternalSwap(&other->_impl_.player_consumables_used_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMatchConsumableUsage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[97]);
}

// ===================================================================

class CMsgMatchEventActionGrants_PlayerGrants::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgMatchEventActionGrants_PlayerGrants>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void CMsgMatchEventActionGrants_PlayerGrants::clear_actions_granted() {
  _impl_.actions_granted_.Clear();
}
CMsgMatchEventActionGrants_PlayerGrants::CMsgMatchEventActionGrants_PlayerGrants(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMatchEventActionGrants.PlayerGrants)
}
CMsgMatchEventActionGrants_PlayerGrants::CMsgMatchEventActionGrants_PlayerGrants(const CMsgMatchEventActionGrants_PlayerGrants& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMatchEventActionGrants_PlayerGrants* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.actions_granted_){from._impl_.actions_granted_}
    , decltype(_impl_.account_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.account_id_ = from._impl_.account_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgMatchEventActionGrants.PlayerGrants)
}

inline void CMsgMatchEventActionGrants_PlayerGrants::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.actions_granted_){arena}
    , decltype(_impl_.account_id_){0u}
  };
}

CMsgMatchEventActionGrants_PlayerGrants::~CMsgMatchEventActionGrants_PlayerGrants() {
  // @@protoc_insertion_point(destructor:CMsgMatchEventActionGrants.PlayerGrants)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMatchEventActionGrants_PlayerGrants::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.actions_granted_.~RepeatedPtrField();
}

void CMsgMatchEventActionGrants_PlayerGrants::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMatchEventActionGrants_PlayerGrants::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMatchEventActionGrants.PlayerGrants)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.actions_granted_.Clear();
  _impl_.account_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMatchEventActionGrants_PlayerGrants::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgPendingEventAward actions_granted = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_actions_granted(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMatchEventActionGrants_PlayerGrants::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMatchEventActionGrants.PlayerGrants)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // repeated .CMsgPendingEventAward actions_granted = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_actions_granted_size()); i < n; i++) {
    const auto& repfield = this->_internal_actions_granted(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMatchEventActionGrants.PlayerGrants)
  return target;
}

size_t CMsgMatchEventActionGrants_PlayerGrants::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMatchEventActionGrants.PlayerGrants)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgPendingEventAward actions_granted = 3;
  total_size += 1UL * this->_internal_actions_granted_size();
  for (const auto& msg : this->_impl_.actions_granted_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 account_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMatchEventActionGrants_PlayerGrants::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMatchEventActionGrants_PlayerGrants::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMatchEventActionGrants_PlayerGrants::GetClassData() const { return &_class_data_; }


void CMsgMatchEventActionGrants_PlayerGrants::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMatchEventActionGrants_PlayerGrants*>(&to_msg);
  auto& from = static_cast<const CMsgMatchEventActionGrants_PlayerGrants&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMatchEventActionGrants.PlayerGrants)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.actions_granted_.MergeFrom(from._impl_.actions_granted_);
  if (from._internal_has_account_id()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMatchEventActionGrants_PlayerGrants::CopyFrom(const CMsgMatchEventActionGrants_PlayerGrants& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMatchEventActionGrants.PlayerGrants)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMatchEventActionGrants_PlayerGrants::IsInitialized() const {
  return true;
}

void CMsgMatchEventActionGrants_PlayerGrants::InternalSwap(CMsgMatchEventActionGrants_PlayerGrants* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.actions_granted_.InternalSwap(&other->_impl_.actions_granted_);
  swap(_impl_.account_id_, other->_impl_.account_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMatchEventActionGrants_PlayerGrants::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[98]);
}

// ===================================================================

class CMsgMatchEventActionGrants::_Internal {
 public:
};

CMsgMatchEventActionGrants::CMsgMatchEventActionGrants(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMatchEventActionGrants)
}
CMsgMatchEventActionGrants::CMsgMatchEventActionGrants(const CMsgMatchEventActionGrants& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMatchEventActionGrants* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.player_grants_){from._impl_.player_grants_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgMatchEventActionGrants)
}

inline void CMsgMatchEventActionGrants::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.player_grants_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgMatchEventActionGrants::~CMsgMatchEventActionGrants() {
  // @@protoc_insertion_point(destructor:CMsgMatchEventActionGrants)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMatchEventActionGrants::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.player_grants_.~RepeatedPtrField();
}

void CMsgMatchEventActionGrants::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMatchEventActionGrants::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMatchEventActionGrants)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_grants_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMatchEventActionGrants::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgMatchEventActionGrants.PlayerGrants player_grants = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_player_grants(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMatchEventActionGrants::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMatchEventActionGrants)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgMatchEventActionGrants.PlayerGrants player_grants = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_player_grants_size()); i < n; i++) {
    const auto& repfield = this->_internal_player_grants(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMatchEventActionGrants)
  return target;
}

size_t CMsgMatchEventActionGrants::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMatchEventActionGrants)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgMatchEventActionGrants.PlayerGrants player_grants = 1;
  total_size += 1UL * this->_internal_player_grants_size();
  for (const auto& msg : this->_impl_.player_grants_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMatchEventActionGrants::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMatchEventActionGrants::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMatchEventActionGrants::GetClassData() const { return &_class_data_; }


void CMsgMatchEventActionGrants::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMatchEventActionGrants*>(&to_msg);
  auto& from = static_cast<const CMsgMatchEventActionGrants&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMatchEventActionGrants)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.player_grants_.MergeFrom(from._impl_.player_grants_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMatchEventActionGrants::CopyFrom(const CMsgMatchEventActionGrants& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMatchEventActionGrants)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMatchEventActionGrants::IsInitialized() const {
  return true;
}

void CMsgMatchEventActionGrants::InternalSwap(CMsgMatchEventActionGrants* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.player_grants_.InternalSwap(&other->_impl_.player_grants_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMatchEventActionGrants::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[99]);
}

// ===================================================================

class CMsgCustomGameWhitelist::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgCustomGameWhitelist>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_disable_whitelist(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgCustomGameWhitelist::CMsgCustomGameWhitelist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgCustomGameWhitelist)
}
CMsgCustomGameWhitelist::CMsgCustomGameWhitelist(const CMsgCustomGameWhitelist& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgCustomGameWhitelist* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.custom_games_whitelist_){from._impl_.custom_games_whitelist_}
    , decltype(_impl_.version_){}
    , decltype(_impl_.disable_whitelist_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.disable_whitelist_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.disable_whitelist_));
  // @@protoc_insertion_point(copy_constructor:CMsgCustomGameWhitelist)
}

inline void CMsgCustomGameWhitelist::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.custom_games_whitelist_){arena}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.disable_whitelist_){false}
  };
}

CMsgCustomGameWhitelist::~CMsgCustomGameWhitelist() {
  // @@protoc_insertion_point(destructor:CMsgCustomGameWhitelist)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgCustomGameWhitelist::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.custom_games_whitelist_.~RepeatedField();
}

void CMsgCustomGameWhitelist::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgCustomGameWhitelist::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgCustomGameWhitelist)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.custom_games_whitelist_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.disable_whitelist_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.disable_whitelist_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgCustomGameWhitelist::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 custom_games_whitelist = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_custom_games_whitelist(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_custom_games_whitelist(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool disable_whitelist = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_disable_whitelist(&has_bits);
          _impl_.disable_whitelist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgCustomGameWhitelist::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgCustomGameWhitelist)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // repeated uint64 custom_games_whitelist = 2;
  for (int i = 0, n = this->_internal_custom_games_whitelist_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_custom_games_whitelist(i), target);
  }

  // optional bool disable_whitelist = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_disable_whitelist(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgCustomGameWhitelist)
  return target;
}

size_t CMsgCustomGameWhitelist::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgCustomGameWhitelist)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 custom_games_whitelist = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.custom_games_whitelist_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_custom_games_whitelist_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional bool disable_whitelist = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgCustomGameWhitelist::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgCustomGameWhitelist::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgCustomGameWhitelist::GetClassData() const { return &_class_data_; }


void CMsgCustomGameWhitelist::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgCustomGameWhitelist*>(&to_msg);
  auto& from = static_cast<const CMsgCustomGameWhitelist&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgCustomGameWhitelist)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.custom_games_whitelist_.MergeFrom(from._impl_.custom_games_whitelist_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.disable_whitelist_ = from._impl_.disable_whitelist_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgCustomGameWhitelist::CopyFrom(const CMsgCustomGameWhitelist& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgCustomGameWhitelist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgCustomGameWhitelist::IsInitialized() const {
  return true;
}

void CMsgCustomGameWhitelist::InternalSwap(CMsgCustomGameWhitelist* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.custom_games_whitelist_.InternalSwap(&other->_impl_.custom_games_whitelist_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgCustomGameWhitelist, _impl_.disable_whitelist_)
      + sizeof(CMsgCustomGameWhitelist::_impl_.disable_whitelist_)
      - PROTOBUF_FIELD_OFFSET(CMsgCustomGameWhitelist, _impl_.version_)>(
          reinterpret_cast<char*>(&_impl_.version_),
          reinterpret_cast<char*>(&other->_impl_.version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgCustomGameWhitelist::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[100]);
}

// ===================================================================

class CMsgCustomGameWhitelistForEdit_WhitelistEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgCustomGameWhitelistForEdit_WhitelistEntry>()._impl_._has_bits_);
  static void set_has_custom_game_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_whitelist_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgCustomGameWhitelistForEdit_WhitelistEntry::CMsgCustomGameWhitelistForEdit_WhitelistEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgCustomGameWhitelistForEdit.WhitelistEntry)
}
CMsgCustomGameWhitelistForEdit_WhitelistEntry::CMsgCustomGameWhitelistForEdit_WhitelistEntry(const CMsgCustomGameWhitelistForEdit_WhitelistEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgCustomGameWhitelistForEdit_WhitelistEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.custom_game_id_){}
    , decltype(_impl_.whitelist_state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.custom_game_id_, &from._impl_.custom_game_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.whitelist_state_) -
    reinterpret_cast<char*>(&_impl_.custom_game_id_)) + sizeof(_impl_.whitelist_state_));
  // @@protoc_insertion_point(copy_constructor:CMsgCustomGameWhitelistForEdit.WhitelistEntry)
}

inline void CMsgCustomGameWhitelistForEdit_WhitelistEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.custom_game_id_){uint64_t{0u}}
    , decltype(_impl_.whitelist_state_){0}
  };
}

CMsgCustomGameWhitelistForEdit_WhitelistEntry::~CMsgCustomGameWhitelistForEdit_WhitelistEntry() {
  // @@protoc_insertion_point(destructor:CMsgCustomGameWhitelistForEdit.WhitelistEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgCustomGameWhitelistForEdit_WhitelistEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgCustomGameWhitelistForEdit_WhitelistEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgCustomGameWhitelistForEdit_WhitelistEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgCustomGameWhitelistForEdit.WhitelistEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.custom_game_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.whitelist_state_) -
        reinterpret_cast<char*>(&_impl_.custom_game_id_)) + sizeof(_impl_.whitelist_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgCustomGameWhitelistForEdit_WhitelistEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 custom_game_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_custom_game_id(&has_bits);
          _impl_.custom_game_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ECustomGameWhitelistState whitelist_state = 2 [default = CUSTOM_GAME_WHITELIST_STATE_UNKNOWN];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ECustomGameWhitelistState_IsValid(val))) {
            _internal_set_whitelist_state(static_cast<::ECustomGameWhitelistState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgCustomGameWhitelistForEdit_WhitelistEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgCustomGameWhitelistForEdit.WhitelistEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 custom_game_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_custom_game_id(), target);
  }

  // optional .ECustomGameWhitelistState whitelist_state = 2 [default = CUSTOM_GAME_WHITELIST_STATE_UNKNOWN];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_whitelist_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgCustomGameWhitelistForEdit.WhitelistEntry)
  return target;
}

size_t CMsgCustomGameWhitelistForEdit_WhitelistEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgCustomGameWhitelistForEdit.WhitelistEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 custom_game_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_custom_game_id());
    }

    // optional .ECustomGameWhitelistState whitelist_state = 2 [default = CUSTOM_GAME_WHITELIST_STATE_UNKNOWN];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_whitelist_state());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgCustomGameWhitelistForEdit_WhitelistEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgCustomGameWhitelistForEdit_WhitelistEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgCustomGameWhitelistForEdit_WhitelistEntry::GetClassData() const { return &_class_data_; }


void CMsgCustomGameWhitelistForEdit_WhitelistEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgCustomGameWhitelistForEdit_WhitelistEntry*>(&to_msg);
  auto& from = static_cast<const CMsgCustomGameWhitelistForEdit_WhitelistEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgCustomGameWhitelistForEdit.WhitelistEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.custom_game_id_ = from._impl_.custom_game_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.whitelist_state_ = from._impl_.whitelist_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgCustomGameWhitelistForEdit_WhitelistEntry::CopyFrom(const CMsgCustomGameWhitelistForEdit_WhitelistEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgCustomGameWhitelistForEdit.WhitelistEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgCustomGameWhitelistForEdit_WhitelistEntry::IsInitialized() const {
  return true;
}

void CMsgCustomGameWhitelistForEdit_WhitelistEntry::InternalSwap(CMsgCustomGameWhitelistForEdit_WhitelistEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgCustomGameWhitelistForEdit_WhitelistEntry, _impl_.whitelist_state_)
      + sizeof(CMsgCustomGameWhitelistForEdit_WhitelistEntry::_impl_.whitelist_state_)
      - PROTOBUF_FIELD_OFFSET(CMsgCustomGameWhitelistForEdit_WhitelistEntry, _impl_.custom_game_id_)>(
          reinterpret_cast<char*>(&_impl_.custom_game_id_),
          reinterpret_cast<char*>(&other->_impl_.custom_game_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgCustomGameWhitelistForEdit_WhitelistEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[101]);
}

// ===================================================================

class CMsgCustomGameWhitelistForEdit::_Internal {
 public:
};

CMsgCustomGameWhitelistForEdit::CMsgCustomGameWhitelistForEdit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgCustomGameWhitelistForEdit)
}
CMsgCustomGameWhitelistForEdit::CMsgCustomGameWhitelistForEdit(const CMsgCustomGameWhitelistForEdit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgCustomGameWhitelistForEdit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.whitelist_entries_){from._impl_.whitelist_entries_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgCustomGameWhitelistForEdit)
}

inline void CMsgCustomGameWhitelistForEdit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.whitelist_entries_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgCustomGameWhitelistForEdit::~CMsgCustomGameWhitelistForEdit() {
  // @@protoc_insertion_point(destructor:CMsgCustomGameWhitelistForEdit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgCustomGameWhitelistForEdit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.whitelist_entries_.~RepeatedPtrField();
}

void CMsgCustomGameWhitelistForEdit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgCustomGameWhitelistForEdit::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgCustomGameWhitelistForEdit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.whitelist_entries_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgCustomGameWhitelistForEdit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgCustomGameWhitelistForEdit.WhitelistEntry whitelist_entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_whitelist_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgCustomGameWhitelistForEdit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgCustomGameWhitelistForEdit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgCustomGameWhitelistForEdit.WhitelistEntry whitelist_entries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_whitelist_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_whitelist_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgCustomGameWhitelistForEdit)
  return target;
}

size_t CMsgCustomGameWhitelistForEdit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgCustomGameWhitelistForEdit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgCustomGameWhitelistForEdit.WhitelistEntry whitelist_entries = 1;
  total_size += 1UL * this->_internal_whitelist_entries_size();
  for (const auto& msg : this->_impl_.whitelist_entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgCustomGameWhitelistForEdit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgCustomGameWhitelistForEdit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgCustomGameWhitelistForEdit::GetClassData() const { return &_class_data_; }


void CMsgCustomGameWhitelistForEdit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgCustomGameWhitelistForEdit*>(&to_msg);
  auto& from = static_cast<const CMsgCustomGameWhitelistForEdit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgCustomGameWhitelistForEdit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.whitelist_entries_.MergeFrom(from._impl_.whitelist_entries_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgCustomGameWhitelistForEdit::CopyFrom(const CMsgCustomGameWhitelistForEdit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgCustomGameWhitelistForEdit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgCustomGameWhitelistForEdit::IsInitialized() const {
  return true;
}

void CMsgCustomGameWhitelistForEdit::InternalSwap(CMsgCustomGameWhitelistForEdit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.whitelist_entries_.InternalSwap(&other->_impl_.whitelist_entries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgCustomGameWhitelistForEdit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[102]);
}

// ===================================================================

class CMsgPlayerRecentMatchInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPlayerRecentMatchInfo>()._impl_._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_win(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_deaths(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_assists(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgPlayerRecentMatchInfo::CMsgPlayerRecentMatchInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPlayerRecentMatchInfo)
}
CMsgPlayerRecentMatchInfo::CMsgPlayerRecentMatchInfo(const CMsgPlayerRecentMatchInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPlayerRecentMatchInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.duration_){}
    , decltype(_impl_.win_){}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.kills_){}
    , decltype(_impl_.deaths_){}
    , decltype(_impl_.assists_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.match_id_, &from._impl_.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.assists_) -
    reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.assists_));
  // @@protoc_insertion_point(copy_constructor:CMsgPlayerRecentMatchInfo)
}

inline void CMsgPlayerRecentMatchInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.timestamp_){0u}
    , decltype(_impl_.duration_){0u}
    , decltype(_impl_.win_){false}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.kills_){0u}
    , decltype(_impl_.deaths_){0u}
    , decltype(_impl_.assists_){0u}
  };
}

CMsgPlayerRecentMatchInfo::~CMsgPlayerRecentMatchInfo() {
  // @@protoc_insertion_point(destructor:CMsgPlayerRecentMatchInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPlayerRecentMatchInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgPlayerRecentMatchInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPlayerRecentMatchInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPlayerRecentMatchInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.assists_) -
        reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.assists_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPlayerRecentMatchInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 match_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 duration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_duration(&has_bits);
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool win = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_win(&has_bits);
          _impl_.win_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 kills = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_kills(&has_bits);
          _impl_.kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 deaths = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_deaths(&has_bits);
          _impl_.deaths_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assists = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_assists(&has_bits);
          _impl_.assists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPlayerRecentMatchInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPlayerRecentMatchInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 match_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_match_id(), target);
  }

  // optional uint32 timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_timestamp(), target);
  }

  // optional uint32 duration = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_duration(), target);
  }

  // optional bool win = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_win(), target);
  }

  // optional uint32 hero_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_hero_id(), target);
  }

  // optional uint32 kills = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_kills(), target);
  }

  // optional uint32 deaths = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_deaths(), target);
  }

  // optional uint32 assists = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_assists(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPlayerRecentMatchInfo)
  return target;
}

size_t CMsgPlayerRecentMatchInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPlayerRecentMatchInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 match_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 timestamp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

    // optional uint32 duration = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_duration());
    }

    // optional bool win = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional uint32 hero_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional uint32 kills = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_kills());
    }

    // optional uint32 deaths = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_deaths());
    }

    // optional uint32 assists = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_assists());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPlayerRecentMatchInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPlayerRecentMatchInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPlayerRecentMatchInfo::GetClassData() const { return &_class_data_; }


void CMsgPlayerRecentMatchInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPlayerRecentMatchInfo*>(&to_msg);
  auto& from = static_cast<const CMsgPlayerRecentMatchInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPlayerRecentMatchInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.duration_ = from._impl_.duration_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.win_ = from._impl_.win_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.kills_ = from._impl_.kills_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.deaths_ = from._impl_.deaths_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.assists_ = from._impl_.assists_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPlayerRecentMatchInfo::CopyFrom(const CMsgPlayerRecentMatchInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPlayerRecentMatchInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPlayerRecentMatchInfo::IsInitialized() const {
  return true;
}

void CMsgPlayerRecentMatchInfo::InternalSwap(CMsgPlayerRecentMatchInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPlayerRecentMatchInfo, _impl_.assists_)
      + sizeof(CMsgPlayerRecentMatchInfo::_impl_.assists_)
      - PROTOBUF_FIELD_OFFSET(CMsgPlayerRecentMatchInfo, _impl_.match_id_)>(
          reinterpret_cast<char*>(&_impl_.match_id_),
          reinterpret_cast<char*>(&other->_impl_.match_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPlayerRecentMatchInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[103]);
}

// ===================================================================

class CMsgPlayerMatchRecord::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPlayerMatchRecord>()._impl_._has_bits_);
  static void set_has_wins(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_losses(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgPlayerMatchRecord::CMsgPlayerMatchRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPlayerMatchRecord)
}
CMsgPlayerMatchRecord::CMsgPlayerMatchRecord(const CMsgPlayerMatchRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPlayerMatchRecord* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.wins_){}
    , decltype(_impl_.losses_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.wins_, &from._impl_.wins_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.losses_) -
    reinterpret_cast<char*>(&_impl_.wins_)) + sizeof(_impl_.losses_));
  // @@protoc_insertion_point(copy_constructor:CMsgPlayerMatchRecord)
}

inline void CMsgPlayerMatchRecord::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.wins_){0u}
    , decltype(_impl_.losses_){0u}
  };
}

CMsgPlayerMatchRecord::~CMsgPlayerMatchRecord() {
  // @@protoc_insertion_point(destructor:CMsgPlayerMatchRecord)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPlayerMatchRecord::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgPlayerMatchRecord::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPlayerMatchRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPlayerMatchRecord)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.wins_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.losses_) -
        reinterpret_cast<char*>(&_impl_.wins_)) + sizeof(_impl_.losses_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPlayerMatchRecord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 wins = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_wins(&has_bits);
          _impl_.wins_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 losses = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_losses(&has_bits);
          _impl_.losses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPlayerMatchRecord::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPlayerMatchRecord)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 wins = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_wins(), target);
  }

  // optional uint32 losses = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_losses(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPlayerMatchRecord)
  return target;
}

size_t CMsgPlayerMatchRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPlayerMatchRecord)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 wins = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_wins());
    }

    // optional uint32 losses = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_losses());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPlayerMatchRecord::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPlayerMatchRecord::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPlayerMatchRecord::GetClassData() const { return &_class_data_; }


void CMsgPlayerMatchRecord::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPlayerMatchRecord*>(&to_msg);
  auto& from = static_cast<const CMsgPlayerMatchRecord&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPlayerMatchRecord)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.wins_ = from._impl_.wins_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.losses_ = from._impl_.losses_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPlayerMatchRecord::CopyFrom(const CMsgPlayerMatchRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPlayerMatchRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPlayerMatchRecord::IsInitialized() const {
  return true;
}

void CMsgPlayerMatchRecord::InternalSwap(CMsgPlayerMatchRecord* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPlayerMatchRecord, _impl_.losses_)
      + sizeof(CMsgPlayerMatchRecord::_impl_.losses_)
      - PROTOBUF_FIELD_OFFSET(CMsgPlayerMatchRecord, _impl_.wins_)>(
          reinterpret_cast<char*>(&_impl_.wins_),
          reinterpret_cast<char*>(&other->_impl_.wins_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPlayerMatchRecord::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[104]);
}

// ===================================================================

class CMsgPlayerRecentMatchOutcomes::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPlayerRecentMatchOutcomes>()._impl_._has_bits_);
  static void set_has_outcomes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_match_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgPlayerRecentMatchOutcomes::CMsgPlayerRecentMatchOutcomes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPlayerRecentMatchOutcomes)
}
CMsgPlayerRecentMatchOutcomes::CMsgPlayerRecentMatchOutcomes(const CMsgPlayerRecentMatchOutcomes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPlayerRecentMatchOutcomes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.outcomes_){}
    , decltype(_impl_.match_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.outcomes_, &from._impl_.outcomes_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.match_count_) -
    reinterpret_cast<char*>(&_impl_.outcomes_)) + sizeof(_impl_.match_count_));
  // @@protoc_insertion_point(copy_constructor:CMsgPlayerRecentMatchOutcomes)
}

inline void CMsgPlayerRecentMatchOutcomes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.outcomes_){0u}
    , decltype(_impl_.match_count_){0u}
  };
}

CMsgPlayerRecentMatchOutcomes::~CMsgPlayerRecentMatchOutcomes() {
  // @@protoc_insertion_point(destructor:CMsgPlayerRecentMatchOutcomes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPlayerRecentMatchOutcomes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgPlayerRecentMatchOutcomes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPlayerRecentMatchOutcomes::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPlayerRecentMatchOutcomes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.outcomes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.match_count_) -
        reinterpret_cast<char*>(&_impl_.outcomes_)) + sizeof(_impl_.match_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPlayerRecentMatchOutcomes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 outcomes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_outcomes(&has_bits);
          _impl_.outcomes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 match_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_match_count(&has_bits);
          _impl_.match_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPlayerRecentMatchOutcomes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPlayerRecentMatchOutcomes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 outcomes = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_outcomes(), target);
  }

  // optional uint32 match_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_match_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPlayerRecentMatchOutcomes)
  return target;
}

size_t CMsgPlayerRecentMatchOutcomes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPlayerRecentMatchOutcomes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 outcomes = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_outcomes());
    }

    // optional uint32 match_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_match_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPlayerRecentMatchOutcomes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPlayerRecentMatchOutcomes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPlayerRecentMatchOutcomes::GetClassData() const { return &_class_data_; }


void CMsgPlayerRecentMatchOutcomes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPlayerRecentMatchOutcomes*>(&to_msg);
  auto& from = static_cast<const CMsgPlayerRecentMatchOutcomes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPlayerRecentMatchOutcomes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.outcomes_ = from._impl_.outcomes_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.match_count_ = from._impl_.match_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPlayerRecentMatchOutcomes::CopyFrom(const CMsgPlayerRecentMatchOutcomes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPlayerRecentMatchOutcomes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPlayerRecentMatchOutcomes::IsInitialized() const {
  return true;
}

void CMsgPlayerRecentMatchOutcomes::InternalSwap(CMsgPlayerRecentMatchOutcomes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPlayerRecentMatchOutcomes, _impl_.match_count_)
      + sizeof(CMsgPlayerRecentMatchOutcomes::_impl_.match_count_)
      - PROTOBUF_FIELD_OFFSET(CMsgPlayerRecentMatchOutcomes, _impl_.outcomes_)>(
          reinterpret_cast<char*>(&_impl_.outcomes_),
          reinterpret_cast<char*>(&other->_impl_.outcomes_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPlayerRecentMatchOutcomes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[105]);
}

// ===================================================================

class CMsgPlayerRecentCommends::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPlayerRecentCommends>()._impl_._has_bits_);
  static void set_has_commends(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_match_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgPlayerRecentCommends::CMsgPlayerRecentCommends(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPlayerRecentCommends)
}
CMsgPlayerRecentCommends::CMsgPlayerRecentCommends(const CMsgPlayerRecentCommends& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPlayerRecentCommends* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.commends_){}
    , decltype(_impl_.match_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.commends_, &from._impl_.commends_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.match_count_) -
    reinterpret_cast<char*>(&_impl_.commends_)) + sizeof(_impl_.match_count_));
  // @@protoc_insertion_point(copy_constructor:CMsgPlayerRecentCommends)
}

inline void CMsgPlayerRecentCommends::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.commends_){0u}
    , decltype(_impl_.match_count_){0u}
  };
}

CMsgPlayerRecentCommends::~CMsgPlayerRecentCommends() {
  // @@protoc_insertion_point(destructor:CMsgPlayerRecentCommends)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPlayerRecentCommends::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgPlayerRecentCommends::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPlayerRecentCommends::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPlayerRecentCommends)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.commends_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.match_count_) -
        reinterpret_cast<char*>(&_impl_.commends_)) + sizeof(_impl_.match_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPlayerRecentCommends::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 commends = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_commends(&has_bits);
          _impl_.commends_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 match_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_match_count(&has_bits);
          _impl_.match_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPlayerRecentCommends::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPlayerRecentCommends)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 commends = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_commends(), target);
  }

  // optional uint32 match_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_match_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPlayerRecentCommends)
  return target;
}

size_t CMsgPlayerRecentCommends::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPlayerRecentCommends)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 commends = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_commends());
    }

    // optional uint32 match_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_match_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPlayerRecentCommends::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPlayerRecentCommends::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPlayerRecentCommends::GetClassData() const { return &_class_data_; }


void CMsgPlayerRecentCommends::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPlayerRecentCommends*>(&to_msg);
  auto& from = static_cast<const CMsgPlayerRecentCommends&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPlayerRecentCommends)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.commends_ = from._impl_.commends_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.match_count_ = from._impl_.match_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPlayerRecentCommends::CopyFrom(const CMsgPlayerRecentCommends& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPlayerRecentCommends)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPlayerRecentCommends::IsInitialized() const {
  return true;
}

void CMsgPlayerRecentCommends::InternalSwap(CMsgPlayerRecentCommends* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPlayerRecentCommends, _impl_.match_count_)
      + sizeof(CMsgPlayerRecentCommends::_impl_.match_count_)
      - PROTOBUF_FIELD_OFFSET(CMsgPlayerRecentCommends, _impl_.commends_)>(
          reinterpret_cast<char*>(&_impl_.commends_),
          reinterpret_cast<char*>(&other->_impl_.commends_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPlayerRecentCommends::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[106]);
}

// ===================================================================

class CMsgPlayerRecentAccomplishments::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPlayerRecentAccomplishments>()._impl_._has_bits_);
  static const ::CMsgPlayerRecentMatchOutcomes& recent_outcomes(const CMsgPlayerRecentAccomplishments* msg);
  static void set_has_recent_outcomes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgPlayerMatchRecord& total_record(const CMsgPlayerRecentAccomplishments* msg);
  static void set_has_total_record(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prediction_streak(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_plus_prediction_streak(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::CMsgPlayerRecentCommends& recent_commends(const CMsgPlayerRecentAccomplishments* msg);
  static void set_has_recent_commends(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_first_match_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::CMsgPlayerRecentMatchInfo& last_match(const CMsgPlayerRecentAccomplishments* msg);
  static void set_has_last_match(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgPlayerRecentMatchOutcomes& recent_mvps(const CMsgPlayerRecentAccomplishments* msg);
  static void set_has_recent_mvps(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgPlayerRecentMatchOutcomes&
CMsgPlayerRecentAccomplishments::_Internal::recent_outcomes(const CMsgPlayerRecentAccomplishments* msg) {
  return *msg->_impl_.recent_outcomes_;
}
const ::CMsgPlayerMatchRecord&
CMsgPlayerRecentAccomplishments::_Internal::total_record(const CMsgPlayerRecentAccomplishments* msg) {
  return *msg->_impl_.total_record_;
}
const ::CMsgPlayerRecentCommends&
CMsgPlayerRecentAccomplishments::_Internal::recent_commends(const CMsgPlayerRecentAccomplishments* msg) {
  return *msg->_impl_.recent_commends_;
}
const ::CMsgPlayerRecentMatchInfo&
CMsgPlayerRecentAccomplishments::_Internal::last_match(const CMsgPlayerRecentAccomplishments* msg) {
  return *msg->_impl_.last_match_;
}
const ::CMsgPlayerRecentMatchOutcomes&
CMsgPlayerRecentAccomplishments::_Internal::recent_mvps(const CMsgPlayerRecentAccomplishments* msg) {
  return *msg->_impl_.recent_mvps_;
}
CMsgPlayerRecentAccomplishments::CMsgPlayerRecentAccomplishments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPlayerRecentAccomplishments)
}
CMsgPlayerRecentAccomplishments::CMsgPlayerRecentAccomplishments(const CMsgPlayerRecentAccomplishments& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPlayerRecentAccomplishments* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.recent_outcomes_){nullptr}
    , decltype(_impl_.total_record_){nullptr}
    , decltype(_impl_.recent_commends_){nullptr}
    , decltype(_impl_.last_match_){nullptr}
    , decltype(_impl_.recent_mvps_){nullptr}
    , decltype(_impl_.prediction_streak_){}
    , decltype(_impl_.plus_prediction_streak_){}
    , decltype(_impl_.first_match_timestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_recent_outcomes()) {
    _this->_impl_.recent_outcomes_ = new ::CMsgPlayerRecentMatchOutcomes(*from._impl_.recent_outcomes_);
  }
  if (from._internal_has_total_record()) {
    _this->_impl_.total_record_ = new ::CMsgPlayerMatchRecord(*from._impl_.total_record_);
  }
  if (from._internal_has_recent_commends()) {
    _this->_impl_.recent_commends_ = new ::CMsgPlayerRecentCommends(*from._impl_.recent_commends_);
  }
  if (from._internal_has_last_match()) {
    _this->_impl_.last_match_ = new ::CMsgPlayerRecentMatchInfo(*from._impl_.last_match_);
  }
  if (from._internal_has_recent_mvps()) {
    _this->_impl_.recent_mvps_ = new ::CMsgPlayerRecentMatchOutcomes(*from._impl_.recent_mvps_);
  }
  ::memcpy(&_impl_.prediction_streak_, &from._impl_.prediction_streak_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.first_match_timestamp_) -
    reinterpret_cast<char*>(&_impl_.prediction_streak_)) + sizeof(_impl_.first_match_timestamp_));
  // @@protoc_insertion_point(copy_constructor:CMsgPlayerRecentAccomplishments)
}

inline void CMsgPlayerRecentAccomplishments::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.recent_outcomes_){nullptr}
    , decltype(_impl_.total_record_){nullptr}
    , decltype(_impl_.recent_commends_){nullptr}
    , decltype(_impl_.last_match_){nullptr}
    , decltype(_impl_.recent_mvps_){nullptr}
    , decltype(_impl_.prediction_streak_){0u}
    , decltype(_impl_.plus_prediction_streak_){0u}
    , decltype(_impl_.first_match_timestamp_){0u}
  };
}

CMsgPlayerRecentAccomplishments::~CMsgPlayerRecentAccomplishments() {
  // @@protoc_insertion_point(destructor:CMsgPlayerRecentAccomplishments)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPlayerRecentAccomplishments::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.recent_outcomes_;
  if (this != internal_default_instance()) delete _impl_.total_record_;
  if (this != internal_default_instance()) delete _impl_.recent_commends_;
  if (this != internal_default_instance()) delete _impl_.last_match_;
  if (this != internal_default_instance()) delete _impl_.recent_mvps_;
}

void CMsgPlayerRecentAccomplishments::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPlayerRecentAccomplishments::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPlayerRecentAccomplishments)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.recent_outcomes_ != nullptr);
      _impl_.recent_outcomes_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.total_record_ != nullptr);
      _impl_.total_record_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.recent_commends_ != nullptr);
      _impl_.recent_commends_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.last_match_ != nullptr);
      _impl_.last_match_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.recent_mvps_ != nullptr);
      _impl_.recent_mvps_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.prediction_streak_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.first_match_timestamp_) -
        reinterpret_cast<char*>(&_impl_.prediction_streak_)) + sizeof(_impl_.first_match_timestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPlayerRecentAccomplishments::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgPlayerRecentMatchOutcomes recent_outcomes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_recent_outcomes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgPlayerMatchRecord total_record = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_total_record(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prediction_streak = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prediction_streak(&has_bits);
          _impl_.prediction_streak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 plus_prediction_streak = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_plus_prediction_streak(&has_bits);
          _impl_.plus_prediction_streak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgPlayerRecentCommends recent_commends = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_recent_commends(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 first_match_timestamp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_first_match_timestamp(&has_bits);
          _impl_.first_match_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgPlayerRecentMatchInfo last_match = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgPlayerRecentMatchOutcomes recent_mvps = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_recent_mvps(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPlayerRecentAccomplishments::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPlayerRecentAccomplishments)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgPlayerRecentMatchOutcomes recent_outcomes = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::recent_outcomes(this),
        _Internal::recent_outcomes(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgPlayerMatchRecord total_record = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::total_record(this),
        _Internal::total_record(this).GetCachedSize(), target, stream);
  }

  // optional uint32 prediction_streak = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_prediction_streak(), target);
  }

  // optional uint32 plus_prediction_streak = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_plus_prediction_streak(), target);
  }

  // optional .CMsgPlayerRecentCommends recent_commends = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::recent_commends(this),
        _Internal::recent_commends(this).GetCachedSize(), target, stream);
  }

  // optional uint32 first_match_timestamp = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_first_match_timestamp(), target);
  }

  // optional .CMsgPlayerRecentMatchInfo last_match = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::last_match(this),
        _Internal::last_match(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgPlayerRecentMatchOutcomes recent_mvps = 8;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::recent_mvps(this),
        _Internal::recent_mvps(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPlayerRecentAccomplishments)
  return target;
}

size_t CMsgPlayerRecentAccomplishments::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPlayerRecentAccomplishments)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgPlayerRecentMatchOutcomes recent_outcomes = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recent_outcomes_);
    }

    // optional .CMsgPlayerMatchRecord total_record = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.total_record_);
    }

    // optional .CMsgPlayerRecentCommends recent_commends = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recent_commends_);
    }

    // optional .CMsgPlayerRecentMatchInfo last_match = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.last_match_);
    }

    // optional .CMsgPlayerRecentMatchOutcomes recent_mvps = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recent_mvps_);
    }

    // optional uint32 prediction_streak = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prediction_streak());
    }

    // optional uint32 plus_prediction_streak = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_plus_prediction_streak());
    }

    // optional uint32 first_match_timestamp = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_first_match_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPlayerRecentAccomplishments::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPlayerRecentAccomplishments::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPlayerRecentAccomplishments::GetClassData() const { return &_class_data_; }


void CMsgPlayerRecentAccomplishments::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPlayerRecentAccomplishments*>(&to_msg);
  auto& from = static_cast<const CMsgPlayerRecentAccomplishments&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPlayerRecentAccomplishments)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_recent_outcomes()->::CMsgPlayerRecentMatchOutcomes::MergeFrom(
          from._internal_recent_outcomes());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_total_record()->::CMsgPlayerMatchRecord::MergeFrom(
          from._internal_total_record());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_recent_commends()->::CMsgPlayerRecentCommends::MergeFrom(
          from._internal_recent_commends());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_last_match()->::CMsgPlayerRecentMatchInfo::MergeFrom(
          from._internal_last_match());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_recent_mvps()->::CMsgPlayerRecentMatchOutcomes::MergeFrom(
          from._internal_recent_mvps());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.prediction_streak_ = from._impl_.prediction_streak_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.plus_prediction_streak_ = from._impl_.plus_prediction_streak_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.first_match_timestamp_ = from._impl_.first_match_timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPlayerRecentAccomplishments::CopyFrom(const CMsgPlayerRecentAccomplishments& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPlayerRecentAccomplishments)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPlayerRecentAccomplishments::IsInitialized() const {
  return true;
}

void CMsgPlayerRecentAccomplishments::InternalSwap(CMsgPlayerRecentAccomplishments* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPlayerRecentAccomplishments, _impl_.first_match_timestamp_)
      + sizeof(CMsgPlayerRecentAccomplishments::_impl_.first_match_timestamp_)
      - PROTOBUF_FIELD_OFFSET(CMsgPlayerRecentAccomplishments, _impl_.recent_outcomes_)>(
          reinterpret_cast<char*>(&_impl_.recent_outcomes_),
          reinterpret_cast<char*>(&other->_impl_.recent_outcomes_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPlayerRecentAccomplishments::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[107]);
}

// ===================================================================

class CMsgPlayerHeroRecentAccomplishments::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPlayerHeroRecentAccomplishments>()._impl_._has_bits_);
  static const ::CMsgPlayerRecentMatchOutcomes& recent_outcomes(const CMsgPlayerHeroRecentAccomplishments* msg);
  static void set_has_recent_outcomes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgPlayerMatchRecord& total_record(const CMsgPlayerHeroRecentAccomplishments* msg);
  static void set_has_total_record(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgPlayerRecentMatchInfo& last_match(const CMsgPlayerHeroRecentAccomplishments* msg);
  static void set_has_last_match(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgPlayerRecentMatchOutcomes&
CMsgPlayerHeroRecentAccomplishments::_Internal::recent_outcomes(const CMsgPlayerHeroRecentAccomplishments* msg) {
  return *msg->_impl_.recent_outcomes_;
}
const ::CMsgPlayerMatchRecord&
CMsgPlayerHeroRecentAccomplishments::_Internal::total_record(const CMsgPlayerHeroRecentAccomplishments* msg) {
  return *msg->_impl_.total_record_;
}
const ::CMsgPlayerRecentMatchInfo&
CMsgPlayerHeroRecentAccomplishments::_Internal::last_match(const CMsgPlayerHeroRecentAccomplishments* msg) {
  return *msg->_impl_.last_match_;
}
CMsgPlayerHeroRecentAccomplishments::CMsgPlayerHeroRecentAccomplishments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPlayerHeroRecentAccomplishments)
}
CMsgPlayerHeroRecentAccomplishments::CMsgPlayerHeroRecentAccomplishments(const CMsgPlayerHeroRecentAccomplishments& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPlayerHeroRecentAccomplishments* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.recent_outcomes_){nullptr}
    , decltype(_impl_.total_record_){nullptr}
    , decltype(_impl_.last_match_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_recent_outcomes()) {
    _this->_impl_.recent_outcomes_ = new ::CMsgPlayerRecentMatchOutcomes(*from._impl_.recent_outcomes_);
  }
  if (from._internal_has_total_record()) {
    _this->_impl_.total_record_ = new ::CMsgPlayerMatchRecord(*from._impl_.total_record_);
  }
  if (from._internal_has_last_match()) {
    _this->_impl_.last_match_ = new ::CMsgPlayerRecentMatchInfo(*from._impl_.last_match_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgPlayerHeroRecentAccomplishments)
}

inline void CMsgPlayerHeroRecentAccomplishments::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.recent_outcomes_){nullptr}
    , decltype(_impl_.total_record_){nullptr}
    , decltype(_impl_.last_match_){nullptr}
  };
}

CMsgPlayerHeroRecentAccomplishments::~CMsgPlayerHeroRecentAccomplishments() {
  // @@protoc_insertion_point(destructor:CMsgPlayerHeroRecentAccomplishments)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPlayerHeroRecentAccomplishments::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.recent_outcomes_;
  if (this != internal_default_instance()) delete _impl_.total_record_;
  if (this != internal_default_instance()) delete _impl_.last_match_;
}

void CMsgPlayerHeroRecentAccomplishments::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPlayerHeroRecentAccomplishments::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPlayerHeroRecentAccomplishments)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.recent_outcomes_ != nullptr);
      _impl_.recent_outcomes_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.total_record_ != nullptr);
      _impl_.total_record_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.last_match_ != nullptr);
      _impl_.last_match_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPlayerHeroRecentAccomplishments::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgPlayerRecentMatchOutcomes recent_outcomes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_recent_outcomes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgPlayerMatchRecord total_record = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_total_record(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgPlayerRecentMatchInfo last_match = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPlayerHeroRecentAccomplishments::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPlayerHeroRecentAccomplishments)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgPlayerRecentMatchOutcomes recent_outcomes = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::recent_outcomes(this),
        _Internal::recent_outcomes(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgPlayerMatchRecord total_record = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::total_record(this),
        _Internal::total_record(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgPlayerRecentMatchInfo last_match = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::last_match(this),
        _Internal::last_match(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPlayerHeroRecentAccomplishments)
  return target;
}

size_t CMsgPlayerHeroRecentAccomplishments::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPlayerHeroRecentAccomplishments)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgPlayerRecentMatchOutcomes recent_outcomes = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recent_outcomes_);
    }

    // optional .CMsgPlayerMatchRecord total_record = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.total_record_);
    }

    // optional .CMsgPlayerRecentMatchInfo last_match = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.last_match_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPlayerHeroRecentAccomplishments::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPlayerHeroRecentAccomplishments::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPlayerHeroRecentAccomplishments::GetClassData() const { return &_class_data_; }


void CMsgPlayerHeroRecentAccomplishments::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPlayerHeroRecentAccomplishments*>(&to_msg);
  auto& from = static_cast<const CMsgPlayerHeroRecentAccomplishments&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPlayerHeroRecentAccomplishments)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_recent_outcomes()->::CMsgPlayerRecentMatchOutcomes::MergeFrom(
          from._internal_recent_outcomes());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_total_record()->::CMsgPlayerMatchRecord::MergeFrom(
          from._internal_total_record());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_last_match()->::CMsgPlayerRecentMatchInfo::MergeFrom(
          from._internal_last_match());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPlayerHeroRecentAccomplishments::CopyFrom(const CMsgPlayerHeroRecentAccomplishments& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPlayerHeroRecentAccomplishments)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPlayerHeroRecentAccomplishments::IsInitialized() const {
  return true;
}

void CMsgPlayerHeroRecentAccomplishments::InternalSwap(CMsgPlayerHeroRecentAccomplishments* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPlayerHeroRecentAccomplishments, _impl_.last_match_)
      + sizeof(CMsgPlayerHeroRecentAccomplishments::_impl_.last_match_)
      - PROTOBUF_FIELD_OFFSET(CMsgPlayerHeroRecentAccomplishments, _impl_.recent_outcomes_)>(
          reinterpret_cast<char*>(&_impl_.recent_outcomes_),
          reinterpret_cast<char*>(&other->_impl_.recent_outcomes_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPlayerHeroRecentAccomplishments::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[108]);
}

// ===================================================================

class CMsgRecentAccomplishments::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRecentAccomplishments>()._impl_._has_bits_);
  static const ::CMsgPlayerRecentAccomplishments& player_accomplishments(const CMsgRecentAccomplishments* msg);
  static void set_has_player_accomplishments(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgPlayerHeroRecentAccomplishments& hero_accomplishments(const CMsgRecentAccomplishments* msg);
  static void set_has_hero_accomplishments(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgPlayerRecentAccomplishments&
CMsgRecentAccomplishments::_Internal::player_accomplishments(const CMsgRecentAccomplishments* msg) {
  return *msg->_impl_.player_accomplishments_;
}
const ::CMsgPlayerHeroRecentAccomplishments&
CMsgRecentAccomplishments::_Internal::hero_accomplishments(const CMsgRecentAccomplishments* msg) {
  return *msg->_impl_.hero_accomplishments_;
}
CMsgRecentAccomplishments::CMsgRecentAccomplishments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgRecentAccomplishments)
}
CMsgRecentAccomplishments::CMsgRecentAccomplishments(const CMsgRecentAccomplishments& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgRecentAccomplishments* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_accomplishments_){nullptr}
    , decltype(_impl_.hero_accomplishments_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_player_accomplishments()) {
    _this->_impl_.player_accomplishments_ = new ::CMsgPlayerRecentAccomplishments(*from._impl_.player_accomplishments_);
  }
  if (from._internal_has_hero_accomplishments()) {
    _this->_impl_.hero_accomplishments_ = new ::CMsgPlayerHeroRecentAccomplishments(*from._impl_.hero_accomplishments_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgRecentAccomplishments)
}

inline void CMsgRecentAccomplishments::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_accomplishments_){nullptr}
    , decltype(_impl_.hero_accomplishments_){nullptr}
  };
}

CMsgRecentAccomplishments::~CMsgRecentAccomplishments() {
  // @@protoc_insertion_point(destructor:CMsgRecentAccomplishments)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgRecentAccomplishments::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.player_accomplishments_;
  if (this != internal_default_instance()) delete _impl_.hero_accomplishments_;
}

void CMsgRecentAccomplishments::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgRecentAccomplishments::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRecentAccomplishments)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.player_accomplishments_ != nullptr);
      _impl_.player_accomplishments_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.hero_accomplishments_ != nullptr);
      _impl_.hero_accomplishments_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRecentAccomplishments::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgPlayerRecentAccomplishments player_accomplishments = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_accomplishments(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgPlayerHeroRecentAccomplishments hero_accomplishments = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_hero_accomplishments(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRecentAccomplishments::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRecentAccomplishments)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgPlayerRecentAccomplishments player_accomplishments = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player_accomplishments(this),
        _Internal::player_accomplishments(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgPlayerHeroRecentAccomplishments hero_accomplishments = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::hero_accomplishments(this),
        _Internal::hero_accomplishments(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRecentAccomplishments)
  return target;
}

size_t CMsgRecentAccomplishments::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRecentAccomplishments)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgPlayerRecentAccomplishments player_accomplishments = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.player_accomplishments_);
    }

    // optional .CMsgPlayerHeroRecentAccomplishments hero_accomplishments = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hero_accomplishments_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRecentAccomplishments::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgRecentAccomplishments::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRecentAccomplishments::GetClassData() const { return &_class_data_; }


void CMsgRecentAccomplishments::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgRecentAccomplishments*>(&to_msg);
  auto& from = static_cast<const CMsgRecentAccomplishments&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgRecentAccomplishments)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_player_accomplishments()->::CMsgPlayerRecentAccomplishments::MergeFrom(
          from._internal_player_accomplishments());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_hero_accomplishments()->::CMsgPlayerHeroRecentAccomplishments::MergeFrom(
          from._internal_hero_accomplishments());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRecentAccomplishments::CopyFrom(const CMsgRecentAccomplishments& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRecentAccomplishments)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRecentAccomplishments::IsInitialized() const {
  return true;
}

void CMsgRecentAccomplishments::InternalSwap(CMsgRecentAccomplishments* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRecentAccomplishments, _impl_.hero_accomplishments_)
      + sizeof(CMsgRecentAccomplishments::_impl_.hero_accomplishments_)
      - PROTOBUF_FIELD_OFFSET(CMsgRecentAccomplishments, _impl_.player_accomplishments_)>(
          reinterpret_cast<char*>(&_impl_.player_accomplishments_),
          reinterpret_cast<char*>(&other->_impl_.player_accomplishments_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRecentAccomplishments::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[109]);
}

// ===================================================================

class CMsgServerToGCRequestPlayerRecentAccomplishments::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgServerToGCRequestPlayerRecentAccomplishments>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgServerToGCRequestPlayerRecentAccomplishments::CMsgServerToGCRequestPlayerRecentAccomplishments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgServerToGCRequestPlayerRecentAccomplishments)
}
CMsgServerToGCRequestPlayerRecentAccomplishments::CMsgServerToGCRequestPlayerRecentAccomplishments(const CMsgServerToGCRequestPlayerRecentAccomplishments& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgServerToGCRequestPlayerRecentAccomplishments* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.hero_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hero_id_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.hero_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgServerToGCRequestPlayerRecentAccomplishments)
}

inline void CMsgServerToGCRequestPlayerRecentAccomplishments::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.hero_id_){0u}
  };
}

CMsgServerToGCRequestPlayerRecentAccomplishments::~CMsgServerToGCRequestPlayerRecentAccomplishments() {
  // @@protoc_insertion_point(destructor:CMsgServerToGCRequestPlayerRecentAccomplishments)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgServerToGCRequestPlayerRecentAccomplishments::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgServerToGCRequestPlayerRecentAccomplishments::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgServerToGCRequestPlayerRecentAccomplishments::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgServerToGCRequestPlayerRecentAccomplishments)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hero_id_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.hero_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgServerToGCRequestPlayerRecentAccomplishments::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgServerToGCRequestPlayerRecentAccomplishments::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgServerToGCRequestPlayerRecentAccomplishments)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 hero_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hero_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgServerToGCRequestPlayerRecentAccomplishments)
  return target;
}

size_t CMsgServerToGCRequestPlayerRecentAccomplishments::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgServerToGCRequestPlayerRecentAccomplishments)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 hero_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgServerToGCRequestPlayerRecentAccomplishments::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgServerToGCRequestPlayerRecentAccomplishments::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgServerToGCRequestPlayerRecentAccomplishments::GetClassData() const { return &_class_data_; }


void CMsgServerToGCRequestPlayerRecentAccomplishments::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgServerToGCRequestPlayerRecentAccomplishments*>(&to_msg);
  auto& from = static_cast<const CMsgServerToGCRequestPlayerRecentAccomplishments&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgServerToGCRequestPlayerRecentAccomplishments)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgServerToGCRequestPlayerRecentAccomplishments::CopyFrom(const CMsgServerToGCRequestPlayerRecentAccomplishments& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgServerToGCRequestPlayerRecentAccomplishments)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgServerToGCRequestPlayerRecentAccomplishments::IsInitialized() const {
  return true;
}

void CMsgServerToGCRequestPlayerRecentAccomplishments::InternalSwap(CMsgServerToGCRequestPlayerRecentAccomplishments* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgServerToGCRequestPlayerRecentAccomplishments, _impl_.hero_id_)
      + sizeof(CMsgServerToGCRequestPlayerRecentAccomplishments::_impl_.hero_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgServerToGCRequestPlayerRecentAccomplishments, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgServerToGCRequestPlayerRecentAccomplishments::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[110]);
}

// ===================================================================

class CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgRecentAccomplishments& player_accomplishments(const CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse* msg);
  static void set_has_player_accomplishments(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgRecentAccomplishments&
CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::_Internal::player_accomplishments(const CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse* msg) {
  return *msg->_impl_.player_accomplishments_;
}
CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse)
}
CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse(const CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_accomplishments_){nullptr}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_player_accomplishments()) {
    _this->_impl_.player_accomplishments_ = new ::CMsgRecentAccomplishments(*from._impl_.player_accomplishments_);
  }
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse)
}

inline void CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_accomplishments_){nullptr}
    , decltype(_impl_.result_){0}
  };
}

CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::~CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse() {
  // @@protoc_insertion_point(destructor:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.player_accomplishments_;
}

void CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.player_accomplishments_ != nullptr);
    _impl_.player_accomplishments_->Clear();
  }
  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse result = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse_IsValid(val))) {
            _internal_set_result(static_cast<::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgRecentAccomplishments player_accomplishments = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_accomplishments(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse result = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_result(), target);
  }

  // optional .CMsgRecentAccomplishments player_accomplishments = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::player_accomplishments(this),
        _Internal::player_accomplishments(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse)
  return target;
}

size_t CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgRecentAccomplishments player_accomplishments = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.player_accomplishments_);
    }

    // optional .CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.EResponse result = 1 [default = k_eInternalError];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_result());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::GetClassData() const { return &_class_data_; }


void CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse*>(&to_msg);
  auto& from = static_cast<const CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_player_accomplishments()->::CMsgRecentAccomplishments::MergeFrom(
          from._internal_player_accomplishments());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.result_ = from._impl_.result_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::CopyFrom(const CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::IsInitialized() const {
  return true;
}

void CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::InternalSwap(CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse, _impl_.result_)
      + sizeof(CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::_impl_.result_)
      - PROTOBUF_FIELD_OFFSET(CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse, _impl_.player_accomplishments_)>(
          reinterpret_cast<char*>(&_impl_.player_accomplishments_),
          reinterpret_cast<char*>(&other->_impl_.player_accomplishments_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[111]);
}

// ===================================================================

class CMsgArcanaVoteMatchVotes::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgArcanaVoteMatchVotes>()._impl_._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vote_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgArcanaVoteMatchVotes::CMsgArcanaVoteMatchVotes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgArcanaVoteMatchVotes)
}
CMsgArcanaVoteMatchVotes::CMsgArcanaVoteMatchVotes(const CMsgArcanaVoteMatchVotes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgArcanaVoteMatchVotes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.vote_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.match_id_, &from._impl_.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vote_count_) -
    reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.vote_count_));
  // @@protoc_insertion_point(copy_constructor:CMsgArcanaVoteMatchVotes)
}

inline void CMsgArcanaVoteMatchVotes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_id_){0u}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.vote_count_){0u}
  };
}

CMsgArcanaVoteMatchVotes::~CMsgArcanaVoteMatchVotes() {
  // @@protoc_insertion_point(destructor:CMsgArcanaVoteMatchVotes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgArcanaVoteMatchVotes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgArcanaVoteMatchVotes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgArcanaVoteMatchVotes::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgArcanaVoteMatchVotes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vote_count_) -
        reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.vote_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgArcanaVoteMatchVotes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 match_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 vote_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vote_count(&has_bits);
          _impl_.vote_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgArcanaVoteMatchVotes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgArcanaVoteMatchVotes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 match_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_match_id(), target);
  }

  // optional uint32 hero_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hero_id(), target);
  }

  // optional uint32 vote_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_vote_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgArcanaVoteMatchVotes)
  return target;
}

size_t CMsgArcanaVoteMatchVotes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgArcanaVoteMatchVotes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 match_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 hero_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional uint32 vote_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vote_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgArcanaVoteMatchVotes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgArcanaVoteMatchVotes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgArcanaVoteMatchVotes::GetClassData() const { return &_class_data_; }


void CMsgArcanaVoteMatchVotes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgArcanaVoteMatchVotes*>(&to_msg);
  auto& from = static_cast<const CMsgArcanaVoteMatchVotes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgArcanaVoteMatchVotes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vote_count_ = from._impl_.vote_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgArcanaVoteMatchVotes::CopyFrom(const CMsgArcanaVoteMatchVotes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgArcanaVoteMatchVotes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgArcanaVoteMatchVotes::IsInitialized() const {
  return true;
}

void CMsgArcanaVoteMatchVotes::InternalSwap(CMsgArcanaVoteMatchVotes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgArcanaVoteMatchVotes, _impl_.vote_count_)
      + sizeof(CMsgArcanaVoteMatchVotes::_impl_.vote_count_)
      - PROTOBUF_FIELD_OFFSET(CMsgArcanaVoteMatchVotes, _impl_.match_id_)>(
          reinterpret_cast<char*>(&_impl_.match_id_),
          reinterpret_cast<char*>(&other->_impl_.match_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgArcanaVoteMatchVotes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[112]);
}

// ===================================================================

class CMsgGCtoGCAssociatedExploiterAccountInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCtoGCAssociatedExploiterAccountInfo>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_matches_to_search(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_min_shared_match_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_additional_players(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgGCtoGCAssociatedExploiterAccountInfo::CMsgGCtoGCAssociatedExploiterAccountInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCtoGCAssociatedExploiterAccountInfo)
}
CMsgGCtoGCAssociatedExploiterAccountInfo::CMsgGCtoGCAssociatedExploiterAccountInfo(const CMsgGCtoGCAssociatedExploiterAccountInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCtoGCAssociatedExploiterAccountInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.num_matches_to_search_){}
    , decltype(_impl_.min_shared_match_count_){}
    , decltype(_impl_.num_additional_players_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_additional_players_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.num_additional_players_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCtoGCAssociatedExploiterAccountInfo)
}

inline void CMsgGCtoGCAssociatedExploiterAccountInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.num_matches_to_search_){0u}
    , decltype(_impl_.min_shared_match_count_){0u}
    , decltype(_impl_.num_additional_players_){0u}
  };
}

CMsgGCtoGCAssociatedExploiterAccountInfo::~CMsgGCtoGCAssociatedExploiterAccountInfo() {
  // @@protoc_insertion_point(destructor:CMsgGCtoGCAssociatedExploiterAccountInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCtoGCAssociatedExploiterAccountInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCtoGCAssociatedExploiterAccountInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCtoGCAssociatedExploiterAccountInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCtoGCAssociatedExploiterAccountInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_additional_players_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.num_additional_players_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCtoGCAssociatedExploiterAccountInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_matches_to_search = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_matches_to_search(&has_bits);
          _impl_.num_matches_to_search_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 min_shared_match_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_min_shared_match_count(&has_bits);
          _impl_.min_shared_match_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_additional_players = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_num_additional_players(&has_bits);
          _impl_.num_additional_players_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCtoGCAssociatedExploiterAccountInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCtoGCAssociatedExploiterAccountInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 num_matches_to_search = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_num_matches_to_search(), target);
  }

  // optional uint32 min_shared_match_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_min_shared_match_count(), target);
  }

  // optional uint32 num_additional_players = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_num_additional_players(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCtoGCAssociatedExploiterAccountInfo)
  return target;
}

size_t CMsgGCtoGCAssociatedExploiterAccountInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCtoGCAssociatedExploiterAccountInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 num_matches_to_search = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_matches_to_search());
    }

    // optional uint32 min_shared_match_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_min_shared_match_count());
    }

    // optional uint32 num_additional_players = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_additional_players());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCtoGCAssociatedExploiterAccountInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCtoGCAssociatedExploiterAccountInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCtoGCAssociatedExploiterAccountInfo::GetClassData() const { return &_class_data_; }


void CMsgGCtoGCAssociatedExploiterAccountInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCtoGCAssociatedExploiterAccountInfo*>(&to_msg);
  auto& from = static_cast<const CMsgGCtoGCAssociatedExploiterAccountInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCtoGCAssociatedExploiterAccountInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_matches_to_search_ = from._impl_.num_matches_to_search_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.min_shared_match_count_ = from._impl_.min_shared_match_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.num_additional_players_ = from._impl_.num_additional_players_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCtoGCAssociatedExploiterAccountInfo::CopyFrom(const CMsgGCtoGCAssociatedExploiterAccountInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCtoGCAssociatedExploiterAccountInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCtoGCAssociatedExploiterAccountInfo::IsInitialized() const {
  return true;
}

void CMsgGCtoGCAssociatedExploiterAccountInfo::InternalSwap(CMsgGCtoGCAssociatedExploiterAccountInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCtoGCAssociatedExploiterAccountInfo, _impl_.num_additional_players_)
      + sizeof(CMsgGCtoGCAssociatedExploiterAccountInfo::_impl_.num_additional_players_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCtoGCAssociatedExploiterAccountInfo, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCtoGCAssociatedExploiterAccountInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[113]);
}

// ===================================================================

class CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_common_matches(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_earliest_common_match(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_latest_common_match(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_generation(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_persona(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_already_banned(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account)
}
CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account(const CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.persona_){}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.num_common_matches_){}
    , decltype(_impl_.earliest_common_match_){}
    , decltype(_impl_.latest_common_match_){}
    , decltype(_impl_.generation_){}
    , decltype(_impl_.already_banned_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.persona_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.persona_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_persona()) {
    _this->_impl_.persona_.Set(from._internal_persona(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.already_banned_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.already_banned_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account)
}

inline void CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.persona_){}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.num_common_matches_){0u}
    , decltype(_impl_.earliest_common_match_){0u}
    , decltype(_impl_.latest_common_match_){0u}
    , decltype(_impl_.generation_){0u}
    , decltype(_impl_.already_banned_){false}
  };
  _impl_.persona_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.persona_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::~CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account() {
  // @@protoc_insertion_point(destructor:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.persona_.Destroy();
}

void CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.persona_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.already_banned_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.already_banned_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_common_matches = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_common_matches(&has_bits);
          _impl_.num_common_matches_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 earliest_common_match = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_earliest_common_match(&has_bits);
          _impl_.earliest_common_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 latest_common_match = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_latest_common_match(&has_bits);
          _impl_.latest_common_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 generation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_generation(&has_bits);
          _impl_.generation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string persona = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_persona();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.persona");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool already_banned = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_already_banned(&has_bits);
          _impl_.already_banned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 num_common_matches = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_num_common_matches(), target);
  }

  // optional uint32 earliest_common_match = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_earliest_common_match(), target);
  }

  // optional uint32 latest_common_match = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_latest_common_match(), target);
  }

  // optional uint32 generation = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_generation(), target);
  }

  // optional string persona = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_persona().data(), static_cast<int>(this->_internal_persona().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account.persona");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_persona(), target);
  }

  // optional bool already_banned = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_already_banned(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account)
  return target;
}

size_t CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string persona = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_persona());
    }

    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 num_common_matches = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_common_matches());
    }

    // optional uint32 earliest_common_match = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_earliest_common_match());
    }

    // optional uint32 latest_common_match = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_common_match());
    }

    // optional uint32 generation = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_generation());
    }

    // optional bool already_banned = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::GetClassData() const { return &_class_data_; }


void CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account*>(&to_msg);
  auto& from = static_cast<const CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_persona(from._internal_persona());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_common_matches_ = from._impl_.num_common_matches_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.earliest_common_match_ = from._impl_.earliest_common_match_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.latest_common_match_ = from._impl_.latest_common_match_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.generation_ = from._impl_.generation_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.already_banned_ = from._impl_.already_banned_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::CopyFrom(const CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::IsInitialized() const {
  return true;
}

void CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::InternalSwap(CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.persona_, lhs_arena,
      &other->_impl_.persona_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account, _impl_.already_banned_)
      + sizeof(CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::_impl_.already_banned_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[114]);
}

// ===================================================================

class CMsgGCtoGCAssociatedExploiterAccountInfoResponse::_Internal {
 public:
};

CMsgGCtoGCAssociatedExploiterAccountInfoResponse::CMsgGCtoGCAssociatedExploiterAccountInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCtoGCAssociatedExploiterAccountInfoResponse)
}
CMsgGCtoGCAssociatedExploiterAccountInfoResponse::CMsgGCtoGCAssociatedExploiterAccountInfoResponse(const CMsgGCtoGCAssociatedExploiterAccountInfoResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCtoGCAssociatedExploiterAccountInfoResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accounts_){from._impl_.accounts_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGCtoGCAssociatedExploiterAccountInfoResponse)
}

inline void CMsgGCtoGCAssociatedExploiterAccountInfoResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accounts_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGCtoGCAssociatedExploiterAccountInfoResponse::~CMsgGCtoGCAssociatedExploiterAccountInfoResponse() {
  // @@protoc_insertion_point(destructor:CMsgGCtoGCAssociatedExploiterAccountInfoResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCtoGCAssociatedExploiterAccountInfoResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.accounts_.~RepeatedPtrField();
}

void CMsgGCtoGCAssociatedExploiterAccountInfoResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCtoGCAssociatedExploiterAccountInfoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCtoGCAssociatedExploiterAccountInfoResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accounts_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCtoGCAssociatedExploiterAccountInfoResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account accounts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_accounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCtoGCAssociatedExploiterAccountInfoResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCtoGCAssociatedExploiterAccountInfoResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account accounts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_accounts_size()); i < n; i++) {
    const auto& repfield = this->_internal_accounts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCtoGCAssociatedExploiterAccountInfoResponse)
  return target;
}

size_t CMsgGCtoGCAssociatedExploiterAccountInfoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCtoGCAssociatedExploiterAccountInfoResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGCtoGCAssociatedExploiterAccountInfoResponse.Account accounts = 1;
  total_size += 1UL * this->_internal_accounts_size();
  for (const auto& msg : this->_impl_.accounts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCtoGCAssociatedExploiterAccountInfoResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCtoGCAssociatedExploiterAccountInfoResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCtoGCAssociatedExploiterAccountInfoResponse::GetClassData() const { return &_class_data_; }


void CMsgGCtoGCAssociatedExploiterAccountInfoResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCtoGCAssociatedExploiterAccountInfoResponse*>(&to_msg);
  auto& from = static_cast<const CMsgGCtoGCAssociatedExploiterAccountInfoResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCtoGCAssociatedExploiterAccountInfoResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.accounts_.MergeFrom(from._impl_.accounts_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCtoGCAssociatedExploiterAccountInfoResponse::CopyFrom(const CMsgGCtoGCAssociatedExploiterAccountInfoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCtoGCAssociatedExploiterAccountInfoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCtoGCAssociatedExploiterAccountInfoResponse::IsInitialized() const {
  return true;
}

void CMsgGCtoGCAssociatedExploiterAccountInfoResponse::InternalSwap(CMsgGCtoGCAssociatedExploiterAccountInfoResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.accounts_.InternalSwap(&other->_impl_.accounts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCtoGCAssociatedExploiterAccountInfoResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[115]);
}

// ===================================================================

class CMsgPullTabsData_Slot::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPullTabsData_Slot>()._impl_._has_bits_);
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_board_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_action_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_redeemed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgPullTabsData_Slot::CMsgPullTabsData_Slot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPullTabsData.Slot)
}
CMsgPullTabsData_Slot::CMsgPullTabsData_Slot(const CMsgPullTabsData_Slot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPullTabsData_Slot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_id_){}
    , decltype(_impl_.board_id_){}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.action_id_){}
    , decltype(_impl_.redeemed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.event_id_, &from._impl_.event_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.redeemed_) -
    reinterpret_cast<char*>(&_impl_.event_id_)) + sizeof(_impl_.redeemed_));
  // @@protoc_insertion_point(copy_constructor:CMsgPullTabsData.Slot)
}

inline void CMsgPullTabsData_Slot::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_id_){0u}
    , decltype(_impl_.board_id_){0u}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.action_id_){0u}
    , decltype(_impl_.redeemed_){false}
  };
}

CMsgPullTabsData_Slot::~CMsgPullTabsData_Slot() {
  // @@protoc_insertion_point(destructor:CMsgPullTabsData.Slot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPullTabsData_Slot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgPullTabsData_Slot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPullTabsData_Slot::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPullTabsData.Slot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.event_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.redeemed_) -
        reinterpret_cast<char*>(&_impl_.event_id_)) + sizeof(_impl_.redeemed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPullTabsData_Slot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 event_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_event_id(&has_bits);
          _impl_.event_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 board_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_board_id(&has_bits);
          _impl_.board_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 action_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_action_id(&has_bits);
          _impl_.action_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool redeemed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_redeemed(&has_bits);
          _impl_.redeemed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPullTabsData_Slot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPullTabsData.Slot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 event_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_event_id(), target);
  }

  // optional uint32 board_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_board_id(), target);
  }

  // optional uint32 hero_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hero_id(), target);
  }

  // optional uint32 action_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_action_id(), target);
  }

  // optional bool redeemed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_redeemed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPullTabsData.Slot)
  return target;
}

size_t CMsgPullTabsData_Slot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPullTabsData.Slot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 event_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_event_id());
    }

    // optional uint32 board_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_board_id());
    }

    // optional uint32 hero_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional uint32 action_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_action_id());
    }

    // optional bool redeemed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPullTabsData_Slot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPullTabsData_Slot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPullTabsData_Slot::GetClassData() const { return &_class_data_; }


void CMsgPullTabsData_Slot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPullTabsData_Slot*>(&to_msg);
  auto& from = static_cast<const CMsgPullTabsData_Slot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPullTabsData.Slot)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.board_id_ = from._impl_.board_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.action_id_ = from._impl_.action_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.redeemed_ = from._impl_.redeemed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPullTabsData_Slot::CopyFrom(const CMsgPullTabsData_Slot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPullTabsData.Slot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPullTabsData_Slot::IsInitialized() const {
  return true;
}

void CMsgPullTabsData_Slot::InternalSwap(CMsgPullTabsData_Slot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPullTabsData_Slot, _impl_.redeemed_)
      + sizeof(CMsgPullTabsData_Slot::_impl_.redeemed_)
      - PROTOBUF_FIELD_OFFSET(CMsgPullTabsData_Slot, _impl_.event_id_)>(
          reinterpret_cast<char*>(&_impl_.event_id_),
          reinterpret_cast<char*>(&other->_impl_.event_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPullTabsData_Slot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[116]);
}

// ===================================================================

class CMsgPullTabsData_Jackpot::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPullTabsData_Jackpot>()._impl_._has_bits_);
  static void set_has_board_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_action_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgPullTabsData_Jackpot::CMsgPullTabsData_Jackpot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPullTabsData.Jackpot)
}
CMsgPullTabsData_Jackpot::CMsgPullTabsData_Jackpot(const CMsgPullTabsData_Jackpot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPullTabsData_Jackpot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.board_id_){}
    , decltype(_impl_.action_id_){}
    , decltype(_impl_.hero_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.board_id_, &from._impl_.board_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hero_id_) -
    reinterpret_cast<char*>(&_impl_.board_id_)) + sizeof(_impl_.hero_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgPullTabsData.Jackpot)
}

inline void CMsgPullTabsData_Jackpot::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.board_id_){0u}
    , decltype(_impl_.action_id_){0u}
    , decltype(_impl_.hero_id_){0u}
  };
}

CMsgPullTabsData_Jackpot::~CMsgPullTabsData_Jackpot() {
  // @@protoc_insertion_point(destructor:CMsgPullTabsData.Jackpot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPullTabsData_Jackpot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgPullTabsData_Jackpot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPullTabsData_Jackpot::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPullTabsData.Jackpot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.board_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hero_id_) -
        reinterpret_cast<char*>(&_impl_.board_id_)) + sizeof(_impl_.hero_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPullTabsData_Jackpot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 board_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_board_id(&has_bits);
          _impl_.board_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 action_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_action_id(&has_bits);
          _impl_.action_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPullTabsData_Jackpot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPullTabsData.Jackpot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 board_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_board_id(), target);
  }

  // optional uint32 action_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_action_id(), target);
  }

  // optional uint32 hero_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hero_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPullTabsData.Jackpot)
  return target;
}

size_t CMsgPullTabsData_Jackpot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPullTabsData.Jackpot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 board_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_board_id());
    }

    // optional uint32 action_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_action_id());
    }

    // optional uint32 hero_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPullTabsData_Jackpot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPullTabsData_Jackpot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPullTabsData_Jackpot::GetClassData() const { return &_class_data_; }


void CMsgPullTabsData_Jackpot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPullTabsData_Jackpot*>(&to_msg);
  auto& from = static_cast<const CMsgPullTabsData_Jackpot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPullTabsData.Jackpot)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.board_id_ = from._impl_.board_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.action_id_ = from._impl_.action_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPullTabsData_Jackpot::CopyFrom(const CMsgPullTabsData_Jackpot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPullTabsData.Jackpot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPullTabsData_Jackpot::IsInitialized() const {
  return true;
}

void CMsgPullTabsData_Jackpot::InternalSwap(CMsgPullTabsData_Jackpot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPullTabsData_Jackpot, _impl_.hero_id_)
      + sizeof(CMsgPullTabsData_Jackpot::_impl_.hero_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgPullTabsData_Jackpot, _impl_.board_id_)>(
          reinterpret_cast<char*>(&_impl_.board_id_),
          reinterpret_cast<char*>(&other->_impl_.board_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPullTabsData_Jackpot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[117]);
}

// ===================================================================

class CMsgPullTabsData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPullTabsData>()._impl_._has_bits_);
  static void set_has_last_board(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgPullTabsData::CMsgPullTabsData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPullTabsData)
}
CMsgPullTabsData::CMsgPullTabsData(const CMsgPullTabsData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPullTabsData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slots_){from._impl_.slots_}
    , decltype(_impl_.jackpots_){from._impl_.jackpots_}
    , decltype(_impl_.last_board_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.last_board_ = from._impl_.last_board_;
  // @@protoc_insertion_point(copy_constructor:CMsgPullTabsData)
}

inline void CMsgPullTabsData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slots_){arena}
    , decltype(_impl_.jackpots_){arena}
    , decltype(_impl_.last_board_){0u}
  };
}

CMsgPullTabsData::~CMsgPullTabsData() {
  // @@protoc_insertion_point(destructor:CMsgPullTabsData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPullTabsData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.slots_.~RepeatedPtrField();
  _impl_.jackpots_.~RepeatedPtrField();
}

void CMsgPullTabsData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPullTabsData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPullTabsData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.slots_.Clear();
  _impl_.jackpots_.Clear();
  _impl_.last_board_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPullTabsData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgPullTabsData.Slot slots = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_slots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgPullTabsData.Jackpot jackpots = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_jackpots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_board = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_last_board(&has_bits);
          _impl_.last_board_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPullTabsData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPullTabsData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgPullTabsData.Slot slots = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_slots_size()); i < n; i++) {
    const auto& repfield = this->_internal_slots(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgPullTabsData.Jackpot jackpots = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_jackpots_size()); i < n; i++) {
    const auto& repfield = this->_internal_jackpots(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 last_board = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_last_board(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPullTabsData)
  return target;
}

size_t CMsgPullTabsData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPullTabsData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgPullTabsData.Slot slots = 1;
  total_size += 1UL * this->_internal_slots_size();
  for (const auto& msg : this->_impl_.slots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgPullTabsData.Jackpot jackpots = 2;
  total_size += 1UL * this->_internal_jackpots_size();
  for (const auto& msg : this->_impl_.jackpots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 last_board = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_board());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPullTabsData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPullTabsData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPullTabsData::GetClassData() const { return &_class_data_; }


void CMsgPullTabsData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPullTabsData*>(&to_msg);
  auto& from = static_cast<const CMsgPullTabsData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPullTabsData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.slots_.MergeFrom(from._impl_.slots_);
  _this->_impl_.jackpots_.MergeFrom(from._impl_.jackpots_);
  if (from._internal_has_last_board()) {
    _this->_internal_set_last_board(from._internal_last_board());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPullTabsData::CopyFrom(const CMsgPullTabsData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPullTabsData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPullTabsData::IsInitialized() const {
  return true;
}

void CMsgPullTabsData::InternalSwap(CMsgPullTabsData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.slots_.InternalSwap(&other->_impl_.slots_);
  _impl_.jackpots_.InternalSwap(&other->_impl_.jackpots_);
  swap(_impl_.last_board_, other->_impl_.last_board_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPullTabsData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[118]);
}

// ===================================================================

class CMsgUnderDraftData_BenchSlot::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgUnderDraftData_BenchSlot>()._impl_._has_bits_);
  static void set_has_slot_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stars(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgUnderDraftData_BenchSlot::CMsgUnderDraftData_BenchSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgUnderDraftData.BenchSlot)
}
CMsgUnderDraftData_BenchSlot::CMsgUnderDraftData_BenchSlot(const CMsgUnderDraftData_BenchSlot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgUnderDraftData_BenchSlot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_id_){}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.stars_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.slot_id_, &from._impl_.slot_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stars_) -
    reinterpret_cast<char*>(&_impl_.slot_id_)) + sizeof(_impl_.stars_));
  // @@protoc_insertion_point(copy_constructor:CMsgUnderDraftData.BenchSlot)
}

inline void CMsgUnderDraftData_BenchSlot::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_id_){0u}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.stars_){0u}
  };
}

CMsgUnderDraftData_BenchSlot::~CMsgUnderDraftData_BenchSlot() {
  // @@protoc_insertion_point(destructor:CMsgUnderDraftData.BenchSlot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgUnderDraftData_BenchSlot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgUnderDraftData_BenchSlot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgUnderDraftData_BenchSlot::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgUnderDraftData.BenchSlot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.slot_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.stars_) -
        reinterpret_cast<char*>(&_impl_.slot_id_)) + sizeof(_impl_.stars_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgUnderDraftData_BenchSlot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 slot_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_slot_id(&has_bits);
          _impl_.slot_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stars = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_stars(&has_bits);
          _impl_.stars_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgUnderDraftData_BenchSlot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgUnderDraftData.BenchSlot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 slot_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_slot_id(), target);
  }

  // optional uint32 hero_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hero_id(), target);
  }

  // optional uint32 stars = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_stars(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgUnderDraftData.BenchSlot)
  return target;
}

size_t CMsgUnderDraftData_BenchSlot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgUnderDraftData.BenchSlot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 slot_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_slot_id());
    }

    // optional uint32 hero_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional uint32 stars = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stars());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgUnderDraftData_BenchSlot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgUnderDraftData_BenchSlot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgUnderDraftData_BenchSlot::GetClassData() const { return &_class_data_; }


void CMsgUnderDraftData_BenchSlot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgUnderDraftData_BenchSlot*>(&to_msg);
  auto& from = static_cast<const CMsgUnderDraftData_BenchSlot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgUnderDraftData.BenchSlot)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.slot_id_ = from._impl_.slot_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.stars_ = from._impl_.stars_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgUnderDraftData_BenchSlot::CopyFrom(const CMsgUnderDraftData_BenchSlot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgUnderDraftData.BenchSlot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgUnderDraftData_BenchSlot::IsInitialized() const {
  return true;
}

void CMsgUnderDraftData_BenchSlot::InternalSwap(CMsgUnderDraftData_BenchSlot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgUnderDraftData_BenchSlot, _impl_.stars_)
      + sizeof(CMsgUnderDraftData_BenchSlot::_impl_.stars_)
      - PROTOBUF_FIELD_OFFSET(CMsgUnderDraftData_BenchSlot, _impl_.slot_id_)>(
          reinterpret_cast<char*>(&_impl_.slot_id_),
          reinterpret_cast<char*>(&other->_impl_.slot_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgUnderDraftData_BenchSlot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[119]);
}

// ===================================================================

class CMsgUnderDraftData_ShopSlot::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgUnderDraftData_ShopSlot>()._impl_._has_bits_);
  static void set_has_slot_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_special_reward(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgUnderDraftData_ShopSlot::CMsgUnderDraftData_ShopSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgUnderDraftData.ShopSlot)
}
CMsgUnderDraftData_ShopSlot::CMsgUnderDraftData_ShopSlot(const CMsgUnderDraftData_ShopSlot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgUnderDraftData_ShopSlot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_id_){}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.is_special_reward_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.slot_id_, &from._impl_.slot_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_special_reward_) -
    reinterpret_cast<char*>(&_impl_.slot_id_)) + sizeof(_impl_.is_special_reward_));
  // @@protoc_insertion_point(copy_constructor:CMsgUnderDraftData.ShopSlot)
}

inline void CMsgUnderDraftData_ShopSlot::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_id_){0u}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.is_special_reward_){false}
  };
}

CMsgUnderDraftData_ShopSlot::~CMsgUnderDraftData_ShopSlot() {
  // @@protoc_insertion_point(destructor:CMsgUnderDraftData.ShopSlot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgUnderDraftData_ShopSlot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgUnderDraftData_ShopSlot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgUnderDraftData_ShopSlot::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgUnderDraftData.ShopSlot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.slot_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_special_reward_) -
        reinterpret_cast<char*>(&_impl_.slot_id_)) + sizeof(_impl_.is_special_reward_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgUnderDraftData_ShopSlot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 slot_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_slot_id(&has_bits);
          _impl_.slot_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_special_reward = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_special_reward(&has_bits);
          _impl_.is_special_reward_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgUnderDraftData_ShopSlot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgUnderDraftData.ShopSlot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 slot_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_slot_id(), target);
  }

  // optional uint32 hero_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hero_id(), target);
  }

  // optional bool is_special_reward = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_special_reward(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgUnderDraftData.ShopSlot)
  return target;
}

size_t CMsgUnderDraftData_ShopSlot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgUnderDraftData.ShopSlot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 slot_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_slot_id());
    }

    // optional uint32 hero_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional bool is_special_reward = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgUnderDraftData_ShopSlot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgUnderDraftData_ShopSlot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgUnderDraftData_ShopSlot::GetClassData() const { return &_class_data_; }


void CMsgUnderDraftData_ShopSlot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgUnderDraftData_ShopSlot*>(&to_msg);
  auto& from = static_cast<const CMsgUnderDraftData_ShopSlot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgUnderDraftData.ShopSlot)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.slot_id_ = from._impl_.slot_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_special_reward_ = from._impl_.is_special_reward_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgUnderDraftData_ShopSlot::CopyFrom(const CMsgUnderDraftData_ShopSlot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgUnderDraftData.ShopSlot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgUnderDraftData_ShopSlot::IsInitialized() const {
  return true;
}

void CMsgUnderDraftData_ShopSlot::InternalSwap(CMsgUnderDraftData_ShopSlot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgUnderDraftData_ShopSlot, _impl_.is_special_reward_)
      + sizeof(CMsgUnderDraftData_ShopSlot::_impl_.is_special_reward_)
      - PROTOBUF_FIELD_OFFSET(CMsgUnderDraftData_ShopSlot, _impl_.slot_id_)>(
          reinterpret_cast<char*>(&_impl_.slot_id_),
          reinterpret_cast<char*>(&other->_impl_.slot_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgUnderDraftData_ShopSlot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[120]);
}

// ===================================================================

class CMsgUnderDraftData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgUnderDraftData>()._impl_._has_bits_);
  static void set_has_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_total_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_not_restorable(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgUnderDraftData::CMsgUnderDraftData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgUnderDraftData)
}
CMsgUnderDraftData::CMsgUnderDraftData(const CMsgUnderDraftData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgUnderDraftData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bench_slots_){from._impl_.bench_slots_}
    , decltype(_impl_.shop_slots_){from._impl_.shop_slots_}
    , decltype(_impl_.gold_){}
    , decltype(_impl_.total_gold_){}
    , decltype(_impl_.not_restorable_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.gold_, &from._impl_.gold_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.not_restorable_) -
    reinterpret_cast<char*>(&_impl_.gold_)) + sizeof(_impl_.not_restorable_));
  // @@protoc_insertion_point(copy_constructor:CMsgUnderDraftData)
}

inline void CMsgUnderDraftData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bench_slots_){arena}
    , decltype(_impl_.shop_slots_){arena}
    , decltype(_impl_.gold_){0u}
    , decltype(_impl_.total_gold_){0u}
    , decltype(_impl_.not_restorable_){false}
  };
}

CMsgUnderDraftData::~CMsgUnderDraftData() {
  // @@protoc_insertion_point(destructor:CMsgUnderDraftData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgUnderDraftData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bench_slots_.~RepeatedPtrField();
  _impl_.shop_slots_.~RepeatedPtrField();
}

void CMsgUnderDraftData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgUnderDraftData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgUnderDraftData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bench_slots_.Clear();
  _impl_.shop_slots_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.gold_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.not_restorable_) -
        reinterpret_cast<char*>(&_impl_.gold_)) + sizeof(_impl_.not_restorable_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgUnderDraftData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgUnderDraftData.BenchSlot bench_slots = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bench_slots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgUnderDraftData.ShopSlot shop_slots = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shop_slots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gold = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_gold(&has_bits);
          _impl_.gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 total_gold = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_total_gold(&has_bits);
          _impl_.total_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool not_restorable = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_not_restorable(&has_bits);
          _impl_.not_restorable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgUnderDraftData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgUnderDraftData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgUnderDraftData.BenchSlot bench_slots = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bench_slots_size()); i < n; i++) {
    const auto& repfield = this->_internal_bench_slots(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgUnderDraftData.ShopSlot shop_slots = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shop_slots_size()); i < n; i++) {
    const auto& repfield = this->_internal_shop_slots(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gold = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_gold(), target);
  }

  // optional uint32 total_gold = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_total_gold(), target);
  }

  // optional bool not_restorable = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_not_restorable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgUnderDraftData)
  return target;
}

size_t CMsgUnderDraftData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgUnderDraftData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgUnderDraftData.BenchSlot bench_slots = 1;
  total_size += 1UL * this->_internal_bench_slots_size();
  for (const auto& msg : this->_impl_.bench_slots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgUnderDraftData.ShopSlot shop_slots = 2;
  total_size += 1UL * this->_internal_shop_slots_size();
  for (const auto& msg : this->_impl_.shop_slots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 gold = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gold());
    }

    // optional uint32 total_gold = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_gold());
    }

    // optional bool not_restorable = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgUnderDraftData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgUnderDraftData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgUnderDraftData::GetClassData() const { return &_class_data_; }


void CMsgUnderDraftData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgUnderDraftData*>(&to_msg);
  auto& from = static_cast<const CMsgUnderDraftData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgUnderDraftData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bench_slots_.MergeFrom(from._impl_.bench_slots_);
  _this->_impl_.shop_slots_.MergeFrom(from._impl_.shop_slots_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gold_ = from._impl_.gold_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.total_gold_ = from._impl_.total_gold_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.not_restorable_ = from._impl_.not_restorable_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgUnderDraftData::CopyFrom(const CMsgUnderDraftData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgUnderDraftData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgUnderDraftData::IsInitialized() const {
  return true;
}

void CMsgUnderDraftData::InternalSwap(CMsgUnderDraftData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.bench_slots_.InternalSwap(&other->_impl_.bench_slots_);
  _impl_.shop_slots_.InternalSwap(&other->_impl_.shop_slots_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgUnderDraftData, _impl_.not_restorable_)
      + sizeof(CMsgUnderDraftData::_impl_.not_restorable_)
      - PROTOBUF_FIELD_OFFSET(CMsgUnderDraftData, _impl_.gold_)>(
          reinterpret_cast<char*>(&_impl_.gold_),
          reinterpret_cast<char*>(&other->_impl_.gold_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgUnderDraftData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[121]);
}

// ===================================================================

class CMsgPlayerTitleData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPlayerTitleData>()._impl_._has_bits_);
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgPlayerTitleData::CMsgPlayerTitleData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPlayerTitleData)
}
CMsgPlayerTitleData::CMsgPlayerTitleData(const CMsgPlayerTitleData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPlayerTitleData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.title_){from._impl_.title_}
    , decltype(_impl_.event_id_){from._impl_.event_id_}
    , decltype(_impl_.active_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.active_ = from._impl_.active_;
  // @@protoc_insertion_point(copy_constructor:CMsgPlayerTitleData)
}

inline void CMsgPlayerTitleData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.title_){arena}
    , decltype(_impl_.event_id_){arena}
    , decltype(_impl_.active_){0u}
  };
}

CMsgPlayerTitleData::~CMsgPlayerTitleData() {
  // @@protoc_insertion_point(destructor:CMsgPlayerTitleData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPlayerTitleData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.title_.~RepeatedField();
  _impl_.event_id_.~RepeatedField();
}

void CMsgPlayerTitleData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPlayerTitleData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPlayerTitleData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.title_.Clear();
  _impl_.event_id_.Clear();
  _impl_.active_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPlayerTitleData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 title = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_title(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_title(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 event_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_event_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_event_id(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 active = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_active(&has_bits);
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPlayerTitleData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPlayerTitleData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 title = 1;
  for (int i = 0, n = this->_internal_title_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_title(i), target);
  }

  // repeated uint32 event_id = 2;
  for (int i = 0, n = this->_internal_event_id_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_event_id(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 active = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_active(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPlayerTitleData)
  return target;
}

size_t CMsgPlayerTitleData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPlayerTitleData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 title = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.title_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_title_size());
    total_size += data_size;
  }

  // repeated uint32 event_id = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.event_id_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_event_id_size());
    total_size += data_size;
  }

  // optional uint32 active = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_active());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPlayerTitleData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPlayerTitleData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPlayerTitleData::GetClassData() const { return &_class_data_; }


void CMsgPlayerTitleData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPlayerTitleData*>(&to_msg);
  auto& from = static_cast<const CMsgPlayerTitleData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPlayerTitleData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.title_.MergeFrom(from._impl_.title_);
  _this->_impl_.event_id_.MergeFrom(from._impl_.event_id_);
  if (from._internal_has_active()) {
    _this->_internal_set_active(from._internal_active());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPlayerTitleData::CopyFrom(const CMsgPlayerTitleData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPlayerTitleData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPlayerTitleData::IsInitialized() const {
  return true;
}

void CMsgPlayerTitleData::InternalSwap(CMsgPlayerTitleData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.title_.InternalSwap(&other->_impl_.title_);
  _impl_.event_id_.InternalSwap(&other->_impl_.event_id_);
  swap(_impl_.active_, other->_impl_.active_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPlayerTitleData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[122]);
}

// ===================================================================

class CMsgDOTATriviaQuestion::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTATriviaQuestion>()._impl_._has_bits_);
  static void set_has_question_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_category(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_question_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_correct_answer_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgDOTATriviaQuestion::CMsgDOTATriviaQuestion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTATriviaQuestion)
}
CMsgDOTATriviaQuestion::CMsgDOTATriviaQuestion(const CMsgDOTATriviaQuestion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTATriviaQuestion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.answer_values_){from._impl_.answer_values_}
    , decltype(_impl_.question_value_){}
    , decltype(_impl_.question_id_){}
    , decltype(_impl_.category_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.correct_answer_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.question_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.question_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_question_value()) {
    _this->_impl_.question_value_.Set(from._internal_question_value(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.question_id_, &from._impl_.question_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.correct_answer_index_) -
    reinterpret_cast<char*>(&_impl_.question_id_)) + sizeof(_impl_.correct_answer_index_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTATriviaQuestion)
}

inline void CMsgDOTATriviaQuestion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.answer_values_){arena}
    , decltype(_impl_.question_value_){}
    , decltype(_impl_.question_id_){0u}
    , decltype(_impl_.category_){0}
    , decltype(_impl_.timestamp_){0u}
    , decltype(_impl_.correct_answer_index_){0u}
  };
  _impl_.question_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.question_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDOTATriviaQuestion::~CMsgDOTATriviaQuestion() {
  // @@protoc_insertion_point(destructor:CMsgDOTATriviaQuestion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTATriviaQuestion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.answer_values_.~RepeatedPtrField();
  _impl_.question_value_.Destroy();
}

void CMsgDOTATriviaQuestion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTATriviaQuestion::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTATriviaQuestion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.answer_values_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.question_value_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.question_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.correct_answer_index_) -
        reinterpret_cast<char*>(&_impl_.question_id_)) + sizeof(_impl_.correct_answer_index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTATriviaQuestion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 question_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_question_id(&has_bits);
          _impl_.question_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EDOTATriviaQuestionCategory category = 2 [default = k_EDOTATriviaQuestionCategory_AbilityIcon];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EDOTATriviaQuestionCategory_IsValid(val))) {
            _internal_set_category(static_cast<::EDOTATriviaQuestionCategory>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string question_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_question_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDOTATriviaQuestion.question_value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string answer_values = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_answer_values();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "CMsgDOTATriviaQuestion.answer_values");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 correct_answer_index = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_correct_answer_index(&has_bits);
          _impl_.correct_answer_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTATriviaQuestion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTATriviaQuestion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 question_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_question_id(), target);
  }

  // optional .EDOTATriviaQuestionCategory category = 2 [default = k_EDOTATriviaQuestionCategory_AbilityIcon];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_category(), target);
  }

  // optional uint32 timestamp = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_timestamp(), target);
  }

  // optional string question_value = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_question_value().data(), static_cast<int>(this->_internal_question_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTATriviaQuestion.question_value");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_question_value(), target);
  }

  // repeated string answer_values = 5;
  for (int i = 0, n = this->_internal_answer_values_size(); i < n; i++) {
    const auto& s = this->_internal_answer_values(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDOTATriviaQuestion.answer_values");
    target = stream->WriteString(5, s, target);
  }

  // optional uint32 correct_answer_index = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_correct_answer_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTATriviaQuestion)
  return target;
}

size_t CMsgDOTATriviaQuestion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTATriviaQuestion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string answer_values = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.answer_values_.size());
  for (int i = 0, n = _impl_.answer_values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.answer_values_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string question_value = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_question_value());
    }

    // optional uint32 question_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_question_id());
    }

    // optional .EDOTATriviaQuestionCategory category = 2 [default = k_EDOTATriviaQuestionCategory_AbilityIcon];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_category());
    }

    // optional uint32 timestamp = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

    // optional uint32 correct_answer_index = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_correct_answer_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTATriviaQuestion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTATriviaQuestion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTATriviaQuestion::GetClassData() const { return &_class_data_; }


void CMsgDOTATriviaQuestion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTATriviaQuestion*>(&to_msg);
  auto& from = static_cast<const CMsgDOTATriviaQuestion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTATriviaQuestion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.answer_values_.MergeFrom(from._impl_.answer_values_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_question_value(from._internal_question_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.question_id_ = from._impl_.question_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.category_ = from._impl_.category_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.correct_answer_index_ = from._impl_.correct_answer_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTATriviaQuestion::CopyFrom(const CMsgDOTATriviaQuestion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTATriviaQuestion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTATriviaQuestion::IsInitialized() const {
  return true;
}

void CMsgDOTATriviaQuestion::InternalSwap(CMsgDOTATriviaQuestion* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.answer_values_.InternalSwap(&other->_impl_.answer_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.question_value_, lhs_arena,
      &other->_impl_.question_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTATriviaQuestion, _impl_.correct_answer_index_)
      + sizeof(CMsgDOTATriviaQuestion::_impl_.correct_answer_index_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTATriviaQuestion, _impl_.question_id_)>(
          reinterpret_cast<char*>(&_impl_.question_id_),
          reinterpret_cast<char*>(&other->_impl_.question_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTATriviaQuestion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[123]);
}

// ===================================================================

class CMsgDOTATriviaQuestionAnswersSummary::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTATriviaQuestionAnswersSummary>()._impl_._has_bits_);
  static void set_has_summary_available(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDOTATriviaQuestionAnswersSummary::CMsgDOTATriviaQuestionAnswersSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTATriviaQuestionAnswersSummary)
}
CMsgDOTATriviaQuestionAnswersSummary::CMsgDOTATriviaQuestionAnswersSummary(const CMsgDOTATriviaQuestionAnswersSummary& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTATriviaQuestionAnswersSummary* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.picked_count_){from._impl_.picked_count_}
    , decltype(_impl_.summary_available_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.summary_available_ = from._impl_.summary_available_;
  // @@protoc_insertion_point(copy_constructor:CMsgDOTATriviaQuestionAnswersSummary)
}

inline void CMsgDOTATriviaQuestionAnswersSummary::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.picked_count_){arena}
    , decltype(_impl_.summary_available_){false}
  };
}

CMsgDOTATriviaQuestionAnswersSummary::~CMsgDOTATriviaQuestionAnswersSummary() {
  // @@protoc_insertion_point(destructor:CMsgDOTATriviaQuestionAnswersSummary)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTATriviaQuestionAnswersSummary::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.picked_count_.~RepeatedField();
}

void CMsgDOTATriviaQuestionAnswersSummary::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTATriviaQuestionAnswersSummary::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTATriviaQuestionAnswersSummary)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.picked_count_.Clear();
  _impl_.summary_available_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTATriviaQuestionAnswersSummary::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool summary_available = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_summary_available(&has_bits);
          _impl_.summary_available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 picked_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_picked_count(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_picked_count(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTATriviaQuestionAnswersSummary::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTATriviaQuestionAnswersSummary)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool summary_available = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_summary_available(), target);
  }

  // repeated uint32 picked_count = 2;
  for (int i = 0, n = this->_internal_picked_count_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_picked_count(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTATriviaQuestionAnswersSummary)
  return target;
}

size_t CMsgDOTATriviaQuestionAnswersSummary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTATriviaQuestionAnswersSummary)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 picked_count = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.picked_count_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_picked_count_size());
    total_size += data_size;
  }

  // optional bool summary_available = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTATriviaQuestionAnswersSummary::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTATriviaQuestionAnswersSummary::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTATriviaQuestionAnswersSummary::GetClassData() const { return &_class_data_; }


void CMsgDOTATriviaQuestionAnswersSummary::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTATriviaQuestionAnswersSummary*>(&to_msg);
  auto& from = static_cast<const CMsgDOTATriviaQuestionAnswersSummary&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTATriviaQuestionAnswersSummary)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.picked_count_.MergeFrom(from._impl_.picked_count_);
  if (from._internal_has_summary_available()) {
    _this->_internal_set_summary_available(from._internal_summary_available());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTATriviaQuestionAnswersSummary::CopyFrom(const CMsgDOTATriviaQuestionAnswersSummary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTATriviaQuestionAnswersSummary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTATriviaQuestionAnswersSummary::IsInitialized() const {
  return true;
}

void CMsgDOTATriviaQuestionAnswersSummary::InternalSwap(CMsgDOTATriviaQuestionAnswersSummary* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.picked_count_.InternalSwap(&other->_impl_.picked_count_);
  swap(_impl_.summary_available_, other->_impl_.summary_available_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTATriviaQuestionAnswersSummary::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[124]);
}

// ===================================================================

class CMsgGameDataSpecialValueBonus::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGameDataSpecialValueBonus>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_operation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgGameDataSpecialValueBonus::CMsgGameDataSpecialValueBonus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGameDataSpecialValueBonus)
}
CMsgGameDataSpecialValueBonus::CMsgGameDataSpecialValueBonus(const CMsgGameDataSpecialValueBonus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGameDataSpecialValueBonus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.operation_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.value_, &from._impl_.value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.operation_) -
    reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.operation_));
  // @@protoc_insertion_point(copy_constructor:CMsgGameDataSpecialValueBonus)
}

inline void CMsgGameDataSpecialValueBonus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){0}
    , decltype(_impl_.operation_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGameDataSpecialValueBonus::~CMsgGameDataSpecialValueBonus() {
  // @@protoc_insertion_point(destructor:CMsgGameDataSpecialValueBonus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGameDataSpecialValueBonus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgGameDataSpecialValueBonus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGameDataSpecialValueBonus::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGameDataSpecialValueBonus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.operation_) -
        reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.operation_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGameDataSpecialValueBonus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataSpecialValueBonus.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional float value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 operation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_operation(&has_bits);
          _impl_.operation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGameDataSpecialValueBonus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGameDataSpecialValueBonus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataSpecialValueBonus.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional float value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_value(), target);
  }

  // optional uint32 operation = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_operation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGameDataSpecialValueBonus)
  return target;
}

size_t CMsgGameDataSpecialValueBonus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGameDataSpecialValueBonus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional float value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 operation = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_operation());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGameDataSpecialValueBonus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGameDataSpecialValueBonus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGameDataSpecialValueBonus::GetClassData() const { return &_class_data_; }


void CMsgGameDataSpecialValueBonus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGameDataSpecialValueBonus*>(&to_msg);
  auto& from = static_cast<const CMsgGameDataSpecialValueBonus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGameDataSpecialValueBonus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.operation_ = from._impl_.operation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGameDataSpecialValueBonus::CopyFrom(const CMsgGameDataSpecialValueBonus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGameDataSpecialValueBonus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGameDataSpecialValueBonus::IsInitialized() const {
  return true;
}

void CMsgGameDataSpecialValueBonus::InternalSwap(CMsgGameDataSpecialValueBonus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGameDataSpecialValueBonus, _impl_.operation_)
      + sizeof(CMsgGameDataSpecialValueBonus::_impl_.operation_)
      - PROTOBUF_FIELD_OFFSET(CMsgGameDataSpecialValueBonus, _impl_.value_)>(
          reinterpret_cast<char*>(&_impl_.value_),
          reinterpret_cast<char*>(&other->_impl_.value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGameDataSpecialValueBonus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[125]);
}

// ===================================================================

class CMsgGameDataSpecialValues::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGameDataSpecialValues>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_percentage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heading_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGameDataSpecialValues::CMsgGameDataSpecialValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGameDataSpecialValues)
}
CMsgGameDataSpecialValues::CMsgGameDataSpecialValues(const CMsgGameDataSpecialValues& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGameDataSpecialValues* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.values_float_){from._impl_.values_float_}
    , decltype(_impl_.bonuses_){from._impl_.bonuses_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.heading_loc_){}
    , decltype(_impl_.is_percentage_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.heading_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heading_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_heading_loc()) {
    _this->_impl_.heading_loc_.Set(from._internal_heading_loc(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.is_percentage_ = from._impl_.is_percentage_;
  // @@protoc_insertion_point(copy_constructor:CMsgGameDataSpecialValues)
}

inline void CMsgGameDataSpecialValues::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.values_float_){arena}
    , decltype(_impl_.bonuses_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.heading_loc_){}
    , decltype(_impl_.is_percentage_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heading_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heading_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGameDataSpecialValues::~CMsgGameDataSpecialValues() {
  // @@protoc_insertion_point(destructor:CMsgGameDataSpecialValues)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGameDataSpecialValues::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.values_float_.~RepeatedField();
  _impl_.bonuses_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.heading_loc_.Destroy();
}

void CMsgGameDataSpecialValues::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGameDataSpecialValues::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGameDataSpecialValues)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.values_float_.Clear();
  _impl_.bonuses_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.heading_loc_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.is_percentage_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGameDataSpecialValues::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataSpecialValues.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated float values_float = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_values_float(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<21>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_values_float(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_percentage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_percentage(&has_bits);
          _impl_.is_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string heading_loc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_heading_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataSpecialValues.heading_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgGameDataSpecialValueBonus bonuses = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bonuses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGameDataSpecialValues::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGameDataSpecialValues)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataSpecialValues.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated float values_float = 2;
  for (int i = 0, n = this->_internal_values_float_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_values_float(i), target);
  }

  // optional bool is_percentage = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_percentage(), target);
  }

  // optional string heading_loc = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_heading_loc().data(), static_cast<int>(this->_internal_heading_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataSpecialValues.heading_loc");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_heading_loc(), target);
  }

  // repeated .CMsgGameDataSpecialValueBonus bonuses = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bonuses_size()); i < n; i++) {
    const auto& repfield = this->_internal_bonuses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGameDataSpecialValues)
  return target;
}

size_t CMsgGameDataSpecialValues::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGameDataSpecialValues)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float values_float = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_values_float_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_values_float_size());
    total_size += data_size;
  }

  // repeated .CMsgGameDataSpecialValueBonus bonuses = 6;
  total_size += 1UL * this->_internal_bonuses_size();
  for (const auto& msg : this->_impl_.bonuses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string heading_loc = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_heading_loc());
    }

    // optional bool is_percentage = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGameDataSpecialValues::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGameDataSpecialValues::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGameDataSpecialValues::GetClassData() const { return &_class_data_; }


void CMsgGameDataSpecialValues::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGameDataSpecialValues*>(&to_msg);
  auto& from = static_cast<const CMsgGameDataSpecialValues&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGameDataSpecialValues)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.values_float_.MergeFrom(from._impl_.values_float_);
  _this->_impl_.bonuses_.MergeFrom(from._impl_.bonuses_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_heading_loc(from._internal_heading_loc());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_percentage_ = from._impl_.is_percentage_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGameDataSpecialValues::CopyFrom(const CMsgGameDataSpecialValues& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGameDataSpecialValues)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGameDataSpecialValues::IsInitialized() const {
  return true;
}

void CMsgGameDataSpecialValues::InternalSwap(CMsgGameDataSpecialValues* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.values_float_.InternalSwap(&other->_impl_.values_float_);
  _impl_.bonuses_.InternalSwap(&other->_impl_.bonuses_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.heading_loc_, lhs_arena,
      &other->_impl_.heading_loc_, rhs_arena
  );
  swap(_impl_.is_percentage_, other->_impl_.is_percentage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGameDataSpecialValues::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[126]);
}

// ===================================================================

class CMsgGameDataAbilityOrItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGameDataAbilityOrItem>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_desc_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lore_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_shard_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_scepter_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_behavior(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_target_team(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_target_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_damage(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_immunity(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_dispellable(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_max_level(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_item(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_ability_has_scepter(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_ability_has_shard(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_ability_is_granted_by_scepter(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_ability_is_granted_by_shard(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_item_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_item_initial_charges(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_item_neutral_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_item_stock_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_item_stock_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_item_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
};

CMsgGameDataAbilityOrItem::CMsgGameDataAbilityOrItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGameDataAbilityOrItem)
}
CMsgGameDataAbilityOrItem::CMsgGameDataAbilityOrItem(const CMsgGameDataAbilityOrItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGameDataAbilityOrItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.notes_loc_){from._impl_.notes_loc_}
    , decltype(_impl_.cast_ranges_){from._impl_.cast_ranges_}
    , decltype(_impl_.cast_points_){from._impl_.cast_points_}
    , decltype(_impl_.channel_times_){from._impl_.channel_times_}
    , decltype(_impl_.cooldowns_){from._impl_.cooldowns_}
    , decltype(_impl_.durations_){from._impl_.durations_}
    , decltype(_impl_.damages_){from._impl_.damages_}
    , decltype(_impl_.mana_costs_){from._impl_.mana_costs_}
    , decltype(_impl_.gold_costs_){from._impl_.gold_costs_}
    , decltype(_impl_.special_values_){from._impl_.special_values_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.name_loc_){}
    , decltype(_impl_.desc_loc_){}
    , decltype(_impl_.lore_loc_){}
    , decltype(_impl_.shard_loc_){}
    , decltype(_impl_.scepter_loc_){}
    , decltype(_impl_.behavior_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.target_team_){}
    , decltype(_impl_.target_type_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.damage_){}
    , decltype(_impl_.immunity_){}
    , decltype(_impl_.dispellable_){}
    , decltype(_impl_.max_level_){}
    , decltype(_impl_.is_item_){}
    , decltype(_impl_.ability_has_scepter_){}
    , decltype(_impl_.ability_has_shard_){}
    , decltype(_impl_.ability_is_granted_by_scepter_){}
    , decltype(_impl_.ability_is_granted_by_shard_){}
    , decltype(_impl_.item_cost_){}
    , decltype(_impl_.item_initial_charges_){}
    , decltype(_impl_.item_neutral_tier_){}
    , decltype(_impl_.item_stock_max_){}
    , decltype(_impl_.item_stock_time_){}
    , decltype(_impl_.item_quality_){}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name_loc()) {
    _this->_impl_.name_loc_.Set(from._internal_name_loc(), 
      _this->GetArenaForAllocation());
  }
  _impl_.desc_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.desc_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_desc_loc()) {
    _this->_impl_.desc_loc_.Set(from._internal_desc_loc(), 
      _this->GetArenaForAllocation());
  }
  _impl_.lore_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lore_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_lore_loc()) {
    _this->_impl_.lore_loc_.Set(from._internal_lore_loc(), 
      _this->GetArenaForAllocation());
  }
  _impl_.shard_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shard_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_shard_loc()) {
    _this->_impl_.shard_loc_.Set(from._internal_shard_loc(), 
      _this->GetArenaForAllocation());
  }
  _impl_.scepter_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scepter_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_scepter_loc()) {
    _this->_impl_.scepter_loc_.Set(from._internal_scepter_loc(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.behavior_, &from._impl_.behavior_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.id_) -
    reinterpret_cast<char*>(&_impl_.behavior_)) + sizeof(_impl_.id_));
  // @@protoc_insertion_point(copy_constructor:CMsgGameDataAbilityOrItem)
}

inline void CMsgGameDataAbilityOrItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.notes_loc_){arena}
    , decltype(_impl_.cast_ranges_){arena}
    , decltype(_impl_.cast_points_){arena}
    , decltype(_impl_.channel_times_){arena}
    , decltype(_impl_.cooldowns_){arena}
    , decltype(_impl_.durations_){arena}
    , decltype(_impl_.damages_){arena}
    , decltype(_impl_.mana_costs_){arena}
    , decltype(_impl_.gold_costs_){arena}
    , decltype(_impl_.special_values_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.name_loc_){}
    , decltype(_impl_.desc_loc_){}
    , decltype(_impl_.lore_loc_){}
    , decltype(_impl_.shard_loc_){}
    , decltype(_impl_.scepter_loc_){}
    , decltype(_impl_.behavior_){uint64_t{0u}}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.target_team_){0u}
    , decltype(_impl_.target_type_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.damage_){0u}
    , decltype(_impl_.immunity_){0u}
    , decltype(_impl_.dispellable_){0u}
    , decltype(_impl_.max_level_){0u}
    , decltype(_impl_.is_item_){false}
    , decltype(_impl_.ability_has_scepter_){false}
    , decltype(_impl_.ability_has_shard_){false}
    , decltype(_impl_.ability_is_granted_by_scepter_){false}
    , decltype(_impl_.ability_is_granted_by_shard_){false}
    , decltype(_impl_.item_cost_){0u}
    , decltype(_impl_.item_initial_charges_){0u}
    , decltype(_impl_.item_neutral_tier_){0u}
    , decltype(_impl_.item_stock_max_){0u}
    , decltype(_impl_.item_stock_time_){0}
    , decltype(_impl_.item_quality_){0u}
    , decltype(_impl_.id_){-1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.desc_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.desc_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.lore_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lore_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.shard_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shard_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.scepter_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scepter_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGameDataAbilityOrItem::~CMsgGameDataAbilityOrItem() {
  // @@protoc_insertion_point(destructor:CMsgGameDataAbilityOrItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGameDataAbilityOrItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.notes_loc_.~RepeatedPtrField();
  _impl_.cast_ranges_.~RepeatedField();
  _impl_.cast_points_.~RepeatedField();
  _impl_.channel_times_.~RepeatedField();
  _impl_.cooldowns_.~RepeatedField();
  _impl_.durations_.~RepeatedField();
  _impl_.damages_.~RepeatedField();
  _impl_.mana_costs_.~RepeatedField();
  _impl_.gold_costs_.~RepeatedField();
  _impl_.special_values_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.name_loc_.Destroy();
  _impl_.desc_loc_.Destroy();
  _impl_.lore_loc_.Destroy();
  _impl_.shard_loc_.Destroy();
  _impl_.scepter_loc_.Destroy();
}

void CMsgGameDataAbilityOrItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGameDataAbilityOrItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGameDataAbilityOrItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.notes_loc_.Clear();
  _impl_.cast_ranges_.Clear();
  _impl_.cast_points_.Clear();
  _impl_.channel_times_.Clear();
  _impl_.cooldowns_.Clear();
  _impl_.durations_.Clear();
  _impl_.damages_.Clear();
  _impl_.mana_costs_.Clear();
  _impl_.gold_costs_.Clear();
  _impl_.special_values_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_loc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.desc_loc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.lore_loc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.shard_loc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.scepter_loc_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.behavior_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.behavior_)) + sizeof(_impl_.type_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.target_team_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_item_) -
        reinterpret_cast<char*>(&_impl_.target_team_)) + sizeof(_impl_.is_item_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.ability_has_scepter_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_stock_max_) -
        reinterpret_cast<char*>(&_impl_.ability_has_scepter_)) + sizeof(_impl_.item_stock_max_));
  }
  if (cached_has_bits & 0x07000000u) {
    ::memset(&_impl_.item_stock_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_quality_) -
        reinterpret_cast<char*>(&_impl_.item_stock_time_)) + sizeof(_impl_.item_quality_));
    _impl_.id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGameDataAbilityOrItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataAbilityOrItem.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string name_loc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataAbilityOrItem.name_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string desc_loc = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_desc_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataAbilityOrItem.desc_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string lore_loc = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_lore_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataAbilityOrItem.lore_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string notes_loc = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_notes_loc();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "CMsgGameDataAbilityOrItem.notes_loc");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string shard_loc = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_shard_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataAbilityOrItem.shard_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string scepter_loc = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_scepter_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataAbilityOrItem.scepter_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 behavior = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_behavior(&has_bits);
          _impl_.behavior_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 target_team = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_target_team(&has_bits);
          _impl_.target_team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 target_type = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_target_type(&has_bits);
          _impl_.target_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 damage = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_damage(&has_bits);
          _impl_.damage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 immunity = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_immunity(&has_bits);
          _impl_.immunity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dispellable = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_dispellable(&has_bits);
          _impl_.dispellable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_level = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_max_level(&has_bits);
          _impl_.max_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 cast_ranges = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_cast_ranges(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<240>(ptr));
        } else if (static_cast<uint8_t>(tag) == 242) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_cast_ranges(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float cast_points = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 253)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_cast_points(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<253>(ptr));
        } else if (static_cast<uint8_t>(tag) == 250) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_cast_points(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float channel_times = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 5)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_channel_times(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<261>(ptr));
        } else if (static_cast<uint8_t>(tag) == 2) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_channel_times(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float cooldowns = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_cooldowns(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<269>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_cooldowns(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float durations = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_durations(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<277>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_durations(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 damages = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_damages(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<280>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_damages(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 mana_costs = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_mana_costs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<288>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_mana_costs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 gold_costs = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_gold_costs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<296>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_gold_costs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgGameDataSpecialValues special_values = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_special_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<322>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool is_item = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_is_item(&has_bits);
          _impl_.is_item_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ability_has_scepter = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_ability_has_scepter(&has_bits);
          _impl_.ability_has_scepter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ability_has_shard = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_ability_has_shard(&has_bits);
          _impl_.ability_has_shard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ability_is_granted_by_scepter = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_ability_is_granted_by_scepter(&has_bits);
          _impl_.ability_is_granted_by_scepter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ability_is_granted_by_shard = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_ability_is_granted_by_shard(&has_bits);
          _impl_.ability_is_granted_by_shard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 item_cost = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_item_cost(&has_bits);
          _impl_.item_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 item_initial_charges = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_item_initial_charges(&has_bits);
          _impl_.item_initial_charges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 item_neutral_tier = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_item_neutral_tier(&has_bits);
          _impl_.item_neutral_tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 item_stock_max = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_item_stock_max(&has_bits);
          _impl_.item_stock_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float item_stock_time = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_item_stock_time(&has_bits);
          _impl_.item_stock_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 item_quality = 85;
      case 85:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_item_quality(&has_bits);
          _impl_.item_quality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGameDataAbilityOrItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGameDataAbilityOrItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 id = 1 [default = -1];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataAbilityOrItem.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string name_loc = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name_loc().data(), static_cast<int>(this->_internal_name_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataAbilityOrItem.name_loc");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name_loc(), target);
  }

  // optional string desc_loc = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_desc_loc().data(), static_cast<int>(this->_internal_desc_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataAbilityOrItem.desc_loc");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_desc_loc(), target);
  }

  // optional string lore_loc = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_lore_loc().data(), static_cast<int>(this->_internal_lore_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataAbilityOrItem.lore_loc");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_lore_loc(), target);
  }

  // repeated string notes_loc = 8;
  for (int i = 0, n = this->_internal_notes_loc_size(); i < n; i++) {
    const auto& s = this->_internal_notes_loc(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataAbilityOrItem.notes_loc");
    target = stream->WriteString(8, s, target);
  }

  // optional string shard_loc = 9;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_shard_loc().data(), static_cast<int>(this->_internal_shard_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataAbilityOrItem.shard_loc");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_shard_loc(), target);
  }

  // optional string scepter_loc = 10;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_scepter_loc().data(), static_cast<int>(this->_internal_scepter_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataAbilityOrItem.scepter_loc");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_scepter_loc(), target);
  }

  // optional uint32 type = 20;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_type(), target);
  }

  // optional uint64 behavior = 21;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(21, this->_internal_behavior(), target);
  }

  // optional uint32 target_team = 22;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_target_team(), target);
  }

  // optional uint32 target_type = 23;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_target_type(), target);
  }

  // optional uint32 flags = 24;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_flags(), target);
  }

  // optional uint32 damage = 25;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_damage(), target);
  }

  // optional uint32 immunity = 26;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(26, this->_internal_immunity(), target);
  }

  // optional uint32 dispellable = 27;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_dispellable(), target);
  }

  // optional uint32 max_level = 28;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_max_level(), target);
  }

  // repeated uint32 cast_ranges = 30;
  for (int i = 0, n = this->_internal_cast_ranges_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(30, this->_internal_cast_ranges(i), target);
  }

  // repeated float cast_points = 31;
  for (int i = 0, n = this->_internal_cast_points_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(31, this->_internal_cast_points(i), target);
  }

  // repeated float channel_times = 32;
  for (int i = 0, n = this->_internal_channel_times_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(32, this->_internal_channel_times(i), target);
  }

  // repeated float cooldowns = 33;
  for (int i = 0, n = this->_internal_cooldowns_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(33, this->_internal_cooldowns(i), target);
  }

  // repeated float durations = 34;
  for (int i = 0, n = this->_internal_durations_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(34, this->_internal_durations(i), target);
  }

  // repeated uint32 damages = 35;
  for (int i = 0, n = this->_internal_damages_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_damages(i), target);
  }

  // repeated uint32 mana_costs = 36;
  for (int i = 0, n = this->_internal_mana_costs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(36, this->_internal_mana_costs(i), target);
  }

  // repeated uint32 gold_costs = 37;
  for (int i = 0, n = this->_internal_gold_costs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(37, this->_internal_gold_costs(i), target);
  }

  // repeated .CMsgGameDataSpecialValues special_values = 40;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_special_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_special_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(40, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool is_item = 50;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(50, this->_internal_is_item(), target);
  }

  // optional bool ability_has_scepter = 60;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(60, this->_internal_ability_has_scepter(), target);
  }

  // optional bool ability_has_shard = 61;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(61, this->_internal_ability_has_shard(), target);
  }

  // optional bool ability_is_granted_by_scepter = 62;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(62, this->_internal_ability_is_granted_by_scepter(), target);
  }

  // optional bool ability_is_granted_by_shard = 63;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(63, this->_internal_ability_is_granted_by_shard(), target);
  }

  // optional uint32 item_cost = 70;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(70, this->_internal_item_cost(), target);
  }

  // optional uint32 item_initial_charges = 71;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(71, this->_internal_item_initial_charges(), target);
  }

  // optional uint32 item_neutral_tier = 72;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(72, this->_internal_item_neutral_tier(), target);
  }

  // optional uint32 item_stock_max = 73;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(73, this->_internal_item_stock_max(), target);
  }

  // optional float item_stock_time = 74;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(74, this->_internal_item_stock_time(), target);
  }

  // optional uint32 item_quality = 85;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(85, this->_internal_item_quality(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGameDataAbilityOrItem)
  return target;
}

size_t CMsgGameDataAbilityOrItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGameDataAbilityOrItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string notes_loc = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.notes_loc_.size());
  for (int i = 0, n = _impl_.notes_loc_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.notes_loc_.Get(i));
  }

  // repeated uint32 cast_ranges = 30;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.cast_ranges_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_cast_ranges_size());
    total_size += data_size;
  }

  // repeated float cast_points = 31;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_cast_points_size());
    size_t data_size = 4UL * count;
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_cast_points_size());
    total_size += data_size;
  }

  // repeated float channel_times = 32;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_channel_times_size());
    size_t data_size = 4UL * count;
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_channel_times_size());
    total_size += data_size;
  }

  // repeated float cooldowns = 33;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_cooldowns_size());
    size_t data_size = 4UL * count;
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_cooldowns_size());
    total_size += data_size;
  }

  // repeated float durations = 34;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_durations_size());
    size_t data_size = 4UL * count;
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_durations_size());
    total_size += data_size;
  }

  // repeated uint32 damages = 35;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.damages_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_damages_size());
    total_size += data_size;
  }

  // repeated uint32 mana_costs = 36;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.mana_costs_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_mana_costs_size());
    total_size += data_size;
  }

  // repeated uint32 gold_costs = 37;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.gold_costs_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_gold_costs_size());
    total_size += data_size;
  }

  // repeated .CMsgGameDataSpecialValues special_values = 40;
  total_size += 2UL * this->_internal_special_values_size();
  for (const auto& msg : this->_impl_.special_values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string name_loc = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name_loc());
    }

    // optional string desc_loc = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_desc_loc());
    }

    // optional string lore_loc = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_lore_loc());
    }

    // optional string shard_loc = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_shard_loc());
    }

    // optional string scepter_loc = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_scepter_loc());
    }

    // optional uint64 behavior = 21;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_behavior());
    }

    // optional uint32 type = 20;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_type());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 target_team = 22;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_target_team());
    }

    // optional uint32 target_type = 23;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_target_type());
    }

    // optional uint32 flags = 24;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_flags());
    }

    // optional uint32 damage = 25;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_damage());
    }

    // optional uint32 immunity = 26;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_immunity());
    }

    // optional uint32 dispellable = 27;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_dispellable());
    }

    // optional uint32 max_level = 28;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_max_level());
    }

    // optional bool is_item = 50;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool ability_has_scepter = 60;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool ability_has_shard = 61;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool ability_is_granted_by_scepter = 62;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool ability_is_granted_by_shard = 63;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional uint32 item_cost = 70;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_item_cost());
    }

    // optional uint32 item_initial_charges = 71;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_item_initial_charges());
    }

    // optional uint32 item_neutral_tier = 72;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_item_neutral_tier());
    }

    // optional uint32 item_stock_max = 73;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_item_stock_max());
    }

  }
  if (cached_has_bits & 0x07000000u) {
    // optional float item_stock_time = 74;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 4;
    }

    // optional uint32 item_quality = 85;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_item_quality());
    }

    // optional int32 id = 1 [default = -1];
    if (cached_has_bits & 0x04000000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGameDataAbilityOrItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGameDataAbilityOrItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGameDataAbilityOrItem::GetClassData() const { return &_class_data_; }


void CMsgGameDataAbilityOrItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGameDataAbilityOrItem*>(&to_msg);
  auto& from = static_cast<const CMsgGameDataAbilityOrItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGameDataAbilityOrItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.notes_loc_.MergeFrom(from._impl_.notes_loc_);
  _this->_impl_.cast_ranges_.MergeFrom(from._impl_.cast_ranges_);
  _this->_impl_.cast_points_.MergeFrom(from._impl_.cast_points_);
  _this->_impl_.channel_times_.MergeFrom(from._impl_.channel_times_);
  _this->_impl_.cooldowns_.MergeFrom(from._impl_.cooldowns_);
  _this->_impl_.durations_.MergeFrom(from._impl_.durations_);
  _this->_impl_.damages_.MergeFrom(from._impl_.damages_);
  _this->_impl_.mana_costs_.MergeFrom(from._impl_.mana_costs_);
  _this->_impl_.gold_costs_.MergeFrom(from._impl_.gold_costs_);
  _this->_impl_.special_values_.MergeFrom(from._impl_.special_values_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name_loc(from._internal_name_loc());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_desc_loc(from._internal_desc_loc());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_lore_loc(from._internal_lore_loc());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_shard_loc(from._internal_shard_loc());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_scepter_loc(from._internal_scepter_loc());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.behavior_ = from._impl_.behavior_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.target_team_ = from._impl_.target_team_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.target_type_ = from._impl_.target_type_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.damage_ = from._impl_.damage_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.immunity_ = from._impl_.immunity_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.dispellable_ = from._impl_.dispellable_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.max_level_ = from._impl_.max_level_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.is_item_ = from._impl_.is_item_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.ability_has_scepter_ = from._impl_.ability_has_scepter_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.ability_has_shard_ = from._impl_.ability_has_shard_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.ability_is_granted_by_scepter_ = from._impl_.ability_is_granted_by_scepter_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.ability_is_granted_by_shard_ = from._impl_.ability_is_granted_by_shard_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.item_cost_ = from._impl_.item_cost_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.item_initial_charges_ = from._impl_.item_initial_charges_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.item_neutral_tier_ = from._impl_.item_neutral_tier_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.item_stock_max_ = from._impl_.item_stock_max_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x07000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.item_stock_time_ = from._impl_.item_stock_time_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.item_quality_ = from._impl_.item_quality_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGameDataAbilityOrItem::CopyFrom(const CMsgGameDataAbilityOrItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGameDataAbilityOrItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGameDataAbilityOrItem::IsInitialized() const {
  return true;
}

void CMsgGameDataAbilityOrItem::InternalSwap(CMsgGameDataAbilityOrItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.notes_loc_.InternalSwap(&other->_impl_.notes_loc_);
  _impl_.cast_ranges_.InternalSwap(&other->_impl_.cast_ranges_);
  _impl_.cast_points_.InternalSwap(&other->_impl_.cast_points_);
  _impl_.channel_times_.InternalSwap(&other->_impl_.channel_times_);
  _impl_.cooldowns_.InternalSwap(&other->_impl_.cooldowns_);
  _impl_.durations_.InternalSwap(&other->_impl_.durations_);
  _impl_.damages_.InternalSwap(&other->_impl_.damages_);
  _impl_.mana_costs_.InternalSwap(&other->_impl_.mana_costs_);
  _impl_.gold_costs_.InternalSwap(&other->_impl_.gold_costs_);
  _impl_.special_values_.InternalSwap(&other->_impl_.special_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_loc_, lhs_arena,
      &other->_impl_.name_loc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.desc_loc_, lhs_arena,
      &other->_impl_.desc_loc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.lore_loc_, lhs_arena,
      &other->_impl_.lore_loc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.shard_loc_, lhs_arena,
      &other->_impl_.shard_loc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.scepter_loc_, lhs_arena,
      &other->_impl_.scepter_loc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGameDataAbilityOrItem, _impl_.item_quality_)
      + sizeof(CMsgGameDataAbilityOrItem::_impl_.item_quality_)
      - PROTOBUF_FIELD_OFFSET(CMsgGameDataAbilityOrItem, _impl_.behavior_)>(
          reinterpret_cast<char*>(&_impl_.behavior_),
          reinterpret_cast<char*>(&other->_impl_.behavior_));
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGameDataAbilityOrItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[127]);
}

// ===================================================================

class CMsgGameDataHero::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGameDataHero>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_name_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bio_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hype_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_npe_desc_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_str_base(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_str_gain(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_agi_base(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_agi_gain(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_int_base(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_int_gain(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_primary_attr(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_complexity(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_attack_capability(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_damage_min(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_damage_max(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_attack_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_attack_range(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_projectile_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_armor(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_magic_resistance(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_movement_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_turn_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_sight_range_day(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_sight_range_night(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_max_health(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_health_regen(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_max_mana(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_mana_regen(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
};

CMsgGameDataHero::CMsgGameDataHero(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGameDataHero)
}
CMsgGameDataHero::CMsgGameDataHero(const CMsgGameDataHero& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGameDataHero* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.role_levels_){from._impl_.role_levels_}
    , decltype(_impl_.abilities_){from._impl_.abilities_}
    , decltype(_impl_.talents_){from._impl_.talents_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.name_loc_){}
    , decltype(_impl_.bio_loc_){}
    , decltype(_impl_.hype_loc_){}
    , decltype(_impl_.npe_desc_loc_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.order_id_){}
    , decltype(_impl_.str_base_){}
    , decltype(_impl_.str_gain_){}
    , decltype(_impl_.agi_base_){}
    , decltype(_impl_.agi_gain_){}
    , decltype(_impl_.int_base_){}
    , decltype(_impl_.int_gain_){}
    , decltype(_impl_.primary_attr_){}
    , decltype(_impl_.complexity_){}
    , decltype(_impl_.attack_capability_){}
    , decltype(_impl_.damage_min_){}
    , decltype(_impl_.damage_max_){}
    , decltype(_impl_.attack_rate_){}
    , decltype(_impl_.attack_range_){}
    , decltype(_impl_.projectile_speed_){}
    , decltype(_impl_.armor_){}
    , decltype(_impl_.magic_resistance_){}
    , decltype(_impl_.movement_speed_){}
    , decltype(_impl_.turn_rate_){}
    , decltype(_impl_.sight_range_day_){}
    , decltype(_impl_.sight_range_night_){}
    , decltype(_impl_.max_health_){}
    , decltype(_impl_.health_regen_){}
    , decltype(_impl_.max_mana_){}
    , decltype(_impl_.mana_regen_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name_loc()) {
    _this->_impl_.name_loc_.Set(from._internal_name_loc(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bio_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bio_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bio_loc()) {
    _this->_impl_.bio_loc_.Set(from._internal_bio_loc(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hype_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hype_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hype_loc()) {
    _this->_impl_.hype_loc_.Set(from._internal_hype_loc(), 
      _this->GetArenaForAllocation());
  }
  _impl_.npe_desc_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.npe_desc_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_npe_desc_loc()) {
    _this->_impl_.npe_desc_loc_.Set(from._internal_npe_desc_loc(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mana_regen_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.mana_regen_));
  // @@protoc_insertion_point(copy_constructor:CMsgGameDataHero)
}

inline void CMsgGameDataHero::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.role_levels_){arena}
    , decltype(_impl_.abilities_){arena}
    , decltype(_impl_.talents_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.name_loc_){}
    , decltype(_impl_.bio_loc_){}
    , decltype(_impl_.hype_loc_){}
    , decltype(_impl_.npe_desc_loc_){}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.order_id_){0u}
    , decltype(_impl_.str_base_){0u}
    , decltype(_impl_.str_gain_){0}
    , decltype(_impl_.agi_base_){0u}
    , decltype(_impl_.agi_gain_){0}
    , decltype(_impl_.int_base_){0u}
    , decltype(_impl_.int_gain_){0}
    , decltype(_impl_.primary_attr_){0u}
    , decltype(_impl_.complexity_){0u}
    , decltype(_impl_.attack_capability_){0u}
    , decltype(_impl_.damage_min_){0u}
    , decltype(_impl_.damage_max_){0u}
    , decltype(_impl_.attack_rate_){0}
    , decltype(_impl_.attack_range_){0u}
    , decltype(_impl_.projectile_speed_){0u}
    , decltype(_impl_.armor_){0}
    , decltype(_impl_.magic_resistance_){0u}
    , decltype(_impl_.movement_speed_){0u}
    , decltype(_impl_.turn_rate_){0}
    , decltype(_impl_.sight_range_day_){0u}
    , decltype(_impl_.sight_range_night_){0u}
    , decltype(_impl_.max_health_){0u}
    , decltype(_impl_.health_regen_){0}
    , decltype(_impl_.max_mana_){0u}
    , decltype(_impl_.mana_regen_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bio_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bio_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hype_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hype_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.npe_desc_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.npe_desc_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGameDataHero::~CMsgGameDataHero() {
  // @@protoc_insertion_point(destructor:CMsgGameDataHero)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGameDataHero::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.role_levels_.~RepeatedField();
  _impl_.abilities_.~RepeatedPtrField();
  _impl_.talents_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.name_loc_.Destroy();
  _impl_.bio_loc_.Destroy();
  _impl_.hype_loc_.Destroy();
  _impl_.npe_desc_loc_.Destroy();
}

void CMsgGameDataHero::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGameDataHero::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGameDataHero)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.role_levels_.Clear();
  _impl_.abilities_.Clear();
  _impl_.talents_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_loc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.bio_loc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.hype_loc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.npe_desc_loc_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.str_base_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.str_base_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.str_gain_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.attack_capability_) -
        reinterpret_cast<char*>(&_impl_.str_gain_)) + sizeof(_impl_.attack_capability_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.damage_min_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.movement_speed_) -
        reinterpret_cast<char*>(&_impl_.damage_min_)) + sizeof(_impl_.movement_speed_));
  }
  if (cached_has_bits & 0x7f000000u) {
    ::memset(&_impl_.turn_rate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mana_regen_) -
        reinterpret_cast<char*>(&_impl_.turn_rate_)) + sizeof(_impl_.mana_regen_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGameDataHero::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataHero.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 order_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_order_id(&has_bits);
          _impl_.order_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name_loc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataHero.name_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string bio_loc = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_bio_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataHero.bio_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string hype_loc = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_hype_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataHero.hype_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string npe_desc_loc = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_npe_desc_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataHero.npe_desc_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 str_base = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_str_base(&has_bits);
          _impl_.str_base_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float str_gain = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_str_gain(&has_bits);
          _impl_.str_gain_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 agi_base = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_agi_base(&has_bits);
          _impl_.agi_base_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float agi_gain = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_agi_gain(&has_bits);
          _impl_.agi_gain_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 int_base = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_int_base(&has_bits);
          _impl_.int_base_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float int_gain = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_int_gain(&has_bits);
          _impl_.int_gain_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 primary_attr = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_primary_attr(&has_bits);
          _impl_.primary_attr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 complexity = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_complexity(&has_bits);
          _impl_.complexity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 attack_capability = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_attack_capability(&has_bits);
          _impl_.attack_capability_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 role_levels = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_role_levels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<184>(ptr));
        } else if (static_cast<uint8_t>(tag) == 186) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_role_levels(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 damage_min = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_damage_min(&has_bits);
          _impl_.damage_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 damage_max = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_damage_max(&has_bits);
          _impl_.damage_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float attack_rate = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 213)) {
          _Internal::set_has_attack_rate(&has_bits);
          _impl_.attack_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 attack_range = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_attack_range(&has_bits);
          _impl_.attack_range_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 projectile_speed = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_projectile_speed(&has_bits);
          _impl_.projectile_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float armor = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 237)) {
          _Internal::set_has_armor(&has_bits);
          _impl_.armor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 magic_resistance = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_magic_resistance(&has_bits);
          _impl_.magic_resistance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 movement_speed = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_movement_speed(&has_bits);
          _impl_.movement_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float turn_rate = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 5)) {
          _Internal::set_has_turn_rate(&has_bits);
          _impl_.turn_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sight_range_day = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sight_range_day(&has_bits);
          _impl_.sight_range_day_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sight_range_night = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sight_range_night(&has_bits);
          _impl_.sight_range_night_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_health = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_health(&has_bits);
          _impl_.max_health_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float health_regen = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_health_regen(&has_bits);
          _impl_.health_regen_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_mana = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_max_mana(&has_bits);
          _impl_.max_mana_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float mana_regen = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_mana_regen(&has_bits);
          _impl_.mana_regen_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgGameDataAbilityOrItem abilities = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_abilities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<322>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgGameDataAbilityOrItem talents = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_talents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<330>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGameDataHero::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGameDataHero)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 id = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataHero.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional uint32 order_id = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_order_id(), target);
  }

  // optional string name_loc = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name_loc().data(), static_cast<int>(this->_internal_name_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataHero.name_loc");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name_loc(), target);
  }

  // optional string bio_loc = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_bio_loc().data(), static_cast<int>(this->_internal_bio_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataHero.bio_loc");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_bio_loc(), target);
  }

  // optional string hype_loc = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hype_loc().data(), static_cast<int>(this->_internal_hype_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataHero.hype_loc");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_hype_loc(), target);
  }

  // optional string npe_desc_loc = 8;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_npe_desc_loc().data(), static_cast<int>(this->_internal_npe_desc_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataHero.npe_desc_loc");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_npe_desc_loc(), target);
  }

  // optional uint32 str_base = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_str_base(), target);
  }

  // optional float str_gain = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_str_gain(), target);
  }

  // optional uint32 agi_base = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_agi_base(), target);
  }

  // optional float agi_gain = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_agi_gain(), target);
  }

  // optional uint32 int_base = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_int_base(), target);
  }

  // optional float int_gain = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_int_gain(), target);
  }

  // optional uint32 primary_attr = 20;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_primary_attr(), target);
  }

  // optional uint32 complexity = 21;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_complexity(), target);
  }

  // optional uint32 attack_capability = 22;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_attack_capability(), target);
  }

  // repeated uint32 role_levels = 23;
  for (int i = 0, n = this->_internal_role_levels_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_role_levels(i), target);
  }

  // optional uint32 damage_min = 24;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_damage_min(), target);
  }

  // optional uint32 damage_max = 25;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_damage_max(), target);
  }

  // optional float attack_rate = 26;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(26, this->_internal_attack_rate(), target);
  }

  // optional uint32 attack_range = 27;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_attack_range(), target);
  }

  // optional uint32 projectile_speed = 28;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_projectile_speed(), target);
  }

  // optional float armor = 29;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(29, this->_internal_armor(), target);
  }

  // optional uint32 magic_resistance = 30;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(30, this->_internal_magic_resistance(), target);
  }

  // optional uint32 movement_speed = 31;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(31, this->_internal_movement_speed(), target);
  }

  // optional float turn_rate = 32;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(32, this->_internal_turn_rate(), target);
  }

  // optional uint32 sight_range_day = 33;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(33, this->_internal_sight_range_day(), target);
  }

  // optional uint32 sight_range_night = 34;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(34, this->_internal_sight_range_night(), target);
  }

  // optional uint32 max_health = 35;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_max_health(), target);
  }

  // optional float health_regen = 36;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(36, this->_internal_health_regen(), target);
  }

  // optional uint32 max_mana = 37;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(37, this->_internal_max_mana(), target);
  }

  // optional float mana_regen = 38;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(38, this->_internal_mana_regen(), target);
  }

  // repeated .CMsgGameDataAbilityOrItem abilities = 40;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_abilities_size()); i < n; i++) {
    const auto& repfield = this->_internal_abilities(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(40, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgGameDataAbilityOrItem talents = 41;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_talents_size()); i < n; i++) {
    const auto& repfield = this->_internal_talents(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(41, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGameDataHero)
  return target;
}

size_t CMsgGameDataHero::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGameDataHero)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 role_levels = 23;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.role_levels_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_role_levels_size());
    total_size += data_size;
  }

  // repeated .CMsgGameDataAbilityOrItem abilities = 40;
  total_size += 2UL * this->_internal_abilities_size();
  for (const auto& msg : this->_impl_.abilities_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgGameDataAbilityOrItem talents = 41;
  total_size += 2UL * this->_internal_talents_size();
  for (const auto& msg : this->_impl_.talents_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string name_loc = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name_loc());
    }

    // optional string bio_loc = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bio_loc());
    }

    // optional string hype_loc = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hype_loc());
    }

    // optional string npe_desc_loc = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_npe_desc_loc());
    }

    // optional uint32 id = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional uint32 order_id = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_order_id());
    }

    // optional uint32 str_base = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_str_base());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float str_gain = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional uint32 agi_base = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_agi_base());
    }

    // optional float agi_gain = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional uint32 int_base = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_int_base());
    }

    // optional float int_gain = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional uint32 primary_attr = 20;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_primary_attr());
    }

    // optional uint32 complexity = 21;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_complexity());
    }

    // optional uint32 attack_capability = 22;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_attack_capability());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 damage_min = 24;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_damage_min());
    }

    // optional uint32 damage_max = 25;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_damage_max());
    }

    // optional float attack_rate = 26;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 4;
    }

    // optional uint32 attack_range = 27;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_attack_range());
    }

    // optional uint32 projectile_speed = 28;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_projectile_speed());
    }

    // optional float armor = 29;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 4;
    }

    // optional uint32 magic_resistance = 30;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_magic_resistance());
    }

    // optional uint32 movement_speed = 31;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_movement_speed());
    }

  }
  if (cached_has_bits & 0x7f000000u) {
    // optional float turn_rate = 32;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 4;
    }

    // optional uint32 sight_range_day = 33;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_sight_range_day());
    }

    // optional uint32 sight_range_night = 34;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_sight_range_night());
    }

    // optional uint32 max_health = 35;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_max_health());
    }

    // optional float health_regen = 36;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 4;
    }

    // optional uint32 max_mana = 37;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_max_mana());
    }

    // optional float mana_regen = 38;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGameDataHero::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGameDataHero::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGameDataHero::GetClassData() const { return &_class_data_; }


void CMsgGameDataHero::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGameDataHero*>(&to_msg);
  auto& from = static_cast<const CMsgGameDataHero&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGameDataHero)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.role_levels_.MergeFrom(from._impl_.role_levels_);
  _this->_impl_.abilities_.MergeFrom(from._impl_.abilities_);
  _this->_impl_.talents_.MergeFrom(from._impl_.talents_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name_loc(from._internal_name_loc());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_bio_loc(from._internal_bio_loc());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_hype_loc(from._internal_hype_loc());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_npe_desc_loc(from._internal_npe_desc_loc());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.order_id_ = from._impl_.order_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.str_base_ = from._impl_.str_base_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.str_gain_ = from._impl_.str_gain_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.agi_base_ = from._impl_.agi_base_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.agi_gain_ = from._impl_.agi_gain_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.int_base_ = from._impl_.int_base_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.int_gain_ = from._impl_.int_gain_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.primary_attr_ = from._impl_.primary_attr_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.complexity_ = from._impl_.complexity_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.attack_capability_ = from._impl_.attack_capability_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.damage_min_ = from._impl_.damage_min_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.damage_max_ = from._impl_.damage_max_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.attack_rate_ = from._impl_.attack_rate_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.attack_range_ = from._impl_.attack_range_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.projectile_speed_ = from._impl_.projectile_speed_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.armor_ = from._impl_.armor_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.magic_resistance_ = from._impl_.magic_resistance_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.movement_speed_ = from._impl_.movement_speed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x7f000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.turn_rate_ = from._impl_.turn_rate_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.sight_range_day_ = from._impl_.sight_range_day_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.sight_range_night_ = from._impl_.sight_range_night_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.max_health_ = from._impl_.max_health_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.health_regen_ = from._impl_.health_regen_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.max_mana_ = from._impl_.max_mana_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.mana_regen_ = from._impl_.mana_regen_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGameDataHero::CopyFrom(const CMsgGameDataHero& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGameDataHero)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGameDataHero::IsInitialized() const {
  return true;
}

void CMsgGameDataHero::InternalSwap(CMsgGameDataHero* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.role_levels_.InternalSwap(&other->_impl_.role_levels_);
  _impl_.abilities_.InternalSwap(&other->_impl_.abilities_);
  _impl_.talents_.InternalSwap(&other->_impl_.talents_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_loc_, lhs_arena,
      &other->_impl_.name_loc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bio_loc_, lhs_arena,
      &other->_impl_.bio_loc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hype_loc_, lhs_arena,
      &other->_impl_.hype_loc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.npe_desc_loc_, lhs_arena,
      &other->_impl_.npe_desc_loc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGameDataHero, _impl_.mana_regen_)
      + sizeof(CMsgGameDataHero::_impl_.mana_regen_)
      - PROTOBUF_FIELD_OFFSET(CMsgGameDataHero, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGameDataHero::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[128]);
}

// ===================================================================

class CMsgGameDataAbilities::_Internal {
 public:
};

CMsgGameDataAbilities::CMsgGameDataAbilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGameDataAbilities)
}
CMsgGameDataAbilities::CMsgGameDataAbilities(const CMsgGameDataAbilities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGameDataAbilities* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.abilities_){from._impl_.abilities_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGameDataAbilities)
}

inline void CMsgGameDataAbilities::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.abilities_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGameDataAbilities::~CMsgGameDataAbilities() {
  // @@protoc_insertion_point(destructor:CMsgGameDataAbilities)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGameDataAbilities::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.abilities_.~RepeatedPtrField();
}

void CMsgGameDataAbilities::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGameDataAbilities::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGameDataAbilities)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.abilities_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGameDataAbilities::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGameDataAbilityOrItem abilities = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_abilities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGameDataAbilities::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGameDataAbilities)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGameDataAbilityOrItem abilities = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_abilities_size()); i < n; i++) {
    const auto& repfield = this->_internal_abilities(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGameDataAbilities)
  return target;
}

size_t CMsgGameDataAbilities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGameDataAbilities)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGameDataAbilityOrItem abilities = 1;
  total_size += 1UL * this->_internal_abilities_size();
  for (const auto& msg : this->_impl_.abilities_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGameDataAbilities::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGameDataAbilities::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGameDataAbilities::GetClassData() const { return &_class_data_; }


void CMsgGameDataAbilities::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGameDataAbilities*>(&to_msg);
  auto& from = static_cast<const CMsgGameDataAbilities&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGameDataAbilities)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.abilities_.MergeFrom(from._impl_.abilities_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGameDataAbilities::CopyFrom(const CMsgGameDataAbilities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGameDataAbilities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGameDataAbilities::IsInitialized() const {
  return true;
}

void CMsgGameDataAbilities::InternalSwap(CMsgGameDataAbilities* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.abilities_.InternalSwap(&other->_impl_.abilities_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGameDataAbilities::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[129]);
}

// ===================================================================

class CMsgGameDataItems::_Internal {
 public:
};

CMsgGameDataItems::CMsgGameDataItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGameDataItems)
}
CMsgGameDataItems::CMsgGameDataItems(const CMsgGameDataItems& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGameDataItems* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGameDataItems)
}

inline void CMsgGameDataItems::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGameDataItems::~CMsgGameDataItems() {
  // @@protoc_insertion_point(destructor:CMsgGameDataItems)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGameDataItems::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void CMsgGameDataItems::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGameDataItems::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGameDataItems)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGameDataItems::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGameDataAbilityOrItem items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGameDataItems::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGameDataItems)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGameDataAbilityOrItem items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGameDataItems)
  return target;
}

size_t CMsgGameDataItems::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGameDataItems)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGameDataAbilityOrItem items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGameDataItems::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGameDataItems::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGameDataItems::GetClassData() const { return &_class_data_; }


void CMsgGameDataItems::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGameDataItems*>(&to_msg);
  auto& from = static_cast<const CMsgGameDataItems&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGameDataItems)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGameDataItems::CopyFrom(const CMsgGameDataItems& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGameDataItems)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGameDataItems::IsInitialized() const {
  return true;
}

void CMsgGameDataItems::InternalSwap(CMsgGameDataItems* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGameDataItems::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[130]);
}

// ===================================================================

class CMsgGameDataHeroes::_Internal {
 public:
};

CMsgGameDataHeroes::CMsgGameDataHeroes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGameDataHeroes)
}
CMsgGameDataHeroes::CMsgGameDataHeroes(const CMsgGameDataHeroes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGameDataHeroes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.heroes_){from._impl_.heroes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGameDataHeroes)
}

inline void CMsgGameDataHeroes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.heroes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGameDataHeroes::~CMsgGameDataHeroes() {
  // @@protoc_insertion_point(destructor:CMsgGameDataHeroes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGameDataHeroes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heroes_.~RepeatedPtrField();
}

void CMsgGameDataHeroes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGameDataHeroes::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGameDataHeroes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.heroes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGameDataHeroes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGameDataHero heroes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_heroes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGameDataHeroes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGameDataHeroes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGameDataHero heroes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_heroes_size()); i < n; i++) {
    const auto& repfield = this->_internal_heroes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGameDataHeroes)
  return target;
}

size_t CMsgGameDataHeroes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGameDataHeroes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGameDataHero heroes = 1;
  total_size += 1UL * this->_internal_heroes_size();
  for (const auto& msg : this->_impl_.heroes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGameDataHeroes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGameDataHeroes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGameDataHeroes::GetClassData() const { return &_class_data_; }


void CMsgGameDataHeroes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGameDataHeroes*>(&to_msg);
  auto& from = static_cast<const CMsgGameDataHeroes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGameDataHeroes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.heroes_.MergeFrom(from._impl_.heroes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGameDataHeroes::CopyFrom(const CMsgGameDataHeroes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGameDataHeroes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGameDataHeroes::IsInitialized() const {
  return true;
}

void CMsgGameDataHeroes::InternalSwap(CMsgGameDataHeroes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.heroes_.InternalSwap(&other->_impl_.heroes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGameDataHeroes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[131]);
}

// ===================================================================

class CMsgGameDataHeroList_HeroInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGameDataHeroList_HeroInfo>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name_english_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_primary_attr(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_complexity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CMsgGameDataHeroList_HeroInfo::CMsgGameDataHeroList_HeroInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGameDataHeroList.HeroInfo)
}
CMsgGameDataHeroList_HeroInfo::CMsgGameDataHeroList_HeroInfo(const CMsgGameDataHeroList_HeroInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGameDataHeroList_HeroInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.name_loc_){}
    , decltype(_impl_.name_english_loc_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.primary_attr_){}
    , decltype(_impl_.complexity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name_loc()) {
    _this->_impl_.name_loc_.Set(from._internal_name_loc(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_english_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_english_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name_english_loc()) {
    _this->_impl_.name_english_loc_.Set(from._internal_name_english_loc(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.complexity_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.complexity_));
  // @@protoc_insertion_point(copy_constructor:CMsgGameDataHeroList.HeroInfo)
}

inline void CMsgGameDataHeroList_HeroInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.name_loc_){}
    , decltype(_impl_.name_english_loc_){}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.primary_attr_){0u}
    , decltype(_impl_.complexity_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_english_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_english_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGameDataHeroList_HeroInfo::~CMsgGameDataHeroList_HeroInfo() {
  // @@protoc_insertion_point(destructor:CMsgGameDataHeroList.HeroInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGameDataHeroList_HeroInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.name_loc_.Destroy();
  _impl_.name_english_loc_.Destroy();
}

void CMsgGameDataHeroList_HeroInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGameDataHeroList_HeroInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGameDataHeroList.HeroInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_loc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.name_english_loc_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.complexity_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.complexity_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGameDataHeroList_HeroInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataHeroList.HeroInfo.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string name_loc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataHeroList.HeroInfo.name_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string name_english_loc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name_english_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataHeroList.HeroInfo.name_english_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 primary_attr = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_primary_attr(&has_bits);
          _impl_.primary_attr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 complexity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_complexity(&has_bits);
          _impl_.complexity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGameDataHeroList_HeroInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGameDataHeroList.HeroInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataHeroList.HeroInfo.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string name_loc = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name_loc().data(), static_cast<int>(this->_internal_name_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataHeroList.HeroInfo.name_loc");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name_loc(), target);
  }

  // optional string name_english_loc = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name_english_loc().data(), static_cast<int>(this->_internal_name_english_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataHeroList.HeroInfo.name_english_loc");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name_english_loc(), target);
  }

  // optional uint32 primary_attr = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_primary_attr(), target);
  }

  // optional uint32 complexity = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_complexity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGameDataHeroList.HeroInfo)
  return target;
}

size_t CMsgGameDataHeroList_HeroInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGameDataHeroList.HeroInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string name_loc = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name_loc());
    }

    // optional string name_english_loc = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name_english_loc());
    }

    // optional uint32 id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional uint32 primary_attr = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_primary_attr());
    }

    // optional uint32 complexity = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_complexity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGameDataHeroList_HeroInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGameDataHeroList_HeroInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGameDataHeroList_HeroInfo::GetClassData() const { return &_class_data_; }


void CMsgGameDataHeroList_HeroInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGameDataHeroList_HeroInfo*>(&to_msg);
  auto& from = static_cast<const CMsgGameDataHeroList_HeroInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGameDataHeroList.HeroInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name_loc(from._internal_name_loc());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_name_english_loc(from._internal_name_english_loc());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.primary_attr_ = from._impl_.primary_attr_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.complexity_ = from._impl_.complexity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGameDataHeroList_HeroInfo::CopyFrom(const CMsgGameDataHeroList_HeroInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGameDataHeroList.HeroInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGameDataHeroList_HeroInfo::IsInitialized() const {
  return true;
}

void CMsgGameDataHeroList_HeroInfo::InternalSwap(CMsgGameDataHeroList_HeroInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_loc_, lhs_arena,
      &other->_impl_.name_loc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_english_loc_, lhs_arena,
      &other->_impl_.name_english_loc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGameDataHeroList_HeroInfo, _impl_.complexity_)
      + sizeof(CMsgGameDataHeroList_HeroInfo::_impl_.complexity_)
      - PROTOBUF_FIELD_OFFSET(CMsgGameDataHeroList_HeroInfo, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGameDataHeroList_HeroInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[132]);
}

// ===================================================================

class CMsgGameDataHeroList::_Internal {
 public:
};

CMsgGameDataHeroList::CMsgGameDataHeroList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGameDataHeroList)
}
CMsgGameDataHeroList::CMsgGameDataHeroList(const CMsgGameDataHeroList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGameDataHeroList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.heroes_){from._impl_.heroes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGameDataHeroList)
}

inline void CMsgGameDataHeroList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.heroes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGameDataHeroList::~CMsgGameDataHeroList() {
  // @@protoc_insertion_point(destructor:CMsgGameDataHeroList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGameDataHeroList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heroes_.~RepeatedPtrField();
}

void CMsgGameDataHeroList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGameDataHeroList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGameDataHeroList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.heroes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGameDataHeroList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGameDataHeroList.HeroInfo heroes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_heroes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGameDataHeroList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGameDataHeroList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGameDataHeroList.HeroInfo heroes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_heroes_size()); i < n; i++) {
    const auto& repfield = this->_internal_heroes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGameDataHeroList)
  return target;
}

size_t CMsgGameDataHeroList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGameDataHeroList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGameDataHeroList.HeroInfo heroes = 1;
  total_size += 1UL * this->_internal_heroes_size();
  for (const auto& msg : this->_impl_.heroes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGameDataHeroList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGameDataHeroList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGameDataHeroList::GetClassData() const { return &_class_data_; }


void CMsgGameDataHeroList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGameDataHeroList*>(&to_msg);
  auto& from = static_cast<const CMsgGameDataHeroList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGameDataHeroList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.heroes_.MergeFrom(from._impl_.heroes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGameDataHeroList::CopyFrom(const CMsgGameDataHeroList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGameDataHeroList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGameDataHeroList::IsInitialized() const {
  return true;
}

void CMsgGameDataHeroList::InternalSwap(CMsgGameDataHeroList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.heroes_.InternalSwap(&other->_impl_.heroes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGameDataHeroList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[133]);
}

// ===================================================================

class CMsgGameDataItemAbilityList_ItemAbilityInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGameDataItemAbilityList_ItemAbilityInfo>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name_english_loc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_neutral_item_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgGameDataItemAbilityList_ItemAbilityInfo::CMsgGameDataItemAbilityList_ItemAbilityInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGameDataItemAbilityList.ItemAbilityInfo)
}
CMsgGameDataItemAbilityList_ItemAbilityInfo::CMsgGameDataItemAbilityList_ItemAbilityInfo(const CMsgGameDataItemAbilityList_ItemAbilityInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGameDataItemAbilityList_ItemAbilityInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.name_loc_){}
    , decltype(_impl_.name_english_loc_){}
    , decltype(_impl_.neutral_item_tier_){}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name_loc()) {
    _this->_impl_.name_loc_.Set(from._internal_name_loc(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_english_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_english_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name_english_loc()) {
    _this->_impl_.name_english_loc_.Set(from._internal_name_english_loc(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.neutral_item_tier_, &from._impl_.neutral_item_tier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.id_) -
    reinterpret_cast<char*>(&_impl_.neutral_item_tier_)) + sizeof(_impl_.id_));
  // @@protoc_insertion_point(copy_constructor:CMsgGameDataItemAbilityList.ItemAbilityInfo)
}

inline void CMsgGameDataItemAbilityList_ItemAbilityInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.name_loc_){}
    , decltype(_impl_.name_english_loc_){}
    , decltype(_impl_.neutral_item_tier_){0}
    , decltype(_impl_.id_){-1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_english_loc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_english_loc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGameDataItemAbilityList_ItemAbilityInfo::~CMsgGameDataItemAbilityList_ItemAbilityInfo() {
  // @@protoc_insertion_point(destructor:CMsgGameDataItemAbilityList.ItemAbilityInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGameDataItemAbilityList_ItemAbilityInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.name_loc_.Destroy();
  _impl_.name_english_loc_.Destroy();
}

void CMsgGameDataItemAbilityList_ItemAbilityInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGameDataItemAbilityList_ItemAbilityInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGameDataItemAbilityList.ItemAbilityInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_loc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.name_english_loc_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    _impl_.neutral_item_tier_ = 0;
    _impl_.id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGameDataItemAbilityList_ItemAbilityInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataItemAbilityList.ItemAbilityInfo.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string name_loc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataItemAbilityList.ItemAbilityInfo.name_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string name_english_loc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name_english_loc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgGameDataItemAbilityList.ItemAbilityInfo.name_english_loc");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 neutral_item_tier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_neutral_item_tier(&has_bits);
          _impl_.neutral_item_tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGameDataItemAbilityList_ItemAbilityInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGameDataItemAbilityList.ItemAbilityInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 id = 1 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataItemAbilityList.ItemAbilityInfo.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string name_loc = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name_loc().data(), static_cast<int>(this->_internal_name_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataItemAbilityList.ItemAbilityInfo.name_loc");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name_loc(), target);
  }

  // optional string name_english_loc = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name_english_loc().data(), static_cast<int>(this->_internal_name_english_loc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGameDataItemAbilityList.ItemAbilityInfo.name_english_loc");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name_english_loc(), target);
  }

  // optional int32 neutral_item_tier = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_neutral_item_tier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGameDataItemAbilityList.ItemAbilityInfo)
  return target;
}

size_t CMsgGameDataItemAbilityList_ItemAbilityInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGameDataItemAbilityList.ItemAbilityInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string name_loc = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name_loc());
    }

    // optional string name_english_loc = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name_english_loc());
    }

    // optional int32 neutral_item_tier = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_neutral_item_tier());
    }

    // optional int32 id = 1 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGameDataItemAbilityList_ItemAbilityInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGameDataItemAbilityList_ItemAbilityInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGameDataItemAbilityList_ItemAbilityInfo::GetClassData() const { return &_class_data_; }


void CMsgGameDataItemAbilityList_ItemAbilityInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGameDataItemAbilityList_ItemAbilityInfo*>(&to_msg);
  auto& from = static_cast<const CMsgGameDataItemAbilityList_ItemAbilityInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGameDataItemAbilityList.ItemAbilityInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name_loc(from._internal_name_loc());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_name_english_loc(from._internal_name_english_loc());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.neutral_item_tier_ = from._impl_.neutral_item_tier_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGameDataItemAbilityList_ItemAbilityInfo::CopyFrom(const CMsgGameDataItemAbilityList_ItemAbilityInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGameDataItemAbilityList.ItemAbilityInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGameDataItemAbilityList_ItemAbilityInfo::IsInitialized() const {
  return true;
}

void CMsgGameDataItemAbilityList_ItemAbilityInfo::InternalSwap(CMsgGameDataItemAbilityList_ItemAbilityInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_loc_, lhs_arena,
      &other->_impl_.name_loc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_english_loc_, lhs_arena,
      &other->_impl_.name_english_loc_, rhs_arena
  );
  swap(_impl_.neutral_item_tier_, other->_impl_.neutral_item_tier_);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGameDataItemAbilityList_ItemAbilityInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[134]);
}

// ===================================================================

class CMsgGameDataItemAbilityList::_Internal {
 public:
};

CMsgGameDataItemAbilityList::CMsgGameDataItemAbilityList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGameDataItemAbilityList)
}
CMsgGameDataItemAbilityList::CMsgGameDataItemAbilityList(const CMsgGameDataItemAbilityList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGameDataItemAbilityList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.itemabilities_){from._impl_.itemabilities_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgGameDataItemAbilityList)
}

inline void CMsgGameDataItemAbilityList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.itemabilities_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgGameDataItemAbilityList::~CMsgGameDataItemAbilityList() {
  // @@protoc_insertion_point(destructor:CMsgGameDataItemAbilityList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGameDataItemAbilityList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.itemabilities_.~RepeatedPtrField();
}

void CMsgGameDataItemAbilityList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGameDataItemAbilityList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGameDataItemAbilityList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.itemabilities_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGameDataItemAbilityList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgGameDataItemAbilityList.ItemAbilityInfo itemabilities = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_itemabilities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGameDataItemAbilityList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGameDataItemAbilityList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgGameDataItemAbilityList.ItemAbilityInfo itemabilities = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_itemabilities_size()); i < n; i++) {
    const auto& repfield = this->_internal_itemabilities(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGameDataItemAbilityList)
  return target;
}

size_t CMsgGameDataItemAbilityList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGameDataItemAbilityList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgGameDataItemAbilityList.ItemAbilityInfo itemabilities = 1;
  total_size += 1UL * this->_internal_itemabilities_size();
  for (const auto& msg : this->_impl_.itemabilities_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGameDataItemAbilityList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGameDataItemAbilityList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGameDataItemAbilityList::GetClassData() const { return &_class_data_; }


void CMsgGameDataItemAbilityList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGameDataItemAbilityList*>(&to_msg);
  auto& from = static_cast<const CMsgGameDataItemAbilityList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGameDataItemAbilityList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.itemabilities_.MergeFrom(from._impl_.itemabilities_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGameDataItemAbilityList::CopyFrom(const CMsgGameDataItemAbilityList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGameDataItemAbilityList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGameDataItemAbilityList::IsInitialized() const {
  return true;
}

void CMsgGameDataItemAbilityList::InternalSwap(CMsgGameDataItemAbilityList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.itemabilities_.InternalSwap(&other->_impl_.itemabilities_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGameDataItemAbilityList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[135]);
}

// ===================================================================

class CMsgLobbyAbilityDraftData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgLobbyAbilityDraftData>()._impl_._has_bits_);
  static void set_has_shuffle_draft_order(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgLobbyAbilityDraftData::CMsgLobbyAbilityDraftData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgLobbyAbilityDraftData)
}
CMsgLobbyAbilityDraftData::CMsgLobbyAbilityDraftData(const CMsgLobbyAbilityDraftData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgLobbyAbilityDraftData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shuffle_draft_order_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.shuffle_draft_order_ = from._impl_.shuffle_draft_order_;
  // @@protoc_insertion_point(copy_constructor:CMsgLobbyAbilityDraftData)
}

inline void CMsgLobbyAbilityDraftData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shuffle_draft_order_){false}
  };
}

CMsgLobbyAbilityDraftData::~CMsgLobbyAbilityDraftData() {
  // @@protoc_insertion_point(destructor:CMsgLobbyAbilityDraftData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgLobbyAbilityDraftData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgLobbyAbilityDraftData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgLobbyAbilityDraftData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgLobbyAbilityDraftData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.shuffle_draft_order_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgLobbyAbilityDraftData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool shuffle_draft_order = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_shuffle_draft_order(&has_bits);
          _impl_.shuffle_draft_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgLobbyAbilityDraftData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgLobbyAbilityDraftData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool shuffle_draft_order = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_shuffle_draft_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgLobbyAbilityDraftData)
  return target;
}

size_t CMsgLobbyAbilityDraftData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgLobbyAbilityDraftData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool shuffle_draft_order = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgLobbyAbilityDraftData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgLobbyAbilityDraftData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgLobbyAbilityDraftData::GetClassData() const { return &_class_data_; }


void CMsgLobbyAbilityDraftData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgLobbyAbilityDraftData*>(&to_msg);
  auto& from = static_cast<const CMsgLobbyAbilityDraftData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgLobbyAbilityDraftData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_shuffle_draft_order()) {
    _this->_internal_set_shuffle_draft_order(from._internal_shuffle_draft_order());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgLobbyAbilityDraftData::CopyFrom(const CMsgLobbyAbilityDraftData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgLobbyAbilityDraftData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgLobbyAbilityDraftData::IsInitialized() const {
  return true;
}

void CMsgLobbyAbilityDraftData::InternalSwap(CMsgLobbyAbilityDraftData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.shuffle_draft_order_, other->_impl_.shuffle_draft_order_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgLobbyAbilityDraftData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[136]);
}

// ===================================================================

class CSOEconItemDropRateBonus::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOEconItemDropRateBonus>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_expiration_date(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bonus(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bonus_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_def_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_seconds_left(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_booster_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CSOEconItemDropRateBonus::CSOEconItemDropRateBonus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOEconItemDropRateBonus)
}
CSOEconItemDropRateBonus::CSOEconItemDropRateBonus(const CSOEconItemDropRateBonus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOEconItemDropRateBonus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.expiration_date_){}
    , decltype(_impl_.bonus_){}
    , decltype(_impl_.bonus_count_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.def_index_){}
    , decltype(_impl_.seconds_left_){}
    , decltype(_impl_.booster_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.booster_type_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.booster_type_));
  // @@protoc_insertion_point(copy_constructor:CSOEconItemDropRateBonus)
}

inline void CSOEconItemDropRateBonus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.expiration_date_){0u}
    , decltype(_impl_.bonus_){0}
    , decltype(_impl_.bonus_count_){0u}
    , decltype(_impl_.item_id_){uint64_t{0u}}
    , decltype(_impl_.def_index_){0u}
    , decltype(_impl_.seconds_left_){0u}
    , decltype(_impl_.booster_type_){0u}
  };
}

CSOEconItemDropRateBonus::~CSOEconItemDropRateBonus() {
  // @@protoc_insertion_point(destructor:CSOEconItemDropRateBonus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOEconItemDropRateBonus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSOEconItemDropRateBonus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOEconItemDropRateBonus::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOEconItemDropRateBonus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.booster_type_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.booster_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOEconItemDropRateBonus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1 [(.key_field) = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 expiration_date = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_expiration_date(&has_bits);
          _impl_.expiration_date_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional float bonus = 3 [(.key_field) = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_bonus(&has_bits);
          _impl_.bonus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bonus_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_bonus_count(&has_bits);
          _impl_.bonus_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 def_index = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_def_index(&has_bits);
          _impl_.def_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seconds_left = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_seconds_left(&has_bits);
          _impl_.seconds_left_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 booster_type = 8 [(.key_field) = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_booster_type(&has_bits);
          _impl_.booster_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOEconItemDropRateBonus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOEconItemDropRateBonus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1 [(.key_field) = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional fixed32 expiration_date = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_expiration_date(), target);
  }

  // optional float bonus = 3 [(.key_field) = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_bonus(), target);
  }

  // optional uint32 bonus_count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_bonus_count(), target);
  }

  // optional uint64 item_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_item_id(), target);
  }

  // optional uint32 def_index = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_def_index(), target);
  }

  // optional uint32 seconds_left = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_seconds_left(), target);
  }

  // optional uint32 booster_type = 8 [(.key_field) = true];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_booster_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOEconItemDropRateBonus)
  return target;
}

size_t CSOEconItemDropRateBonus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOEconItemDropRateBonus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 account_id = 1 [(.key_field) = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional fixed32 expiration_date = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float bonus = 3 [(.key_field) = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 bonus_count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bonus_count());
    }

    // optional uint64 item_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional uint32 def_index = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_def_index());
    }

    // optional uint32 seconds_left = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seconds_left());
    }

    // optional uint32 booster_type = 8 [(.key_field) = true];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_booster_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOEconItemDropRateBonus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOEconItemDropRateBonus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOEconItemDropRateBonus::GetClassData() const { return &_class_data_; }


void CSOEconItemDropRateBonus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOEconItemDropRateBonus*>(&to_msg);
  auto& from = static_cast<const CSOEconItemDropRateBonus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOEconItemDropRateBonus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.expiration_date_ = from._impl_.expiration_date_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bonus_ = from._impl_.bonus_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bonus_count_ = from._impl_.bonus_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.def_index_ = from._impl_.def_index_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.seconds_left_ = from._impl_.seconds_left_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.booster_type_ = from._impl_.booster_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOEconItemDropRateBonus::CopyFrom(const CSOEconItemDropRateBonus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOEconItemDropRateBonus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOEconItemDropRateBonus::IsInitialized() const {
  return true;
}

void CSOEconItemDropRateBonus::InternalSwap(CSOEconItemDropRateBonus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOEconItemDropRateBonus, _impl_.booster_type_)
      + sizeof(CSOEconItemDropRateBonus::_impl_.booster_type_)
      - PROTOBUF_FIELD_OFFSET(CSOEconItemDropRateBonus, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOEconItemDropRateBonus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[137]);
}

// ===================================================================

class CSOEconItemTournamentPassport::_Internal {
 public:
  using HasBits = decltype(std::declval<CSOEconItemTournamentPassport>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_league_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_original_purchaser_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_passports_bought(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_def_index(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_reward_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CSOEconItemTournamentPassport::CSOEconItemTournamentPassport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSOEconItemTournamentPassport)
}
CSOEconItemTournamentPassport::CSOEconItemTournamentPassport(const CSOEconItemTournamentPassport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSOEconItemTournamentPassport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
    , decltype(_impl_.league_id_){}
    , decltype(_impl_.item_id_){}
    , decltype(_impl_.original_purchaser_id_){}
    , decltype(_impl_.passports_bought_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.def_index_){}
    , decltype(_impl_.reward_flags_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.account_id_, &from._impl_.account_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reward_flags_) -
    reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.reward_flags_));
  // @@protoc_insertion_point(copy_constructor:CSOEconItemTournamentPassport)
}

inline void CSOEconItemTournamentPassport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){0u}
    , decltype(_impl_.league_id_){0u}
    , decltype(_impl_.item_id_){uint64_t{0u}}
    , decltype(_impl_.original_purchaser_id_){0u}
    , decltype(_impl_.passports_bought_){0u}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.def_index_){0u}
    , decltype(_impl_.reward_flags_){0u}
  };
}

CSOEconItemTournamentPassport::~CSOEconItemTournamentPassport() {
  // @@protoc_insertion_point(destructor:CSOEconItemTournamentPassport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSOEconItemTournamentPassport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSOEconItemTournamentPassport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSOEconItemTournamentPassport::Clear() {
// @@protoc_insertion_point(message_clear_start:CSOEconItemTournamentPassport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.account_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.reward_flags_) -
        reinterpret_cast<char*>(&_impl_.account_id_)) + sizeof(_impl_.reward_flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSOEconItemTournamentPassport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account_id(&has_bits);
          _impl_.account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_league_id(&has_bits);
          _impl_.league_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_id(&has_bits);
          _impl_.item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 original_purchaser_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_original_purchaser_id(&has_bits);
          _impl_.original_purchaser_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 passports_bought = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_passports_bought(&has_bits);
          _impl_.passports_bought_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 def_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_def_index(&has_bits);
          _impl_.def_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 reward_flags = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_reward_flags(&has_bits);
          _impl_.reward_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSOEconItemTournamentPassport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSOEconItemTournamentPassport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account_id(), target);
  }

  // optional uint32 league_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_league_id(), target);
  }

  // optional uint64 item_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_item_id(), target);
  }

  // optional uint32 original_purchaser_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_original_purchaser_id(), target);
  }

  // optional uint32 passports_bought = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_passports_bought(), target);
  }

  // optional uint32 version = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_version(), target);
  }

  // optional uint32 def_index = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_def_index(), target);
  }

  // optional uint32 reward_flags = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_reward_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSOEconItemTournamentPassport)
  return target;
}

size_t CSOEconItemTournamentPassport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSOEconItemTournamentPassport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 account_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account_id());
    }

    // optional uint32 league_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league_id());
    }

    // optional uint64 item_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional uint32 original_purchaser_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_original_purchaser_id());
    }

    // optional uint32 passports_bought = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_passports_bought());
    }

    // optional uint32 version = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional uint32 def_index = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_def_index());
    }

    // optional uint32 reward_flags = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reward_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSOEconItemTournamentPassport::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSOEconItemTournamentPassport::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSOEconItemTournamentPassport::GetClassData() const { return &_class_data_; }


void CSOEconItemTournamentPassport::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSOEconItemTournamentPassport*>(&to_msg);
  auto& from = static_cast<const CSOEconItemTournamentPassport&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSOEconItemTournamentPassport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.account_id_ = from._impl_.account_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.league_id_ = from._impl_.league_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_id_ = from._impl_.item_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.original_purchaser_id_ = from._impl_.original_purchaser_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.passports_bought_ = from._impl_.passports_bought_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.def_index_ = from._impl_.def_index_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.reward_flags_ = from._impl_.reward_flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSOEconItemTournamentPassport::CopyFrom(const CSOEconItemTournamentPassport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSOEconItemTournamentPassport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSOEconItemTournamentPassport::IsInitialized() const {
  return true;
}

void CSOEconItemTournamentPassport::InternalSwap(CSOEconItemTournamentPassport* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSOEconItemTournamentPassport, _impl_.reward_flags_)
      + sizeof(CSOEconItemTournamentPassport::_impl_.reward_flags_)
      - PROTOBUF_FIELD_OFFSET(CSOEconItemTournamentPassport, _impl_.account_id_)>(
          reinterpret_cast<char*>(&_impl_.account_id_),
          reinterpret_cast<char*>(&other->_impl_.account_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSOEconItemTournamentPassport::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[138]);
}

// ===================================================================

class CMsgStickerbookSticker::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgStickerbookSticker>()._impl_._has_bits_);
  static void set_has_item_def_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sticker_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_position_x(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_position_y(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_position_z(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_source_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_depth_bias(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

CMsgStickerbookSticker::CMsgStickerbookSticker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgStickerbookSticker)
}
CMsgStickerbookSticker::CMsgStickerbookSticker(const CMsgStickerbookSticker& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgStickerbookSticker* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_def_id_){}
    , decltype(_impl_.sticker_num_){}
    , decltype(_impl_.quality_){}
    , decltype(_impl_.position_x_){}
    , decltype(_impl_.position_y_){}
    , decltype(_impl_.rotation_){}
    , decltype(_impl_.scale_){}
    , decltype(_impl_.position_z_){}
    , decltype(_impl_.source_item_id_){}
    , decltype(_impl_.depth_bias_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.item_def_id_, &from._impl_.item_def_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.depth_bias_) -
    reinterpret_cast<char*>(&_impl_.item_def_id_)) + sizeof(_impl_.depth_bias_));
  // @@protoc_insertion_point(copy_constructor:CMsgStickerbookSticker)
}

inline void CMsgStickerbookSticker::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_def_id_){0u}
    , decltype(_impl_.sticker_num_){0u}
    , decltype(_impl_.quality_){0u}
    , decltype(_impl_.position_x_){0}
    , decltype(_impl_.position_y_){0}
    , decltype(_impl_.rotation_){0}
    , decltype(_impl_.scale_){0}
    , decltype(_impl_.position_z_){0}
    , decltype(_impl_.source_item_id_){uint64_t{0u}}
    , decltype(_impl_.depth_bias_){0u}
  };
}

CMsgStickerbookSticker::~CMsgStickerbookSticker() {
  // @@protoc_insertion_point(destructor:CMsgStickerbookSticker)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgStickerbookSticker::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgStickerbookSticker::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgStickerbookSticker::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgStickerbookSticker)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.item_def_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.position_z_) -
        reinterpret_cast<char*>(&_impl_.item_def_id_)) + sizeof(_impl_.position_z_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.source_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.depth_bias_) -
        reinterpret_cast<char*>(&_impl_.source_item_id_)) + sizeof(_impl_.depth_bias_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgStickerbookSticker::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 item_def_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_def_id(&has_bits);
          _impl_.item_def_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sticker_num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sticker_num(&has_bits);
          _impl_.sticker_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 quality = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_quality(&has_bits);
          _impl_.quality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float position_x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_position_x(&has_bits);
          _impl_.position_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float position_y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_position_y(&has_bits);
          _impl_.position_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float rotation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_rotation(&has_bits);
          _impl_.rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float scale = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_scale(&has_bits);
          _impl_.scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float position_z = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_position_z(&has_bits);
          _impl_.position_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 source_item_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_source_item_id(&has_bits);
          _impl_.source_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 depth_bias = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_depth_bias(&has_bits);
          _impl_.depth_bias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgStickerbookSticker::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgStickerbookSticker)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 item_def_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_item_def_id(), target);
  }

  // optional uint32 sticker_num = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sticker_num(), target);
  }

  // optional uint32 quality = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_quality(), target);
  }

  // optional float position_x = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_position_x(), target);
  }

  // optional float position_y = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_position_y(), target);
  }

  // optional float rotation = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_rotation(), target);
  }

  // optional float scale = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_scale(), target);
  }

  // optional float position_z = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_position_z(), target);
  }

  // optional uint64 source_item_id = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_source_item_id(), target);
  }

  // optional uint32 depth_bias = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_depth_bias(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgStickerbookSticker)
  return target;
}

size_t CMsgStickerbookSticker::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgStickerbookSticker)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 item_def_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_item_def_id());
    }

    // optional uint32 sticker_num = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sticker_num());
    }

    // optional uint32 quality = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_quality());
    }

    // optional float position_x = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float position_y = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float rotation = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float scale = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float position_z = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint64 source_item_id = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_source_item_id());
    }

    // optional uint32 depth_bias = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_depth_bias());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgStickerbookSticker::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgStickerbookSticker::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgStickerbookSticker::GetClassData() const { return &_class_data_; }


void CMsgStickerbookSticker::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgStickerbookSticker*>(&to_msg);
  auto& from = static_cast<const CMsgStickerbookSticker&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgStickerbookSticker)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.item_def_id_ = from._impl_.item_def_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sticker_num_ = from._impl_.sticker_num_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.quality_ = from._impl_.quality_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.position_x_ = from._impl_.position_x_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.position_y_ = from._impl_.position_y_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.rotation_ = from._impl_.rotation_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.position_z_ = from._impl_.position_z_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.source_item_id_ = from._impl_.source_item_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.depth_bias_ = from._impl_.depth_bias_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgStickerbookSticker::CopyFrom(const CMsgStickerbookSticker& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgStickerbookSticker)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgStickerbookSticker::IsInitialized() const {
  return true;
}

void CMsgStickerbookSticker::InternalSwap(CMsgStickerbookSticker* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgStickerbookSticker, _impl_.depth_bias_)
      + sizeof(CMsgStickerbookSticker::_impl_.depth_bias_)
      - PROTOBUF_FIELD_OFFSET(CMsgStickerbookSticker, _impl_.item_def_id_)>(
          reinterpret_cast<char*>(&_impl_.item_def_id_),
          reinterpret_cast<char*>(&other->_impl_.item_def_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgStickerbookSticker::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[139]);
}

// ===================================================================

class CMsgStickerbookPage::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgStickerbookPage>()._impl_._has_bits_);
  static void set_has_page_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_page_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgStickerbookPage::CMsgStickerbookPage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgStickerbookPage)
}
CMsgStickerbookPage::CMsgStickerbookPage(const CMsgStickerbookPage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgStickerbookPage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stickers_){from._impl_.stickers_}
    , decltype(_impl_.page_num_){}
    , decltype(_impl_.event_id_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.page_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.page_num_, &from._impl_.page_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.page_type_) -
    reinterpret_cast<char*>(&_impl_.page_num_)) + sizeof(_impl_.page_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgStickerbookPage)
}

inline void CMsgStickerbookPage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stickers_){arena}
    , decltype(_impl_.page_num_){0u}
    , decltype(_impl_.event_id_){0}
    , decltype(_impl_.team_id_){0u}
    , decltype(_impl_.page_type_){0}
  };
}

CMsgStickerbookPage::~CMsgStickerbookPage() {
  // @@protoc_insertion_point(destructor:CMsgStickerbookPage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgStickerbookPage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stickers_.~RepeatedPtrField();
}

void CMsgStickerbookPage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgStickerbookPage::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgStickerbookPage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stickers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.page_num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.page_type_) -
        reinterpret_cast<char*>(&_impl_.page_num_)) + sizeof(_impl_.page_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgStickerbookPage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 page_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_page_num(&has_bits);
          _impl_.page_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EEvent event_id = 2 [default = EVENT_ID_NONE];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EEvent_IsValid(val))) {
            _internal_set_event_id(static_cast<::EEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgStickerbookSticker stickers = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stickers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .EStickerbookPageType page_type = 5 [default = STICKER_PAGE_GENERIC];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStickerbookPageType_IsValid(val))) {
            _internal_set_page_type(static_cast<::EStickerbookPageType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgStickerbookPage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgStickerbookPage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 page_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_page_num(), target);
  }

  // optional .EEvent event_id = 2 [default = EVENT_ID_NONE];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_event_id(), target);
  }

  // optional uint32 team_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_team_id(), target);
  }

  // repeated .CMsgStickerbookSticker stickers = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stickers_size()); i < n; i++) {
    const auto& repfield = this->_internal_stickers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .EStickerbookPageType page_type = 5 [default = STICKER_PAGE_GENERIC];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_page_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgStickerbookPage)
  return target;
}

size_t CMsgStickerbookPage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgStickerbookPage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgStickerbookSticker stickers = 4;
  total_size += 1UL * this->_internal_stickers_size();
  for (const auto& msg : this->_impl_.stickers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 page_num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_page_num());
    }

    // optional .EEvent event_id = 2 [default = EVENT_ID_NONE];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event_id());
    }

    // optional uint32 team_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team_id());
    }

    // optional .EStickerbookPageType page_type = 5 [default = STICKER_PAGE_GENERIC];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_page_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgStickerbookPage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgStickerbookPage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgStickerbookPage::GetClassData() const { return &_class_data_; }


void CMsgStickerbookPage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgStickerbookPage*>(&to_msg);
  auto& from = static_cast<const CMsgStickerbookPage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgStickerbookPage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stickers_.MergeFrom(from._impl_.stickers_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.page_num_ = from._impl_.page_num_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.page_type_ = from._impl_.page_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgStickerbookPage::CopyFrom(const CMsgStickerbookPage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgStickerbookPage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgStickerbookPage::IsInitialized() const {
  return true;
}

void CMsgStickerbookPage::InternalSwap(CMsgStickerbookPage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.stickers_.InternalSwap(&other->_impl_.stickers_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgStickerbookPage, _impl_.page_type_)
      + sizeof(CMsgStickerbookPage::_impl_.page_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgStickerbookPage, _impl_.page_num_)>(
          reinterpret_cast<char*>(&_impl_.page_num_),
          reinterpret_cast<char*>(&other->_impl_.page_num_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgStickerbookPage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[140]);
}

// ===================================================================

class CMsgStickerbookTeamPageOrderSequence::_Internal {
 public:
};

CMsgStickerbookTeamPageOrderSequence::CMsgStickerbookTeamPageOrderSequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgStickerbookTeamPageOrderSequence)
}
CMsgStickerbookTeamPageOrderSequence::CMsgStickerbookTeamPageOrderSequence(const CMsgStickerbookTeamPageOrderSequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgStickerbookTeamPageOrderSequence* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.page_numbers_){from._impl_.page_numbers_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgStickerbookTeamPageOrderSequence)
}

inline void CMsgStickerbookTeamPageOrderSequence::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.page_numbers_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgStickerbookTeamPageOrderSequence::~CMsgStickerbookTeamPageOrderSequence() {
  // @@protoc_insertion_point(destructor:CMsgStickerbookTeamPageOrderSequence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgStickerbookTeamPageOrderSequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.page_numbers_.~RepeatedField();
}

void CMsgStickerbookTeamPageOrderSequence::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgStickerbookTeamPageOrderSequence::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgStickerbookTeamPageOrderSequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.page_numbers_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgStickerbookTeamPageOrderSequence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 page_numbers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_page_numbers(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_page_numbers(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgStickerbookTeamPageOrderSequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgStickerbookTeamPageOrderSequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 page_numbers = 1;
  for (int i = 0, n = this->_internal_page_numbers_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_page_numbers(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgStickerbookTeamPageOrderSequence)
  return target;
}

size_t CMsgStickerbookTeamPageOrderSequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgStickerbookTeamPageOrderSequence)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 page_numbers = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.page_numbers_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_page_numbers_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgStickerbookTeamPageOrderSequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgStickerbookTeamPageOrderSequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgStickerbookTeamPageOrderSequence::GetClassData() const { return &_class_data_; }


void CMsgStickerbookTeamPageOrderSequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgStickerbookTeamPageOrderSequence*>(&to_msg);
  auto& from = static_cast<const CMsgStickerbookTeamPageOrderSequence&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgStickerbookTeamPageOrderSequence)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.page_numbers_.MergeFrom(from._impl_.page_numbers_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgStickerbookTeamPageOrderSequence::CopyFrom(const CMsgStickerbookTeamPageOrderSequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgStickerbookTeamPageOrderSequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgStickerbookTeamPageOrderSequence::IsInitialized() const {
  return true;
}

void CMsgStickerbookTeamPageOrderSequence::InternalSwap(CMsgStickerbookTeamPageOrderSequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.page_numbers_.InternalSwap(&other->_impl_.page_numbers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgStickerbookTeamPageOrderSequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[141]);
}

// ===================================================================

class CMsgStickerbook::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgStickerbook>()._impl_._has_bits_);
  static const ::CMsgStickerbookTeamPageOrderSequence& team_page_order_sequence(const CMsgStickerbook* msg);
  static void set_has_team_page_order_sequence(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_favorite_page_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgStickerbookTeamPageOrderSequence&
CMsgStickerbook::_Internal::team_page_order_sequence(const CMsgStickerbook* msg) {
  return *msg->_impl_.team_page_order_sequence_;
}
CMsgStickerbook::CMsgStickerbook(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgStickerbook)
}
CMsgStickerbook::CMsgStickerbook(const CMsgStickerbook& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgStickerbook* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pages_){from._impl_.pages_}
    , decltype(_impl_.team_page_order_sequence_){nullptr}
    , decltype(_impl_.favorite_page_num_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_team_page_order_sequence()) {
    _this->_impl_.team_page_order_sequence_ = new ::CMsgStickerbookTeamPageOrderSequence(*from._impl_.team_page_order_sequence_);
  }
  _this->_impl_.favorite_page_num_ = from._impl_.favorite_page_num_;
  // @@protoc_insertion_point(copy_constructor:CMsgStickerbook)
}

inline void CMsgStickerbook::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pages_){arena}
    , decltype(_impl_.team_page_order_sequence_){nullptr}
    , decltype(_impl_.favorite_page_num_){0u}
  };
}

CMsgStickerbook::~CMsgStickerbook() {
  // @@protoc_insertion_point(destructor:CMsgStickerbook)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgStickerbook::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pages_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.team_page_order_sequence_;
}

void CMsgStickerbook::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgStickerbook::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgStickerbook)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pages_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.team_page_order_sequence_ != nullptr);
    _impl_.team_page_order_sequence_->Clear();
  }
  _impl_.favorite_page_num_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgStickerbook::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgStickerbookPage pages = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgStickerbookTeamPageOrderSequence team_page_order_sequence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_team_page_order_sequence(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 favorite_page_num = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_favorite_page_num(&has_bits);
          _impl_.favorite_page_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgStickerbook::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgStickerbook)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgStickerbookPage pages = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pages_size()); i < n; i++) {
    const auto& repfield = this->_internal_pages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgStickerbookTeamPageOrderSequence team_page_order_sequence = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::team_page_order_sequence(this),
        _Internal::team_page_order_sequence(this).GetCachedSize(), target, stream);
  }

  // optional uint32 favorite_page_num = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_favorite_page_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgStickerbook)
  return target;
}

size_t CMsgStickerbook::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgStickerbook)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgStickerbookPage pages = 1;
  total_size += 1UL * this->_internal_pages_size();
  for (const auto& msg : this->_impl_.pages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgStickerbookTeamPageOrderSequence team_page_order_sequence = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.team_page_order_sequence_);
    }

    // optional uint32 favorite_page_num = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_favorite_page_num());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgStickerbook::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgStickerbook::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgStickerbook::GetClassData() const { return &_class_data_; }


void CMsgStickerbook::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgStickerbook*>(&to_msg);
  auto& from = static_cast<const CMsgStickerbook&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgStickerbook)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pages_.MergeFrom(from._impl_.pages_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_team_page_order_sequence()->::CMsgStickerbookTeamPageOrderSequence::MergeFrom(
          from._internal_team_page_order_sequence());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.favorite_page_num_ = from._impl_.favorite_page_num_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgStickerbook::CopyFrom(const CMsgStickerbook& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgStickerbook)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgStickerbook::IsInitialized() const {
  return true;
}

void CMsgStickerbook::InternalSwap(CMsgStickerbook* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.pages_.InternalSwap(&other->_impl_.pages_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgStickerbook, _impl_.favorite_page_num_)
      + sizeof(CMsgStickerbook::_impl_.favorite_page_num_)
      - PROTOBUF_FIELD_OFFSET(CMsgStickerbook, _impl_.team_page_order_sequence_)>(
          reinterpret_cast<char*>(&_impl_.team_page_order_sequence_),
          reinterpret_cast<char*>(&other->_impl_.team_page_order_sequence_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgStickerbook::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[142]);
}

// ===================================================================

class CMsgStickerHero::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgStickerHero>()._impl_._has_bits_);
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_item_def_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_source_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgStickerHero::CMsgStickerHero(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgStickerHero)
}
CMsgStickerHero::CMsgStickerHero(const CMsgStickerHero& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgStickerHero* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.item_def_id_){}
    , decltype(_impl_.source_item_id_){}
    , decltype(_impl_.quality_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hero_id_, &from._impl_.hero_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.quality_) -
    reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.quality_));
  // @@protoc_insertion_point(copy_constructor:CMsgStickerHero)
}

inline void CMsgStickerHero::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_id_){0u}
    , decltype(_impl_.item_def_id_){0u}
    , decltype(_impl_.source_item_id_){uint64_t{0u}}
    , decltype(_impl_.quality_){0u}
  };
}

CMsgStickerHero::~CMsgStickerHero() {
  // @@protoc_insertion_point(destructor:CMsgStickerHero)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgStickerHero::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgStickerHero::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgStickerHero::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgStickerHero)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.hero_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.quality_) -
        reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.quality_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgStickerHero::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 hero_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 item_def_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_def_id(&has_bits);
          _impl_.item_def_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 quality = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_quality(&has_bits);
          _impl_.quality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 source_item_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_source_item_id(&has_bits);
          _impl_.source_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgStickerHero::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgStickerHero)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 hero_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hero_id(), target);
  }

  // optional uint32 item_def_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_item_def_id(), target);
  }

  // optional uint32 quality = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_quality(), target);
  }

  // optional uint64 source_item_id = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_source_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgStickerHero)
  return target;
}

size_t CMsgStickerHero::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgStickerHero)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 hero_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

    // optional uint32 item_def_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_item_def_id());
    }

    // optional uint64 source_item_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_source_item_id());
    }

    // optional uint32 quality = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_quality());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgStickerHero::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgStickerHero::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgStickerHero::GetClassData() const { return &_class_data_; }


void CMsgStickerHero::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgStickerHero*>(&to_msg);
  auto& from = static_cast<const CMsgStickerHero&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgStickerHero)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_def_id_ = from._impl_.item_def_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.source_item_id_ = from._impl_.source_item_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.quality_ = from._impl_.quality_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgStickerHero::CopyFrom(const CMsgStickerHero& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgStickerHero)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgStickerHero::IsInitialized() const {
  return true;
}

void CMsgStickerHero::InternalSwap(CMsgStickerHero* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgStickerHero, _impl_.quality_)
      + sizeof(CMsgStickerHero::_impl_.quality_)
      - PROTOBUF_FIELD_OFFSET(CMsgStickerHero, _impl_.hero_id_)>(
          reinterpret_cast<char*>(&_impl_.hero_id_),
          reinterpret_cast<char*>(&other->_impl_.hero_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgStickerHero::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[143]);
}

// ===================================================================

class CMsgStickerHeroes::_Internal {
 public:
};

CMsgStickerHeroes::CMsgStickerHeroes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgStickerHeroes)
}
CMsgStickerHeroes::CMsgStickerHeroes(const CMsgStickerHeroes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgStickerHeroes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.heroes_){from._impl_.heroes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgStickerHeroes)
}

inline void CMsgStickerHeroes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.heroes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgStickerHeroes::~CMsgStickerHeroes() {
  // @@protoc_insertion_point(destructor:CMsgStickerHeroes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgStickerHeroes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heroes_.~RepeatedPtrField();
}

void CMsgStickerHeroes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgStickerHeroes::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgStickerHeroes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.heroes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgStickerHeroes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgStickerHero heroes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_heroes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgStickerHeroes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgStickerHeroes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgStickerHero heroes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_heroes_size()); i < n; i++) {
    const auto& repfield = this->_internal_heroes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgStickerHeroes)
  return target;
}

size_t CMsgStickerHeroes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgStickerHeroes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgStickerHero heroes = 1;
  total_size += 1UL * this->_internal_heroes_size();
  for (const auto& msg : this->_impl_.heroes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgStickerHeroes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgStickerHeroes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgStickerHeroes::GetClassData() const { return &_class_data_; }


void CMsgStickerHeroes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgStickerHeroes*>(&to_msg);
  auto& from = static_cast<const CMsgStickerHeroes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgStickerHeroes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.heroes_.MergeFrom(from._impl_.heroes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgStickerHeroes::CopyFrom(const CMsgStickerHeroes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgStickerHeroes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgStickerHeroes::IsInitialized() const {
  return true;
}

void CMsgStickerHeroes::InternalSwap(CMsgStickerHeroes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.heroes_.InternalSwap(&other->_impl_.heroes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgStickerHeroes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[144]);
}

// ===================================================================

class CMsgHeroRoleStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgHeroRoleStats>()._impl_._has_bits_);
  static void set_has_lane_selection_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_match_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_win_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgHeroRoleStats::CMsgHeroRoleStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgHeroRoleStats)
}
CMsgHeroRoleStats::CMsgHeroRoleStats(const CMsgHeroRoleStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgHeroRoleStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lane_selection_flags_){}
    , decltype(_impl_.match_count_){}
    , decltype(_impl_.win_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.lane_selection_flags_, &from._impl_.lane_selection_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.win_count_) -
    reinterpret_cast<char*>(&_impl_.lane_selection_flags_)) + sizeof(_impl_.win_count_));
  // @@protoc_insertion_point(copy_constructor:CMsgHeroRoleStats)
}

inline void CMsgHeroRoleStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lane_selection_flags_){0u}
    , decltype(_impl_.match_count_){0u}
    , decltype(_impl_.win_count_){0u}
  };
}

CMsgHeroRoleStats::~CMsgHeroRoleStats() {
  // @@protoc_insertion_point(destructor:CMsgHeroRoleStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgHeroRoleStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgHeroRoleStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgHeroRoleStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgHeroRoleStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.lane_selection_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.win_count_) -
        reinterpret_cast<char*>(&_impl_.lane_selection_flags_)) + sizeof(_impl_.win_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgHeroRoleStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 lane_selection_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_lane_selection_flags(&has_bits);
          _impl_.lane_selection_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 match_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_match_count(&has_bits);
          _impl_.match_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 win_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_win_count(&has_bits);
          _impl_.win_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgHeroRoleStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgHeroRoleStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 lane_selection_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_lane_selection_flags(), target);
  }

  // optional uint32 match_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_match_count(), target);
  }

  // optional uint32 win_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_win_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgHeroRoleStats)
  return target;
}

size_t CMsgHeroRoleStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgHeroRoleStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 lane_selection_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lane_selection_flags());
    }

    // optional uint32 match_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_match_count());
    }

    // optional uint32 win_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_win_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgHeroRoleStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgHeroRoleStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgHeroRoleStats::GetClassData() const { return &_class_data_; }


void CMsgHeroRoleStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgHeroRoleStats*>(&to_msg);
  auto& from = static_cast<const CMsgHeroRoleStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgHeroRoleStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.lane_selection_flags_ = from._impl_.lane_selection_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.match_count_ = from._impl_.match_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.win_count_ = from._impl_.win_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgHeroRoleStats::CopyFrom(const CMsgHeroRoleStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgHeroRoleStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgHeroRoleStats::IsInitialized() const {
  return true;
}

void CMsgHeroRoleStats::InternalSwap(CMsgHeroRoleStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgHeroRoleStats, _impl_.win_count_)
      + sizeof(CMsgHeroRoleStats::_impl_.win_count_)
      - PROTOBUF_FIELD_OFFSET(CMsgHeroRoleStats, _impl_.lane_selection_flags_)>(
          reinterpret_cast<char*>(&_impl_.lane_selection_flags_),
          reinterpret_cast<char*>(&other->_impl_.lane_selection_flags_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgHeroRoleStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[145]);
}

// ===================================================================

class CMsgHeroRoleHeroStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgHeroRoleHeroStats>()._impl_._has_bits_);
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgHeroRoleHeroStats::CMsgHeroRoleHeroStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgHeroRoleHeroStats)
}
CMsgHeroRoleHeroStats::CMsgHeroRoleHeroStats(const CMsgHeroRoleHeroStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgHeroRoleHeroStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.role_stats_){from._impl_.role_stats_}
    , decltype(_impl_.hero_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.hero_id_ = from._impl_.hero_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgHeroRoleHeroStats)
}

inline void CMsgHeroRoleHeroStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.role_stats_){arena}
    , decltype(_impl_.hero_id_){0u}
  };
}

CMsgHeroRoleHeroStats::~CMsgHeroRoleHeroStats() {
  // @@protoc_insertion_point(destructor:CMsgHeroRoleHeroStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgHeroRoleHeroStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.role_stats_.~RepeatedPtrField();
}

void CMsgHeroRoleHeroStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgHeroRoleHeroStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgHeroRoleHeroStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.role_stats_.Clear();
  _impl_.hero_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgHeroRoleHeroStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 hero_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgHeroRoleStats role_stats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_role_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgHeroRoleHeroStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgHeroRoleHeroStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 hero_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hero_id(), target);
  }

  // repeated .CMsgHeroRoleStats role_stats = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_role_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_role_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgHeroRoleHeroStats)
  return target;
}

size_t CMsgHeroRoleHeroStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgHeroRoleHeroStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgHeroRoleStats role_stats = 2;
  total_size += 1UL * this->_internal_role_stats_size();
  for (const auto& msg : this->_impl_.role_stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 hero_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgHeroRoleHeroStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgHeroRoleHeroStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgHeroRoleHeroStats::GetClassData() const { return &_class_data_; }


void CMsgHeroRoleHeroStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgHeroRoleHeroStats*>(&to_msg);
  auto& from = static_cast<const CMsgHeroRoleHeroStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgHeroRoleHeroStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.role_stats_.MergeFrom(from._impl_.role_stats_);
  if (from._internal_has_hero_id()) {
    _this->_internal_set_hero_id(from._internal_hero_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgHeroRoleHeroStats::CopyFrom(const CMsgHeroRoleHeroStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgHeroRoleHeroStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgHeroRoleHeroStats::IsInitialized() const {
  return true;
}

void CMsgHeroRoleHeroStats::InternalSwap(CMsgHeroRoleHeroStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.role_stats_.InternalSwap(&other->_impl_.role_stats_);
  swap(_impl_.hero_id_, other->_impl_.hero_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgHeroRoleHeroStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[146]);
}

// ===================================================================

class CMsgHeroRoleRankStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgHeroRoleRankStats>()._impl_._has_bits_);
  static void set_has_rank_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgHeroRoleRankStats::CMsgHeroRoleRankStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgHeroRoleRankStats)
}
CMsgHeroRoleRankStats::CMsgHeroRoleRankStats(const CMsgHeroRoleRankStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgHeroRoleRankStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_stats_){from._impl_.hero_stats_}
    , decltype(_impl_.rank_tier_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.rank_tier_ = from._impl_.rank_tier_;
  // @@protoc_insertion_point(copy_constructor:CMsgHeroRoleRankStats)
}

inline void CMsgHeroRoleRankStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_stats_){arena}
    , decltype(_impl_.rank_tier_){0u}
  };
}

CMsgHeroRoleRankStats::~CMsgHeroRoleRankStats() {
  // @@protoc_insertion_point(destructor:CMsgHeroRoleRankStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgHeroRoleRankStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hero_stats_.~RepeatedPtrField();
}

void CMsgHeroRoleRankStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgHeroRoleRankStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgHeroRoleRankStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hero_stats_.Clear();
  _impl_.rank_tier_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgHeroRoleRankStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 rank_tier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_rank_tier(&has_bits);
          _impl_.rank_tier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgHeroRoleHeroStats hero_stats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hero_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgHeroRoleRankStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgHeroRoleRankStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 rank_tier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_rank_tier(), target);
  }

  // repeated .CMsgHeroRoleHeroStats hero_stats = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hero_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_hero_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgHeroRoleRankStats)
  return target;
}

size_t CMsgHeroRoleRankStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgHeroRoleRankStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgHeroRoleHeroStats hero_stats = 2;
  total_size += 1UL * this->_internal_hero_stats_size();
  for (const auto& msg : this->_impl_.hero_stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 rank_tier = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rank_tier());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgHeroRoleRankStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgHeroRoleRankStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgHeroRoleRankStats::GetClassData() const { return &_class_data_; }


void CMsgHeroRoleRankStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgHeroRoleRankStats*>(&to_msg);
  auto& from = static_cast<const CMsgHeroRoleRankStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgHeroRoleRankStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hero_stats_.MergeFrom(from._impl_.hero_stats_);
  if (from._internal_has_rank_tier()) {
    _this->_internal_set_rank_tier(from._internal_rank_tier());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgHeroRoleRankStats::CopyFrom(const CMsgHeroRoleRankStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgHeroRoleRankStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgHeroRoleRankStats::IsInitialized() const {
  return true;
}

void CMsgHeroRoleRankStats::InternalSwap(CMsgHeroRoleRankStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.hero_stats_.InternalSwap(&other->_impl_.hero_stats_);
  swap(_impl_.rank_tier_, other->_impl_.rank_tier_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgHeroRoleRankStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[147]);
}

// ===================================================================

class CMsgHeroRoleAllRanksStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgHeroRoleAllRanksStats>()._impl_._has_bits_);
  static void set_has_start_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgHeroRoleAllRanksStats::CMsgHeroRoleAllRanksStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgHeroRoleAllRanksStats)
}
CMsgHeroRoleAllRanksStats::CMsgHeroRoleAllRanksStats(const CMsgHeroRoleAllRanksStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgHeroRoleAllRanksStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rank_stats_){from._impl_.rank_stats_}
    , decltype(_impl_.start_timestamp_){}
    , decltype(_impl_.end_timestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.start_timestamp_, &from._impl_.start_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.end_timestamp_) -
    reinterpret_cast<char*>(&_impl_.start_timestamp_)) + sizeof(_impl_.end_timestamp_));
  // @@protoc_insertion_point(copy_constructor:CMsgHeroRoleAllRanksStats)
}

inline void CMsgHeroRoleAllRanksStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rank_stats_){arena}
    , decltype(_impl_.start_timestamp_){0u}
    , decltype(_impl_.end_timestamp_){0u}
  };
}

CMsgHeroRoleAllRanksStats::~CMsgHeroRoleAllRanksStats() {
  // @@protoc_insertion_point(destructor:CMsgHeroRoleAllRanksStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgHeroRoleAllRanksStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rank_stats_.~RepeatedPtrField();
}

void CMsgHeroRoleAllRanksStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgHeroRoleAllRanksStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgHeroRoleAllRanksStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rank_stats_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.start_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.end_timestamp_) -
        reinterpret_cast<char*>(&_impl_.start_timestamp_)) + sizeof(_impl_.end_timestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgHeroRoleAllRanksStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 start_timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_start_timestamp(&has_bits);
          _impl_.start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 end_timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_end_timestamp(&has_bits);
          _impl_.end_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgHeroRoleRankStats rank_stats = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rank_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgHeroRoleAllRanksStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgHeroRoleAllRanksStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 start_timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_start_timestamp(), target);
  }

  // optional uint32 end_timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_end_timestamp(), target);
  }

  // repeated .CMsgHeroRoleRankStats rank_stats = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rank_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_rank_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgHeroRoleAllRanksStats)
  return target;
}

size_t CMsgHeroRoleAllRanksStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgHeroRoleAllRanksStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgHeroRoleRankStats rank_stats = 3;
  total_size += 1UL * this->_internal_rank_stats_size();
  for (const auto& msg : this->_impl_.rank_stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 start_timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_timestamp());
    }

    // optional uint32 end_timestamp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgHeroRoleAllRanksStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgHeroRoleAllRanksStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgHeroRoleAllRanksStats::GetClassData() const { return &_class_data_; }


void CMsgHeroRoleAllRanksStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgHeroRoleAllRanksStats*>(&to_msg);
  auto& from = static_cast<const CMsgHeroRoleAllRanksStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgHeroRoleAllRanksStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.rank_stats_.MergeFrom(from._impl_.rank_stats_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.start_timestamp_ = from._impl_.start_timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.end_timestamp_ = from._impl_.end_timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgHeroRoleAllRanksStats::CopyFrom(const CMsgHeroRoleAllRanksStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgHeroRoleAllRanksStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgHeroRoleAllRanksStats::IsInitialized() const {
  return true;
}

void CMsgHeroRoleAllRanksStats::InternalSwap(CMsgHeroRoleAllRanksStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.rank_stats_.InternalSwap(&other->_impl_.rank_stats_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgHeroRoleAllRanksStats, _impl_.end_timestamp_)
      + sizeof(CMsgHeroRoleAllRanksStats::_impl_.end_timestamp_)
      - PROTOBUF_FIELD_OFFSET(CMsgHeroRoleAllRanksStats, _impl_.start_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.start_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.start_timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgHeroRoleAllRanksStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_2eproto[148]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CSODOTAGameAccountClient_RoleHandicap*
Arena::CreateMaybeMessage< ::CSODOTAGameAccountClient_RoleHandicap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSODOTAGameAccountClient_RoleHandicap >(arena);
}
template<> PROTOBUF_NOINLINE ::CSODOTAGameAccountClient*
Arena::CreateMaybeMessage< ::CSODOTAGameAccountClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSODOTAGameAccountClient >(arena);
}
template<> PROTOBUF_NOINLINE ::CSODOTAGameAccountPlus*
Arena::CreateMaybeMessage< ::CSODOTAGameAccountPlus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSODOTAGameAccountPlus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgLobbyFeaturedGamemodeProgress_AccountProgress*
Arena::CreateMaybeMessage< ::CMsgLobbyFeaturedGamemodeProgress_AccountProgress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgLobbyFeaturedGamemodeProgress_AccountProgress >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgLobbyFeaturedGamemodeProgress*
Arena::CreateMaybeMessage< ::CMsgLobbyFeaturedGamemodeProgress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgLobbyFeaturedGamemodeProgress >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgBattleCupVictory*
Arena::CreateMaybeMessage< ::CMsgBattleCupVictory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgBattleCupVictory >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgLobbyBattleCupVictoryList*
Arena::CreateMaybeMessage< ::CMsgLobbyBattleCupVictoryList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgLobbyBattleCupVictoryList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTABroadcastNotification*
Arena::CreateMaybeMessage< ::CMsgDOTABroadcastNotification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTABroadcastNotification >(arena);
}
template<> PROTOBUF_NOINLINE ::CProtoItemHeroStatue*
Arena::CreateMaybeMessage< ::CProtoItemHeroStatue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CProtoItemHeroStatue >(arena);
}
template<> PROTOBUF_NOINLINE ::CMatchPlayerAbilityUpgrade*
Arena::CreateMaybeMessage< ::CMatchPlayerAbilityUpgrade >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMatchPlayerAbilityUpgrade >(arena);
}
template<> PROTOBUF_NOINLINE ::CMatchPlayerTimedStats*
Arena::CreateMaybeMessage< ::CMatchPlayerTimedStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMatchPlayerTimedStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMatchTeamTimedStats*
Arena::CreateMaybeMessage< ::CMatchTeamTimedStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMatchTeamTimedStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMatchAdditionalUnitInventory*
Arena::CreateMaybeMessage< ::CMatchAdditionalUnitInventory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMatchAdditionalUnitInventory >(arena);
}
template<> PROTOBUF_NOINLINE ::CMatchPlayerPermanentBuff*
Arena::CreateMaybeMessage< ::CMatchPlayerPermanentBuff >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMatchPlayerPermanentBuff >(arena);
}
template<> PROTOBUF_NOINLINE ::CMatchHeroSelectEvent*
Arena::CreateMaybeMessage< ::CMatchHeroSelectEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMatchHeroSelectEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::CMatchClip*
Arena::CreateMaybeMessage< ::CMatchClip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMatchClip >(arena);
}
template<> PROTOBUF_NOINLINE ::CPartySearchClientParty*
Arena::CreateMaybeMessage< ::CPartySearchClientParty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CPartySearchClientParty >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAHasItemQuery*
Arena::CreateMaybeMessage< ::CMsgDOTAHasItemQuery >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAHasItemQuery >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAHasItemResponse*
Arena::CreateMaybeMessage< ::CMsgDOTAHasItemResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAHasItemResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCGetPlayerCardItemInfo*
Arena::CreateMaybeMessage< ::CMsgGCGetPlayerCardItemInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGetPlayerCardItemInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo*
Arena::CreateMaybeMessage< ::CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCGetPlayerCardItemInfoResponse*
Arena::CreateMaybeMessage< ::CMsgGCGetPlayerCardItemInfoResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCGetPlayerCardItemInfoResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CSODOTAMapLocationState*
Arena::CreateMaybeMessage< ::CSODOTAMapLocationState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSODOTAMapLocationState >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgLeagueAdminList*
Arena::CreateMaybeMessage< ::CMsgLeagueAdminList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgLeagueAdminList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAProfileCard_Slot_Trophy*
Arena::CreateMaybeMessage< ::CMsgDOTAProfileCard_Slot_Trophy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAProfileCard_Slot_Trophy >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAProfileCard_Slot_Stat*
Arena::CreateMaybeMessage< ::CMsgDOTAProfileCard_Slot_Stat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAProfileCard_Slot_Stat >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAProfileCard_Slot_Item*
Arena::CreateMaybeMessage< ::CMsgDOTAProfileCard_Slot_Item >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAProfileCard_Slot_Item >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAProfileCard_Slot_Hero*
Arena::CreateMaybeMessage< ::CMsgDOTAProfileCard_Slot_Hero >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAProfileCard_Slot_Hero >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAProfileCard_Slot_Emoticon*
Arena::CreateMaybeMessage< ::CMsgDOTAProfileCard_Slot_Emoticon >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAProfileCard_Slot_Emoticon >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAProfileCard_Slot_Team*
Arena::CreateMaybeMessage< ::CMsgDOTAProfileCard_Slot_Team >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAProfileCard_Slot_Team >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAProfileCard_Slot*
Arena::CreateMaybeMessage< ::CMsgDOTAProfileCard_Slot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAProfileCard_Slot >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAProfileCard*
Arena::CreateMaybeMessage< ::CMsgDOTAProfileCard >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAProfileCard >(arena);
}
template<> PROTOBUF_NOINLINE ::CSODOTAPlayerChallenge*
Arena::CreateMaybeMessage< ::CSODOTAPlayerChallenge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSODOTAPlayerChallenge >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCRerollPlayerChallenge*
Arena::CreateMaybeMessage< ::CMsgClientToGCRerollPlayerChallenge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCRerollPlayerChallenge >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCRerollPlayerChallengeResponse*
Arena::CreateMaybeMessage< ::CMsgGCRerollPlayerChallengeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCRerollPlayerChallengeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCTopCustomGamesList*
Arena::CreateMaybeMessage< ::CMsgGCTopCustomGamesList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCTopCustomGamesList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_TeamDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_TeamDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_TeamDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_ItemDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_ItemDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_ItemDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_AbilityDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_AbilityDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_AbilityDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_HeroToHeroStats*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_HeroToHeroStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_HeroToHeroStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_AbilityList*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_AbilityList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_AbilityList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_PlayerDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_PlayerDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_PlayerDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_BuildingDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_BuildingDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_BuildingDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_KillDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_KillDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_KillDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_BroadcasterDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_BroadcasterDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_BroadcasterDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_PickBanDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_PickBanDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_PickBanDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_MatchDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_MatchDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_MatchDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_GraphData_LocationStats*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_GraphData_LocationStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_GraphData_LocationStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats_GraphData*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats_GraphData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats_GraphData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStats*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStatsTerse_TeamDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStatsTerse_TeamDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStatsTerse_TeamDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStatsTerse_PlayerDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStatsTerse_PlayerDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStatsTerse_PlayerDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStatsTerse_BuildingDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStatsTerse_BuildingDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStatsTerse_BuildingDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStatsTerse_PickBanDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStatsTerse_PickBanDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStatsTerse_PickBanDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStatsTerse_MatchDetails*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStatsTerse_MatchDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStatsTerse_MatchDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStatsTerse_GraphData*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStatsTerse_GraphData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStatsTerse_GraphData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTARealtimeGameStatsTerse*
Arena::CreateMaybeMessage< ::CMsgDOTARealtimeGameStatsTerse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTARealtimeGameStatsTerse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTABroadcastTimelineEvent*
Arena::CreateMaybeMessage< ::CMsgDOTABroadcastTimelineEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTABroadcastTimelineEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToClientMatchGroupsVersion*
Arena::CreateMaybeMessage< ::CMsgGCToClientMatchGroupsVersion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToClientMatchGroupsVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTASDOHeroStatsHistory*
Arena::CreateMaybeMessage< ::CMsgDOTASDOHeroStatsHistory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTASDOHeroStatsHistory >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPredictionChoice*
Arena::CreateMaybeMessage< ::CMsgPredictionChoice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPredictionChoice >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgInGamePrediction_QueryKeyValues*
Arena::CreateMaybeMessage< ::CMsgInGamePrediction_QueryKeyValues >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgInGamePrediction_QueryKeyValues >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgInGamePrediction*
Arena::CreateMaybeMessage< ::CMsgInGamePrediction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgInGamePrediction >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTASeasonPredictions_Prediction_Answers*
Arena::CreateMaybeMessage< ::CMsgDOTASeasonPredictions_Prediction_Answers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTASeasonPredictions_Prediction_Answers >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTASeasonPredictions_Prediction*
Arena::CreateMaybeMessage< ::CMsgDOTASeasonPredictions_Prediction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTASeasonPredictions_Prediction >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTASeasonPredictions*
Arena::CreateMaybeMessage< ::CMsgDOTASeasonPredictions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTASeasonPredictions >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAvailablePredictions_MatchPrediction*
Arena::CreateMaybeMessage< ::CMsgAvailablePredictions_MatchPrediction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAvailablePredictions_MatchPrediction >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAvailablePredictions*
Arena::CreateMaybeMessage< ::CMsgAvailablePredictions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAvailablePredictions >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgLeagueWatchedGames_Series*
Arena::CreateMaybeMessage< ::CMsgLeagueWatchedGames_Series >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgLeagueWatchedGames_Series >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgLeagueWatchedGames_League*
Arena::CreateMaybeMessage< ::CMsgLeagueWatchedGames_League >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgLeagueWatchedGames_League >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgLeagueWatchedGames*
Arena::CreateMaybeMessage< ::CMsgLeagueWatchedGames >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgLeagueWatchedGames >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAMatch_Player_CustomGameData*
Arena::CreateMaybeMessage< ::CMsgDOTAMatch_Player_CustomGameData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAMatch_Player_CustomGameData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAMatch_Player_HeroDamageReceived*
Arena::CreateMaybeMessage< ::CMsgDOTAMatch_Player_HeroDamageReceived >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAMatch_Player_HeroDamageReceived >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAMatch_Player*
Arena::CreateMaybeMessage< ::CMsgDOTAMatch_Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAMatch_Player >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAMatch_BroadcasterInfo*
Arena::CreateMaybeMessage< ::CMsgDOTAMatch_BroadcasterInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAMatch_BroadcasterInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAMatch_BroadcasterChannel*
Arena::CreateMaybeMessage< ::CMsgDOTAMatch_BroadcasterChannel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAMatch_BroadcasterChannel >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAMatch_Coach*
Arena::CreateMaybeMessage< ::CMsgDOTAMatch_Coach >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAMatch_Coach >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAMatch_CustomGameData*
Arena::CreateMaybeMessage< ::CMsgDOTAMatch_CustomGameData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAMatch_CustomGameData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAMatch*
Arena::CreateMaybeMessage< ::CMsgDOTAMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPlayerCard_StatModifier*
Arena::CreateMaybeMessage< ::CMsgPlayerCard_StatModifier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPlayerCard_StatModifier >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPlayerCard*
Arena::CreateMaybeMessage< ::CMsgPlayerCard >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPlayerCard >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAFantasyPlayerStats*
Arena::CreateMaybeMessage< ::CMsgDOTAFantasyPlayerStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAFantasyPlayerStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAFantasyPlayerMatchStats*
Arena::CreateMaybeMessage< ::CMsgDOTAFantasyPlayerMatchStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAFantasyPlayerMatchStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTABotDebugInfo_Bot_Mode*
Arena::CreateMaybeMessage< ::CMsgDOTABotDebugInfo_Bot_Mode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTABotDebugInfo_Bot_Mode >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTABotDebugInfo_Bot_Action*
Arena::CreateMaybeMessage< ::CMsgDOTABotDebugInfo_Bot_Action >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTABotDebugInfo_Bot_Action >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTABotDebugInfo_Bot*
Arena::CreateMaybeMessage< ::CMsgDOTABotDebugInfo_Bot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTABotDebugInfo_Bot >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTABotDebugInfo*
Arena::CreateMaybeMessage< ::CMsgDOTABotDebugInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTABotDebugInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSuccessfulHero*
Arena::CreateMaybeMessage< ::CMsgSuccessfulHero >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSuccessfulHero >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRecentMatchInfo*
Arena::CreateMaybeMessage< ::CMsgRecentMatchInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRecentMatchInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMatchTips_SingleTip*
Arena::CreateMaybeMessage< ::CMsgMatchTips_SingleTip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMatchTips_SingleTip >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMatchTips*
Arena::CreateMaybeMessage< ::CMsgMatchTips >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMatchTips >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAMatchMinimal_Player*
Arena::CreateMaybeMessage< ::CMsgDOTAMatchMinimal_Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAMatchMinimal_Player >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAMatchMinimal_Tourney*
Arena::CreateMaybeMessage< ::CMsgDOTAMatchMinimal_Tourney >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAMatchMinimal_Tourney >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTAMatchMinimal*
Arena::CreateMaybeMessage< ::CMsgDOTAMatchMinimal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTAMatchMinimal >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgConsumableUsage*
Arena::CreateMaybeMessage< ::CMsgConsumableUsage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgConsumableUsage >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMatchConsumableUsage_PlayerUsage*
Arena::CreateMaybeMessage< ::CMsgMatchConsumableUsage_PlayerUsage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMatchConsumableUsage_PlayerUsage >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMatchConsumableUsage*
Arena::CreateMaybeMessage< ::CMsgMatchConsumableUsage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMatchConsumableUsage >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMatchEventActionGrants_PlayerGrants*
Arena::CreateMaybeMessage< ::CMsgMatchEventActionGrants_PlayerGrants >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMatchEventActionGrants_PlayerGrants >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMatchEventActionGrants*
Arena::CreateMaybeMessage< ::CMsgMatchEventActionGrants >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMatchEventActionGrants >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgCustomGameWhitelist*
Arena::CreateMaybeMessage< ::CMsgCustomGameWhitelist >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgCustomGameWhitelist >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgCustomGameWhitelistForEdit_WhitelistEntry*
Arena::CreateMaybeMessage< ::CMsgCustomGameWhitelistForEdit_WhitelistEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgCustomGameWhitelistForEdit_WhitelistEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgCustomGameWhitelistForEdit*
Arena::CreateMaybeMessage< ::CMsgCustomGameWhitelistForEdit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgCustomGameWhitelistForEdit >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPlayerRecentMatchInfo*
Arena::CreateMaybeMessage< ::CMsgPlayerRecentMatchInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPlayerRecentMatchInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPlayerMatchRecord*
Arena::CreateMaybeMessage< ::CMsgPlayerMatchRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPlayerMatchRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPlayerRecentMatchOutcomes*
Arena::CreateMaybeMessage< ::CMsgPlayerRecentMatchOutcomes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPlayerRecentMatchOutcomes >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPlayerRecentCommends*
Arena::CreateMaybeMessage< ::CMsgPlayerRecentCommends >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPlayerRecentCommends >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPlayerRecentAccomplishments*
Arena::CreateMaybeMessage< ::CMsgPlayerRecentAccomplishments >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPlayerRecentAccomplishments >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPlayerHeroRecentAccomplishments*
Arena::CreateMaybeMessage< ::CMsgPlayerHeroRecentAccomplishments >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPlayerHeroRecentAccomplishments >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRecentAccomplishments*
Arena::CreateMaybeMessage< ::CMsgRecentAccomplishments >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRecentAccomplishments >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerToGCRequestPlayerRecentAccomplishments*
Arena::CreateMaybeMessage< ::CMsgServerToGCRequestPlayerRecentAccomplishments >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerToGCRequestPlayerRecentAccomplishments >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse*
Arena::CreateMaybeMessage< ::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgArcanaVoteMatchVotes*
Arena::CreateMaybeMessage< ::CMsgArcanaVoteMatchVotes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgArcanaVoteMatchVotes >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCtoGCAssociatedExploiterAccountInfo*
Arena::CreateMaybeMessage< ::CMsgGCtoGCAssociatedExploiterAccountInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCtoGCAssociatedExploiterAccountInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account*
Arena::CreateMaybeMessage< ::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCtoGCAssociatedExploiterAccountInfoResponse*
Arena::CreateMaybeMessage< ::CMsgGCtoGCAssociatedExploiterAccountInfoResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCtoGCAssociatedExploiterAccountInfoResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPullTabsData_Slot*
Arena::CreateMaybeMessage< ::CMsgPullTabsData_Slot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPullTabsData_Slot >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPullTabsData_Jackpot*
Arena::CreateMaybeMessage< ::CMsgPullTabsData_Jackpot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPullTabsData_Jackpot >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPullTabsData*
Arena::CreateMaybeMessage< ::CMsgPullTabsData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPullTabsData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgUnderDraftData_BenchSlot*
Arena::CreateMaybeMessage< ::CMsgUnderDraftData_BenchSlot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgUnderDraftData_BenchSlot >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgUnderDraftData_ShopSlot*
Arena::CreateMaybeMessage< ::CMsgUnderDraftData_ShopSlot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgUnderDraftData_ShopSlot >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgUnderDraftData*
Arena::CreateMaybeMessage< ::CMsgUnderDraftData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgUnderDraftData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPlayerTitleData*
Arena::CreateMaybeMessage< ::CMsgPlayerTitleData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPlayerTitleData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTATriviaQuestion*
Arena::CreateMaybeMessage< ::CMsgDOTATriviaQuestion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTATriviaQuestion >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTATriviaQuestionAnswersSummary*
Arena::CreateMaybeMessage< ::CMsgDOTATriviaQuestionAnswersSummary >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTATriviaQuestionAnswersSummary >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGameDataSpecialValueBonus*
Arena::CreateMaybeMessage< ::CMsgGameDataSpecialValueBonus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGameDataSpecialValueBonus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGameDataSpecialValues*
Arena::CreateMaybeMessage< ::CMsgGameDataSpecialValues >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGameDataSpecialValues >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGameDataAbilityOrItem*
Arena::CreateMaybeMessage< ::CMsgGameDataAbilityOrItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGameDataAbilityOrItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGameDataHero*
Arena::CreateMaybeMessage< ::CMsgGameDataHero >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGameDataHero >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGameDataAbilities*
Arena::CreateMaybeMessage< ::CMsgGameDataAbilities >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGameDataAbilities >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGameDataItems*
Arena::CreateMaybeMessage< ::CMsgGameDataItems >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGameDataItems >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGameDataHeroes*
Arena::CreateMaybeMessage< ::CMsgGameDataHeroes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGameDataHeroes >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGameDataHeroList_HeroInfo*
Arena::CreateMaybeMessage< ::CMsgGameDataHeroList_HeroInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGameDataHeroList_HeroInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGameDataHeroList*
Arena::CreateMaybeMessage< ::CMsgGameDataHeroList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGameDataHeroList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGameDataItemAbilityList_ItemAbilityInfo*
Arena::CreateMaybeMessage< ::CMsgGameDataItemAbilityList_ItemAbilityInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGameDataItemAbilityList_ItemAbilityInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGameDataItemAbilityList*
Arena::CreateMaybeMessage< ::CMsgGameDataItemAbilityList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGameDataItemAbilityList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgLobbyAbilityDraftData*
Arena::CreateMaybeMessage< ::CMsgLobbyAbilityDraftData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgLobbyAbilityDraftData >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOEconItemDropRateBonus*
Arena::CreateMaybeMessage< ::CSOEconItemDropRateBonus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOEconItemDropRateBonus >(arena);
}
template<> PROTOBUF_NOINLINE ::CSOEconItemTournamentPassport*
Arena::CreateMaybeMessage< ::CSOEconItemTournamentPassport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSOEconItemTournamentPassport >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgStickerbookSticker*
Arena::CreateMaybeMessage< ::CMsgStickerbookSticker >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgStickerbookSticker >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgStickerbookPage*
Arena::CreateMaybeMessage< ::CMsgStickerbookPage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgStickerbookPage >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgStickerbookTeamPageOrderSequence*
Arena::CreateMaybeMessage< ::CMsgStickerbookTeamPageOrderSequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgStickerbookTeamPageOrderSequence >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgStickerbook*
Arena::CreateMaybeMessage< ::CMsgStickerbook >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgStickerbook >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgStickerHero*
Arena::CreateMaybeMessage< ::CMsgStickerHero >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgStickerHero >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgStickerHeroes*
Arena::CreateMaybeMessage< ::CMsgStickerHeroes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgStickerHeroes >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgHeroRoleStats*
Arena::CreateMaybeMessage< ::CMsgHeroRoleStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgHeroRoleStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgHeroRoleHeroStats*
Arena::CreateMaybeMessage< ::CMsgHeroRoleHeroStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgHeroRoleHeroStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgHeroRoleRankStats*
Arena::CreateMaybeMessage< ::CMsgHeroRoleRankStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgHeroRoleRankStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgHeroRoleAllRanksStats*
Arena::CreateMaybeMessage< ::CMsgHeroRoleAllRanksStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgHeroRoleAllRanksStats >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
