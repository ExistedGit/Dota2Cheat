// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_shared_enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dota_5fshared_5fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dota_5fshared_5fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dota_5fshared_5fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dota_5fshared_5fenums_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dota_5fshared_5fenums_2eproto;
class CDOTAClientHardwareSpecs;
struct CDOTAClientHardwareSpecsDefaultTypeInternal;
extern CDOTAClientHardwareSpecsDefaultTypeInternal _CDOTAClientHardwareSpecs_default_instance_;
class CDOTASaveGame;
struct CDOTASaveGameDefaultTypeInternal;
extern CDOTASaveGameDefaultTypeInternal _CDOTASaveGame_default_instance_;
class CDOTASaveGame_Player;
struct CDOTASaveGame_PlayerDefaultTypeInternal;
extern CDOTASaveGame_PlayerDefaultTypeInternal _CDOTASaveGame_Player_default_instance_;
class CDOTASaveGame_SaveInstance;
struct CDOTASaveGame_SaveInstanceDefaultTypeInternal;
extern CDOTASaveGame_SaveInstanceDefaultTypeInternal _CDOTASaveGame_SaveInstance_default_instance_;
class CDOTASaveGame_SaveInstance_PlayerPositions;
struct CDOTASaveGame_SaveInstance_PlayerPositionsDefaultTypeInternal;
extern CDOTASaveGame_SaveInstance_PlayerPositionsDefaultTypeInternal _CDOTASaveGame_SaveInstance_PlayerPositions_default_instance_;
class CMsgDOTACombatLogEntry;
struct CMsgDOTACombatLogEntryDefaultTypeInternal;
extern CMsgDOTACombatLogEntryDefaultTypeInternal _CMsgDOTACombatLogEntry_default_instance_;
class CMsgPendingEventAward;
struct CMsgPendingEventAwardDefaultTypeInternal;
extern CMsgPendingEventAwardDefaultTypeInternal _CMsgPendingEventAward_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CDOTAClientHardwareSpecs* Arena::CreateMaybeMessage<::CDOTAClientHardwareSpecs>(Arena*);
template<> ::CDOTASaveGame* Arena::CreateMaybeMessage<::CDOTASaveGame>(Arena*);
template<> ::CDOTASaveGame_Player* Arena::CreateMaybeMessage<::CDOTASaveGame_Player>(Arena*);
template<> ::CDOTASaveGame_SaveInstance* Arena::CreateMaybeMessage<::CDOTASaveGame_SaveInstance>(Arena*);
template<> ::CDOTASaveGame_SaveInstance_PlayerPositions* Arena::CreateMaybeMessage<::CDOTASaveGame_SaveInstance_PlayerPositions>(Arena*);
template<> ::CMsgDOTACombatLogEntry* Arena::CreateMaybeMessage<::CMsgDOTACombatLogEntry>(Arena*);
template<> ::CMsgPendingEventAward* Arena::CreateMaybeMessage<::CMsgPendingEventAward>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum DOTA_GameMode : int {
  DOTA_GAMEMODE_NONE = 0,
  DOTA_GAMEMODE_AP = 1,
  DOTA_GAMEMODE_CM = 2,
  DOTA_GAMEMODE_RD = 3,
  DOTA_GAMEMODE_SD = 4,
  DOTA_GAMEMODE_AR = 5,
  DOTA_GAMEMODE_INTRO = 6,
  DOTA_GAMEMODE_HW = 7,
  DOTA_GAMEMODE_REVERSE_CM = 8,
  DOTA_GAMEMODE_XMAS = 9,
  DOTA_GAMEMODE_TUTORIAL = 10,
  DOTA_GAMEMODE_MO = 11,
  DOTA_GAMEMODE_LP = 12,
  DOTA_GAMEMODE_POOL1 = 13,
  DOTA_GAMEMODE_FH = 14,
  DOTA_GAMEMODE_CUSTOM = 15,
  DOTA_GAMEMODE_CD = 16,
  DOTA_GAMEMODE_BD = 17,
  DOTA_GAMEMODE_ABILITY_DRAFT = 18,
  DOTA_GAMEMODE_EVENT = 19,
  DOTA_GAMEMODE_ARDM = 20,
  DOTA_GAMEMODE_1V1MID = 21,
  DOTA_GAMEMODE_ALL_DRAFT = 22,
  DOTA_GAMEMODE_TURBO = 23,
  DOTA_GAMEMODE_MUTATION = 24,
  DOTA_GAMEMODE_COACHES_CHALLENGE = 25
};
bool DOTA_GameMode_IsValid(int value);
constexpr DOTA_GameMode DOTA_GameMode_MIN = DOTA_GAMEMODE_NONE;
constexpr DOTA_GameMode DOTA_GameMode_MAX = DOTA_GAMEMODE_COACHES_CHALLENGE;
constexpr int DOTA_GameMode_ARRAYSIZE = DOTA_GameMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_GameMode_descriptor();
template<typename T>
inline const std::string& DOTA_GameMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTA_GameMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTA_GameMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTA_GameMode_descriptor(), enum_t_value);
}
inline bool DOTA_GameMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTA_GameMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTA_GameMode>(
    DOTA_GameMode_descriptor(), name, value);
}
enum DOTA_GameState : int {
  DOTA_GAMERULES_STATE_INIT = 0,
  DOTA_GAMERULES_STATE_WAIT_FOR_PLAYERS_TO_LOAD = 1,
  DOTA_GAMERULES_STATE_HERO_SELECTION = 2,
  DOTA_GAMERULES_STATE_STRATEGY_TIME = 3,
  DOTA_GAMERULES_STATE_PRE_GAME = 4,
  DOTA_GAMERULES_STATE_GAME_IN_PROGRESS = 5,
  DOTA_GAMERULES_STATE_POST_GAME = 6,
  DOTA_GAMERULES_STATE_DISCONNECT = 7,
  DOTA_GAMERULES_STATE_TEAM_SHOWCASE = 8,
  DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP = 9,
  DOTA_GAMERULES_STATE_WAIT_FOR_MAP_TO_LOAD = 10,
  DOTA_GAMERULES_STATE_SCENARIO_SETUP = 11,
  DOTA_GAMERULES_STATE_LAST = 12
};
bool DOTA_GameState_IsValid(int value);
constexpr DOTA_GameState DOTA_GameState_MIN = DOTA_GAMERULES_STATE_INIT;
constexpr DOTA_GameState DOTA_GameState_MAX = DOTA_GAMERULES_STATE_LAST;
constexpr int DOTA_GameState_ARRAYSIZE = DOTA_GameState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_GameState_descriptor();
template<typename T>
inline const std::string& DOTA_GameState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTA_GameState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTA_GameState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTA_GameState_descriptor(), enum_t_value);
}
inline bool DOTA_GameState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTA_GameState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTA_GameState>(
    DOTA_GameState_descriptor(), name, value);
}
enum DOTA_GC_TEAM : int {
  DOTA_GC_TEAM_GOOD_GUYS = 0,
  DOTA_GC_TEAM_BAD_GUYS = 1,
  DOTA_GC_TEAM_BROADCASTER = 2,
  DOTA_GC_TEAM_SPECTATOR = 3,
  DOTA_GC_TEAM_PLAYER_POOL = 4,
  DOTA_GC_TEAM_NOTEAM = 5,
  DOTA_GC_TEAM_CUSTOM_1 = 6,
  DOTA_GC_TEAM_CUSTOM_2 = 7,
  DOTA_GC_TEAM_CUSTOM_3 = 8,
  DOTA_GC_TEAM_CUSTOM_4 = 9,
  DOTA_GC_TEAM_CUSTOM_5 = 10,
  DOTA_GC_TEAM_CUSTOM_6 = 11,
  DOTA_GC_TEAM_CUSTOM_7 = 12,
  DOTA_GC_TEAM_CUSTOM_8 = 13,
  DOTA_GC_TEAM_NEUTRALS = 14
};
bool DOTA_GC_TEAM_IsValid(int value);
constexpr DOTA_GC_TEAM DOTA_GC_TEAM_MIN = DOTA_GC_TEAM_GOOD_GUYS;
constexpr DOTA_GC_TEAM DOTA_GC_TEAM_MAX = DOTA_GC_TEAM_NEUTRALS;
constexpr int DOTA_GC_TEAM_ARRAYSIZE = DOTA_GC_TEAM_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_GC_TEAM_descriptor();
template<typename T>
inline const std::string& DOTA_GC_TEAM_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTA_GC_TEAM>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTA_GC_TEAM_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTA_GC_TEAM_descriptor(), enum_t_value);
}
inline bool DOTA_GC_TEAM_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTA_GC_TEAM* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTA_GC_TEAM>(
    DOTA_GC_TEAM_descriptor(), name, value);
}
enum EEvent : int {
  EVENT_ID_NONE = 0,
  EVENT_ID_DIRETIDE = 1,
  EVENT_ID_SPRING_FESTIVAL = 2,
  EVENT_ID_FROSTIVUS_2013 = 3,
  EVENT_ID_COMPENDIUM_2014 = 4,
  EVENT_ID_NEXON_PC_BANG = 5,
  EVENT_ID_PWRD_DAC_2015 = 6,
  EVENT_ID_NEW_BLOOM_2015 = 7,
  EVENT_ID_INTERNATIONAL_2015 = 8,
  EVENT_ID_FALL_MAJOR_2015 = 9,
  EVENT_ID_ORACLE_PA = 10,
  EVENT_ID_NEW_BLOOM_2015_PREBEAST = 11,
  EVENT_ID_FROSTIVUS = 12,
  EVENT_ID_WINTER_MAJOR_2016 = 13,
  EVENT_ID_INTERNATIONAL_2016 = 14,
  EVENT_ID_FALL_MAJOR_2016 = 15,
  EVENT_ID_WINTER_MAJOR_2017 = 16,
  EVENT_ID_NEW_BLOOM_2017 = 17,
  EVENT_ID_INTERNATIONAL_2017 = 18,
  EVENT_ID_PLUS_SUBSCRIPTION = 19,
  EVENT_ID_SINGLES_DAY_2017 = 20,
  EVENT_ID_FROSTIVUS_2017 = 21,
  EVENT_ID_INTERNATIONAL_2018 = 22,
  EVENT_ID_FROSTIVUS_2018 = 23,
  EVENT_ID_NEW_BLOOM_2019 = 24,
  EVENT_ID_INTERNATIONAL_2019 = 25,
  EVENT_ID_NEW_PLAYER_EXPERIENCE = 26,
  EVENT_ID_FROSTIVUS_2019 = 27,
  EVENT_ID_NEW_BLOOM_2020 = 28,
  EVENT_ID_INTERNATIONAL_2020 = 29,
  EVENT_ID_TEAM_FANDOM = 30,
  EVENT_ID_DIRETIDE_2020 = 31,
  EVENT_ID_SPRING_2021 = 32,
  EVENT_ID_FALL_2021 = 33,
  EVENT_ID_TEAM_FANDOM_FALL_2021 = 34,
  EVENT_ID_TEAM_2021_2022_TOUR2 = 35,
  EVENT_ID_INTERNATIONAL_2022 = 36,
  EVENT_ID_TEAM_2021_2022_TOUR3 = 37,
  EVENT_ID_TEAM_INTERNATIONAL_2022 = 38,
  EVENT_ID_PERMANENT_GRANTS = 39,
  EVENT_ID_MUERTA_RELEASE_SPRING2023 = 40,
  EVENT_ID_TEAM_2023_TOUR1 = 41,
  EVENT_ID_TEAM_2023_TOUR2 = 42
};
bool EEvent_IsValid(int value);
constexpr EEvent EEvent_MIN = EVENT_ID_NONE;
constexpr EEvent EEvent_MAX = EVENT_ID_TEAM_2023_TOUR2;
constexpr int EEvent_ARRAYSIZE = EEvent_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EEvent_descriptor();
template<typename T>
inline const std::string& EEvent_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EEvent>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EEvent_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EEvent_descriptor(), enum_t_value);
}
inline bool EEvent_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EEvent* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EEvent>(
    EEvent_descriptor(), name, value);
}
enum ERankType : int {
  k_ERankType_Invalid = 0,
  k_ERankType_Casual = 1,
  k_ERankType_Ranked = 2,
  k_ERankType_CasualLegacy = 3,
  k_ERankType_RankedLegacy = 4
};
bool ERankType_IsValid(int value);
constexpr ERankType ERankType_MIN = k_ERankType_Invalid;
constexpr ERankType ERankType_MAX = k_ERankType_RankedLegacy;
constexpr int ERankType_ARRAYSIZE = ERankType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERankType_descriptor();
template<typename T>
inline const std::string& ERankType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ERankType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ERankType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ERankType_descriptor(), enum_t_value);
}
inline bool ERankType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ERankType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ERankType>(
    ERankType_descriptor(), name, value);
}
enum DOTALeaverStatus_t : int {
  DOTA_LEAVER_NONE = 0,
  DOTA_LEAVER_DISCONNECTED = 1,
  DOTA_LEAVER_DISCONNECTED_TOO_LONG = 2,
  DOTA_LEAVER_ABANDONED = 3,
  DOTA_LEAVER_AFK = 4,
  DOTA_LEAVER_NEVER_CONNECTED = 5,
  DOTA_LEAVER_NEVER_CONNECTED_TOO_LONG = 6,
  DOTA_LEAVER_FAILED_TO_READY_UP = 7,
  DOTA_LEAVER_DECLINED = 8
};
bool DOTALeaverStatus_t_IsValid(int value);
constexpr DOTALeaverStatus_t DOTALeaverStatus_t_MIN = DOTA_LEAVER_NONE;
constexpr DOTALeaverStatus_t DOTALeaverStatus_t_MAX = DOTA_LEAVER_DECLINED;
constexpr int DOTALeaverStatus_t_ARRAYSIZE = DOTALeaverStatus_t_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTALeaverStatus_t_descriptor();
template<typename T>
inline const std::string& DOTALeaverStatus_t_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTALeaverStatus_t>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTALeaverStatus_t_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTALeaverStatus_t_descriptor(), enum_t_value);
}
inline bool DOTALeaverStatus_t_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTALeaverStatus_t* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTALeaverStatus_t>(
    DOTALeaverStatus_t_descriptor(), name, value);
}
enum DOTAConnectionState_t : int {
  DOTA_CONNECTION_STATE_UNKNOWN = 0,
  DOTA_CONNECTION_STATE_NOT_YET_CONNECTED = 1,
  DOTA_CONNECTION_STATE_CONNECTED = 2,
  DOTA_CONNECTION_STATE_DISCONNECTED = 3,
  DOTA_CONNECTION_STATE_ABANDONED = 4,
  DOTA_CONNECTION_STATE_LOADING = 5,
  DOTA_CONNECTION_STATE_FAILED = 6
};
bool DOTAConnectionState_t_IsValid(int value);
constexpr DOTAConnectionState_t DOTAConnectionState_t_MIN = DOTA_CONNECTION_STATE_UNKNOWN;
constexpr DOTAConnectionState_t DOTAConnectionState_t_MAX = DOTA_CONNECTION_STATE_FAILED;
constexpr int DOTAConnectionState_t_ARRAYSIZE = DOTAConnectionState_t_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAConnectionState_t_descriptor();
template<typename T>
inline const std::string& DOTAConnectionState_t_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTAConnectionState_t>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTAConnectionState_t_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTAConnectionState_t_descriptor(), enum_t_value);
}
inline bool DOTAConnectionState_t_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTAConnectionState_t* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTAConnectionState_t>(
    DOTAConnectionState_t_descriptor(), name, value);
}
enum Fantasy_Roles : int {
  FANTASY_ROLE_UNDEFINED = 0,
  FANTASY_ROLE_CORE = 1,
  FANTASY_ROLE_SUPPORT = 2,
  FANTASY_ROLE_OFFLANE = 3,
  FANTASY_ROLE_MID = 4
};
bool Fantasy_Roles_IsValid(int value);
constexpr Fantasy_Roles Fantasy_Roles_MIN = FANTASY_ROLE_UNDEFINED;
constexpr Fantasy_Roles Fantasy_Roles_MAX = FANTASY_ROLE_MID;
constexpr int Fantasy_Roles_ARRAYSIZE = Fantasy_Roles_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Fantasy_Roles_descriptor();
template<typename T>
inline const std::string& Fantasy_Roles_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Fantasy_Roles>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Fantasy_Roles_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Fantasy_Roles_descriptor(), enum_t_value);
}
inline bool Fantasy_Roles_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Fantasy_Roles* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Fantasy_Roles>(
    Fantasy_Roles_descriptor(), name, value);
}
enum Fantasy_Team_Slots : int {
  FANTASY_SLOT_NONE = 0,
  FANTASY_SLOT_CORE = 1,
  FANTASY_SLOT_SUPPORT = 2,
  FANTASY_SLOT_ANY = 3,
  FANTASY_SLOT_BENCH = 4
};
bool Fantasy_Team_Slots_IsValid(int value);
constexpr Fantasy_Team_Slots Fantasy_Team_Slots_MIN = FANTASY_SLOT_NONE;
constexpr Fantasy_Team_Slots Fantasy_Team_Slots_MAX = FANTASY_SLOT_BENCH;
constexpr int Fantasy_Team_Slots_ARRAYSIZE = Fantasy_Team_Slots_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Fantasy_Team_Slots_descriptor();
template<typename T>
inline const std::string& Fantasy_Team_Slots_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Fantasy_Team_Slots>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Fantasy_Team_Slots_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Fantasy_Team_Slots_descriptor(), enum_t_value);
}
inline bool Fantasy_Team_Slots_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Fantasy_Team_Slots* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Fantasy_Team_Slots>(
    Fantasy_Team_Slots_descriptor(), name, value);
}
enum Fantasy_Selection_Mode : int {
  FANTASY_SELECTION_INVALID = 0,
  FANTASY_SELECTION_LOCKED = 1,
  FANTASY_SELECTION_SHUFFLE = 2,
  FANTASY_SELECTION_FREE_PICK = 3,
  FANTASY_SELECTION_ENDED = 4,
  FANTASY_SELECTION_PRE_SEASON = 5,
  FANTASY_SELECTION_PRE_DRAFT = 6,
  FANTASY_SELECTION_DRAFTING = 7,
  FANTASY_SELECTION_REGULAR_SEASON = 8,
  FANTASY_SELECTION_CARD_BASED = 9
};
bool Fantasy_Selection_Mode_IsValid(int value);
constexpr Fantasy_Selection_Mode Fantasy_Selection_Mode_MIN = FANTASY_SELECTION_INVALID;
constexpr Fantasy_Selection_Mode Fantasy_Selection_Mode_MAX = FANTASY_SELECTION_CARD_BASED;
constexpr int Fantasy_Selection_Mode_ARRAYSIZE = Fantasy_Selection_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Fantasy_Selection_Mode_descriptor();
template<typename T>
inline const std::string& Fantasy_Selection_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Fantasy_Selection_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Fantasy_Selection_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Fantasy_Selection_Mode_descriptor(), enum_t_value);
}
inline bool Fantasy_Selection_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Fantasy_Selection_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Fantasy_Selection_Mode>(
    Fantasy_Selection_Mode_descriptor(), name, value);
}
enum DOTAChatChannelType_t : int {
  DOTAChannelType_Regional = 0,
  DOTAChannelType_Custom = 1,
  DOTAChannelType_Party = 2,
  DOTAChannelType_Lobby = 3,
  DOTAChannelType_Team = 4,
  DOTAChannelType_Guild = 5,
  DOTAChannelType_Fantasy = 6,
  DOTAChannelType_Whisper = 7,
  DOTAChannelType_Console = 8,
  DOTAChannelType_Tab = 9,
  DOTAChannelType_Invalid = 10,
  DOTAChannelType_GameAll = 11,
  DOTAChannelType_GameAllies = 12,
  DOTAChannelType_GameSpectator = 13,
  DOTAChannelType_GameCoaching = 14,
  DOTAChannelType_Cafe = 15,
  DOTAChannelType_CustomGame = 16,
  DOTAChannelType_Private = 17,
  DOTAChannelType_PostGame = 18,
  DOTAChannelType_BattleCup = 19,
  DOTAChannelType_HLTVSpectator = 20,
  DOTAChannelType_GameEvents = 21,
  DOTAChannelType_Trivia = 22,
  DOTAChannelType_NewPlayer = 23,
  DOTAChannelType_PrivateCoaching = 24
};
bool DOTAChatChannelType_t_IsValid(int value);
constexpr DOTAChatChannelType_t DOTAChatChannelType_t_MIN = DOTAChannelType_Regional;
constexpr DOTAChatChannelType_t DOTAChatChannelType_t_MAX = DOTAChannelType_PrivateCoaching;
constexpr int DOTAChatChannelType_t_ARRAYSIZE = DOTAChatChannelType_t_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAChatChannelType_t_descriptor();
template<typename T>
inline const std::string& DOTAChatChannelType_t_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTAChatChannelType_t>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTAChatChannelType_t_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTAChatChannelType_t_descriptor(), enum_t_value);
}
inline bool DOTAChatChannelType_t_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTAChatChannelType_t* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTAChatChannelType_t>(
    DOTAChatChannelType_t_descriptor(), name, value);
}
enum EChatSpecialPrivileges : int {
  k_EChatSpecialPrivileges_None = 0,
  k_EChatSpecialPrivileges_Moderator = 1,
  k_EChatSpecialPrivileges_SuperModerator = 2
};
bool EChatSpecialPrivileges_IsValid(int value);
constexpr EChatSpecialPrivileges EChatSpecialPrivileges_MIN = k_EChatSpecialPrivileges_None;
constexpr EChatSpecialPrivileges EChatSpecialPrivileges_MAX = k_EChatSpecialPrivileges_SuperModerator;
constexpr int EChatSpecialPrivileges_ARRAYSIZE = EChatSpecialPrivileges_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EChatSpecialPrivileges_descriptor();
template<typename T>
inline const std::string& EChatSpecialPrivileges_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EChatSpecialPrivileges>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EChatSpecialPrivileges_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EChatSpecialPrivileges_descriptor(), enum_t_value);
}
inline bool EChatSpecialPrivileges_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EChatSpecialPrivileges* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EChatSpecialPrivileges>(
    EChatSpecialPrivileges_descriptor(), name, value);
}
enum EProfileCardSlotType : int {
  k_EProfileCardSlotType_Empty = 0,
  k_EProfileCardSlotType_Stat = 1,
  k_EProfileCardSlotType_Trophy = 2,
  k_EProfileCardSlotType_Item = 3,
  k_EProfileCardSlotType_Hero = 4,
  k_EProfileCardSlotType_Emoticon = 5,
  k_EProfileCardSlotType_Team = 6
};
bool EProfileCardSlotType_IsValid(int value);
constexpr EProfileCardSlotType EProfileCardSlotType_MIN = k_EProfileCardSlotType_Empty;
constexpr EProfileCardSlotType EProfileCardSlotType_MAX = k_EProfileCardSlotType_Team;
constexpr int EProfileCardSlotType_ARRAYSIZE = EProfileCardSlotType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EProfileCardSlotType_descriptor();
template<typename T>
inline const std::string& EProfileCardSlotType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EProfileCardSlotType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EProfileCardSlotType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EProfileCardSlotType_descriptor(), enum_t_value);
}
inline bool EProfileCardSlotType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EProfileCardSlotType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EProfileCardSlotType>(
    EProfileCardSlotType_descriptor(), name, value);
}
enum EMatchGroupServerStatus : int {
  k_EMatchGroupServerStatus_OK = 0,
  k_EMatchGroupServerStatus_LimitedAvailability = 1,
  k_EMatchGroupServerStatus_Offline = 2
};
bool EMatchGroupServerStatus_IsValid(int value);
constexpr EMatchGroupServerStatus EMatchGroupServerStatus_MIN = k_EMatchGroupServerStatus_OK;
constexpr EMatchGroupServerStatus EMatchGroupServerStatus_MAX = k_EMatchGroupServerStatus_Offline;
constexpr int EMatchGroupServerStatus_ARRAYSIZE = EMatchGroupServerStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EMatchGroupServerStatus_descriptor();
template<typename T>
inline const std::string& EMatchGroupServerStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EMatchGroupServerStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EMatchGroupServerStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EMatchGroupServerStatus_descriptor(), enum_t_value);
}
inline bool EMatchGroupServerStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EMatchGroupServerStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EMatchGroupServerStatus>(
    EMatchGroupServerStatus_descriptor(), name, value);
}
enum DOTA_CM_PICK : int {
  DOTA_CM_RANDOM = 0,
  DOTA_CM_GOOD_GUYS = 1,
  DOTA_CM_BAD_GUYS = 2
};
bool DOTA_CM_PICK_IsValid(int value);
constexpr DOTA_CM_PICK DOTA_CM_PICK_MIN = DOTA_CM_RANDOM;
constexpr DOTA_CM_PICK DOTA_CM_PICK_MAX = DOTA_CM_BAD_GUYS;
constexpr int DOTA_CM_PICK_ARRAYSIZE = DOTA_CM_PICK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_CM_PICK_descriptor();
template<typename T>
inline const std::string& DOTA_CM_PICK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTA_CM_PICK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTA_CM_PICK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTA_CM_PICK_descriptor(), enum_t_value);
}
inline bool DOTA_CM_PICK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTA_CM_PICK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTA_CM_PICK>(
    DOTA_CM_PICK_descriptor(), name, value);
}
enum DOTALowPriorityBanType : int {
  DOTA_LOW_PRIORITY_BAN_ABANDON = 0,
  DOTA_LOW_PRIORITY_BAN_REPORTS = 1,
  DOTA_LOW_PRIORITY_BAN_SECONDARY_ABANDON = 2,
  DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE = 3
};
bool DOTALowPriorityBanType_IsValid(int value);
constexpr DOTALowPriorityBanType DOTALowPriorityBanType_MIN = DOTA_LOW_PRIORITY_BAN_ABANDON;
constexpr DOTALowPriorityBanType DOTALowPriorityBanType_MAX = DOTA_LOW_PRIORITY_BAN_PRE_GAME_ROLE;
constexpr int DOTALowPriorityBanType_ARRAYSIZE = DOTALowPriorityBanType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTALowPriorityBanType_descriptor();
template<typename T>
inline const std::string& DOTALowPriorityBanType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTALowPriorityBanType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTALowPriorityBanType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTALowPriorityBanType_descriptor(), enum_t_value);
}
inline bool DOTALowPriorityBanType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTALowPriorityBanType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTALowPriorityBanType>(
    DOTALowPriorityBanType_descriptor(), name, value);
}
enum DOTALobbyReadyState : int {
  DOTALobbyReadyState_UNDECLARED = 0,
  DOTALobbyReadyState_ACCEPTED = 1,
  DOTALobbyReadyState_DECLINED = 2
};
bool DOTALobbyReadyState_IsValid(int value);
constexpr DOTALobbyReadyState DOTALobbyReadyState_MIN = DOTALobbyReadyState_UNDECLARED;
constexpr DOTALobbyReadyState DOTALobbyReadyState_MAX = DOTALobbyReadyState_DECLINED;
constexpr int DOTALobbyReadyState_ARRAYSIZE = DOTALobbyReadyState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTALobbyReadyState_descriptor();
template<typename T>
inline const std::string& DOTALobbyReadyState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTALobbyReadyState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTALobbyReadyState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTALobbyReadyState_descriptor(), enum_t_value);
}
inline bool DOTALobbyReadyState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTALobbyReadyState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTALobbyReadyState>(
    DOTALobbyReadyState_descriptor(), name, value);
}
enum DOTAJoinLobbyResult : int {
  DOTA_JOIN_RESULT_SUCCESS = 0,
  DOTA_JOIN_RESULT_ALREADY_IN_GAME = 1,
  DOTA_JOIN_RESULT_INVALID_LOBBY = 2,
  DOTA_JOIN_RESULT_INCORRECT_PASSWORD = 3,
  DOTA_JOIN_RESULT_ACCESS_DENIED = 4,
  DOTA_JOIN_RESULT_GENERIC_ERROR = 5,
  DOTA_JOIN_RESULT_INCORRECT_VERSION = 6,
  DOTA_JOIN_RESULT_IN_TEAM_PARTY = 7,
  DOTA_JOIN_RESULT_NO_LOBBY_FOUND = 8,
  DOTA_JOIN_RESULT_LOBBY_FULL = 9,
  DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT_VERSION = 10,
  DOTA_JOIN_RESULT_TIMEOUT = 11,
  DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOWN = 12,
  DOTA_JOIN_RESULT_BUSY = 13,
  DOTA_JOIN_RESULT_NO_PLAYTIME = 14
};
bool DOTAJoinLobbyResult_IsValid(int value);
constexpr DOTAJoinLobbyResult DOTAJoinLobbyResult_MIN = DOTA_JOIN_RESULT_SUCCESS;
constexpr DOTAJoinLobbyResult DOTAJoinLobbyResult_MAX = DOTA_JOIN_RESULT_NO_PLAYTIME;
constexpr int DOTAJoinLobbyResult_ARRAYSIZE = DOTAJoinLobbyResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAJoinLobbyResult_descriptor();
template<typename T>
inline const std::string& DOTAJoinLobbyResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTAJoinLobbyResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTAJoinLobbyResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTAJoinLobbyResult_descriptor(), enum_t_value);
}
inline bool DOTAJoinLobbyResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTAJoinLobbyResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTAJoinLobbyResult>(
    DOTAJoinLobbyResult_descriptor(), name, value);
}
enum DOTASelectionPriorityRules : int {
  k_DOTASelectionPriorityRules_Manual = 0,
  k_DOTASelectionPriorityRules_Automatic = 1
};
bool DOTASelectionPriorityRules_IsValid(int value);
constexpr DOTASelectionPriorityRules DOTASelectionPriorityRules_MIN = k_DOTASelectionPriorityRules_Manual;
constexpr DOTASelectionPriorityRules DOTASelectionPriorityRules_MAX = k_DOTASelectionPriorityRules_Automatic;
constexpr int DOTASelectionPriorityRules_ARRAYSIZE = DOTASelectionPriorityRules_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTASelectionPriorityRules_descriptor();
template<typename T>
inline const std::string& DOTASelectionPriorityRules_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTASelectionPriorityRules>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTASelectionPriorityRules_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTASelectionPriorityRules_descriptor(), enum_t_value);
}
inline bool DOTASelectionPriorityRules_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTASelectionPriorityRules* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTASelectionPriorityRules>(
    DOTASelectionPriorityRules_descriptor(), name, value);
}
enum DOTASelectionPriorityChoice : int {
  k_DOTASelectionPriorityChoice_Invalid = 0,
  k_DOTASelectionPriorityChoice_FirstPick = 1,
  k_DOTASelectionPriorityChoice_SecondPick = 2,
  k_DOTASelectionPriorityChoice_Radiant = 3,
  k_DOTASelectionPriorityChoice_Dire = 4
};
bool DOTASelectionPriorityChoice_IsValid(int value);
constexpr DOTASelectionPriorityChoice DOTASelectionPriorityChoice_MIN = k_DOTASelectionPriorityChoice_Invalid;
constexpr DOTASelectionPriorityChoice DOTASelectionPriorityChoice_MAX = k_DOTASelectionPriorityChoice_Dire;
constexpr int DOTASelectionPriorityChoice_ARRAYSIZE = DOTASelectionPriorityChoice_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTASelectionPriorityChoice_descriptor();
template<typename T>
inline const std::string& DOTASelectionPriorityChoice_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTASelectionPriorityChoice>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTASelectionPriorityChoice_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTASelectionPriorityChoice_descriptor(), enum_t_value);
}
inline bool DOTASelectionPriorityChoice_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTASelectionPriorityChoice* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTASelectionPriorityChoice>(
    DOTASelectionPriorityChoice_descriptor(), name, value);
}
enum DOTAMatchVote : int {
  DOTAMatchVote_INVALID = 0,
  DOTAMatchVote_POSITIVE = 1,
  DOTAMatchVote_NEGATIVE = 2
};
bool DOTAMatchVote_IsValid(int value);
constexpr DOTAMatchVote DOTAMatchVote_MIN = DOTAMatchVote_INVALID;
constexpr DOTAMatchVote DOTAMatchVote_MAX = DOTAMatchVote_NEGATIVE;
constexpr int DOTAMatchVote_ARRAYSIZE = DOTAMatchVote_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAMatchVote_descriptor();
template<typename T>
inline const std::string& DOTAMatchVote_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTAMatchVote>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTAMatchVote_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTAMatchVote_descriptor(), enum_t_value);
}
inline bool DOTAMatchVote_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTAMatchVote* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTAMatchVote>(
    DOTAMatchVote_descriptor(), name, value);
}
enum DOTALobbyVisibility : int {
  DOTALobbyVisibility_Public = 0,
  DOTALobbyVisibility_Friends = 1,
  DOTALobbyVisibility_Unlisted = 2
};
bool DOTALobbyVisibility_IsValid(int value);
constexpr DOTALobbyVisibility DOTALobbyVisibility_MIN = DOTALobbyVisibility_Public;
constexpr DOTALobbyVisibility DOTALobbyVisibility_MAX = DOTALobbyVisibility_Unlisted;
constexpr int DOTALobbyVisibility_ARRAYSIZE = DOTALobbyVisibility_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTALobbyVisibility_descriptor();
template<typename T>
inline const std::string& DOTALobbyVisibility_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTALobbyVisibility>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTALobbyVisibility_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTALobbyVisibility_descriptor(), enum_t_value);
}
inline bool DOTALobbyVisibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTALobbyVisibility* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTALobbyVisibility>(
    DOTALobbyVisibility_descriptor(), name, value);
}
enum EDOTAPlayerMMRType : int {
  k_EDOTAPlayerMMRType_Invalid = 0,
  k_EDOTAPlayerMMRType_GeneralHidden = 1,
  k_EDOTAPlayerMMRType_GeneralCompetitive = 3
};
bool EDOTAPlayerMMRType_IsValid(int value);
constexpr EDOTAPlayerMMRType EDOTAPlayerMMRType_MIN = k_EDOTAPlayerMMRType_Invalid;
constexpr EDOTAPlayerMMRType EDOTAPlayerMMRType_MAX = k_EDOTAPlayerMMRType_GeneralCompetitive;
constexpr int EDOTAPlayerMMRType_ARRAYSIZE = EDOTAPlayerMMRType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDOTAPlayerMMRType_descriptor();
template<typename T>
inline const std::string& EDOTAPlayerMMRType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EDOTAPlayerMMRType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EDOTAPlayerMMRType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EDOTAPlayerMMRType_descriptor(), enum_t_value);
}
inline bool EDOTAPlayerMMRType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EDOTAPlayerMMRType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EDOTAPlayerMMRType>(
    EDOTAPlayerMMRType_descriptor(), name, value);
}
enum EDOTAMMRBoostType : int {
  k_EDOTAMMRBoostType_None = 0,
  k_EDOTAMMRBoostType_Leader = 1,
  k_EDOTAMMRBoostType_Follower = 2
};
bool EDOTAMMRBoostType_IsValid(int value);
constexpr EDOTAMMRBoostType EDOTAMMRBoostType_MIN = k_EDOTAMMRBoostType_None;
constexpr EDOTAMMRBoostType EDOTAMMRBoostType_MAX = k_EDOTAMMRBoostType_Follower;
constexpr int EDOTAMMRBoostType_ARRAYSIZE = EDOTAMMRBoostType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDOTAMMRBoostType_descriptor();
template<typename T>
inline const std::string& EDOTAMMRBoostType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EDOTAMMRBoostType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EDOTAMMRBoostType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EDOTAMMRBoostType_descriptor(), enum_t_value);
}
inline bool EDOTAMMRBoostType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EDOTAMMRBoostType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EDOTAMMRBoostType>(
    EDOTAMMRBoostType_descriptor(), name, value);
}
enum MatchType : int {
  MATCH_TYPE_CASUAL = 0,
  MATCH_TYPE_COOP_BOTS = 1,
  MATCH_TYPE_COMPETITIVE = 4,
  MATCH_TYPE_WEEKEND_TOURNEY = 5,
  MATCH_TYPE_EVENT = 7,
  MATCH_TYPE_COACHES_CHALLENGE = 12,
  MATCH_TYPE_NEW_PLAYER_POOL = 14
};
bool MatchType_IsValid(int value);
constexpr MatchType MatchType_MIN = MATCH_TYPE_CASUAL;
constexpr MatchType MatchType_MAX = MATCH_TYPE_NEW_PLAYER_POOL;
constexpr int MatchType_ARRAYSIZE = MatchType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchType_descriptor();
template<typename T>
inline const std::string& MatchType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MatchType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MatchType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MatchType_descriptor(), enum_t_value);
}
inline bool MatchType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MatchType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MatchType>(
    MatchType_descriptor(), name, value);
}
enum DOTABotDifficulty : int {
  BOT_DIFFICULTY_PASSIVE = 0,
  BOT_DIFFICULTY_EASY = 1,
  BOT_DIFFICULTY_MEDIUM = 2,
  BOT_DIFFICULTY_HARD = 3,
  BOT_DIFFICULTY_UNFAIR = 4,
  BOT_DIFFICULTY_INVALID = 5,
  BOT_DIFFICULTY_EXTRA1 = 6,
  BOT_DIFFICULTY_EXTRA2 = 7,
  BOT_DIFFICULTY_EXTRA3 = 8,
  BOT_DIFFICULTY_NPX = 9
};
bool DOTABotDifficulty_IsValid(int value);
constexpr DOTABotDifficulty DOTABotDifficulty_MIN = BOT_DIFFICULTY_PASSIVE;
constexpr DOTABotDifficulty DOTABotDifficulty_MAX = BOT_DIFFICULTY_NPX;
constexpr int DOTABotDifficulty_ARRAYSIZE = DOTABotDifficulty_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTABotDifficulty_descriptor();
template<typename T>
inline const std::string& DOTABotDifficulty_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTABotDifficulty>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTABotDifficulty_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTABotDifficulty_descriptor(), enum_t_value);
}
inline bool DOTABotDifficulty_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTABotDifficulty* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTABotDifficulty>(
    DOTABotDifficulty_descriptor(), name, value);
}
enum DOTA_BOT_MODE : int {
  DOTA_BOT_MODE_NONE = 0,
  DOTA_BOT_MODE_LANING = 1,
  DOTA_BOT_MODE_ATTACK = 2,
  DOTA_BOT_MODE_ROAM = 3,
  DOTA_BOT_MODE_RETREAT = 4,
  DOTA_BOT_MODE_SECRET_SHOP = 5,
  DOTA_BOT_MODE_SIDE_SHOP = 6,
  DOTA_BOT_MODE_RUNE = 7,
  DOTA_BOT_MODE_PUSH_TOWER_TOP = 8,
  DOTA_BOT_MODE_PUSH_TOWER_MID = 9,
  DOTA_BOT_MODE_PUSH_TOWER_BOT = 10,
  DOTA_BOT_MODE_DEFEND_TOWER_TOP = 11,
  DOTA_BOT_MODE_DEFEND_TOWER_MID = 12,
  DOTA_BOT_MODE_DEFEND_TOWER_BOT = 13,
  DOTA_BOT_MODE_ASSEMBLE = 14,
  DOTA_BOT_MODE_ASSEMBLE_WITH_HUMANS = 15,
  DOTA_BOT_MODE_TEAM_ROAM = 16,
  DOTA_BOT_MODE_FARM = 17,
  DOTA_BOT_MODE_DEFEND_ALLY = 18,
  DOTA_BOT_MODE_EVASIVE_MANEUVERS = 19,
  DOTA_BOT_MODE_ROSHAN = 20,
  DOTA_BOT_MODE_ITEM = 21,
  DOTA_BOT_MODE_WARD = 22,
  DOTA_BOT_MODE_COMPANION = 23,
  DOTA_BOT_MODE_TUTORIAL_BOSS = 24,
  DOTA_BOT_MODE_MINION = 25,
  DOTA_BOT_MODE_OUTPOST = 26
};
bool DOTA_BOT_MODE_IsValid(int value);
constexpr DOTA_BOT_MODE DOTA_BOT_MODE_MIN = DOTA_BOT_MODE_NONE;
constexpr DOTA_BOT_MODE DOTA_BOT_MODE_MAX = DOTA_BOT_MODE_OUTPOST;
constexpr int DOTA_BOT_MODE_ARRAYSIZE = DOTA_BOT_MODE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_BOT_MODE_descriptor();
template<typename T>
inline const std::string& DOTA_BOT_MODE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTA_BOT_MODE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTA_BOT_MODE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTA_BOT_MODE_descriptor(), enum_t_value);
}
inline bool DOTA_BOT_MODE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTA_BOT_MODE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTA_BOT_MODE>(
    DOTA_BOT_MODE_descriptor(), name, value);
}
enum MatchLanguages : int {
  MATCH_LANGUAGE_INVALID = 0,
  MATCH_LANGUAGE_ENGLISH = 1,
  MATCH_LANGUAGE_RUSSIAN = 2,
  MATCH_LANGUAGE_CHINESE = 3,
  MATCH_LANGUAGE_KOREAN = 4,
  MATCH_LANGUAGE_SPANISH = 5,
  MATCH_LANGUAGE_PORTUGUESE = 6,
  MATCH_LANGUAGE_ENGLISH2 = 7
};
bool MatchLanguages_IsValid(int value);
constexpr MatchLanguages MatchLanguages_MIN = MATCH_LANGUAGE_INVALID;
constexpr MatchLanguages MatchLanguages_MAX = MATCH_LANGUAGE_ENGLISH2;
constexpr int MatchLanguages_ARRAYSIZE = MatchLanguages_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchLanguages_descriptor();
template<typename T>
inline const std::string& MatchLanguages_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MatchLanguages>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MatchLanguages_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MatchLanguages_descriptor(), enum_t_value);
}
inline bool MatchLanguages_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MatchLanguages* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MatchLanguages>(
    MatchLanguages_descriptor(), name, value);
}
enum ETourneyQueueDeadlineState : int {
  k_ETourneyQueueDeadlineState_Normal = 0,
  k_ETourneyQueueDeadlineState_Missed = 1,
  k_ETourneyQueueDeadlineState_ExpiredOK = 2,
  k_ETourneyQueueDeadlineState_SeekingBye = 3,
  k_ETourneyQueueDeadlineState_EligibleForRefund = 4,
  k_ETourneyQueueDeadlineState_NA = -1,
  k_ETourneyQueueDeadlineState_ExpiringSoon = 101
};
bool ETourneyQueueDeadlineState_IsValid(int value);
constexpr ETourneyQueueDeadlineState ETourneyQueueDeadlineState_MIN = k_ETourneyQueueDeadlineState_NA;
constexpr ETourneyQueueDeadlineState ETourneyQueueDeadlineState_MAX = k_ETourneyQueueDeadlineState_ExpiringSoon;
constexpr int ETourneyQueueDeadlineState_ARRAYSIZE = ETourneyQueueDeadlineState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETourneyQueueDeadlineState_descriptor();
template<typename T>
inline const std::string& ETourneyQueueDeadlineState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ETourneyQueueDeadlineState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ETourneyQueueDeadlineState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ETourneyQueueDeadlineState_descriptor(), enum_t_value);
}
inline bool ETourneyQueueDeadlineState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ETourneyQueueDeadlineState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ETourneyQueueDeadlineState>(
    ETourneyQueueDeadlineState_descriptor(), name, value);
}
enum EMatchOutcome : int {
  k_EMatchOutcome_Unknown = 0,
  k_EMatchOutcome_RadVictory = 2,
  k_EMatchOutcome_DireVictory = 3,
  k_EMatchOutcome_NeutralVictory = 4,
  k_EMatchOutcome_NoTeamWinner = 5,
  k_EMatchOutcome_Custom1Victory = 6,
  k_EMatchOutcome_Custom2Victory = 7,
  k_EMatchOutcome_Custom3Victory = 8,
  k_EMatchOutcome_Custom4Victory = 9,
  k_EMatchOutcome_Custom5Victory = 10,
  k_EMatchOutcome_Custom6Victory = 11,
  k_EMatchOutcome_Custom7Victory = 12,
  k_EMatchOutcome_Custom8Victory = 13,
  k_EMatchOutcome_NotScored_PoorNetworkConditions = 64,
  k_EMatchOutcome_NotScored_Leaver = 65,
  k_EMatchOutcome_NotScored_ServerCrash = 66,
  k_EMatchOutcome_NotScored_NeverStarted = 67,
  k_EMatchOutcome_NotScored_Canceled = 68,
  k_EMatchOutcome_NotScored_Suspicious = 69
};
bool EMatchOutcome_IsValid(int value);
constexpr EMatchOutcome EMatchOutcome_MIN = k_EMatchOutcome_Unknown;
constexpr EMatchOutcome EMatchOutcome_MAX = k_EMatchOutcome_NotScored_Suspicious;
constexpr int EMatchOutcome_ARRAYSIZE = EMatchOutcome_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EMatchOutcome_descriptor();
template<typename T>
inline const std::string& EMatchOutcome_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EMatchOutcome>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EMatchOutcome_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EMatchOutcome_descriptor(), enum_t_value);
}
inline bool EMatchOutcome_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EMatchOutcome* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EMatchOutcome>(
    EMatchOutcome_descriptor(), name, value);
}
enum ELaneType : int {
  LANE_TYPE_UNKNOWN = 0,
  LANE_TYPE_SAFE = 1,
  LANE_TYPE_OFF = 2,
  LANE_TYPE_MID = 3,
  LANE_TYPE_JUNGLE = 4,
  LANE_TYPE_ROAM = 5
};
bool ELaneType_IsValid(int value);
constexpr ELaneType ELaneType_MIN = LANE_TYPE_UNKNOWN;
constexpr ELaneType ELaneType_MAX = LANE_TYPE_ROAM;
constexpr int ELaneType_ARRAYSIZE = ELaneType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELaneType_descriptor();
template<typename T>
inline const std::string& ELaneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELaneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELaneType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELaneType_descriptor(), enum_t_value);
}
inline bool ELaneType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELaneType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELaneType>(
    ELaneType_descriptor(), name, value);
}
enum EBadgeType : int {
  k_EBadgeType_TI7_Midweek = 1,
  k_EBadgeType_TI7_Finals = 2,
  k_EBadgeType_TI7_AllEvent = 3,
  k_EBadgeType_TI8_Midweek = 4,
  k_EBadgeType_TI8_Finals = 5,
  k_EBadgeType_TI8_AllEvent = 6,
  k_EBadgeType_TI10 = 7,
  k_EBadgeType_TI11_PlayoffsDay1 = 8,
  k_EBadgeType_TI11_PlayoffsDay2 = 9,
  k_EBadgeType_TI11_PlayoffsDay3 = 10,
  k_EBadgeType_TI11_PlayoffsDay4 = 11,
  k_EBadgeType_TI11_FinalsWeekend = 12
};
bool EBadgeType_IsValid(int value);
constexpr EBadgeType EBadgeType_MIN = k_EBadgeType_TI7_Midweek;
constexpr EBadgeType EBadgeType_MAX = k_EBadgeType_TI11_FinalsWeekend;
constexpr int EBadgeType_ARRAYSIZE = EBadgeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBadgeType_descriptor();
template<typename T>
inline const std::string& EBadgeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBadgeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBadgeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBadgeType_descriptor(), enum_t_value);
}
inline bool EBadgeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBadgeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBadgeType>(
    EBadgeType_descriptor(), name, value);
}
enum ELeagueStatus : int {
  LEAGUE_STATUS_UNSET = 0,
  LEAGUE_STATUS_UNSUBMITTED = 1,
  LEAGUE_STATUS_SUBMITTED = 2,
  LEAGUE_STATUS_ACCEPTED = 3,
  LEAGUE_STATUS_REJECTED = 4,
  LEAGUE_STATUS_CONCLUDED = 5,
  LEAGUE_STATUS_DELETED = 6
};
bool ELeagueStatus_IsValid(int value);
constexpr ELeagueStatus ELeagueStatus_MIN = LEAGUE_STATUS_UNSET;
constexpr ELeagueStatus ELeagueStatus_MAX = LEAGUE_STATUS_DELETED;
constexpr int ELeagueStatus_ARRAYSIZE = ELeagueStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueStatus_descriptor();
template<typename T>
inline const std::string& ELeagueStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELeagueStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELeagueStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELeagueStatus_descriptor(), enum_t_value);
}
inline bool ELeagueStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELeagueStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELeagueStatus>(
    ELeagueStatus_descriptor(), name, value);
}
enum ELeagueRegion : int {
  LEAGUE_REGION_UNSET = 0,
  LEAGUE_REGION_NA = 1,
  LEAGUE_REGION_SA = 2,
  LEAGUE_REGION_WEU = 3,
  LEAGUE_REGION_EEU = 4,
  LEAGUE_REGION_CHINA = 5,
  LEAGUE_REGION_SEA = 6
};
bool ELeagueRegion_IsValid(int value);
constexpr ELeagueRegion ELeagueRegion_MIN = LEAGUE_REGION_UNSET;
constexpr ELeagueRegion ELeagueRegion_MAX = LEAGUE_REGION_SEA;
constexpr int ELeagueRegion_ARRAYSIZE = ELeagueRegion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueRegion_descriptor();
template<typename T>
inline const std::string& ELeagueRegion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELeagueRegion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELeagueRegion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELeagueRegion_descriptor(), enum_t_value);
}
inline bool ELeagueRegion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELeagueRegion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELeagueRegion>(
    ELeagueRegion_descriptor(), name, value);
}
enum ELeagueTier : int {
  LEAGUE_TIER_UNSET = 0,
  LEAGUE_TIER_AMATEUR = 1,
  LEAGUE_TIER_PROFESSIONAL = 2,
  LEAGUE_TIER_MINOR = 3,
  LEAGUE_TIER_MAJOR = 4,
  LEAGUE_TIER_INTERNATIONAL = 5,
  LEAGUE_TIER_DPC_QUALIFIER = 6,
  LEAGUE_TIER_DPC_LEAGUE_QUALIFIER = 7,
  LEAGUE_TIER_DPC_LEAGUE = 8,
  LEAGUE_TIER_DPC_LEAGUE_FINALS = 9
};
bool ELeagueTier_IsValid(int value);
constexpr ELeagueTier ELeagueTier_MIN = LEAGUE_TIER_UNSET;
constexpr ELeagueTier ELeagueTier_MAX = LEAGUE_TIER_DPC_LEAGUE_FINALS;
constexpr int ELeagueTier_ARRAYSIZE = ELeagueTier_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueTier_descriptor();
template<typename T>
inline const std::string& ELeagueTier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELeagueTier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELeagueTier_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELeagueTier_descriptor(), enum_t_value);
}
inline bool ELeagueTier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELeagueTier* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELeagueTier>(
    ELeagueTier_descriptor(), name, value);
}
enum ELeagueTierCategory : int {
  LEAGUE_TIER_CATEGORY_AMATEUR = 1,
  LEAGUE_TIER_CATEGORY_PROFESSIONAL = 2,
  LEAGUE_TIER_CATEGORY_DPC = 3
};
bool ELeagueTierCategory_IsValid(int value);
constexpr ELeagueTierCategory ELeagueTierCategory_MIN = LEAGUE_TIER_CATEGORY_AMATEUR;
constexpr ELeagueTierCategory ELeagueTierCategory_MAX = LEAGUE_TIER_CATEGORY_DPC;
constexpr int ELeagueTierCategory_ARRAYSIZE = ELeagueTierCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueTierCategory_descriptor();
template<typename T>
inline const std::string& ELeagueTierCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELeagueTierCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELeagueTierCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELeagueTierCategory_descriptor(), enum_t_value);
}
inline bool ELeagueTierCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELeagueTierCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELeagueTierCategory>(
    ELeagueTierCategory_descriptor(), name, value);
}
enum ELeagueDivision : int {
  LEAGUE_DIVISION_UNSET = 0,
  LEAGUE_DIVISION_I = 1,
  LEAGUE_DIVISION_II = 2
};
bool ELeagueDivision_IsValid(int value);
constexpr ELeagueDivision ELeagueDivision_MIN = LEAGUE_DIVISION_UNSET;
constexpr ELeagueDivision ELeagueDivision_MAX = LEAGUE_DIVISION_II;
constexpr int ELeagueDivision_ARRAYSIZE = ELeagueDivision_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueDivision_descriptor();
template<typename T>
inline const std::string& ELeagueDivision_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELeagueDivision>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELeagueDivision_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELeagueDivision_descriptor(), enum_t_value);
}
inline bool ELeagueDivision_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELeagueDivision* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELeagueDivision>(
    ELeagueDivision_descriptor(), name, value);
}
enum ELeagueBroadcastProvider : int {
  LEAGUE_BROADCAST_UNKNOWN = 0,
  LEAGUE_BROADCAST_STEAM = 1,
  LEAGUE_BROADCAST_TWITCH = 2,
  LEAGUE_BROADCAST_YOUTUBE = 3,
  LEAGUE_BROADCAST_OTHER = 100
};
bool ELeagueBroadcastProvider_IsValid(int value);
constexpr ELeagueBroadcastProvider ELeagueBroadcastProvider_MIN = LEAGUE_BROADCAST_UNKNOWN;
constexpr ELeagueBroadcastProvider ELeagueBroadcastProvider_MAX = LEAGUE_BROADCAST_OTHER;
constexpr int ELeagueBroadcastProvider_ARRAYSIZE = ELeagueBroadcastProvider_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueBroadcastProvider_descriptor();
template<typename T>
inline const std::string& ELeagueBroadcastProvider_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELeagueBroadcastProvider>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELeagueBroadcastProvider_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELeagueBroadcastProvider_descriptor(), enum_t_value);
}
inline bool ELeagueBroadcastProvider_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELeagueBroadcastProvider* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELeagueBroadcastProvider>(
    ELeagueBroadcastProvider_descriptor(), name, value);
}
enum ELeaguePhase : int {
  LEAGUE_PHASE_UNSET = 0,
  LEAGUE_PHASE_REGIONAL_QUALIFIER = 1,
  LEAGUE_PHASE_GROUP_STAGE = 2,
  LEAGUE_PHASE_MAIN_EVENT = 3
};
bool ELeaguePhase_IsValid(int value);
constexpr ELeaguePhase ELeaguePhase_MIN = LEAGUE_PHASE_UNSET;
constexpr ELeaguePhase ELeaguePhase_MAX = LEAGUE_PHASE_MAIN_EVENT;
constexpr int ELeaguePhase_ARRAYSIZE = ELeaguePhase_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeaguePhase_descriptor();
template<typename T>
inline const std::string& ELeaguePhase_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELeaguePhase>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELeaguePhase_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELeaguePhase_descriptor(), enum_t_value);
}
inline bool ELeaguePhase_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELeaguePhase* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELeaguePhase>(
    ELeaguePhase_descriptor(), name, value);
}
enum ELeagueAuditAction : int {
  LEAGUE_AUDIT_ACTION_INVALID = 0,
  LEAGUE_AUDIT_ACTION_LEAGUE_CREATE = 1,
  LEAGUE_AUDIT_ACTION_LEAGUE_EDIT = 2,
  LEAGUE_AUDIT_ACTION_LEAGUE_DELETE = 3,
  LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD = 4,
  LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOKE = 5,
  LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_PROMOTE = 6,
  LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_ADD = 7,
  LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_REMOVE = 8,
  LEAGUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED = 9,
  LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_ADDED = 10,
  LEAGUE_AUDIT_ACTION_LEAGUE_SUBMITTED = 11,
  LEAGUE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL = 12,
  LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_POOL_ITEM = 13,
  LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM = 14,
  LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_START = 15,
  LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_END = 16,
  LEAGUE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM = 17,
  LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_INVITED_TEAM = 18,
  LEAGUE_AUDIT_ACTION_LEAGUE_STATUS_CHANGED = 19,
  LEAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT = 20,
  LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP = 21,
  LEAGUE_AUDIT_ACTION_NODEGROUP_CREATE = 100,
  LEAGUE_AUDIT_ACTION_NODEGROUP_DESTROY = 101,
  LEAGUE_AUDIT_ACTION_NODEGROUP_ADD_TEAM = 102,
  LEAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM = 103,
  LEAGUE_AUDIT_ACTION_NODEGROUP_SET_ADVANCING = 104,
  LEAGUE_AUDIT_ACTION_NODEGROUP_EDIT = 105,
  LEAGUE_AUDIT_ACTION_NODEGROUP_POPULATE = 106,
  LEAGUE_AUDIT_ACTION_NODEGROUP_COMPLETED = 107,
  LEAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDARY_ADVANCING = 108,
  LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TERTIARY_ADVANCING = 109,
  LEAGUE_AUDIT_ACTION_NODE_CREATE = 200,
  LEAGUE_AUDIT_ACTION_NODE_DESTROY = 201,
  LEAGUE_AUDIT_ACTION_NODE_AUTOCREATE = 202,
  LEAGUE_AUDIT_ACTION_NODE_SET_TEAM = 203,
  LEAGUE_AUDIT_ACTION_NODE_SET_SERIES_ID = 204,
  LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING = 205,
  LEAGUE_AUDIT_ACTION_NODE_SET_TIME = 206,
  LEAGUE_AUDIT_ACTION_NODE_MATCH_COMPLETED = 207,
  LEAGUE_AUDIT_ACTION_NODE_COMPLETED = 208,
  LEAGUE_AUDIT_ACTION_NODE_EDIT = 209
};
bool ELeagueAuditAction_IsValid(int value);
constexpr ELeagueAuditAction ELeagueAuditAction_MIN = LEAGUE_AUDIT_ACTION_INVALID;
constexpr ELeagueAuditAction ELeagueAuditAction_MAX = LEAGUE_AUDIT_ACTION_NODE_EDIT;
constexpr int ELeagueAuditAction_ARRAYSIZE = ELeagueAuditAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueAuditAction_descriptor();
template<typename T>
inline const std::string& ELeagueAuditAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELeagueAuditAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELeagueAuditAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELeagueAuditAction_descriptor(), enum_t_value);
}
inline bool ELeagueAuditAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELeagueAuditAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELeagueAuditAction>(
    ELeagueAuditAction_descriptor(), name, value);
}
enum DOTA_COMBATLOG_TYPES : int {
  DOTA_COMBATLOG_INVALID = -1,
  DOTA_COMBATLOG_DAMAGE = 0,
  DOTA_COMBATLOG_HEAL = 1,
  DOTA_COMBATLOG_MODIFIER_ADD = 2,
  DOTA_COMBATLOG_MODIFIER_REMOVE = 3,
  DOTA_COMBATLOG_DEATH = 4,
  DOTA_COMBATLOG_ABILITY = 5,
  DOTA_COMBATLOG_ITEM = 6,
  DOTA_COMBATLOG_LOCATION = 7,
  DOTA_COMBATLOG_GOLD = 8,
  DOTA_COMBATLOG_GAME_STATE = 9,
  DOTA_COMBATLOG_XP = 10,
  DOTA_COMBATLOG_PURCHASE = 11,
  DOTA_COMBATLOG_BUYBACK = 12,
  DOTA_COMBATLOG_ABILITY_TRIGGER = 13,
  DOTA_COMBATLOG_PLAYERSTATS = 14,
  DOTA_COMBATLOG_MULTIKILL = 15,
  DOTA_COMBATLOG_KILLSTREAK = 16,
  DOTA_COMBATLOG_TEAM_BUILDING_KILL = 17,
  DOTA_COMBATLOG_FIRST_BLOOD = 18,
  DOTA_COMBATLOG_MODIFIER_STACK_EVENT = 19,
  DOTA_COMBATLOG_NEUTRAL_CAMP_STACK = 20,
  DOTA_COMBATLOG_PICKUP_RUNE = 21,
  DOTA_COMBATLOG_REVEALED_INVISIBLE = 22,
  DOTA_COMBATLOG_HERO_SAVED = 23,
  DOTA_COMBATLOG_MANA_RESTORED = 24,
  DOTA_COMBATLOG_HERO_LEVELUP = 25,
  DOTA_COMBATLOG_BOTTLE_HEAL_ALLY = 26,
  DOTA_COMBATLOG_ENDGAME_STATS = 27,
  DOTA_COMBATLOG_INTERRUPT_CHANNEL = 28,
  DOTA_COMBATLOG_ALLIED_GOLD = 29,
  DOTA_COMBATLOG_AEGIS_TAKEN = 30,
  DOTA_COMBATLOG_MANA_DAMAGE = 31,
  DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED = 32,
  DOTA_COMBATLOG_UNIT_SUMMONED = 33,
  DOTA_COMBATLOG_ATTACK_EVADE = 34,
  DOTA_COMBATLOG_TREE_CUT = 35,
  DOTA_COMBATLOG_SUCCESSFUL_SCAN = 36,
  DOTA_COMBATLOG_END_KILLSTREAK = 37,
  DOTA_COMBATLOG_BLOODSTONE_CHARGE = 38,
  DOTA_COMBATLOG_CRITICAL_DAMAGE = 39,
  DOTA_COMBATLOG_SPELL_ABSORB = 40,
  DOTA_COMBATLOG_UNIT_TELEPORTED = 41,
  DOTA_COMBATLOG_KILL_EATER_EVENT = 42,
  DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED = 43
};
bool DOTA_COMBATLOG_TYPES_IsValid(int value);
constexpr DOTA_COMBATLOG_TYPES DOTA_COMBATLOG_TYPES_MIN = DOTA_COMBATLOG_INVALID;
constexpr DOTA_COMBATLOG_TYPES DOTA_COMBATLOG_TYPES_MAX = DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED;
constexpr int DOTA_COMBATLOG_TYPES_ARRAYSIZE = DOTA_COMBATLOG_TYPES_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_COMBATLOG_TYPES_descriptor();
template<typename T>
inline const std::string& DOTA_COMBATLOG_TYPES_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DOTA_COMBATLOG_TYPES>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DOTA_COMBATLOG_TYPES_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DOTA_COMBATLOG_TYPES_descriptor(), enum_t_value);
}
inline bool DOTA_COMBATLOG_TYPES_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DOTA_COMBATLOG_TYPES* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DOTA_COMBATLOG_TYPES>(
    DOTA_COMBATLOG_TYPES_descriptor(), name, value);
}
enum EDPCFavoriteType : int {
  FAVORITE_TYPE_ALL = 0,
  FAVORITE_TYPE_PLAYER = 1,
  FAVORITE_TYPE_TEAM = 2,
  FAVORITE_TYPE_LEAGUE = 3
};
bool EDPCFavoriteType_IsValid(int value);
constexpr EDPCFavoriteType EDPCFavoriteType_MIN = FAVORITE_TYPE_ALL;
constexpr EDPCFavoriteType EDPCFavoriteType_MAX = FAVORITE_TYPE_LEAGUE;
constexpr int EDPCFavoriteType_ARRAYSIZE = EDPCFavoriteType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDPCFavoriteType_descriptor();
template<typename T>
inline const std::string& EDPCFavoriteType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EDPCFavoriteType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EDPCFavoriteType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EDPCFavoriteType_descriptor(), enum_t_value);
}
inline bool EDPCFavoriteType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EDPCFavoriteType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EDPCFavoriteType>(
    EDPCFavoriteType_descriptor(), name, value);
}
enum EDPCPushNotification : int {
  DPC_PUSH_NOTIFICATION_MATCH_STARTING = 1,
  DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM = 10,
  DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM = 11,
  DPC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_AS_COACH = 12,
  DPC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS_COACH = 13,
  DPC_PUSH_NOTIFICATION_LEAGUE_RESULT = 20,
  DPC_PUSH_NOTIFICATION_PREDICTION_MATCHES_AVAILABLE = 30,
  DPC_PUSH_NOTIFICATION_PREDICTION_RESULT = 31,
  DPC_PUSH_NOTIFICATION_FANTASY_PLAYER_CLEARED = 40,
  DPC_PUSH_NOTIFICATION_FANTASY_DAILY_SUMMARY = 41,
  DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS = 42
};
bool EDPCPushNotification_IsValid(int value);
constexpr EDPCPushNotification EDPCPushNotification_MIN = DPC_PUSH_NOTIFICATION_MATCH_STARTING;
constexpr EDPCPushNotification EDPCPushNotification_MAX = DPC_PUSH_NOTIFICATION_FANTASY_FINAL_RESULTS;
constexpr int EDPCPushNotification_ARRAYSIZE = EDPCPushNotification_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDPCPushNotification_descriptor();
template<typename T>
inline const std::string& EDPCPushNotification_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EDPCPushNotification>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EDPCPushNotification_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EDPCPushNotification_descriptor(), enum_t_value);
}
inline bool EDPCPushNotification_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EDPCPushNotification* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EDPCPushNotification>(
    EDPCPushNotification_descriptor(), name, value);
}
enum EEventActionScoreMode : int {
  k_eEventActionScoreMode_Add = 0,
  k_eEventActionScoreMode_Min = 1
};
bool EEventActionScoreMode_IsValid(int value);
constexpr EEventActionScoreMode EEventActionScoreMode_MIN = k_eEventActionScoreMode_Add;
constexpr EEventActionScoreMode EEventActionScoreMode_MAX = k_eEventActionScoreMode_Min;
constexpr int EEventActionScoreMode_ARRAYSIZE = EEventActionScoreMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EEventActionScoreMode_descriptor();
template<typename T>
inline const std::string& EEventActionScoreMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EEventActionScoreMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EEventActionScoreMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EEventActionScoreMode_descriptor(), enum_t_value);
}
inline bool EEventActionScoreMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EEventActionScoreMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EEventActionScoreMode>(
    EEventActionScoreMode_descriptor(), name, value);
}
enum EPlayerChallengeHistoryType : int {
  k_EPlayerChallengeHistoryType_Invalid = 0,
  k_EPlayerChallengeHistoryType_KillEater = 1,
  k_EPlayerChallengeHistoryType_DotaPlusRelic = 2,
  k_EPlayerChallengeHistoryType_DotaPlusHeroPlayerChallenge = 3,
  k_EPlayerChallengeHistoryType_InGameEventChallenge = 4,
  k_EPlayerChallengeHistoryType_GuildContract = 5
};
bool EPlayerChallengeHistoryType_IsValid(int value);
constexpr EPlayerChallengeHistoryType EPlayerChallengeHistoryType_MIN = k_EPlayerChallengeHistoryType_Invalid;
constexpr EPlayerChallengeHistoryType EPlayerChallengeHistoryType_MAX = k_EPlayerChallengeHistoryType_GuildContract;
constexpr int EPlayerChallengeHistoryType_ARRAYSIZE = EPlayerChallengeHistoryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPlayerChallengeHistoryType_descriptor();
template<typename T>
inline const std::string& EPlayerChallengeHistoryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPlayerChallengeHistoryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPlayerChallengeHistoryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPlayerChallengeHistoryType_descriptor(), enum_t_value);
}
inline bool EPlayerChallengeHistoryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPlayerChallengeHistoryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPlayerChallengeHistoryType>(
    EPlayerChallengeHistoryType_descriptor(), name, value);
}
enum EOverwatchReportReason : int {
  k_EOverwatchReportReason_Unknown = 0,
  k_EOverwatchReportReason_Cheating = 1,
  k_EOverwatchReportReason_Feeding = 2,
  k_EOverwatchReportReason_Griefing = 3,
  k_EOverwatchReportReason_Suspicious = 4,
  k_EOverwatchReportReason_AbilityAbuse = 5
};
bool EOverwatchReportReason_IsValid(int value);
constexpr EOverwatchReportReason EOverwatchReportReason_MIN = k_EOverwatchReportReason_Unknown;
constexpr EOverwatchReportReason EOverwatchReportReason_MAX = k_EOverwatchReportReason_AbilityAbuse;
constexpr int EOverwatchReportReason_ARRAYSIZE = EOverwatchReportReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EOverwatchReportReason_descriptor();
template<typename T>
inline const std::string& EOverwatchReportReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EOverwatchReportReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EOverwatchReportReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EOverwatchReportReason_descriptor(), enum_t_value);
}
inline bool EOverwatchReportReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EOverwatchReportReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EOverwatchReportReason>(
    EOverwatchReportReason_descriptor(), name, value);
}
// ===================================================================

class CDOTAClientHardwareSpecs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CDOTAClientHardwareSpecs) */ {
 public:
  inline CDOTAClientHardwareSpecs() : CDOTAClientHardwareSpecs(nullptr) {}
  ~CDOTAClientHardwareSpecs() override;
  explicit PROTOBUF_CONSTEXPR CDOTAClientHardwareSpecs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDOTAClientHardwareSpecs(const CDOTAClientHardwareSpecs& from);
  CDOTAClientHardwareSpecs(CDOTAClientHardwareSpecs&& from) noexcept
    : CDOTAClientHardwareSpecs() {
    *this = ::std::move(from);
  }

  inline CDOTAClientHardwareSpecs& operator=(const CDOTAClientHardwareSpecs& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDOTAClientHardwareSpecs& operator=(CDOTAClientHardwareSpecs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDOTAClientHardwareSpecs& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDOTAClientHardwareSpecs* internal_default_instance() {
    return reinterpret_cast<const CDOTAClientHardwareSpecs*>(
               &_CDOTAClientHardwareSpecs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CDOTAClientHardwareSpecs& a, CDOTAClientHardwareSpecs& b) {
    a.Swap(&b);
  }
  inline void Swap(CDOTAClientHardwareSpecs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDOTAClientHardwareSpecs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDOTAClientHardwareSpecs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDOTAClientHardwareSpecs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CDOTAClientHardwareSpecs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CDOTAClientHardwareSpecs& from) {
    CDOTAClientHardwareSpecs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDOTAClientHardwareSpecs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDOTAClientHardwareSpecs";
  }
  protected:
  explicit CDOTAClientHardwareSpecs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCpuCyclesPerSecondFieldNumber = 2,
    kTotalPhysicalMemoryFieldNumber = 3,
    kLogicalProcessorsFieldNumber = 1,
    kIs64BitOsFieldNumber = 4,
    kPreferNotHostFieldNumber = 6,
    kUploadMeasurementFieldNumber = 5,
  };
  // optional fixed64 cpu_cycles_per_second = 2;
  bool has_cpu_cycles_per_second() const;
  private:
  bool _internal_has_cpu_cycles_per_second() const;
  public:
  void clear_cpu_cycles_per_second();
  uint64_t cpu_cycles_per_second() const;
  void set_cpu_cycles_per_second(uint64_t value);
  private:
  uint64_t _internal_cpu_cycles_per_second() const;
  void _internal_set_cpu_cycles_per_second(uint64_t value);
  public:

  // optional fixed64 total_physical_memory = 3;
  bool has_total_physical_memory() const;
  private:
  bool _internal_has_total_physical_memory() const;
  public:
  void clear_total_physical_memory();
  uint64_t total_physical_memory() const;
  void set_total_physical_memory(uint64_t value);
  private:
  uint64_t _internal_total_physical_memory() const;
  void _internal_set_total_physical_memory(uint64_t value);
  public:

  // optional uint32 logical_processors = 1;
  bool has_logical_processors() const;
  private:
  bool _internal_has_logical_processors() const;
  public:
  void clear_logical_processors();
  uint32_t logical_processors() const;
  void set_logical_processors(uint32_t value);
  private:
  uint32_t _internal_logical_processors() const;
  void _internal_set_logical_processors(uint32_t value);
  public:

  // optional bool is_64_bit_os = 4;
  bool has_is_64_bit_os() const;
  private:
  bool _internal_has_is_64_bit_os() const;
  public:
  void clear_is_64_bit_os();
  bool is_64_bit_os() const;
  void set_is_64_bit_os(bool value);
  private:
  bool _internal_is_64_bit_os() const;
  void _internal_set_is_64_bit_os(bool value);
  public:

  // optional bool prefer_not_host = 6;
  bool has_prefer_not_host() const;
  private:
  bool _internal_has_prefer_not_host() const;
  public:
  void clear_prefer_not_host();
  bool prefer_not_host() const;
  void set_prefer_not_host(bool value);
  private:
  bool _internal_prefer_not_host() const;
  void _internal_set_prefer_not_host(bool value);
  public:

  // optional uint64 upload_measurement = 5;
  bool has_upload_measurement() const;
  private:
  bool _internal_has_upload_measurement() const;
  public:
  void clear_upload_measurement();
  uint64_t upload_measurement() const;
  void set_upload_measurement(uint64_t value);
  private:
  uint64_t _internal_upload_measurement() const;
  void _internal_set_upload_measurement(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CDOTAClientHardwareSpecs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t cpu_cycles_per_second_;
    uint64_t total_physical_memory_;
    uint32_t logical_processors_;
    bool is_64_bit_os_;
    bool prefer_not_host_;
    uint64_t upload_measurement_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fshared_5fenums_2eproto;
};
// -------------------------------------------------------------------

class CDOTASaveGame_Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CDOTASaveGame.Player) */ {
 public:
  inline CDOTASaveGame_Player() : CDOTASaveGame_Player(nullptr) {}
  ~CDOTASaveGame_Player() override;
  explicit PROTOBUF_CONSTEXPR CDOTASaveGame_Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDOTASaveGame_Player(const CDOTASaveGame_Player& from);
  CDOTASaveGame_Player(CDOTASaveGame_Player&& from) noexcept
    : CDOTASaveGame_Player() {
    *this = ::std::move(from);
  }

  inline CDOTASaveGame_Player& operator=(const CDOTASaveGame_Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDOTASaveGame_Player& operator=(CDOTASaveGame_Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDOTASaveGame_Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDOTASaveGame_Player* internal_default_instance() {
    return reinterpret_cast<const CDOTASaveGame_Player*>(
               &_CDOTASaveGame_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CDOTASaveGame_Player& a, CDOTASaveGame_Player& b) {
    a.Swap(&b);
  }
  inline void Swap(CDOTASaveGame_Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDOTASaveGame_Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDOTASaveGame_Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDOTASaveGame_Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CDOTASaveGame_Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CDOTASaveGame_Player& from) {
    CDOTASaveGame_Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDOTASaveGame_Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDOTASaveGame.Player";
  }
  protected:
  explicit CDOTASaveGame_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kHeroFieldNumber = 3,
    kTeamFieldNumber = 1,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string hero = 3;
  bool has_hero() const;
  private:
  bool _internal_has_hero() const;
  public:
  void clear_hero();
  const std::string& hero() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hero(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hero();
  PROTOBUF_NODISCARD std::string* release_hero();
  void set_allocated_hero(std::string* hero);
  private:
  const std::string& _internal_hero() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hero(const std::string& value);
  std::string* _internal_mutable_hero();
  public:

  // optional .DOTA_GC_TEAM team = 1 [default = DOTA_GC_TEAM_GOOD_GUYS];
  bool has_team() const;
  private:
  bool _internal_has_team() const;
  public:
  void clear_team();
  ::DOTA_GC_TEAM team() const;
  void set_team(::DOTA_GC_TEAM value);
  private:
  ::DOTA_GC_TEAM _internal_team() const;
  void _internal_set_team(::DOTA_GC_TEAM value);
  public:

  // @@protoc_insertion_point(class_scope:CDOTASaveGame.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hero_;
    int team_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fshared_5fenums_2eproto;
};
// -------------------------------------------------------------------

class CDOTASaveGame_SaveInstance_PlayerPositions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CDOTASaveGame.SaveInstance.PlayerPositions) */ {
 public:
  inline CDOTASaveGame_SaveInstance_PlayerPositions() : CDOTASaveGame_SaveInstance_PlayerPositions(nullptr) {}
  ~CDOTASaveGame_SaveInstance_PlayerPositions() override;
  explicit PROTOBUF_CONSTEXPR CDOTASaveGame_SaveInstance_PlayerPositions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDOTASaveGame_SaveInstance_PlayerPositions(const CDOTASaveGame_SaveInstance_PlayerPositions& from);
  CDOTASaveGame_SaveInstance_PlayerPositions(CDOTASaveGame_SaveInstance_PlayerPositions&& from) noexcept
    : CDOTASaveGame_SaveInstance_PlayerPositions() {
    *this = ::std::move(from);
  }

  inline CDOTASaveGame_SaveInstance_PlayerPositions& operator=(const CDOTASaveGame_SaveInstance_PlayerPositions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDOTASaveGame_SaveInstance_PlayerPositions& operator=(CDOTASaveGame_SaveInstance_PlayerPositions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDOTASaveGame_SaveInstance_PlayerPositions& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDOTASaveGame_SaveInstance_PlayerPositions* internal_default_instance() {
    return reinterpret_cast<const CDOTASaveGame_SaveInstance_PlayerPositions*>(
               &_CDOTASaveGame_SaveInstance_PlayerPositions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CDOTASaveGame_SaveInstance_PlayerPositions& a, CDOTASaveGame_SaveInstance_PlayerPositions& b) {
    a.Swap(&b);
  }
  inline void Swap(CDOTASaveGame_SaveInstance_PlayerPositions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDOTASaveGame_SaveInstance_PlayerPositions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDOTASaveGame_SaveInstance_PlayerPositions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDOTASaveGame_SaveInstance_PlayerPositions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CDOTASaveGame_SaveInstance_PlayerPositions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CDOTASaveGame_SaveInstance_PlayerPositions& from) {
    CDOTASaveGame_SaveInstance_PlayerPositions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDOTASaveGame_SaveInstance_PlayerPositions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDOTASaveGame.SaveInstance.PlayerPositions";
  }
  protected:
  explicit CDOTASaveGame_SaveInstance_PlayerPositions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:CDOTASaveGame.SaveInstance.PlayerPositions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fshared_5fenums_2eproto;
};
// -------------------------------------------------------------------

class CDOTASaveGame_SaveInstance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CDOTASaveGame.SaveInstance) */ {
 public:
  inline CDOTASaveGame_SaveInstance() : CDOTASaveGame_SaveInstance(nullptr) {}
  ~CDOTASaveGame_SaveInstance() override;
  explicit PROTOBUF_CONSTEXPR CDOTASaveGame_SaveInstance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDOTASaveGame_SaveInstance(const CDOTASaveGame_SaveInstance& from);
  CDOTASaveGame_SaveInstance(CDOTASaveGame_SaveInstance&& from) noexcept
    : CDOTASaveGame_SaveInstance() {
    *this = ::std::move(from);
  }

  inline CDOTASaveGame_SaveInstance& operator=(const CDOTASaveGame_SaveInstance& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDOTASaveGame_SaveInstance& operator=(CDOTASaveGame_SaveInstance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDOTASaveGame_SaveInstance& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDOTASaveGame_SaveInstance* internal_default_instance() {
    return reinterpret_cast<const CDOTASaveGame_SaveInstance*>(
               &_CDOTASaveGame_SaveInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CDOTASaveGame_SaveInstance& a, CDOTASaveGame_SaveInstance& b) {
    a.Swap(&b);
  }
  inline void Swap(CDOTASaveGame_SaveInstance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDOTASaveGame_SaveInstance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDOTASaveGame_SaveInstance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDOTASaveGame_SaveInstance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CDOTASaveGame_SaveInstance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CDOTASaveGame_SaveInstance& from) {
    CDOTASaveGame_SaveInstance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDOTASaveGame_SaveInstance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDOTASaveGame.SaveInstance";
  }
  protected:
  explicit CDOTASaveGame_SaveInstance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CDOTASaveGame_SaveInstance_PlayerPositions PlayerPositions;

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerPositionsFieldNumber = 5,
    kGameTimeFieldNumber = 2,
    kTeam1ScoreFieldNumber = 3,
    kTeam2ScoreFieldNumber = 4,
    kSaveIdFieldNumber = 6,
    kSaveTimeFieldNumber = 7,
  };
  // repeated .CDOTASaveGame.SaveInstance.PlayerPositions player_positions = 5;
  int player_positions_size() const;
  private:
  int _internal_player_positions_size() const;
  public:
  void clear_player_positions();
  ::CDOTASaveGame_SaveInstance_PlayerPositions* mutable_player_positions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_SaveInstance_PlayerPositions >*
      mutable_player_positions();
  private:
  const ::CDOTASaveGame_SaveInstance_PlayerPositions& _internal_player_positions(int index) const;
  ::CDOTASaveGame_SaveInstance_PlayerPositions* _internal_add_player_positions();
  public:
  const ::CDOTASaveGame_SaveInstance_PlayerPositions& player_positions(int index) const;
  ::CDOTASaveGame_SaveInstance_PlayerPositions* add_player_positions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_SaveInstance_PlayerPositions >&
      player_positions() const;

  // optional uint32 game_time = 2;
  bool has_game_time() const;
  private:
  bool _internal_has_game_time() const;
  public:
  void clear_game_time();
  uint32_t game_time() const;
  void set_game_time(uint32_t value);
  private:
  uint32_t _internal_game_time() const;
  void _internal_set_game_time(uint32_t value);
  public:

  // optional uint32 team1_score = 3;
  bool has_team1_score() const;
  private:
  bool _internal_has_team1_score() const;
  public:
  void clear_team1_score();
  uint32_t team1_score() const;
  void set_team1_score(uint32_t value);
  private:
  uint32_t _internal_team1_score() const;
  void _internal_set_team1_score(uint32_t value);
  public:

  // optional uint32 team2_score = 4;
  bool has_team2_score() const;
  private:
  bool _internal_has_team2_score() const;
  public:
  void clear_team2_score();
  uint32_t team2_score() const;
  void set_team2_score(uint32_t value);
  private:
  uint32_t _internal_team2_score() const;
  void _internal_set_team2_score(uint32_t value);
  public:

  // optional uint32 save_id = 6;
  bool has_save_id() const;
  private:
  bool _internal_has_save_id() const;
  public:
  void clear_save_id();
  uint32_t save_id() const;
  void set_save_id(uint32_t value);
  private:
  uint32_t _internal_save_id() const;
  void _internal_set_save_id(uint32_t value);
  public:

  // optional uint32 save_time = 7;
  bool has_save_time() const;
  private:
  bool _internal_has_save_time() const;
  public:
  void clear_save_time();
  uint32_t save_time() const;
  void set_save_time(uint32_t value);
  private:
  uint32_t _internal_save_time() const;
  void _internal_set_save_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CDOTASaveGame.SaveInstance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_SaveInstance_PlayerPositions > player_positions_;
    uint32_t game_time_;
    uint32_t team1_score_;
    uint32_t team2_score_;
    uint32_t save_id_;
    uint32_t save_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fshared_5fenums_2eproto;
};
// -------------------------------------------------------------------

class CDOTASaveGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CDOTASaveGame) */ {
 public:
  inline CDOTASaveGame() : CDOTASaveGame(nullptr) {}
  ~CDOTASaveGame() override;
  explicit PROTOBUF_CONSTEXPR CDOTASaveGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDOTASaveGame(const CDOTASaveGame& from);
  CDOTASaveGame(CDOTASaveGame&& from) noexcept
    : CDOTASaveGame() {
    *this = ::std::move(from);
  }

  inline CDOTASaveGame& operator=(const CDOTASaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDOTASaveGame& operator=(CDOTASaveGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDOTASaveGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDOTASaveGame* internal_default_instance() {
    return reinterpret_cast<const CDOTASaveGame*>(
               &_CDOTASaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CDOTASaveGame& a, CDOTASaveGame& b) {
    a.Swap(&b);
  }
  inline void Swap(CDOTASaveGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDOTASaveGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDOTASaveGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDOTASaveGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CDOTASaveGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CDOTASaveGame& from) {
    CDOTASaveGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDOTASaveGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDOTASaveGame";
  }
  protected:
  explicit CDOTASaveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CDOTASaveGame_Player Player;
  typedef CDOTASaveGame_SaveInstance SaveInstance;

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 3,
    kSaveInstancesFieldNumber = 4,
    kMatchIdFieldNumber = 5,
    kSaveTimeFieldNumber = 2,
  };
  // repeated .CDOTASaveGame.Player players = 3;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::CDOTASaveGame_Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_Player >*
      mutable_players();
  private:
  const ::CDOTASaveGame_Player& _internal_players(int index) const;
  ::CDOTASaveGame_Player* _internal_add_players();
  public:
  const ::CDOTASaveGame_Player& players(int index) const;
  ::CDOTASaveGame_Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_Player >&
      players() const;

  // repeated .CDOTASaveGame.SaveInstance save_instances = 4;
  int save_instances_size() const;
  private:
  int _internal_save_instances_size() const;
  public:
  void clear_save_instances();
  ::CDOTASaveGame_SaveInstance* mutable_save_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_SaveInstance >*
      mutable_save_instances();
  private:
  const ::CDOTASaveGame_SaveInstance& _internal_save_instances(int index) const;
  ::CDOTASaveGame_SaveInstance* _internal_add_save_instances();
  public:
  const ::CDOTASaveGame_SaveInstance& save_instances(int index) const;
  ::CDOTASaveGame_SaveInstance* add_save_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_SaveInstance >&
      save_instances() const;

  // optional uint64 match_id = 5;
  bool has_match_id() const;
  private:
  bool _internal_has_match_id() const;
  public:
  void clear_match_id();
  uint64_t match_id() const;
  void set_match_id(uint64_t value);
  private:
  uint64_t _internal_match_id() const;
  void _internal_set_match_id(uint64_t value);
  public:

  // optional uint32 save_time = 2;
  bool has_save_time() const;
  private:
  bool _internal_has_save_time() const;
  public:
  void clear_save_time();
  uint32_t save_time() const;
  void set_save_time(uint32_t value);
  private:
  uint32_t _internal_save_time() const;
  void _internal_set_save_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CDOTASaveGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_Player > players_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_SaveInstance > save_instances_;
    uint64_t match_id_;
    uint32_t save_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fshared_5fenums_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTACombatLogEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgDOTACombatLogEntry) */ {
 public:
  inline CMsgDOTACombatLogEntry() : CMsgDOTACombatLogEntry(nullptr) {}
  ~CMsgDOTACombatLogEntry() override;
  explicit PROTOBUF_CONSTEXPR CMsgDOTACombatLogEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgDOTACombatLogEntry(const CMsgDOTACombatLogEntry& from);
  CMsgDOTACombatLogEntry(CMsgDOTACombatLogEntry&& from) noexcept
    : CMsgDOTACombatLogEntry() {
    *this = ::std::move(from);
  }

  inline CMsgDOTACombatLogEntry& operator=(const CMsgDOTACombatLogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgDOTACombatLogEntry& operator=(CMsgDOTACombatLogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgDOTACombatLogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgDOTACombatLogEntry* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTACombatLogEntry*>(
               &_CMsgDOTACombatLogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CMsgDOTACombatLogEntry& a, CMsgDOTACombatLogEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgDOTACombatLogEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgDOTACombatLogEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgDOTACombatLogEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgDOTACombatLogEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgDOTACombatLogEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgDOTACombatLogEntry& from) {
    CMsgDOTACombatLogEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTACombatLogEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgDOTACombatLogEntry";
  }
  protected:
  explicit CMsgDOTACombatLogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssistPlayersFieldNumber = 40,
    kTargetNameFieldNumber = 2,
    kTargetSourceNameFieldNumber = 3,
    kAttackerNameFieldNumber = 4,
    kDamageSourceNameFieldNumber = 5,
    kInflictorNameFieldNumber = 6,
    kIsAttackerIllusionFieldNumber = 7,
    kIsAttackerHeroFieldNumber = 8,
    kIsTargetIllusionFieldNumber = 9,
    kIsTargetHeroFieldNumber = 10,
    kValueFieldNumber = 13,
    kHealthFieldNumber = 14,
    kTimestampFieldNumber = 15,
    kIsVisibleRadiantFieldNumber = 11,
    kIsVisibleDireFieldNumber = 12,
    kIsAbilityToggleOnFieldNumber = 18,
    kIsAbilityToggleOffFieldNumber = 19,
    kStunDurationFieldNumber = 16,
    kSlowDurationFieldNumber = 17,
    kAbilityLevelFieldNumber = 20,
    kLocationXFieldNumber = 21,
    kLocationYFieldNumber = 22,
    kGoldReasonFieldNumber = 23,
    kTimestampRawFieldNumber = 24,
    kModifierDurationFieldNumber = 25,
    kXpReasonFieldNumber = 26,
    kLastHitsFieldNumber = 27,
    kAttackerTeamFieldNumber = 28,
    kTargetTeamFieldNumber = 29,
    kObsWardsPlacedFieldNumber = 30,
    kAssistPlayer0FieldNumber = 31,
    kAssistPlayer1FieldNumber = 32,
    kAssistPlayer2FieldNumber = 33,
    kAssistPlayer3FieldNumber = 34,
    kStackCountFieldNumber = 35,
    kNeutralCampTypeFieldNumber = 38,
    kRuneTypeFieldNumber = 39,
    kHiddenModifierFieldNumber = 36,
    kIsTargetBuildingFieldNumber = 37,
    kIsHealSaveFieldNumber = 41,
    kIsUltimateAbilityFieldNumber = 42,
    kAttackerHeroLevelFieldNumber = 43,
    kTargetHeroLevelFieldNumber = 44,
    kXpmFieldNumber = 45,
    kGpmFieldNumber = 46,
    kEventLocationFieldNumber = 47,
    kDamageTypeFieldNumber = 49,
    kDamageCategoryFieldNumber = 51,
    kNetworthFieldNumber = 52,
    kTargetIsSelfFieldNumber = 48,
    kInvisibilityModifierFieldNumber = 50,
    kSilenceModifierFieldNumber = 55,
    kHealFromLifestealFieldNumber = 56,
    kBuildingTypeFieldNumber = 53,
    kModifierElapsedDurationFieldNumber = 54,
    kModifierPurgedFieldNumber = 57,
    kSpellEvadedFieldNumber = 58,
    kMotionControllerModifierFieldNumber = 59,
    kLongRangeKillFieldNumber = 60,
    kModifierPurgeAbilityFieldNumber = 61,
    kModifierPurgeNpcFieldNumber = 62,
    kTotalUnitDeathCountFieldNumber = 64,
    kRootModifierFieldNumber = 63,
    kAuraModifierFieldNumber = 65,
    kArmorDebuffModifierFieldNumber = 66,
    kNoPhysicalDamageModifierFieldNumber = 67,
    kModifierAbilityFieldNumber = 68,
    kKillEaterEventFieldNumber = 71,
    kModifierHiddenFieldNumber = 69,
    kInflictorIsStolenAbilityFieldNumber = 70,
    kSpellGeneratedAttackFieldNumber = 73,
    kAtNightTimeFieldNumber = 74,
    kUnitStatusLabelFieldNumber = 72,
    kNeutralCampTeamFieldNumber = 76,
    kRegeneratedHealthFieldNumber = 77,
    kAttackerHasScepterFieldNumber = 75,
    kWillReincarnateFieldNumber = 78,
    kUsesChargesFieldNumber = 79,
    kTypeFieldNumber = 1,
  };
  // repeated int32 assist_players = 40;
  int assist_players_size() const;
  private:
  int _internal_assist_players_size() const;
  public:
  void clear_assist_players();
  private:
  int32_t _internal_assist_players(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_assist_players() const;
  void _internal_add_assist_players(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_assist_players();
  public:
  int32_t assist_players(int index) const;
  void set_assist_players(int index, int32_t value);
  void add_assist_players(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      assist_players() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_assist_players();

  // optional uint32 target_name = 2;
  bool has_target_name() const;
  private:
  bool _internal_has_target_name() const;
  public:
  void clear_target_name();
  uint32_t target_name() const;
  void set_target_name(uint32_t value);
  private:
  uint32_t _internal_target_name() const;
  void _internal_set_target_name(uint32_t value);
  public:

  // optional uint32 target_source_name = 3;
  bool has_target_source_name() const;
  private:
  bool _internal_has_target_source_name() const;
  public:
  void clear_target_source_name();
  uint32_t target_source_name() const;
  void set_target_source_name(uint32_t value);
  private:
  uint32_t _internal_target_source_name() const;
  void _internal_set_target_source_name(uint32_t value);
  public:

  // optional uint32 attacker_name = 4;
  bool has_attacker_name() const;
  private:
  bool _internal_has_attacker_name() const;
  public:
  void clear_attacker_name();
  uint32_t attacker_name() const;
  void set_attacker_name(uint32_t value);
  private:
  uint32_t _internal_attacker_name() const;
  void _internal_set_attacker_name(uint32_t value);
  public:

  // optional uint32 damage_source_name = 5;
  bool has_damage_source_name() const;
  private:
  bool _internal_has_damage_source_name() const;
  public:
  void clear_damage_source_name();
  uint32_t damage_source_name() const;
  void set_damage_source_name(uint32_t value);
  private:
  uint32_t _internal_damage_source_name() const;
  void _internal_set_damage_source_name(uint32_t value);
  public:

  // optional uint32 inflictor_name = 6;
  bool has_inflictor_name() const;
  private:
  bool _internal_has_inflictor_name() const;
  public:
  void clear_inflictor_name();
  uint32_t inflictor_name() const;
  void set_inflictor_name(uint32_t value);
  private:
  uint32_t _internal_inflictor_name() const;
  void _internal_set_inflictor_name(uint32_t value);
  public:

  // optional bool is_attacker_illusion = 7;
  bool has_is_attacker_illusion() const;
  private:
  bool _internal_has_is_attacker_illusion() const;
  public:
  void clear_is_attacker_illusion();
  bool is_attacker_illusion() const;
  void set_is_attacker_illusion(bool value);
  private:
  bool _internal_is_attacker_illusion() const;
  void _internal_set_is_attacker_illusion(bool value);
  public:

  // optional bool is_attacker_hero = 8;
  bool has_is_attacker_hero() const;
  private:
  bool _internal_has_is_attacker_hero() const;
  public:
  void clear_is_attacker_hero();
  bool is_attacker_hero() const;
  void set_is_attacker_hero(bool value);
  private:
  bool _internal_is_attacker_hero() const;
  void _internal_set_is_attacker_hero(bool value);
  public:

  // optional bool is_target_illusion = 9;
  bool has_is_target_illusion() const;
  private:
  bool _internal_has_is_target_illusion() const;
  public:
  void clear_is_target_illusion();
  bool is_target_illusion() const;
  void set_is_target_illusion(bool value);
  private:
  bool _internal_is_target_illusion() const;
  void _internal_set_is_target_illusion(bool value);
  public:

  // optional bool is_target_hero = 10;
  bool has_is_target_hero() const;
  private:
  bool _internal_has_is_target_hero() const;
  public:
  void clear_is_target_hero();
  bool is_target_hero() const;
  void set_is_target_hero(bool value);
  private:
  bool _internal_is_target_hero() const;
  void _internal_set_is_target_hero(bool value);
  public:

  // optional uint32 value = 13;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  uint32_t value() const;
  void set_value(uint32_t value);
  private:
  uint32_t _internal_value() const;
  void _internal_set_value(uint32_t value);
  public:

  // optional int32 health = 14;
  bool has_health() const;
  private:
  bool _internal_has_health() const;
  public:
  void clear_health();
  int32_t health() const;
  void set_health(int32_t value);
  private:
  int32_t _internal_health() const;
  void _internal_set_health(int32_t value);
  public:

  // optional float timestamp = 15;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  float timestamp() const;
  void set_timestamp(float value);
  private:
  float _internal_timestamp() const;
  void _internal_set_timestamp(float value);
  public:

  // optional bool is_visible_radiant = 11;
  bool has_is_visible_radiant() const;
  private:
  bool _internal_has_is_visible_radiant() const;
  public:
  void clear_is_visible_radiant();
  bool is_visible_radiant() const;
  void set_is_visible_radiant(bool value);
  private:
  bool _internal_is_visible_radiant() const;
  void _internal_set_is_visible_radiant(bool value);
  public:

  // optional bool is_visible_dire = 12;
  bool has_is_visible_dire() const;
  private:
  bool _internal_has_is_visible_dire() const;
  public:
  void clear_is_visible_dire();
  bool is_visible_dire() const;
  void set_is_visible_dire(bool value);
  private:
  bool _internal_is_visible_dire() const;
  void _internal_set_is_visible_dire(bool value);
  public:

  // optional bool is_ability_toggle_on = 18;
  bool has_is_ability_toggle_on() const;
  private:
  bool _internal_has_is_ability_toggle_on() const;
  public:
  void clear_is_ability_toggle_on();
  bool is_ability_toggle_on() const;
  void set_is_ability_toggle_on(bool value);
  private:
  bool _internal_is_ability_toggle_on() const;
  void _internal_set_is_ability_toggle_on(bool value);
  public:

  // optional bool is_ability_toggle_off = 19;
  bool has_is_ability_toggle_off() const;
  private:
  bool _internal_has_is_ability_toggle_off() const;
  public:
  void clear_is_ability_toggle_off();
  bool is_ability_toggle_off() const;
  void set_is_ability_toggle_off(bool value);
  private:
  bool _internal_is_ability_toggle_off() const;
  void _internal_set_is_ability_toggle_off(bool value);
  public:

  // optional float stun_duration = 16;
  bool has_stun_duration() const;
  private:
  bool _internal_has_stun_duration() const;
  public:
  void clear_stun_duration();
  float stun_duration() const;
  void set_stun_duration(float value);
  private:
  float _internal_stun_duration() const;
  void _internal_set_stun_duration(float value);
  public:

  // optional float slow_duration = 17;
  bool has_slow_duration() const;
  private:
  bool _internal_has_slow_duration() const;
  public:
  void clear_slow_duration();
  float slow_duration() const;
  void set_slow_duration(float value);
  private:
  float _internal_slow_duration() const;
  void _internal_set_slow_duration(float value);
  public:

  // optional uint32 ability_level = 20;
  bool has_ability_level() const;
  private:
  bool _internal_has_ability_level() const;
  public:
  void clear_ability_level();
  uint32_t ability_level() const;
  void set_ability_level(uint32_t value);
  private:
  uint32_t _internal_ability_level() const;
  void _internal_set_ability_level(uint32_t value);
  public:

  // optional float location_x = 21;
  bool has_location_x() const;
  private:
  bool _internal_has_location_x() const;
  public:
  void clear_location_x();
  float location_x() const;
  void set_location_x(float value);
  private:
  float _internal_location_x() const;
  void _internal_set_location_x(float value);
  public:

  // optional float location_y = 22;
  bool has_location_y() const;
  private:
  bool _internal_has_location_y() const;
  public:
  void clear_location_y();
  float location_y() const;
  void set_location_y(float value);
  private:
  float _internal_location_y() const;
  void _internal_set_location_y(float value);
  public:

  // optional uint32 gold_reason = 23;
  bool has_gold_reason() const;
  private:
  bool _internal_has_gold_reason() const;
  public:
  void clear_gold_reason();
  uint32_t gold_reason() const;
  void set_gold_reason(uint32_t value);
  private:
  uint32_t _internal_gold_reason() const;
  void _internal_set_gold_reason(uint32_t value);
  public:

  // optional float timestamp_raw = 24;
  bool has_timestamp_raw() const;
  private:
  bool _internal_has_timestamp_raw() const;
  public:
  void clear_timestamp_raw();
  float timestamp_raw() const;
  void set_timestamp_raw(float value);
  private:
  float _internal_timestamp_raw() const;
  void _internal_set_timestamp_raw(float value);
  public:

  // optional float modifier_duration = 25;
  bool has_modifier_duration() const;
  private:
  bool _internal_has_modifier_duration() const;
  public:
  void clear_modifier_duration();
  float modifier_duration() const;
  void set_modifier_duration(float value);
  private:
  float _internal_modifier_duration() const;
  void _internal_set_modifier_duration(float value);
  public:

  // optional uint32 xp_reason = 26;
  bool has_xp_reason() const;
  private:
  bool _internal_has_xp_reason() const;
  public:
  void clear_xp_reason();
  uint32_t xp_reason() const;
  void set_xp_reason(uint32_t value);
  private:
  uint32_t _internal_xp_reason() const;
  void _internal_set_xp_reason(uint32_t value);
  public:

  // optional uint32 last_hits = 27;
  bool has_last_hits() const;
  private:
  bool _internal_has_last_hits() const;
  public:
  void clear_last_hits();
  uint32_t last_hits() const;
  void set_last_hits(uint32_t value);
  private:
  uint32_t _internal_last_hits() const;
  void _internal_set_last_hits(uint32_t value);
  public:

  // optional uint32 attacker_team = 28;
  bool has_attacker_team() const;
  private:
  bool _internal_has_attacker_team() const;
  public:
  void clear_attacker_team();
  uint32_t attacker_team() const;
  void set_attacker_team(uint32_t value);
  private:
  uint32_t _internal_attacker_team() const;
  void _internal_set_attacker_team(uint32_t value);
  public:

  // optional uint32 target_team = 29;
  bool has_target_team() const;
  private:
  bool _internal_has_target_team() const;
  public:
  void clear_target_team();
  uint32_t target_team() const;
  void set_target_team(uint32_t value);
  private:
  uint32_t _internal_target_team() const;
  void _internal_set_target_team(uint32_t value);
  public:

  // optional uint32 obs_wards_placed = 30;
  bool has_obs_wards_placed() const;
  private:
  bool _internal_has_obs_wards_placed() const;
  public:
  void clear_obs_wards_placed();
  uint32_t obs_wards_placed() const;
  void set_obs_wards_placed(uint32_t value);
  private:
  uint32_t _internal_obs_wards_placed() const;
  void _internal_set_obs_wards_placed(uint32_t value);
  public:

  // optional uint32 assist_player0 = 31;
  bool has_assist_player0() const;
  private:
  bool _internal_has_assist_player0() const;
  public:
  void clear_assist_player0();
  uint32_t assist_player0() const;
  void set_assist_player0(uint32_t value);
  private:
  uint32_t _internal_assist_player0() const;
  void _internal_set_assist_player0(uint32_t value);
  public:

  // optional uint32 assist_player1 = 32;
  bool has_assist_player1() const;
  private:
  bool _internal_has_assist_player1() const;
  public:
  void clear_assist_player1();
  uint32_t assist_player1() const;
  void set_assist_player1(uint32_t value);
  private:
  uint32_t _internal_assist_player1() const;
  void _internal_set_assist_player1(uint32_t value);
  public:

  // optional uint32 assist_player2 = 33;
  bool has_assist_player2() const;
  private:
  bool _internal_has_assist_player2() const;
  public:
  void clear_assist_player2();
  uint32_t assist_player2() const;
  void set_assist_player2(uint32_t value);
  private:
  uint32_t _internal_assist_player2() const;
  void _internal_set_assist_player2(uint32_t value);
  public:

  // optional uint32 assist_player3 = 34;
  bool has_assist_player3() const;
  private:
  bool _internal_has_assist_player3() const;
  public:
  void clear_assist_player3();
  uint32_t assist_player3() const;
  void set_assist_player3(uint32_t value);
  private:
  uint32_t _internal_assist_player3() const;
  void _internal_set_assist_player3(uint32_t value);
  public:

  // optional uint32 stack_count = 35;
  bool has_stack_count() const;
  private:
  bool _internal_has_stack_count() const;
  public:
  void clear_stack_count();
  uint32_t stack_count() const;
  void set_stack_count(uint32_t value);
  private:
  uint32_t _internal_stack_count() const;
  void _internal_set_stack_count(uint32_t value);
  public:

  // optional uint32 neutral_camp_type = 38;
  bool has_neutral_camp_type() const;
  private:
  bool _internal_has_neutral_camp_type() const;
  public:
  void clear_neutral_camp_type();
  uint32_t neutral_camp_type() const;
  void set_neutral_camp_type(uint32_t value);
  private:
  uint32_t _internal_neutral_camp_type() const;
  void _internal_set_neutral_camp_type(uint32_t value);
  public:

  // optional uint32 rune_type = 39;
  bool has_rune_type() const;
  private:
  bool _internal_has_rune_type() const;
  public:
  void clear_rune_type();
  uint32_t rune_type() const;
  void set_rune_type(uint32_t value);
  private:
  uint32_t _internal_rune_type() const;
  void _internal_set_rune_type(uint32_t value);
  public:

  // optional bool hidden_modifier = 36;
  bool has_hidden_modifier() const;
  private:
  bool _internal_has_hidden_modifier() const;
  public:
  void clear_hidden_modifier();
  bool hidden_modifier() const;
  void set_hidden_modifier(bool value);
  private:
  bool _internal_hidden_modifier() const;
  void _internal_set_hidden_modifier(bool value);
  public:

  // optional bool is_target_building = 37;
  bool has_is_target_building() const;
  private:
  bool _internal_has_is_target_building() const;
  public:
  void clear_is_target_building();
  bool is_target_building() const;
  void set_is_target_building(bool value);
  private:
  bool _internal_is_target_building() const;
  void _internal_set_is_target_building(bool value);
  public:

  // optional bool is_heal_save = 41;
  bool has_is_heal_save() const;
  private:
  bool _internal_has_is_heal_save() const;
  public:
  void clear_is_heal_save();
  bool is_heal_save() const;
  void set_is_heal_save(bool value);
  private:
  bool _internal_is_heal_save() const;
  void _internal_set_is_heal_save(bool value);
  public:

  // optional bool is_ultimate_ability = 42;
  bool has_is_ultimate_ability() const;
  private:
  bool _internal_has_is_ultimate_ability() const;
  public:
  void clear_is_ultimate_ability();
  bool is_ultimate_ability() const;
  void set_is_ultimate_ability(bool value);
  private:
  bool _internal_is_ultimate_ability() const;
  void _internal_set_is_ultimate_ability(bool value);
  public:

  // optional uint32 attacker_hero_level = 43;
  bool has_attacker_hero_level() const;
  private:
  bool _internal_has_attacker_hero_level() const;
  public:
  void clear_attacker_hero_level();
  uint32_t attacker_hero_level() const;
  void set_attacker_hero_level(uint32_t value);
  private:
  uint32_t _internal_attacker_hero_level() const;
  void _internal_set_attacker_hero_level(uint32_t value);
  public:

  // optional uint32 target_hero_level = 44;
  bool has_target_hero_level() const;
  private:
  bool _internal_has_target_hero_level() const;
  public:
  void clear_target_hero_level();
  uint32_t target_hero_level() const;
  void set_target_hero_level(uint32_t value);
  private:
  uint32_t _internal_target_hero_level() const;
  void _internal_set_target_hero_level(uint32_t value);
  public:

  // optional uint32 xpm = 45;
  bool has_xpm() const;
  private:
  bool _internal_has_xpm() const;
  public:
  void clear_xpm();
  uint32_t xpm() const;
  void set_xpm(uint32_t value);
  private:
  uint32_t _internal_xpm() const;
  void _internal_set_xpm(uint32_t value);
  public:

  // optional uint32 gpm = 46;
  bool has_gpm() const;
  private:
  bool _internal_has_gpm() const;
  public:
  void clear_gpm();
  uint32_t gpm() const;
  void set_gpm(uint32_t value);
  private:
  uint32_t _internal_gpm() const;
  void _internal_set_gpm(uint32_t value);
  public:

  // optional uint32 event_location = 47;
  bool has_event_location() const;
  private:
  bool _internal_has_event_location() const;
  public:
  void clear_event_location();
  uint32_t event_location() const;
  void set_event_location(uint32_t value);
  private:
  uint32_t _internal_event_location() const;
  void _internal_set_event_location(uint32_t value);
  public:

  // optional uint32 damage_type = 49;
  bool has_damage_type() const;
  private:
  bool _internal_has_damage_type() const;
  public:
  void clear_damage_type();
  uint32_t damage_type() const;
  void set_damage_type(uint32_t value);
  private:
  uint32_t _internal_damage_type() const;
  void _internal_set_damage_type(uint32_t value);
  public:

  // optional uint32 damage_category = 51;
  bool has_damage_category() const;
  private:
  bool _internal_has_damage_category() const;
  public:
  void clear_damage_category();
  uint32_t damage_category() const;
  void set_damage_category(uint32_t value);
  private:
  uint32_t _internal_damage_category() const;
  void _internal_set_damage_category(uint32_t value);
  public:

  // optional uint32 networth = 52;
  bool has_networth() const;
  private:
  bool _internal_has_networth() const;
  public:
  void clear_networth();
  uint32_t networth() const;
  void set_networth(uint32_t value);
  private:
  uint32_t _internal_networth() const;
  void _internal_set_networth(uint32_t value);
  public:

  // optional bool target_is_self = 48;
  bool has_target_is_self() const;
  private:
  bool _internal_has_target_is_self() const;
  public:
  void clear_target_is_self();
  bool target_is_self() const;
  void set_target_is_self(bool value);
  private:
  bool _internal_target_is_self() const;
  void _internal_set_target_is_self(bool value);
  public:

  // optional bool invisibility_modifier = 50;
  bool has_invisibility_modifier() const;
  private:
  bool _internal_has_invisibility_modifier() const;
  public:
  void clear_invisibility_modifier();
  bool invisibility_modifier() const;
  void set_invisibility_modifier(bool value);
  private:
  bool _internal_invisibility_modifier() const;
  void _internal_set_invisibility_modifier(bool value);
  public:

  // optional bool silence_modifier = 55;
  bool has_silence_modifier() const;
  private:
  bool _internal_has_silence_modifier() const;
  public:
  void clear_silence_modifier();
  bool silence_modifier() const;
  void set_silence_modifier(bool value);
  private:
  bool _internal_silence_modifier() const;
  void _internal_set_silence_modifier(bool value);
  public:

  // optional bool heal_from_lifesteal = 56;
  bool has_heal_from_lifesteal() const;
  private:
  bool _internal_has_heal_from_lifesteal() const;
  public:
  void clear_heal_from_lifesteal();
  bool heal_from_lifesteal() const;
  void set_heal_from_lifesteal(bool value);
  private:
  bool _internal_heal_from_lifesteal() const;
  void _internal_set_heal_from_lifesteal(bool value);
  public:

  // optional uint32 building_type = 53;
  bool has_building_type() const;
  private:
  bool _internal_has_building_type() const;
  public:
  void clear_building_type();
  uint32_t building_type() const;
  void set_building_type(uint32_t value);
  private:
  uint32_t _internal_building_type() const;
  void _internal_set_building_type(uint32_t value);
  public:

  // optional float modifier_elapsed_duration = 54;
  bool has_modifier_elapsed_duration() const;
  private:
  bool _internal_has_modifier_elapsed_duration() const;
  public:
  void clear_modifier_elapsed_duration();
  float modifier_elapsed_duration() const;
  void set_modifier_elapsed_duration(float value);
  private:
  float _internal_modifier_elapsed_duration() const;
  void _internal_set_modifier_elapsed_duration(float value);
  public:

  // optional bool modifier_purged = 57;
  bool has_modifier_purged() const;
  private:
  bool _internal_has_modifier_purged() const;
  public:
  void clear_modifier_purged();
  bool modifier_purged() const;
  void set_modifier_purged(bool value);
  private:
  bool _internal_modifier_purged() const;
  void _internal_set_modifier_purged(bool value);
  public:

  // optional bool spell_evaded = 58;
  bool has_spell_evaded() const;
  private:
  bool _internal_has_spell_evaded() const;
  public:
  void clear_spell_evaded();
  bool spell_evaded() const;
  void set_spell_evaded(bool value);
  private:
  bool _internal_spell_evaded() const;
  void _internal_set_spell_evaded(bool value);
  public:

  // optional bool motion_controller_modifier = 59;
  bool has_motion_controller_modifier() const;
  private:
  bool _internal_has_motion_controller_modifier() const;
  public:
  void clear_motion_controller_modifier();
  bool motion_controller_modifier() const;
  void set_motion_controller_modifier(bool value);
  private:
  bool _internal_motion_controller_modifier() const;
  void _internal_set_motion_controller_modifier(bool value);
  public:

  // optional bool long_range_kill = 60;
  bool has_long_range_kill() const;
  private:
  bool _internal_has_long_range_kill() const;
  public:
  void clear_long_range_kill();
  bool long_range_kill() const;
  void set_long_range_kill(bool value);
  private:
  bool _internal_long_range_kill() const;
  void _internal_set_long_range_kill(bool value);
  public:

  // optional uint32 modifier_purge_ability = 61;
  bool has_modifier_purge_ability() const;
  private:
  bool _internal_has_modifier_purge_ability() const;
  public:
  void clear_modifier_purge_ability();
  uint32_t modifier_purge_ability() const;
  void set_modifier_purge_ability(uint32_t value);
  private:
  uint32_t _internal_modifier_purge_ability() const;
  void _internal_set_modifier_purge_ability(uint32_t value);
  public:

  // optional uint32 modifier_purge_npc = 62;
  bool has_modifier_purge_npc() const;
  private:
  bool _internal_has_modifier_purge_npc() const;
  public:
  void clear_modifier_purge_npc();
  uint32_t modifier_purge_npc() const;
  void set_modifier_purge_npc(uint32_t value);
  private:
  uint32_t _internal_modifier_purge_npc() const;
  void _internal_set_modifier_purge_npc(uint32_t value);
  public:

  // optional uint32 total_unit_death_count = 64;
  bool has_total_unit_death_count() const;
  private:
  bool _internal_has_total_unit_death_count() const;
  public:
  void clear_total_unit_death_count();
  uint32_t total_unit_death_count() const;
  void set_total_unit_death_count(uint32_t value);
  private:
  uint32_t _internal_total_unit_death_count() const;
  void _internal_set_total_unit_death_count(uint32_t value);
  public:

  // optional bool root_modifier = 63;
  bool has_root_modifier() const;
  private:
  bool _internal_has_root_modifier() const;
  public:
  void clear_root_modifier();
  bool root_modifier() const;
  void set_root_modifier(bool value);
  private:
  bool _internal_root_modifier() const;
  void _internal_set_root_modifier(bool value);
  public:

  // optional bool aura_modifier = 65;
  bool has_aura_modifier() const;
  private:
  bool _internal_has_aura_modifier() const;
  public:
  void clear_aura_modifier();
  bool aura_modifier() const;
  void set_aura_modifier(bool value);
  private:
  bool _internal_aura_modifier() const;
  void _internal_set_aura_modifier(bool value);
  public:

  // optional bool armor_debuff_modifier = 66;
  bool has_armor_debuff_modifier() const;
  private:
  bool _internal_has_armor_debuff_modifier() const;
  public:
  void clear_armor_debuff_modifier();
  bool armor_debuff_modifier() const;
  void set_armor_debuff_modifier(bool value);
  private:
  bool _internal_armor_debuff_modifier() const;
  void _internal_set_armor_debuff_modifier(bool value);
  public:

  // optional bool no_physical_damage_modifier = 67;
  bool has_no_physical_damage_modifier() const;
  private:
  bool _internal_has_no_physical_damage_modifier() const;
  public:
  void clear_no_physical_damage_modifier();
  bool no_physical_damage_modifier() const;
  void set_no_physical_damage_modifier(bool value);
  private:
  bool _internal_no_physical_damage_modifier() const;
  void _internal_set_no_physical_damage_modifier(bool value);
  public:

  // optional uint32 modifier_ability = 68;
  bool has_modifier_ability() const;
  private:
  bool _internal_has_modifier_ability() const;
  public:
  void clear_modifier_ability();
  uint32_t modifier_ability() const;
  void set_modifier_ability(uint32_t value);
  private:
  uint32_t _internal_modifier_ability() const;
  void _internal_set_modifier_ability(uint32_t value);
  public:

  // optional uint32 kill_eater_event = 71;
  bool has_kill_eater_event() const;
  private:
  bool _internal_has_kill_eater_event() const;
  public:
  void clear_kill_eater_event();
  uint32_t kill_eater_event() const;
  void set_kill_eater_event(uint32_t value);
  private:
  uint32_t _internal_kill_eater_event() const;
  void _internal_set_kill_eater_event(uint32_t value);
  public:

  // optional bool modifier_hidden = 69;
  bool has_modifier_hidden() const;
  private:
  bool _internal_has_modifier_hidden() const;
  public:
  void clear_modifier_hidden();
  bool modifier_hidden() const;
  void set_modifier_hidden(bool value);
  private:
  bool _internal_modifier_hidden() const;
  void _internal_set_modifier_hidden(bool value);
  public:

  // optional bool inflictor_is_stolen_ability = 70;
  bool has_inflictor_is_stolen_ability() const;
  private:
  bool _internal_has_inflictor_is_stolen_ability() const;
  public:
  void clear_inflictor_is_stolen_ability();
  bool inflictor_is_stolen_ability() const;
  void set_inflictor_is_stolen_ability(bool value);
  private:
  bool _internal_inflictor_is_stolen_ability() const;
  void _internal_set_inflictor_is_stolen_ability(bool value);
  public:

  // optional bool spell_generated_attack = 73;
  bool has_spell_generated_attack() const;
  private:
  bool _internal_has_spell_generated_attack() const;
  public:
  void clear_spell_generated_attack();
  bool spell_generated_attack() const;
  void set_spell_generated_attack(bool value);
  private:
  bool _internal_spell_generated_attack() const;
  void _internal_set_spell_generated_attack(bool value);
  public:

  // optional bool at_night_time = 74;
  bool has_at_night_time() const;
  private:
  bool _internal_has_at_night_time() const;
  public:
  void clear_at_night_time();
  bool at_night_time() const;
  void set_at_night_time(bool value);
  private:
  bool _internal_at_night_time() const;
  void _internal_set_at_night_time(bool value);
  public:

  // optional uint32 unit_status_label = 72;
  bool has_unit_status_label() const;
  private:
  bool _internal_has_unit_status_label() const;
  public:
  void clear_unit_status_label();
  uint32_t unit_status_label() const;
  void set_unit_status_label(uint32_t value);
  private:
  uint32_t _internal_unit_status_label() const;
  void _internal_set_unit_status_label(uint32_t value);
  public:

  // optional uint32 neutral_camp_team = 76;
  bool has_neutral_camp_team() const;
  private:
  bool _internal_has_neutral_camp_team() const;
  public:
  void clear_neutral_camp_team();
  uint32_t neutral_camp_team() const;
  void set_neutral_camp_team(uint32_t value);
  private:
  uint32_t _internal_neutral_camp_team() const;
  void _internal_set_neutral_camp_team(uint32_t value);
  public:

  // optional float regenerated_health = 77;
  bool has_regenerated_health() const;
  private:
  bool _internal_has_regenerated_health() const;
  public:
  void clear_regenerated_health();
  float regenerated_health() const;
  void set_regenerated_health(float value);
  private:
  float _internal_regenerated_health() const;
  void _internal_set_regenerated_health(float value);
  public:

  // optional bool attacker_has_scepter = 75;
  bool has_attacker_has_scepter() const;
  private:
  bool _internal_has_attacker_has_scepter() const;
  public:
  void clear_attacker_has_scepter();
  bool attacker_has_scepter() const;
  void set_attacker_has_scepter(bool value);
  private:
  bool _internal_attacker_has_scepter() const;
  void _internal_set_attacker_has_scepter(bool value);
  public:

  // optional bool will_reincarnate = 78;
  bool has_will_reincarnate() const;
  private:
  bool _internal_has_will_reincarnate() const;
  public:
  void clear_will_reincarnate();
  bool will_reincarnate() const;
  void set_will_reincarnate(bool value);
  private:
  bool _internal_will_reincarnate() const;
  void _internal_set_will_reincarnate(bool value);
  public:

  // optional bool uses_charges = 79;
  bool has_uses_charges() const;
  private:
  bool _internal_has_uses_charges() const;
  public:
  void clear_uses_charges();
  bool uses_charges() const;
  void set_uses_charges(bool value);
  private:
  bool _internal_uses_charges() const;
  void _internal_set_uses_charges(bool value);
  public:

  // optional .DOTA_COMBATLOG_TYPES type = 1 [default = DOTA_COMBATLOG_INVALID];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::DOTA_COMBATLOG_TYPES type() const;
  void set_type(::DOTA_COMBATLOG_TYPES value);
  private:
  ::DOTA_COMBATLOG_TYPES _internal_type() const;
  void _internal_set_type(::DOTA_COMBATLOG_TYPES value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgDOTACombatLogEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<3> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > assist_players_;
    uint32_t target_name_;
    uint32_t target_source_name_;
    uint32_t attacker_name_;
    uint32_t damage_source_name_;
    uint32_t inflictor_name_;
    bool is_attacker_illusion_;
    bool is_attacker_hero_;
    bool is_target_illusion_;
    bool is_target_hero_;
    uint32_t value_;
    int32_t health_;
    float timestamp_;
    bool is_visible_radiant_;
    bool is_visible_dire_;
    bool is_ability_toggle_on_;
    bool is_ability_toggle_off_;
    float stun_duration_;
    float slow_duration_;
    uint32_t ability_level_;
    float location_x_;
    float location_y_;
    uint32_t gold_reason_;
    float timestamp_raw_;
    float modifier_duration_;
    uint32_t xp_reason_;
    uint32_t last_hits_;
    uint32_t attacker_team_;
    uint32_t target_team_;
    uint32_t obs_wards_placed_;
    uint32_t assist_player0_;
    uint32_t assist_player1_;
    uint32_t assist_player2_;
    uint32_t assist_player3_;
    uint32_t stack_count_;
    uint32_t neutral_camp_type_;
    uint32_t rune_type_;
    bool hidden_modifier_;
    bool is_target_building_;
    bool is_heal_save_;
    bool is_ultimate_ability_;
    uint32_t attacker_hero_level_;
    uint32_t target_hero_level_;
    uint32_t xpm_;
    uint32_t gpm_;
    uint32_t event_location_;
    uint32_t damage_type_;
    uint32_t damage_category_;
    uint32_t networth_;
    bool target_is_self_;
    bool invisibility_modifier_;
    bool silence_modifier_;
    bool heal_from_lifesteal_;
    uint32_t building_type_;
    float modifier_elapsed_duration_;
    bool modifier_purged_;
    bool spell_evaded_;
    bool motion_controller_modifier_;
    bool long_range_kill_;
    uint32_t modifier_purge_ability_;
    uint32_t modifier_purge_npc_;
    uint32_t total_unit_death_count_;
    bool root_modifier_;
    bool aura_modifier_;
    bool armor_debuff_modifier_;
    bool no_physical_damage_modifier_;
    uint32_t modifier_ability_;
    uint32_t kill_eater_event_;
    bool modifier_hidden_;
    bool inflictor_is_stolen_ability_;
    bool spell_generated_attack_;
    bool at_night_time_;
    uint32_t unit_status_label_;
    uint32_t neutral_camp_team_;
    float regenerated_health_;
    bool attacker_has_scepter_;
    bool will_reincarnate_;
    bool uses_charges_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fshared_5fenums_2eproto;
};
// -------------------------------------------------------------------

class CMsgPendingEventAward final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgPendingEventAward) */ {
 public:
  inline CMsgPendingEventAward() : CMsgPendingEventAward(nullptr) {}
  ~CMsgPendingEventAward() override;
  explicit PROTOBUF_CONSTEXPR CMsgPendingEventAward(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgPendingEventAward(const CMsgPendingEventAward& from);
  CMsgPendingEventAward(CMsgPendingEventAward&& from) noexcept
    : CMsgPendingEventAward() {
    *this = ::std::move(from);
  }

  inline CMsgPendingEventAward& operator=(const CMsgPendingEventAward& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgPendingEventAward& operator=(CMsgPendingEventAward&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgPendingEventAward& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgPendingEventAward* internal_default_instance() {
    return reinterpret_cast<const CMsgPendingEventAward*>(
               &_CMsgPendingEventAward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CMsgPendingEventAward& a, CMsgPendingEventAward& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgPendingEventAward* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgPendingEventAward* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgPendingEventAward* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgPendingEventAward>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgPendingEventAward& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgPendingEventAward& from) {
    CMsgPendingEventAward::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPendingEventAward* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgPendingEventAward";
  }
  protected:
  explicit CMsgPendingEventAward(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdFieldNumber = 1,
    kActionIdFieldNumber = 2,
    kNumToGrantFieldNumber = 3,
    kScoreModeFieldNumber = 4,
    kAuditDataFieldNumber = 6,
    kAuditActionFieldNumber = 5,
  };
  // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
  bool has_event_id() const;
  private:
  bool _internal_has_event_id() const;
  public:
  void clear_event_id();
  ::EEvent event_id() const;
  void set_event_id(::EEvent value);
  private:
  ::EEvent _internal_event_id() const;
  void _internal_set_event_id(::EEvent value);
  public:

  // optional uint32 action_id = 2;
  bool has_action_id() const;
  private:
  bool _internal_has_action_id() const;
  public:
  void clear_action_id();
  uint32_t action_id() const;
  void set_action_id(uint32_t value);
  private:
  uint32_t _internal_action_id() const;
  void _internal_set_action_id(uint32_t value);
  public:

  // optional uint32 num_to_grant = 3;
  bool has_num_to_grant() const;
  private:
  bool _internal_has_num_to_grant() const;
  public:
  void clear_num_to_grant();
  uint32_t num_to_grant() const;
  void set_num_to_grant(uint32_t value);
  private:
  uint32_t _internal_num_to_grant() const;
  void _internal_set_num_to_grant(uint32_t value);
  public:

  // optional .EEventActionScoreMode score_mode = 4 [default = k_eEventActionScoreMode_Add];
  bool has_score_mode() const;
  private:
  bool _internal_has_score_mode() const;
  public:
  void clear_score_mode();
  ::EEventActionScoreMode score_mode() const;
  void set_score_mode(::EEventActionScoreMode value);
  private:
  ::EEventActionScoreMode _internal_score_mode() const;
  void _internal_set_score_mode(::EEventActionScoreMode value);
  public:

  // optional uint64 audit_data = 6;
  bool has_audit_data() const;
  private:
  bool _internal_has_audit_data() const;
  public:
  void clear_audit_data();
  uint64_t audit_data() const;
  void set_audit_data(uint64_t value);
  private:
  uint64_t _internal_audit_data() const;
  void _internal_set_audit_data(uint64_t value);
  public:

  // optional uint32 audit_action = 5;
  bool has_audit_action() const;
  private:
  bool _internal_has_audit_action() const;
  public:
  void clear_audit_action();
  uint32_t audit_action() const;
  void set_audit_action(uint32_t value);
  private:
  uint32_t _internal_audit_action() const;
  void _internal_set_audit_action(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgPendingEventAward)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int event_id_;
    uint32_t action_id_;
    uint32_t num_to_grant_;
    int score_mode_;
    uint64_t audit_data_;
    uint32_t audit_action_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fshared_5fenums_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CDOTAClientHardwareSpecs

// optional uint32 logical_processors = 1;
inline bool CDOTAClientHardwareSpecs::_internal_has_logical_processors() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CDOTAClientHardwareSpecs::has_logical_processors() const {
  return _internal_has_logical_processors();
}
inline void CDOTAClientHardwareSpecs::clear_logical_processors() {
  _impl_.logical_processors_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CDOTAClientHardwareSpecs::_internal_logical_processors() const {
  return _impl_.logical_processors_;
}
inline uint32_t CDOTAClientHardwareSpecs::logical_processors() const {
  // @@protoc_insertion_point(field_get:CDOTAClientHardwareSpecs.logical_processors)
  return _internal_logical_processors();
}
inline void CDOTAClientHardwareSpecs::_internal_set_logical_processors(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.logical_processors_ = value;
}
inline void CDOTAClientHardwareSpecs::set_logical_processors(uint32_t value) {
  _internal_set_logical_processors(value);
  // @@protoc_insertion_point(field_set:CDOTAClientHardwareSpecs.logical_processors)
}

// optional fixed64 cpu_cycles_per_second = 2;
inline bool CDOTAClientHardwareSpecs::_internal_has_cpu_cycles_per_second() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CDOTAClientHardwareSpecs::has_cpu_cycles_per_second() const {
  return _internal_has_cpu_cycles_per_second();
}
inline void CDOTAClientHardwareSpecs::clear_cpu_cycles_per_second() {
  _impl_.cpu_cycles_per_second_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CDOTAClientHardwareSpecs::_internal_cpu_cycles_per_second() const {
  return _impl_.cpu_cycles_per_second_;
}
inline uint64_t CDOTAClientHardwareSpecs::cpu_cycles_per_second() const {
  // @@protoc_insertion_point(field_get:CDOTAClientHardwareSpecs.cpu_cycles_per_second)
  return _internal_cpu_cycles_per_second();
}
inline void CDOTAClientHardwareSpecs::_internal_set_cpu_cycles_per_second(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cpu_cycles_per_second_ = value;
}
inline void CDOTAClientHardwareSpecs::set_cpu_cycles_per_second(uint64_t value) {
  _internal_set_cpu_cycles_per_second(value);
  // @@protoc_insertion_point(field_set:CDOTAClientHardwareSpecs.cpu_cycles_per_second)
}

// optional fixed64 total_physical_memory = 3;
inline bool CDOTAClientHardwareSpecs::_internal_has_total_physical_memory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CDOTAClientHardwareSpecs::has_total_physical_memory() const {
  return _internal_has_total_physical_memory();
}
inline void CDOTAClientHardwareSpecs::clear_total_physical_memory() {
  _impl_.total_physical_memory_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CDOTAClientHardwareSpecs::_internal_total_physical_memory() const {
  return _impl_.total_physical_memory_;
}
inline uint64_t CDOTAClientHardwareSpecs::total_physical_memory() const {
  // @@protoc_insertion_point(field_get:CDOTAClientHardwareSpecs.total_physical_memory)
  return _internal_total_physical_memory();
}
inline void CDOTAClientHardwareSpecs::_internal_set_total_physical_memory(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.total_physical_memory_ = value;
}
inline void CDOTAClientHardwareSpecs::set_total_physical_memory(uint64_t value) {
  _internal_set_total_physical_memory(value);
  // @@protoc_insertion_point(field_set:CDOTAClientHardwareSpecs.total_physical_memory)
}

// optional bool is_64_bit_os = 4;
inline bool CDOTAClientHardwareSpecs::_internal_has_is_64_bit_os() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CDOTAClientHardwareSpecs::has_is_64_bit_os() const {
  return _internal_has_is_64_bit_os();
}
inline void CDOTAClientHardwareSpecs::clear_is_64_bit_os() {
  _impl_.is_64_bit_os_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool CDOTAClientHardwareSpecs::_internal_is_64_bit_os() const {
  return _impl_.is_64_bit_os_;
}
inline bool CDOTAClientHardwareSpecs::is_64_bit_os() const {
  // @@protoc_insertion_point(field_get:CDOTAClientHardwareSpecs.is_64_bit_os)
  return _internal_is_64_bit_os();
}
inline void CDOTAClientHardwareSpecs::_internal_set_is_64_bit_os(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.is_64_bit_os_ = value;
}
inline void CDOTAClientHardwareSpecs::set_is_64_bit_os(bool value) {
  _internal_set_is_64_bit_os(value);
  // @@protoc_insertion_point(field_set:CDOTAClientHardwareSpecs.is_64_bit_os)
}

// optional uint64 upload_measurement = 5;
inline bool CDOTAClientHardwareSpecs::_internal_has_upload_measurement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CDOTAClientHardwareSpecs::has_upload_measurement() const {
  return _internal_has_upload_measurement();
}
inline void CDOTAClientHardwareSpecs::clear_upload_measurement() {
  _impl_.upload_measurement_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t CDOTAClientHardwareSpecs::_internal_upload_measurement() const {
  return _impl_.upload_measurement_;
}
inline uint64_t CDOTAClientHardwareSpecs::upload_measurement() const {
  // @@protoc_insertion_point(field_get:CDOTAClientHardwareSpecs.upload_measurement)
  return _internal_upload_measurement();
}
inline void CDOTAClientHardwareSpecs::_internal_set_upload_measurement(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.upload_measurement_ = value;
}
inline void CDOTAClientHardwareSpecs::set_upload_measurement(uint64_t value) {
  _internal_set_upload_measurement(value);
  // @@protoc_insertion_point(field_set:CDOTAClientHardwareSpecs.upload_measurement)
}

// optional bool prefer_not_host = 6;
inline bool CDOTAClientHardwareSpecs::_internal_has_prefer_not_host() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CDOTAClientHardwareSpecs::has_prefer_not_host() const {
  return _internal_has_prefer_not_host();
}
inline void CDOTAClientHardwareSpecs::clear_prefer_not_host() {
  _impl_.prefer_not_host_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool CDOTAClientHardwareSpecs::_internal_prefer_not_host() const {
  return _impl_.prefer_not_host_;
}
inline bool CDOTAClientHardwareSpecs::prefer_not_host() const {
  // @@protoc_insertion_point(field_get:CDOTAClientHardwareSpecs.prefer_not_host)
  return _internal_prefer_not_host();
}
inline void CDOTAClientHardwareSpecs::_internal_set_prefer_not_host(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.prefer_not_host_ = value;
}
inline void CDOTAClientHardwareSpecs::set_prefer_not_host(bool value) {
  _internal_set_prefer_not_host(value);
  // @@protoc_insertion_point(field_set:CDOTAClientHardwareSpecs.prefer_not_host)
}

// -------------------------------------------------------------------

// CDOTASaveGame_Player

// optional .DOTA_GC_TEAM team = 1 [default = DOTA_GC_TEAM_GOOD_GUYS];
inline bool CDOTASaveGame_Player::_internal_has_team() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CDOTASaveGame_Player::has_team() const {
  return _internal_has_team();
}
inline void CDOTASaveGame_Player::clear_team() {
  _impl_.team_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::DOTA_GC_TEAM CDOTASaveGame_Player::_internal_team() const {
  return static_cast< ::DOTA_GC_TEAM >(_impl_.team_);
}
inline ::DOTA_GC_TEAM CDOTASaveGame_Player::team() const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.Player.team)
  return _internal_team();
}
inline void CDOTASaveGame_Player::_internal_set_team(::DOTA_GC_TEAM value) {
  assert(::DOTA_GC_TEAM_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.team_ = value;
}
inline void CDOTASaveGame_Player::set_team(::DOTA_GC_TEAM value) {
  _internal_set_team(value);
  // @@protoc_insertion_point(field_set:CDOTASaveGame.Player.team)
}

// optional string name = 2;
inline bool CDOTASaveGame_Player::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CDOTASaveGame_Player::has_name() const {
  return _internal_has_name();
}
inline void CDOTASaveGame_Player::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CDOTASaveGame_Player::name() const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.Player.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CDOTASaveGame_Player::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CDOTASaveGame.Player.name)
}
inline std::string* CDOTASaveGame_Player::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CDOTASaveGame.Player.name)
  return _s;
}
inline const std::string& CDOTASaveGame_Player::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CDOTASaveGame_Player::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CDOTASaveGame_Player::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CDOTASaveGame_Player::release_name() {
  // @@protoc_insertion_point(field_release:CDOTASaveGame.Player.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CDOTASaveGame_Player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CDOTASaveGame.Player.name)
}

// optional string hero = 3;
inline bool CDOTASaveGame_Player::_internal_has_hero() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CDOTASaveGame_Player::has_hero() const {
  return _internal_has_hero();
}
inline void CDOTASaveGame_Player::clear_hero() {
  _impl_.hero_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CDOTASaveGame_Player::hero() const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.Player.hero)
  return _internal_hero();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CDOTASaveGame_Player::set_hero(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.hero_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CDOTASaveGame.Player.hero)
}
inline std::string* CDOTASaveGame_Player::mutable_hero() {
  std::string* _s = _internal_mutable_hero();
  // @@protoc_insertion_point(field_mutable:CDOTASaveGame.Player.hero)
  return _s;
}
inline const std::string& CDOTASaveGame_Player::_internal_hero() const {
  return _impl_.hero_.Get();
}
inline void CDOTASaveGame_Player::_internal_set_hero(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.hero_.Set(value, GetArenaForAllocation());
}
inline std::string* CDOTASaveGame_Player::_internal_mutable_hero() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.hero_.Mutable(GetArenaForAllocation());
}
inline std::string* CDOTASaveGame_Player::release_hero() {
  // @@protoc_insertion_point(field_release:CDOTASaveGame.Player.hero)
  if (!_internal_has_hero()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.hero_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hero_.IsDefault()) {
    _impl_.hero_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CDOTASaveGame_Player::set_allocated_hero(std::string* hero) {
  if (hero != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.hero_.SetAllocated(hero, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hero_.IsDefault()) {
    _impl_.hero_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CDOTASaveGame.Player.hero)
}

// -------------------------------------------------------------------

// CDOTASaveGame_SaveInstance_PlayerPositions

// optional float x = 1;
inline bool CDOTASaveGame_SaveInstance_PlayerPositions::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CDOTASaveGame_SaveInstance_PlayerPositions::has_x() const {
  return _internal_has_x();
}
inline void CDOTASaveGame_SaveInstance_PlayerPositions::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float CDOTASaveGame_SaveInstance_PlayerPositions::_internal_x() const {
  return _impl_.x_;
}
inline float CDOTASaveGame_SaveInstance_PlayerPositions::x() const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.SaveInstance.PlayerPositions.x)
  return _internal_x();
}
inline void CDOTASaveGame_SaveInstance_PlayerPositions::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void CDOTASaveGame_SaveInstance_PlayerPositions::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:CDOTASaveGame.SaveInstance.PlayerPositions.x)
}

// optional float y = 2;
inline bool CDOTASaveGame_SaveInstance_PlayerPositions::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CDOTASaveGame_SaveInstance_PlayerPositions::has_y() const {
  return _internal_has_y();
}
inline void CDOTASaveGame_SaveInstance_PlayerPositions::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float CDOTASaveGame_SaveInstance_PlayerPositions::_internal_y() const {
  return _impl_.y_;
}
inline float CDOTASaveGame_SaveInstance_PlayerPositions::y() const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.SaveInstance.PlayerPositions.y)
  return _internal_y();
}
inline void CDOTASaveGame_SaveInstance_PlayerPositions::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void CDOTASaveGame_SaveInstance_PlayerPositions::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:CDOTASaveGame.SaveInstance.PlayerPositions.y)
}

// -------------------------------------------------------------------

// CDOTASaveGame_SaveInstance

// optional uint32 game_time = 2;
inline bool CDOTASaveGame_SaveInstance::_internal_has_game_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CDOTASaveGame_SaveInstance::has_game_time() const {
  return _internal_has_game_time();
}
inline void CDOTASaveGame_SaveInstance::clear_game_time() {
  _impl_.game_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CDOTASaveGame_SaveInstance::_internal_game_time() const {
  return _impl_.game_time_;
}
inline uint32_t CDOTASaveGame_SaveInstance::game_time() const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.SaveInstance.game_time)
  return _internal_game_time();
}
inline void CDOTASaveGame_SaveInstance::_internal_set_game_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.game_time_ = value;
}
inline void CDOTASaveGame_SaveInstance::set_game_time(uint32_t value) {
  _internal_set_game_time(value);
  // @@protoc_insertion_point(field_set:CDOTASaveGame.SaveInstance.game_time)
}

// optional uint32 team1_score = 3;
inline bool CDOTASaveGame_SaveInstance::_internal_has_team1_score() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CDOTASaveGame_SaveInstance::has_team1_score() const {
  return _internal_has_team1_score();
}
inline void CDOTASaveGame_SaveInstance::clear_team1_score() {
  _impl_.team1_score_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CDOTASaveGame_SaveInstance::_internal_team1_score() const {
  return _impl_.team1_score_;
}
inline uint32_t CDOTASaveGame_SaveInstance::team1_score() const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.SaveInstance.team1_score)
  return _internal_team1_score();
}
inline void CDOTASaveGame_SaveInstance::_internal_set_team1_score(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.team1_score_ = value;
}
inline void CDOTASaveGame_SaveInstance::set_team1_score(uint32_t value) {
  _internal_set_team1_score(value);
  // @@protoc_insertion_point(field_set:CDOTASaveGame.SaveInstance.team1_score)
}

// optional uint32 team2_score = 4;
inline bool CDOTASaveGame_SaveInstance::_internal_has_team2_score() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CDOTASaveGame_SaveInstance::has_team2_score() const {
  return _internal_has_team2_score();
}
inline void CDOTASaveGame_SaveInstance::clear_team2_score() {
  _impl_.team2_score_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CDOTASaveGame_SaveInstance::_internal_team2_score() const {
  return _impl_.team2_score_;
}
inline uint32_t CDOTASaveGame_SaveInstance::team2_score() const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.SaveInstance.team2_score)
  return _internal_team2_score();
}
inline void CDOTASaveGame_SaveInstance::_internal_set_team2_score(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.team2_score_ = value;
}
inline void CDOTASaveGame_SaveInstance::set_team2_score(uint32_t value) {
  _internal_set_team2_score(value);
  // @@protoc_insertion_point(field_set:CDOTASaveGame.SaveInstance.team2_score)
}

// repeated .CDOTASaveGame.SaveInstance.PlayerPositions player_positions = 5;
inline int CDOTASaveGame_SaveInstance::_internal_player_positions_size() const {
  return _impl_.player_positions_.size();
}
inline int CDOTASaveGame_SaveInstance::player_positions_size() const {
  return _internal_player_positions_size();
}
inline void CDOTASaveGame_SaveInstance::clear_player_positions() {
  _impl_.player_positions_.Clear();
}
inline ::CDOTASaveGame_SaveInstance_PlayerPositions* CDOTASaveGame_SaveInstance::mutable_player_positions(int index) {
  // @@protoc_insertion_point(field_mutable:CDOTASaveGame.SaveInstance.player_positions)
  return _impl_.player_positions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_SaveInstance_PlayerPositions >*
CDOTASaveGame_SaveInstance::mutable_player_positions() {
  // @@protoc_insertion_point(field_mutable_list:CDOTASaveGame.SaveInstance.player_positions)
  return &_impl_.player_positions_;
}
inline const ::CDOTASaveGame_SaveInstance_PlayerPositions& CDOTASaveGame_SaveInstance::_internal_player_positions(int index) const {
  return _impl_.player_positions_.Get(index);
}
inline const ::CDOTASaveGame_SaveInstance_PlayerPositions& CDOTASaveGame_SaveInstance::player_positions(int index) const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.SaveInstance.player_positions)
  return _internal_player_positions(index);
}
inline ::CDOTASaveGame_SaveInstance_PlayerPositions* CDOTASaveGame_SaveInstance::_internal_add_player_positions() {
  return _impl_.player_positions_.Add();
}
inline ::CDOTASaveGame_SaveInstance_PlayerPositions* CDOTASaveGame_SaveInstance::add_player_positions() {
  ::CDOTASaveGame_SaveInstance_PlayerPositions* _add = _internal_add_player_positions();
  // @@protoc_insertion_point(field_add:CDOTASaveGame.SaveInstance.player_positions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_SaveInstance_PlayerPositions >&
CDOTASaveGame_SaveInstance::player_positions() const {
  // @@protoc_insertion_point(field_list:CDOTASaveGame.SaveInstance.player_positions)
  return _impl_.player_positions_;
}

// optional uint32 save_id = 6;
inline bool CDOTASaveGame_SaveInstance::_internal_has_save_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CDOTASaveGame_SaveInstance::has_save_id() const {
  return _internal_has_save_id();
}
inline void CDOTASaveGame_SaveInstance::clear_save_id() {
  _impl_.save_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CDOTASaveGame_SaveInstance::_internal_save_id() const {
  return _impl_.save_id_;
}
inline uint32_t CDOTASaveGame_SaveInstance::save_id() const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.SaveInstance.save_id)
  return _internal_save_id();
}
inline void CDOTASaveGame_SaveInstance::_internal_set_save_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.save_id_ = value;
}
inline void CDOTASaveGame_SaveInstance::set_save_id(uint32_t value) {
  _internal_set_save_id(value);
  // @@protoc_insertion_point(field_set:CDOTASaveGame.SaveInstance.save_id)
}

// optional uint32 save_time = 7;
inline bool CDOTASaveGame_SaveInstance::_internal_has_save_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CDOTASaveGame_SaveInstance::has_save_time() const {
  return _internal_has_save_time();
}
inline void CDOTASaveGame_SaveInstance::clear_save_time() {
  _impl_.save_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CDOTASaveGame_SaveInstance::_internal_save_time() const {
  return _impl_.save_time_;
}
inline uint32_t CDOTASaveGame_SaveInstance::save_time() const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.SaveInstance.save_time)
  return _internal_save_time();
}
inline void CDOTASaveGame_SaveInstance::_internal_set_save_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.save_time_ = value;
}
inline void CDOTASaveGame_SaveInstance::set_save_time(uint32_t value) {
  _internal_set_save_time(value);
  // @@protoc_insertion_point(field_set:CDOTASaveGame.SaveInstance.save_time)
}

// -------------------------------------------------------------------

// CDOTASaveGame

// optional uint64 match_id = 5;
inline bool CDOTASaveGame::_internal_has_match_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CDOTASaveGame::has_match_id() const {
  return _internal_has_match_id();
}
inline void CDOTASaveGame::clear_match_id() {
  _impl_.match_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CDOTASaveGame::_internal_match_id() const {
  return _impl_.match_id_;
}
inline uint64_t CDOTASaveGame::match_id() const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.match_id)
  return _internal_match_id();
}
inline void CDOTASaveGame::_internal_set_match_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.match_id_ = value;
}
inline void CDOTASaveGame::set_match_id(uint64_t value) {
  _internal_set_match_id(value);
  // @@protoc_insertion_point(field_set:CDOTASaveGame.match_id)
}

// optional uint32 save_time = 2;
inline bool CDOTASaveGame::_internal_has_save_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CDOTASaveGame::has_save_time() const {
  return _internal_has_save_time();
}
inline void CDOTASaveGame::clear_save_time() {
  _impl_.save_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CDOTASaveGame::_internal_save_time() const {
  return _impl_.save_time_;
}
inline uint32_t CDOTASaveGame::save_time() const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.save_time)
  return _internal_save_time();
}
inline void CDOTASaveGame::_internal_set_save_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.save_time_ = value;
}
inline void CDOTASaveGame::set_save_time(uint32_t value) {
  _internal_set_save_time(value);
  // @@protoc_insertion_point(field_set:CDOTASaveGame.save_time)
}

// repeated .CDOTASaveGame.Player players = 3;
inline int CDOTASaveGame::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int CDOTASaveGame::players_size() const {
  return _internal_players_size();
}
inline void CDOTASaveGame::clear_players() {
  _impl_.players_.Clear();
}
inline ::CDOTASaveGame_Player* CDOTASaveGame::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:CDOTASaveGame.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_Player >*
CDOTASaveGame::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:CDOTASaveGame.players)
  return &_impl_.players_;
}
inline const ::CDOTASaveGame_Player& CDOTASaveGame::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::CDOTASaveGame_Player& CDOTASaveGame::players(int index) const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.players)
  return _internal_players(index);
}
inline ::CDOTASaveGame_Player* CDOTASaveGame::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::CDOTASaveGame_Player* CDOTASaveGame::add_players() {
  ::CDOTASaveGame_Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:CDOTASaveGame.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_Player >&
CDOTASaveGame::players() const {
  // @@protoc_insertion_point(field_list:CDOTASaveGame.players)
  return _impl_.players_;
}

// repeated .CDOTASaveGame.SaveInstance save_instances = 4;
inline int CDOTASaveGame::_internal_save_instances_size() const {
  return _impl_.save_instances_.size();
}
inline int CDOTASaveGame::save_instances_size() const {
  return _internal_save_instances_size();
}
inline void CDOTASaveGame::clear_save_instances() {
  _impl_.save_instances_.Clear();
}
inline ::CDOTASaveGame_SaveInstance* CDOTASaveGame::mutable_save_instances(int index) {
  // @@protoc_insertion_point(field_mutable:CDOTASaveGame.save_instances)
  return _impl_.save_instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_SaveInstance >*
CDOTASaveGame::mutable_save_instances() {
  // @@protoc_insertion_point(field_mutable_list:CDOTASaveGame.save_instances)
  return &_impl_.save_instances_;
}
inline const ::CDOTASaveGame_SaveInstance& CDOTASaveGame::_internal_save_instances(int index) const {
  return _impl_.save_instances_.Get(index);
}
inline const ::CDOTASaveGame_SaveInstance& CDOTASaveGame::save_instances(int index) const {
  // @@protoc_insertion_point(field_get:CDOTASaveGame.save_instances)
  return _internal_save_instances(index);
}
inline ::CDOTASaveGame_SaveInstance* CDOTASaveGame::_internal_add_save_instances() {
  return _impl_.save_instances_.Add();
}
inline ::CDOTASaveGame_SaveInstance* CDOTASaveGame::add_save_instances() {
  ::CDOTASaveGame_SaveInstance* _add = _internal_add_save_instances();
  // @@protoc_insertion_point(field_add:CDOTASaveGame.save_instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CDOTASaveGame_SaveInstance >&
CDOTASaveGame::save_instances() const {
  // @@protoc_insertion_point(field_list:CDOTASaveGame.save_instances)
  return _impl_.save_instances_;
}

// -------------------------------------------------------------------

// CMsgDOTACombatLogEntry

// optional .DOTA_COMBATLOG_TYPES type = 1 [default = DOTA_COMBATLOG_INVALID];
inline bool CMsgDOTACombatLogEntry::_internal_has_type() const {
  bool value = (_impl_._has_bits_[2] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_type() const {
  return _internal_has_type();
}
inline void CMsgDOTACombatLogEntry::clear_type() {
  _impl_.type_ = -1;
  _impl_._has_bits_[2] &= ~0x00002000u;
}
inline ::DOTA_COMBATLOG_TYPES CMsgDOTACombatLogEntry::_internal_type() const {
  return static_cast< ::DOTA_COMBATLOG_TYPES >(_impl_.type_);
}
inline ::DOTA_COMBATLOG_TYPES CMsgDOTACombatLogEntry::type() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.type)
  return _internal_type();
}
inline void CMsgDOTACombatLogEntry::_internal_set_type(::DOTA_COMBATLOG_TYPES value) {
  assert(::DOTA_COMBATLOG_TYPES_IsValid(value));
  _impl_._has_bits_[2] |= 0x00002000u;
  _impl_.type_ = value;
}
inline void CMsgDOTACombatLogEntry::set_type(::DOTA_COMBATLOG_TYPES value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.type)
}

// optional uint32 target_name = 2;
inline bool CMsgDOTACombatLogEntry::_internal_has_target_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_target_name() const {
  return _internal_has_target_name();
}
inline void CMsgDOTACombatLogEntry::clear_target_name() {
  _impl_.target_name_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_target_name() const {
  return _impl_.target_name_;
}
inline uint32_t CMsgDOTACombatLogEntry::target_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.target_name)
  return _internal_target_name();
}
inline void CMsgDOTACombatLogEntry::_internal_set_target_name(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.target_name_ = value;
}
inline void CMsgDOTACombatLogEntry::set_target_name(uint32_t value) {
  _internal_set_target_name(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.target_name)
}

// optional uint32 target_source_name = 3;
inline bool CMsgDOTACombatLogEntry::_internal_has_target_source_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_target_source_name() const {
  return _internal_has_target_source_name();
}
inline void CMsgDOTACombatLogEntry::clear_target_source_name() {
  _impl_.target_source_name_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_target_source_name() const {
  return _impl_.target_source_name_;
}
inline uint32_t CMsgDOTACombatLogEntry::target_source_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.target_source_name)
  return _internal_target_source_name();
}
inline void CMsgDOTACombatLogEntry::_internal_set_target_source_name(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.target_source_name_ = value;
}
inline void CMsgDOTACombatLogEntry::set_target_source_name(uint32_t value) {
  _internal_set_target_source_name(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.target_source_name)
}

// optional uint32 attacker_name = 4;
inline bool CMsgDOTACombatLogEntry::_internal_has_attacker_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_attacker_name() const {
  return _internal_has_attacker_name();
}
inline void CMsgDOTACombatLogEntry::clear_attacker_name() {
  _impl_.attacker_name_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_attacker_name() const {
  return _impl_.attacker_name_;
}
inline uint32_t CMsgDOTACombatLogEntry::attacker_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.attacker_name)
  return _internal_attacker_name();
}
inline void CMsgDOTACombatLogEntry::_internal_set_attacker_name(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.attacker_name_ = value;
}
inline void CMsgDOTACombatLogEntry::set_attacker_name(uint32_t value) {
  _internal_set_attacker_name(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.attacker_name)
}

// optional uint32 damage_source_name = 5;
inline bool CMsgDOTACombatLogEntry::_internal_has_damage_source_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_damage_source_name() const {
  return _internal_has_damage_source_name();
}
inline void CMsgDOTACombatLogEntry::clear_damage_source_name() {
  _impl_.damage_source_name_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_damage_source_name() const {
  return _impl_.damage_source_name_;
}
inline uint32_t CMsgDOTACombatLogEntry::damage_source_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.damage_source_name)
  return _internal_damage_source_name();
}
inline void CMsgDOTACombatLogEntry::_internal_set_damage_source_name(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.damage_source_name_ = value;
}
inline void CMsgDOTACombatLogEntry::set_damage_source_name(uint32_t value) {
  _internal_set_damage_source_name(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.damage_source_name)
}

// optional uint32 inflictor_name = 6;
inline bool CMsgDOTACombatLogEntry::_internal_has_inflictor_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_inflictor_name() const {
  return _internal_has_inflictor_name();
}
inline void CMsgDOTACombatLogEntry::clear_inflictor_name() {
  _impl_.inflictor_name_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_inflictor_name() const {
  return _impl_.inflictor_name_;
}
inline uint32_t CMsgDOTACombatLogEntry::inflictor_name() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.inflictor_name)
  return _internal_inflictor_name();
}
inline void CMsgDOTACombatLogEntry::_internal_set_inflictor_name(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.inflictor_name_ = value;
}
inline void CMsgDOTACombatLogEntry::set_inflictor_name(uint32_t value) {
  _internal_set_inflictor_name(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.inflictor_name)
}

// optional bool is_attacker_illusion = 7;
inline bool CMsgDOTACombatLogEntry::_internal_has_is_attacker_illusion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_is_attacker_illusion() const {
  return _internal_has_is_attacker_illusion();
}
inline void CMsgDOTACombatLogEntry::clear_is_attacker_illusion() {
  _impl_.is_attacker_illusion_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool CMsgDOTACombatLogEntry::_internal_is_attacker_illusion() const {
  return _impl_.is_attacker_illusion_;
}
inline bool CMsgDOTACombatLogEntry::is_attacker_illusion() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.is_attacker_illusion)
  return _internal_is_attacker_illusion();
}
inline void CMsgDOTACombatLogEntry::_internal_set_is_attacker_illusion(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.is_attacker_illusion_ = value;
}
inline void CMsgDOTACombatLogEntry::set_is_attacker_illusion(bool value) {
  _internal_set_is_attacker_illusion(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.is_attacker_illusion)
}

// optional bool is_attacker_hero = 8;
inline bool CMsgDOTACombatLogEntry::_internal_has_is_attacker_hero() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_is_attacker_hero() const {
  return _internal_has_is_attacker_hero();
}
inline void CMsgDOTACombatLogEntry::clear_is_attacker_hero() {
  _impl_.is_attacker_hero_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool CMsgDOTACombatLogEntry::_internal_is_attacker_hero() const {
  return _impl_.is_attacker_hero_;
}
inline bool CMsgDOTACombatLogEntry::is_attacker_hero() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.is_attacker_hero)
  return _internal_is_attacker_hero();
}
inline void CMsgDOTACombatLogEntry::_internal_set_is_attacker_hero(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.is_attacker_hero_ = value;
}
inline void CMsgDOTACombatLogEntry::set_is_attacker_hero(bool value) {
  _internal_set_is_attacker_hero(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.is_attacker_hero)
}

// optional bool is_target_illusion = 9;
inline bool CMsgDOTACombatLogEntry::_internal_has_is_target_illusion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_is_target_illusion() const {
  return _internal_has_is_target_illusion();
}
inline void CMsgDOTACombatLogEntry::clear_is_target_illusion() {
  _impl_.is_target_illusion_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool CMsgDOTACombatLogEntry::_internal_is_target_illusion() const {
  return _impl_.is_target_illusion_;
}
inline bool CMsgDOTACombatLogEntry::is_target_illusion() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.is_target_illusion)
  return _internal_is_target_illusion();
}
inline void CMsgDOTACombatLogEntry::_internal_set_is_target_illusion(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.is_target_illusion_ = value;
}
inline void CMsgDOTACombatLogEntry::set_is_target_illusion(bool value) {
  _internal_set_is_target_illusion(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.is_target_illusion)
}

// optional bool is_target_hero = 10;
inline bool CMsgDOTACombatLogEntry::_internal_has_is_target_hero() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_is_target_hero() const {
  return _internal_has_is_target_hero();
}
inline void CMsgDOTACombatLogEntry::clear_is_target_hero() {
  _impl_.is_target_hero_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool CMsgDOTACombatLogEntry::_internal_is_target_hero() const {
  return _impl_.is_target_hero_;
}
inline bool CMsgDOTACombatLogEntry::is_target_hero() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.is_target_hero)
  return _internal_is_target_hero();
}
inline void CMsgDOTACombatLogEntry::_internal_set_is_target_hero(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.is_target_hero_ = value;
}
inline void CMsgDOTACombatLogEntry::set_is_target_hero(bool value) {
  _internal_set_is_target_hero(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.is_target_hero)
}

// optional bool is_visible_radiant = 11;
inline bool CMsgDOTACombatLogEntry::_internal_has_is_visible_radiant() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_is_visible_radiant() const {
  return _internal_has_is_visible_radiant();
}
inline void CMsgDOTACombatLogEntry::clear_is_visible_radiant() {
  _impl_.is_visible_radiant_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_is_visible_radiant() const {
  return _impl_.is_visible_radiant_;
}
inline bool CMsgDOTACombatLogEntry::is_visible_radiant() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.is_visible_radiant)
  return _internal_is_visible_radiant();
}
inline void CMsgDOTACombatLogEntry::_internal_set_is_visible_radiant(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.is_visible_radiant_ = value;
}
inline void CMsgDOTACombatLogEntry::set_is_visible_radiant(bool value) {
  _internal_set_is_visible_radiant(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.is_visible_radiant)
}

// optional bool is_visible_dire = 12;
inline bool CMsgDOTACombatLogEntry::_internal_has_is_visible_dire() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_is_visible_dire() const {
  return _internal_has_is_visible_dire();
}
inline void CMsgDOTACombatLogEntry::clear_is_visible_dire() {
  _impl_.is_visible_dire_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_is_visible_dire() const {
  return _impl_.is_visible_dire_;
}
inline bool CMsgDOTACombatLogEntry::is_visible_dire() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.is_visible_dire)
  return _internal_is_visible_dire();
}
inline void CMsgDOTACombatLogEntry::_internal_set_is_visible_dire(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.is_visible_dire_ = value;
}
inline void CMsgDOTACombatLogEntry::set_is_visible_dire(bool value) {
  _internal_set_is_visible_dire(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.is_visible_dire)
}

// optional uint32 value = 13;
inline bool CMsgDOTACombatLogEntry::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_value() const {
  return _internal_has_value();
}
inline void CMsgDOTACombatLogEntry::clear_value() {
  _impl_.value_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_value() const {
  return _impl_.value_;
}
inline uint32_t CMsgDOTACombatLogEntry::value() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.value)
  return _internal_value();
}
inline void CMsgDOTACombatLogEntry::_internal_set_value(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.value_ = value;
}
inline void CMsgDOTACombatLogEntry::set_value(uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.value)
}

// optional int32 health = 14;
inline bool CMsgDOTACombatLogEntry::_internal_has_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_health() const {
  return _internal_has_health();
}
inline void CMsgDOTACombatLogEntry::clear_health() {
  _impl_.health_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int32_t CMsgDOTACombatLogEntry::_internal_health() const {
  return _impl_.health_;
}
inline int32_t CMsgDOTACombatLogEntry::health() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.health)
  return _internal_health();
}
inline void CMsgDOTACombatLogEntry::_internal_set_health(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.health_ = value;
}
inline void CMsgDOTACombatLogEntry::set_health(int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.health)
}

// optional float timestamp = 15;
inline bool CMsgDOTACombatLogEntry::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CMsgDOTACombatLogEntry::clear_timestamp() {
  _impl_.timestamp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float CMsgDOTACombatLogEntry::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline float CMsgDOTACombatLogEntry::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.timestamp)
  return _internal_timestamp();
}
inline void CMsgDOTACombatLogEntry::_internal_set_timestamp(float value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.timestamp_ = value;
}
inline void CMsgDOTACombatLogEntry::set_timestamp(float value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.timestamp)
}

// optional float stun_duration = 16;
inline bool CMsgDOTACombatLogEntry::_internal_has_stun_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_stun_duration() const {
  return _internal_has_stun_duration();
}
inline void CMsgDOTACombatLogEntry::clear_stun_duration() {
  _impl_.stun_duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline float CMsgDOTACombatLogEntry::_internal_stun_duration() const {
  return _impl_.stun_duration_;
}
inline float CMsgDOTACombatLogEntry::stun_duration() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.stun_duration)
  return _internal_stun_duration();
}
inline void CMsgDOTACombatLogEntry::_internal_set_stun_duration(float value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.stun_duration_ = value;
}
inline void CMsgDOTACombatLogEntry::set_stun_duration(float value) {
  _internal_set_stun_duration(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.stun_duration)
}

// optional float slow_duration = 17;
inline bool CMsgDOTACombatLogEntry::_internal_has_slow_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_slow_duration() const {
  return _internal_has_slow_duration();
}
inline void CMsgDOTACombatLogEntry::clear_slow_duration() {
  _impl_.slow_duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline float CMsgDOTACombatLogEntry::_internal_slow_duration() const {
  return _impl_.slow_duration_;
}
inline float CMsgDOTACombatLogEntry::slow_duration() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.slow_duration)
  return _internal_slow_duration();
}
inline void CMsgDOTACombatLogEntry::_internal_set_slow_duration(float value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.slow_duration_ = value;
}
inline void CMsgDOTACombatLogEntry::set_slow_duration(float value) {
  _internal_set_slow_duration(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.slow_duration)
}

// optional bool is_ability_toggle_on = 18;
inline bool CMsgDOTACombatLogEntry::_internal_has_is_ability_toggle_on() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_is_ability_toggle_on() const {
  return _internal_has_is_ability_toggle_on();
}
inline void CMsgDOTACombatLogEntry::clear_is_ability_toggle_on() {
  _impl_.is_ability_toggle_on_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_is_ability_toggle_on() const {
  return _impl_.is_ability_toggle_on_;
}
inline bool CMsgDOTACombatLogEntry::is_ability_toggle_on() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.is_ability_toggle_on)
  return _internal_is_ability_toggle_on();
}
inline void CMsgDOTACombatLogEntry::_internal_set_is_ability_toggle_on(bool value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.is_ability_toggle_on_ = value;
}
inline void CMsgDOTACombatLogEntry::set_is_ability_toggle_on(bool value) {
  _internal_set_is_ability_toggle_on(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.is_ability_toggle_on)
}

// optional bool is_ability_toggle_off = 19;
inline bool CMsgDOTACombatLogEntry::_internal_has_is_ability_toggle_off() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_is_ability_toggle_off() const {
  return _internal_has_is_ability_toggle_off();
}
inline void CMsgDOTACombatLogEntry::clear_is_ability_toggle_off() {
  _impl_.is_ability_toggle_off_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_is_ability_toggle_off() const {
  return _impl_.is_ability_toggle_off_;
}
inline bool CMsgDOTACombatLogEntry::is_ability_toggle_off() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.is_ability_toggle_off)
  return _internal_is_ability_toggle_off();
}
inline void CMsgDOTACombatLogEntry::_internal_set_is_ability_toggle_off(bool value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.is_ability_toggle_off_ = value;
}
inline void CMsgDOTACombatLogEntry::set_is_ability_toggle_off(bool value) {
  _internal_set_is_ability_toggle_off(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.is_ability_toggle_off)
}

// optional uint32 ability_level = 20;
inline bool CMsgDOTACombatLogEntry::_internal_has_ability_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_ability_level() const {
  return _internal_has_ability_level();
}
inline void CMsgDOTACombatLogEntry::clear_ability_level() {
  _impl_.ability_level_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_ability_level() const {
  return _impl_.ability_level_;
}
inline uint32_t CMsgDOTACombatLogEntry::ability_level() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.ability_level)
  return _internal_ability_level();
}
inline void CMsgDOTACombatLogEntry::_internal_set_ability_level(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.ability_level_ = value;
}
inline void CMsgDOTACombatLogEntry::set_ability_level(uint32_t value) {
  _internal_set_ability_level(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.ability_level)
}

// optional float location_x = 21;
inline bool CMsgDOTACombatLogEntry::_internal_has_location_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_location_x() const {
  return _internal_has_location_x();
}
inline void CMsgDOTACombatLogEntry::clear_location_x() {
  _impl_.location_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline float CMsgDOTACombatLogEntry::_internal_location_x() const {
  return _impl_.location_x_;
}
inline float CMsgDOTACombatLogEntry::location_x() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.location_x)
  return _internal_location_x();
}
inline void CMsgDOTACombatLogEntry::_internal_set_location_x(float value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.location_x_ = value;
}
inline void CMsgDOTACombatLogEntry::set_location_x(float value) {
  _internal_set_location_x(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.location_x)
}

// optional float location_y = 22;
inline bool CMsgDOTACombatLogEntry::_internal_has_location_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_location_y() const {
  return _internal_has_location_y();
}
inline void CMsgDOTACombatLogEntry::clear_location_y() {
  _impl_.location_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline float CMsgDOTACombatLogEntry::_internal_location_y() const {
  return _impl_.location_y_;
}
inline float CMsgDOTACombatLogEntry::location_y() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.location_y)
  return _internal_location_y();
}
inline void CMsgDOTACombatLogEntry::_internal_set_location_y(float value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.location_y_ = value;
}
inline void CMsgDOTACombatLogEntry::set_location_y(float value) {
  _internal_set_location_y(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.location_y)
}

// optional uint32 gold_reason = 23;
inline bool CMsgDOTACombatLogEntry::_internal_has_gold_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_gold_reason() const {
  return _internal_has_gold_reason();
}
inline void CMsgDOTACombatLogEntry::clear_gold_reason() {
  _impl_.gold_reason_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_gold_reason() const {
  return _impl_.gold_reason_;
}
inline uint32_t CMsgDOTACombatLogEntry::gold_reason() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.gold_reason)
  return _internal_gold_reason();
}
inline void CMsgDOTACombatLogEntry::_internal_set_gold_reason(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.gold_reason_ = value;
}
inline void CMsgDOTACombatLogEntry::set_gold_reason(uint32_t value) {
  _internal_set_gold_reason(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.gold_reason)
}

// optional float timestamp_raw = 24;
inline bool CMsgDOTACombatLogEntry::_internal_has_timestamp_raw() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_timestamp_raw() const {
  return _internal_has_timestamp_raw();
}
inline void CMsgDOTACombatLogEntry::clear_timestamp_raw() {
  _impl_.timestamp_raw_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline float CMsgDOTACombatLogEntry::_internal_timestamp_raw() const {
  return _impl_.timestamp_raw_;
}
inline float CMsgDOTACombatLogEntry::timestamp_raw() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.timestamp_raw)
  return _internal_timestamp_raw();
}
inline void CMsgDOTACombatLogEntry::_internal_set_timestamp_raw(float value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.timestamp_raw_ = value;
}
inline void CMsgDOTACombatLogEntry::set_timestamp_raw(float value) {
  _internal_set_timestamp_raw(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.timestamp_raw)
}

// optional float modifier_duration = 25;
inline bool CMsgDOTACombatLogEntry::_internal_has_modifier_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_modifier_duration() const {
  return _internal_has_modifier_duration();
}
inline void CMsgDOTACombatLogEntry::clear_modifier_duration() {
  _impl_.modifier_duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline float CMsgDOTACombatLogEntry::_internal_modifier_duration() const {
  return _impl_.modifier_duration_;
}
inline float CMsgDOTACombatLogEntry::modifier_duration() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.modifier_duration)
  return _internal_modifier_duration();
}
inline void CMsgDOTACombatLogEntry::_internal_set_modifier_duration(float value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.modifier_duration_ = value;
}
inline void CMsgDOTACombatLogEntry::set_modifier_duration(float value) {
  _internal_set_modifier_duration(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.modifier_duration)
}

// optional uint32 xp_reason = 26;
inline bool CMsgDOTACombatLogEntry::_internal_has_xp_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_xp_reason() const {
  return _internal_has_xp_reason();
}
inline void CMsgDOTACombatLogEntry::clear_xp_reason() {
  _impl_.xp_reason_ = 0u;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_xp_reason() const {
  return _impl_.xp_reason_;
}
inline uint32_t CMsgDOTACombatLogEntry::xp_reason() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.xp_reason)
  return _internal_xp_reason();
}
inline void CMsgDOTACombatLogEntry::_internal_set_xp_reason(uint32_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.xp_reason_ = value;
}
inline void CMsgDOTACombatLogEntry::set_xp_reason(uint32_t value) {
  _internal_set_xp_reason(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.xp_reason)
}

// optional uint32 last_hits = 27;
inline bool CMsgDOTACombatLogEntry::_internal_has_last_hits() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_last_hits() const {
  return _internal_has_last_hits();
}
inline void CMsgDOTACombatLogEntry::clear_last_hits() {
  _impl_.last_hits_ = 0u;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_last_hits() const {
  return _impl_.last_hits_;
}
inline uint32_t CMsgDOTACombatLogEntry::last_hits() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.last_hits)
  return _internal_last_hits();
}
inline void CMsgDOTACombatLogEntry::_internal_set_last_hits(uint32_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.last_hits_ = value;
}
inline void CMsgDOTACombatLogEntry::set_last_hits(uint32_t value) {
  _internal_set_last_hits(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.last_hits)
}

// optional uint32 attacker_team = 28;
inline bool CMsgDOTACombatLogEntry::_internal_has_attacker_team() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_attacker_team() const {
  return _internal_has_attacker_team();
}
inline void CMsgDOTACombatLogEntry::clear_attacker_team() {
  _impl_.attacker_team_ = 0u;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_attacker_team() const {
  return _impl_.attacker_team_;
}
inline uint32_t CMsgDOTACombatLogEntry::attacker_team() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.attacker_team)
  return _internal_attacker_team();
}
inline void CMsgDOTACombatLogEntry::_internal_set_attacker_team(uint32_t value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.attacker_team_ = value;
}
inline void CMsgDOTACombatLogEntry::set_attacker_team(uint32_t value) {
  _internal_set_attacker_team(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.attacker_team)
}

// optional uint32 target_team = 29;
inline bool CMsgDOTACombatLogEntry::_internal_has_target_team() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_target_team() const {
  return _internal_has_target_team();
}
inline void CMsgDOTACombatLogEntry::clear_target_team() {
  _impl_.target_team_ = 0u;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_target_team() const {
  return _impl_.target_team_;
}
inline uint32_t CMsgDOTACombatLogEntry::target_team() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.target_team)
  return _internal_target_team();
}
inline void CMsgDOTACombatLogEntry::_internal_set_target_team(uint32_t value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.target_team_ = value;
}
inline void CMsgDOTACombatLogEntry::set_target_team(uint32_t value) {
  _internal_set_target_team(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.target_team)
}

// optional uint32 obs_wards_placed = 30;
inline bool CMsgDOTACombatLogEntry::_internal_has_obs_wards_placed() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_obs_wards_placed() const {
  return _internal_has_obs_wards_placed();
}
inline void CMsgDOTACombatLogEntry::clear_obs_wards_placed() {
  _impl_.obs_wards_placed_ = 0u;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_obs_wards_placed() const {
  return _impl_.obs_wards_placed_;
}
inline uint32_t CMsgDOTACombatLogEntry::obs_wards_placed() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.obs_wards_placed)
  return _internal_obs_wards_placed();
}
inline void CMsgDOTACombatLogEntry::_internal_set_obs_wards_placed(uint32_t value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.obs_wards_placed_ = value;
}
inline void CMsgDOTACombatLogEntry::set_obs_wards_placed(uint32_t value) {
  _internal_set_obs_wards_placed(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.obs_wards_placed)
}

// optional uint32 assist_player0 = 31;
inline bool CMsgDOTACombatLogEntry::_internal_has_assist_player0() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_assist_player0() const {
  return _internal_has_assist_player0();
}
inline void CMsgDOTACombatLogEntry::clear_assist_player0() {
  _impl_.assist_player0_ = 0u;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_assist_player0() const {
  return _impl_.assist_player0_;
}
inline uint32_t CMsgDOTACombatLogEntry::assist_player0() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.assist_player0)
  return _internal_assist_player0();
}
inline void CMsgDOTACombatLogEntry::_internal_set_assist_player0(uint32_t value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.assist_player0_ = value;
}
inline void CMsgDOTACombatLogEntry::set_assist_player0(uint32_t value) {
  _internal_set_assist_player0(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.assist_player0)
}

// optional uint32 assist_player1 = 32;
inline bool CMsgDOTACombatLogEntry::_internal_has_assist_player1() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_assist_player1() const {
  return _internal_has_assist_player1();
}
inline void CMsgDOTACombatLogEntry::clear_assist_player1() {
  _impl_.assist_player1_ = 0u;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_assist_player1() const {
  return _impl_.assist_player1_;
}
inline uint32_t CMsgDOTACombatLogEntry::assist_player1() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.assist_player1)
  return _internal_assist_player1();
}
inline void CMsgDOTACombatLogEntry::_internal_set_assist_player1(uint32_t value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.assist_player1_ = value;
}
inline void CMsgDOTACombatLogEntry::set_assist_player1(uint32_t value) {
  _internal_set_assist_player1(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.assist_player1)
}

// optional uint32 assist_player2 = 33;
inline bool CMsgDOTACombatLogEntry::_internal_has_assist_player2() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_assist_player2() const {
  return _internal_has_assist_player2();
}
inline void CMsgDOTACombatLogEntry::clear_assist_player2() {
  _impl_.assist_player2_ = 0u;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_assist_player2() const {
  return _impl_.assist_player2_;
}
inline uint32_t CMsgDOTACombatLogEntry::assist_player2() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.assist_player2)
  return _internal_assist_player2();
}
inline void CMsgDOTACombatLogEntry::_internal_set_assist_player2(uint32_t value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.assist_player2_ = value;
}
inline void CMsgDOTACombatLogEntry::set_assist_player2(uint32_t value) {
  _internal_set_assist_player2(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.assist_player2)
}

// optional uint32 assist_player3 = 34;
inline bool CMsgDOTACombatLogEntry::_internal_has_assist_player3() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_assist_player3() const {
  return _internal_has_assist_player3();
}
inline void CMsgDOTACombatLogEntry::clear_assist_player3() {
  _impl_.assist_player3_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_assist_player3() const {
  return _impl_.assist_player3_;
}
inline uint32_t CMsgDOTACombatLogEntry::assist_player3() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.assist_player3)
  return _internal_assist_player3();
}
inline void CMsgDOTACombatLogEntry::_internal_set_assist_player3(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.assist_player3_ = value;
}
inline void CMsgDOTACombatLogEntry::set_assist_player3(uint32_t value) {
  _internal_set_assist_player3(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.assist_player3)
}

// optional uint32 stack_count = 35;
inline bool CMsgDOTACombatLogEntry::_internal_has_stack_count() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_stack_count() const {
  return _internal_has_stack_count();
}
inline void CMsgDOTACombatLogEntry::clear_stack_count() {
  _impl_.stack_count_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_stack_count() const {
  return _impl_.stack_count_;
}
inline uint32_t CMsgDOTACombatLogEntry::stack_count() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.stack_count)
  return _internal_stack_count();
}
inline void CMsgDOTACombatLogEntry::_internal_set_stack_count(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.stack_count_ = value;
}
inline void CMsgDOTACombatLogEntry::set_stack_count(uint32_t value) {
  _internal_set_stack_count(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.stack_count)
}

// optional bool hidden_modifier = 36;
inline bool CMsgDOTACombatLogEntry::_internal_has_hidden_modifier() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_hidden_modifier() const {
  return _internal_has_hidden_modifier();
}
inline void CMsgDOTACombatLogEntry::clear_hidden_modifier() {
  _impl_.hidden_modifier_ = false;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline bool CMsgDOTACombatLogEntry::_internal_hidden_modifier() const {
  return _impl_.hidden_modifier_;
}
inline bool CMsgDOTACombatLogEntry::hidden_modifier() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.hidden_modifier)
  return _internal_hidden_modifier();
}
inline void CMsgDOTACombatLogEntry::_internal_set_hidden_modifier(bool value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.hidden_modifier_ = value;
}
inline void CMsgDOTACombatLogEntry::set_hidden_modifier(bool value) {
  _internal_set_hidden_modifier(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.hidden_modifier)
}

// optional bool is_target_building = 37;
inline bool CMsgDOTACombatLogEntry::_internal_has_is_target_building() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_is_target_building() const {
  return _internal_has_is_target_building();
}
inline void CMsgDOTACombatLogEntry::clear_is_target_building() {
  _impl_.is_target_building_ = false;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline bool CMsgDOTACombatLogEntry::_internal_is_target_building() const {
  return _impl_.is_target_building_;
}
inline bool CMsgDOTACombatLogEntry::is_target_building() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.is_target_building)
  return _internal_is_target_building();
}
inline void CMsgDOTACombatLogEntry::_internal_set_is_target_building(bool value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.is_target_building_ = value;
}
inline void CMsgDOTACombatLogEntry::set_is_target_building(bool value) {
  _internal_set_is_target_building(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.is_target_building)
}

// optional uint32 neutral_camp_type = 38;
inline bool CMsgDOTACombatLogEntry::_internal_has_neutral_camp_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_neutral_camp_type() const {
  return _internal_has_neutral_camp_type();
}
inline void CMsgDOTACombatLogEntry::clear_neutral_camp_type() {
  _impl_.neutral_camp_type_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_neutral_camp_type() const {
  return _impl_.neutral_camp_type_;
}
inline uint32_t CMsgDOTACombatLogEntry::neutral_camp_type() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.neutral_camp_type)
  return _internal_neutral_camp_type();
}
inline void CMsgDOTACombatLogEntry::_internal_set_neutral_camp_type(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.neutral_camp_type_ = value;
}
inline void CMsgDOTACombatLogEntry::set_neutral_camp_type(uint32_t value) {
  _internal_set_neutral_camp_type(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.neutral_camp_type)
}

// optional uint32 rune_type = 39;
inline bool CMsgDOTACombatLogEntry::_internal_has_rune_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_rune_type() const {
  return _internal_has_rune_type();
}
inline void CMsgDOTACombatLogEntry::clear_rune_type() {
  _impl_.rune_type_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_rune_type() const {
  return _impl_.rune_type_;
}
inline uint32_t CMsgDOTACombatLogEntry::rune_type() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.rune_type)
  return _internal_rune_type();
}
inline void CMsgDOTACombatLogEntry::_internal_set_rune_type(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.rune_type_ = value;
}
inline void CMsgDOTACombatLogEntry::set_rune_type(uint32_t value) {
  _internal_set_rune_type(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.rune_type)
}

// repeated int32 assist_players = 40;
inline int CMsgDOTACombatLogEntry::_internal_assist_players_size() const {
  return _impl_.assist_players_.size();
}
inline int CMsgDOTACombatLogEntry::assist_players_size() const {
  return _internal_assist_players_size();
}
inline void CMsgDOTACombatLogEntry::clear_assist_players() {
  _impl_.assist_players_.Clear();
}
inline int32_t CMsgDOTACombatLogEntry::_internal_assist_players(int index) const {
  return _impl_.assist_players_.Get(index);
}
inline int32_t CMsgDOTACombatLogEntry::assist_players(int index) const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.assist_players)
  return _internal_assist_players(index);
}
inline void CMsgDOTACombatLogEntry::set_assist_players(int index, int32_t value) {
  _impl_.assist_players_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.assist_players)
}
inline void CMsgDOTACombatLogEntry::_internal_add_assist_players(int32_t value) {
  _impl_.assist_players_.Add(value);
}
inline void CMsgDOTACombatLogEntry::add_assist_players(int32_t value) {
  _internal_add_assist_players(value);
  // @@protoc_insertion_point(field_add:CMsgDOTACombatLogEntry.assist_players)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
CMsgDOTACombatLogEntry::_internal_assist_players() const {
  return _impl_.assist_players_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
CMsgDOTACombatLogEntry::assist_players() const {
  // @@protoc_insertion_point(field_list:CMsgDOTACombatLogEntry.assist_players)
  return _internal_assist_players();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
CMsgDOTACombatLogEntry::_internal_mutable_assist_players() {
  return &_impl_.assist_players_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
CMsgDOTACombatLogEntry::mutable_assist_players() {
  // @@protoc_insertion_point(field_mutable_list:CMsgDOTACombatLogEntry.assist_players)
  return _internal_mutable_assist_players();
}

// optional bool is_heal_save = 41;
inline bool CMsgDOTACombatLogEntry::_internal_has_is_heal_save() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_is_heal_save() const {
  return _internal_has_is_heal_save();
}
inline void CMsgDOTACombatLogEntry::clear_is_heal_save() {
  _impl_.is_heal_save_ = false;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline bool CMsgDOTACombatLogEntry::_internal_is_heal_save() const {
  return _impl_.is_heal_save_;
}
inline bool CMsgDOTACombatLogEntry::is_heal_save() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.is_heal_save)
  return _internal_is_heal_save();
}
inline void CMsgDOTACombatLogEntry::_internal_set_is_heal_save(bool value) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.is_heal_save_ = value;
}
inline void CMsgDOTACombatLogEntry::set_is_heal_save(bool value) {
  _internal_set_is_heal_save(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.is_heal_save)
}

// optional bool is_ultimate_ability = 42;
inline bool CMsgDOTACombatLogEntry::_internal_has_is_ultimate_ability() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_is_ultimate_ability() const {
  return _internal_has_is_ultimate_ability();
}
inline void CMsgDOTACombatLogEntry::clear_is_ultimate_ability() {
  _impl_.is_ultimate_ability_ = false;
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline bool CMsgDOTACombatLogEntry::_internal_is_ultimate_ability() const {
  return _impl_.is_ultimate_ability_;
}
inline bool CMsgDOTACombatLogEntry::is_ultimate_ability() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.is_ultimate_ability)
  return _internal_is_ultimate_ability();
}
inline void CMsgDOTACombatLogEntry::_internal_set_is_ultimate_ability(bool value) {
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.is_ultimate_ability_ = value;
}
inline void CMsgDOTACombatLogEntry::set_is_ultimate_ability(bool value) {
  _internal_set_is_ultimate_ability(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.is_ultimate_ability)
}

// optional uint32 attacker_hero_level = 43;
inline bool CMsgDOTACombatLogEntry::_internal_has_attacker_hero_level() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_attacker_hero_level() const {
  return _internal_has_attacker_hero_level();
}
inline void CMsgDOTACombatLogEntry::clear_attacker_hero_level() {
  _impl_.attacker_hero_level_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_attacker_hero_level() const {
  return _impl_.attacker_hero_level_;
}
inline uint32_t CMsgDOTACombatLogEntry::attacker_hero_level() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.attacker_hero_level)
  return _internal_attacker_hero_level();
}
inline void CMsgDOTACombatLogEntry::_internal_set_attacker_hero_level(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.attacker_hero_level_ = value;
}
inline void CMsgDOTACombatLogEntry::set_attacker_hero_level(uint32_t value) {
  _internal_set_attacker_hero_level(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.attacker_hero_level)
}

// optional uint32 target_hero_level = 44;
inline bool CMsgDOTACombatLogEntry::_internal_has_target_hero_level() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_target_hero_level() const {
  return _internal_has_target_hero_level();
}
inline void CMsgDOTACombatLogEntry::clear_target_hero_level() {
  _impl_.target_hero_level_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_target_hero_level() const {
  return _impl_.target_hero_level_;
}
inline uint32_t CMsgDOTACombatLogEntry::target_hero_level() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.target_hero_level)
  return _internal_target_hero_level();
}
inline void CMsgDOTACombatLogEntry::_internal_set_target_hero_level(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.target_hero_level_ = value;
}
inline void CMsgDOTACombatLogEntry::set_target_hero_level(uint32_t value) {
  _internal_set_target_hero_level(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.target_hero_level)
}

// optional uint32 xpm = 45;
inline bool CMsgDOTACombatLogEntry::_internal_has_xpm() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_xpm() const {
  return _internal_has_xpm();
}
inline void CMsgDOTACombatLogEntry::clear_xpm() {
  _impl_.xpm_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_xpm() const {
  return _impl_.xpm_;
}
inline uint32_t CMsgDOTACombatLogEntry::xpm() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.xpm)
  return _internal_xpm();
}
inline void CMsgDOTACombatLogEntry::_internal_set_xpm(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.xpm_ = value;
}
inline void CMsgDOTACombatLogEntry::set_xpm(uint32_t value) {
  _internal_set_xpm(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.xpm)
}

// optional uint32 gpm = 46;
inline bool CMsgDOTACombatLogEntry::_internal_has_gpm() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_gpm() const {
  return _internal_has_gpm();
}
inline void CMsgDOTACombatLogEntry::clear_gpm() {
  _impl_.gpm_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_gpm() const {
  return _impl_.gpm_;
}
inline uint32_t CMsgDOTACombatLogEntry::gpm() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.gpm)
  return _internal_gpm();
}
inline void CMsgDOTACombatLogEntry::_internal_set_gpm(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000800u;
  _impl_.gpm_ = value;
}
inline void CMsgDOTACombatLogEntry::set_gpm(uint32_t value) {
  _internal_set_gpm(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.gpm)
}

// optional uint32 event_location = 47;
inline bool CMsgDOTACombatLogEntry::_internal_has_event_location() const {
  bool value = (_impl_._has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_event_location() const {
  return _internal_has_event_location();
}
inline void CMsgDOTACombatLogEntry::clear_event_location() {
  _impl_.event_location_ = 0u;
  _impl_._has_bits_[1] &= ~0x00001000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_event_location() const {
  return _impl_.event_location_;
}
inline uint32_t CMsgDOTACombatLogEntry::event_location() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.event_location)
  return _internal_event_location();
}
inline void CMsgDOTACombatLogEntry::_internal_set_event_location(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00001000u;
  _impl_.event_location_ = value;
}
inline void CMsgDOTACombatLogEntry::set_event_location(uint32_t value) {
  _internal_set_event_location(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.event_location)
}

// optional bool target_is_self = 48;
inline bool CMsgDOTACombatLogEntry::_internal_has_target_is_self() const {
  bool value = (_impl_._has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_target_is_self() const {
  return _internal_has_target_is_self();
}
inline void CMsgDOTACombatLogEntry::clear_target_is_self() {
  _impl_.target_is_self_ = false;
  _impl_._has_bits_[1] &= ~0x00010000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_target_is_self() const {
  return _impl_.target_is_self_;
}
inline bool CMsgDOTACombatLogEntry::target_is_self() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.target_is_self)
  return _internal_target_is_self();
}
inline void CMsgDOTACombatLogEntry::_internal_set_target_is_self(bool value) {
  _impl_._has_bits_[1] |= 0x00010000u;
  _impl_.target_is_self_ = value;
}
inline void CMsgDOTACombatLogEntry::set_target_is_self(bool value) {
  _internal_set_target_is_self(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.target_is_self)
}

// optional uint32 damage_type = 49;
inline bool CMsgDOTACombatLogEntry::_internal_has_damage_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_damage_type() const {
  return _internal_has_damage_type();
}
inline void CMsgDOTACombatLogEntry::clear_damage_type() {
  _impl_.damage_type_ = 0u;
  _impl_._has_bits_[1] &= ~0x00002000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_damage_type() const {
  return _impl_.damage_type_;
}
inline uint32_t CMsgDOTACombatLogEntry::damage_type() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.damage_type)
  return _internal_damage_type();
}
inline void CMsgDOTACombatLogEntry::_internal_set_damage_type(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00002000u;
  _impl_.damage_type_ = value;
}
inline void CMsgDOTACombatLogEntry::set_damage_type(uint32_t value) {
  _internal_set_damage_type(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.damage_type)
}

// optional bool invisibility_modifier = 50;
inline bool CMsgDOTACombatLogEntry::_internal_has_invisibility_modifier() const {
  bool value = (_impl_._has_bits_[1] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_invisibility_modifier() const {
  return _internal_has_invisibility_modifier();
}
inline void CMsgDOTACombatLogEntry::clear_invisibility_modifier() {
  _impl_.invisibility_modifier_ = false;
  _impl_._has_bits_[1] &= ~0x00020000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_invisibility_modifier() const {
  return _impl_.invisibility_modifier_;
}
inline bool CMsgDOTACombatLogEntry::invisibility_modifier() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.invisibility_modifier)
  return _internal_invisibility_modifier();
}
inline void CMsgDOTACombatLogEntry::_internal_set_invisibility_modifier(bool value) {
  _impl_._has_bits_[1] |= 0x00020000u;
  _impl_.invisibility_modifier_ = value;
}
inline void CMsgDOTACombatLogEntry::set_invisibility_modifier(bool value) {
  _internal_set_invisibility_modifier(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.invisibility_modifier)
}

// optional uint32 damage_category = 51;
inline bool CMsgDOTACombatLogEntry::_internal_has_damage_category() const {
  bool value = (_impl_._has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_damage_category() const {
  return _internal_has_damage_category();
}
inline void CMsgDOTACombatLogEntry::clear_damage_category() {
  _impl_.damage_category_ = 0u;
  _impl_._has_bits_[1] &= ~0x00004000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_damage_category() const {
  return _impl_.damage_category_;
}
inline uint32_t CMsgDOTACombatLogEntry::damage_category() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.damage_category)
  return _internal_damage_category();
}
inline void CMsgDOTACombatLogEntry::_internal_set_damage_category(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00004000u;
  _impl_.damage_category_ = value;
}
inline void CMsgDOTACombatLogEntry::set_damage_category(uint32_t value) {
  _internal_set_damage_category(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.damage_category)
}

// optional uint32 networth = 52;
inline bool CMsgDOTACombatLogEntry::_internal_has_networth() const {
  bool value = (_impl_._has_bits_[1] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_networth() const {
  return _internal_has_networth();
}
inline void CMsgDOTACombatLogEntry::clear_networth() {
  _impl_.networth_ = 0u;
  _impl_._has_bits_[1] &= ~0x00008000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_networth() const {
  return _impl_.networth_;
}
inline uint32_t CMsgDOTACombatLogEntry::networth() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.networth)
  return _internal_networth();
}
inline void CMsgDOTACombatLogEntry::_internal_set_networth(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00008000u;
  _impl_.networth_ = value;
}
inline void CMsgDOTACombatLogEntry::set_networth(uint32_t value) {
  _internal_set_networth(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.networth)
}

// optional uint32 building_type = 53;
inline bool CMsgDOTACombatLogEntry::_internal_has_building_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00100000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_building_type() const {
  return _internal_has_building_type();
}
inline void CMsgDOTACombatLogEntry::clear_building_type() {
  _impl_.building_type_ = 0u;
  _impl_._has_bits_[1] &= ~0x00100000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_building_type() const {
  return _impl_.building_type_;
}
inline uint32_t CMsgDOTACombatLogEntry::building_type() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.building_type)
  return _internal_building_type();
}
inline void CMsgDOTACombatLogEntry::_internal_set_building_type(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00100000u;
  _impl_.building_type_ = value;
}
inline void CMsgDOTACombatLogEntry::set_building_type(uint32_t value) {
  _internal_set_building_type(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.building_type)
}

// optional float modifier_elapsed_duration = 54;
inline bool CMsgDOTACombatLogEntry::_internal_has_modifier_elapsed_duration() const {
  bool value = (_impl_._has_bits_[1] & 0x00200000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_modifier_elapsed_duration() const {
  return _internal_has_modifier_elapsed_duration();
}
inline void CMsgDOTACombatLogEntry::clear_modifier_elapsed_duration() {
  _impl_.modifier_elapsed_duration_ = 0;
  _impl_._has_bits_[1] &= ~0x00200000u;
}
inline float CMsgDOTACombatLogEntry::_internal_modifier_elapsed_duration() const {
  return _impl_.modifier_elapsed_duration_;
}
inline float CMsgDOTACombatLogEntry::modifier_elapsed_duration() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.modifier_elapsed_duration)
  return _internal_modifier_elapsed_duration();
}
inline void CMsgDOTACombatLogEntry::_internal_set_modifier_elapsed_duration(float value) {
  _impl_._has_bits_[1] |= 0x00200000u;
  _impl_.modifier_elapsed_duration_ = value;
}
inline void CMsgDOTACombatLogEntry::set_modifier_elapsed_duration(float value) {
  _internal_set_modifier_elapsed_duration(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.modifier_elapsed_duration)
}

// optional bool silence_modifier = 55;
inline bool CMsgDOTACombatLogEntry::_internal_has_silence_modifier() const {
  bool value = (_impl_._has_bits_[1] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_silence_modifier() const {
  return _internal_has_silence_modifier();
}
inline void CMsgDOTACombatLogEntry::clear_silence_modifier() {
  _impl_.silence_modifier_ = false;
  _impl_._has_bits_[1] &= ~0x00040000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_silence_modifier() const {
  return _impl_.silence_modifier_;
}
inline bool CMsgDOTACombatLogEntry::silence_modifier() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.silence_modifier)
  return _internal_silence_modifier();
}
inline void CMsgDOTACombatLogEntry::_internal_set_silence_modifier(bool value) {
  _impl_._has_bits_[1] |= 0x00040000u;
  _impl_.silence_modifier_ = value;
}
inline void CMsgDOTACombatLogEntry::set_silence_modifier(bool value) {
  _internal_set_silence_modifier(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.silence_modifier)
}

// optional bool heal_from_lifesteal = 56;
inline bool CMsgDOTACombatLogEntry::_internal_has_heal_from_lifesteal() const {
  bool value = (_impl_._has_bits_[1] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_heal_from_lifesteal() const {
  return _internal_has_heal_from_lifesteal();
}
inline void CMsgDOTACombatLogEntry::clear_heal_from_lifesteal() {
  _impl_.heal_from_lifesteal_ = false;
  _impl_._has_bits_[1] &= ~0x00080000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_heal_from_lifesteal() const {
  return _impl_.heal_from_lifesteal_;
}
inline bool CMsgDOTACombatLogEntry::heal_from_lifesteal() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.heal_from_lifesteal)
  return _internal_heal_from_lifesteal();
}
inline void CMsgDOTACombatLogEntry::_internal_set_heal_from_lifesteal(bool value) {
  _impl_._has_bits_[1] |= 0x00080000u;
  _impl_.heal_from_lifesteal_ = value;
}
inline void CMsgDOTACombatLogEntry::set_heal_from_lifesteal(bool value) {
  _internal_set_heal_from_lifesteal(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.heal_from_lifesteal)
}

// optional bool modifier_purged = 57;
inline bool CMsgDOTACombatLogEntry::_internal_has_modifier_purged() const {
  bool value = (_impl_._has_bits_[1] & 0x00400000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_modifier_purged() const {
  return _internal_has_modifier_purged();
}
inline void CMsgDOTACombatLogEntry::clear_modifier_purged() {
  _impl_.modifier_purged_ = false;
  _impl_._has_bits_[1] &= ~0x00400000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_modifier_purged() const {
  return _impl_.modifier_purged_;
}
inline bool CMsgDOTACombatLogEntry::modifier_purged() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.modifier_purged)
  return _internal_modifier_purged();
}
inline void CMsgDOTACombatLogEntry::_internal_set_modifier_purged(bool value) {
  _impl_._has_bits_[1] |= 0x00400000u;
  _impl_.modifier_purged_ = value;
}
inline void CMsgDOTACombatLogEntry::set_modifier_purged(bool value) {
  _internal_set_modifier_purged(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.modifier_purged)
}

// optional bool spell_evaded = 58;
inline bool CMsgDOTACombatLogEntry::_internal_has_spell_evaded() const {
  bool value = (_impl_._has_bits_[1] & 0x00800000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_spell_evaded() const {
  return _internal_has_spell_evaded();
}
inline void CMsgDOTACombatLogEntry::clear_spell_evaded() {
  _impl_.spell_evaded_ = false;
  _impl_._has_bits_[1] &= ~0x00800000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_spell_evaded() const {
  return _impl_.spell_evaded_;
}
inline bool CMsgDOTACombatLogEntry::spell_evaded() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.spell_evaded)
  return _internal_spell_evaded();
}
inline void CMsgDOTACombatLogEntry::_internal_set_spell_evaded(bool value) {
  _impl_._has_bits_[1] |= 0x00800000u;
  _impl_.spell_evaded_ = value;
}
inline void CMsgDOTACombatLogEntry::set_spell_evaded(bool value) {
  _internal_set_spell_evaded(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.spell_evaded)
}

// optional bool motion_controller_modifier = 59;
inline bool CMsgDOTACombatLogEntry::_internal_has_motion_controller_modifier() const {
  bool value = (_impl_._has_bits_[1] & 0x01000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_motion_controller_modifier() const {
  return _internal_has_motion_controller_modifier();
}
inline void CMsgDOTACombatLogEntry::clear_motion_controller_modifier() {
  _impl_.motion_controller_modifier_ = false;
  _impl_._has_bits_[1] &= ~0x01000000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_motion_controller_modifier() const {
  return _impl_.motion_controller_modifier_;
}
inline bool CMsgDOTACombatLogEntry::motion_controller_modifier() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.motion_controller_modifier)
  return _internal_motion_controller_modifier();
}
inline void CMsgDOTACombatLogEntry::_internal_set_motion_controller_modifier(bool value) {
  _impl_._has_bits_[1] |= 0x01000000u;
  _impl_.motion_controller_modifier_ = value;
}
inline void CMsgDOTACombatLogEntry::set_motion_controller_modifier(bool value) {
  _internal_set_motion_controller_modifier(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.motion_controller_modifier)
}

// optional bool long_range_kill = 60;
inline bool CMsgDOTACombatLogEntry::_internal_has_long_range_kill() const {
  bool value = (_impl_._has_bits_[1] & 0x02000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_long_range_kill() const {
  return _internal_has_long_range_kill();
}
inline void CMsgDOTACombatLogEntry::clear_long_range_kill() {
  _impl_.long_range_kill_ = false;
  _impl_._has_bits_[1] &= ~0x02000000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_long_range_kill() const {
  return _impl_.long_range_kill_;
}
inline bool CMsgDOTACombatLogEntry::long_range_kill() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.long_range_kill)
  return _internal_long_range_kill();
}
inline void CMsgDOTACombatLogEntry::_internal_set_long_range_kill(bool value) {
  _impl_._has_bits_[1] |= 0x02000000u;
  _impl_.long_range_kill_ = value;
}
inline void CMsgDOTACombatLogEntry::set_long_range_kill(bool value) {
  _internal_set_long_range_kill(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.long_range_kill)
}

// optional uint32 modifier_purge_ability = 61;
inline bool CMsgDOTACombatLogEntry::_internal_has_modifier_purge_ability() const {
  bool value = (_impl_._has_bits_[1] & 0x04000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_modifier_purge_ability() const {
  return _internal_has_modifier_purge_ability();
}
inline void CMsgDOTACombatLogEntry::clear_modifier_purge_ability() {
  _impl_.modifier_purge_ability_ = 0u;
  _impl_._has_bits_[1] &= ~0x04000000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_modifier_purge_ability() const {
  return _impl_.modifier_purge_ability_;
}
inline uint32_t CMsgDOTACombatLogEntry::modifier_purge_ability() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.modifier_purge_ability)
  return _internal_modifier_purge_ability();
}
inline void CMsgDOTACombatLogEntry::_internal_set_modifier_purge_ability(uint32_t value) {
  _impl_._has_bits_[1] |= 0x04000000u;
  _impl_.modifier_purge_ability_ = value;
}
inline void CMsgDOTACombatLogEntry::set_modifier_purge_ability(uint32_t value) {
  _internal_set_modifier_purge_ability(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.modifier_purge_ability)
}

// optional uint32 modifier_purge_npc = 62;
inline bool CMsgDOTACombatLogEntry::_internal_has_modifier_purge_npc() const {
  bool value = (_impl_._has_bits_[1] & 0x08000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_modifier_purge_npc() const {
  return _internal_has_modifier_purge_npc();
}
inline void CMsgDOTACombatLogEntry::clear_modifier_purge_npc() {
  _impl_.modifier_purge_npc_ = 0u;
  _impl_._has_bits_[1] &= ~0x08000000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_modifier_purge_npc() const {
  return _impl_.modifier_purge_npc_;
}
inline uint32_t CMsgDOTACombatLogEntry::modifier_purge_npc() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.modifier_purge_npc)
  return _internal_modifier_purge_npc();
}
inline void CMsgDOTACombatLogEntry::_internal_set_modifier_purge_npc(uint32_t value) {
  _impl_._has_bits_[1] |= 0x08000000u;
  _impl_.modifier_purge_npc_ = value;
}
inline void CMsgDOTACombatLogEntry::set_modifier_purge_npc(uint32_t value) {
  _internal_set_modifier_purge_npc(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.modifier_purge_npc)
}

// optional bool root_modifier = 63;
inline bool CMsgDOTACombatLogEntry::_internal_has_root_modifier() const {
  bool value = (_impl_._has_bits_[1] & 0x20000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_root_modifier() const {
  return _internal_has_root_modifier();
}
inline void CMsgDOTACombatLogEntry::clear_root_modifier() {
  _impl_.root_modifier_ = false;
  _impl_._has_bits_[1] &= ~0x20000000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_root_modifier() const {
  return _impl_.root_modifier_;
}
inline bool CMsgDOTACombatLogEntry::root_modifier() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.root_modifier)
  return _internal_root_modifier();
}
inline void CMsgDOTACombatLogEntry::_internal_set_root_modifier(bool value) {
  _impl_._has_bits_[1] |= 0x20000000u;
  _impl_.root_modifier_ = value;
}
inline void CMsgDOTACombatLogEntry::set_root_modifier(bool value) {
  _internal_set_root_modifier(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.root_modifier)
}

// optional uint32 total_unit_death_count = 64;
inline bool CMsgDOTACombatLogEntry::_internal_has_total_unit_death_count() const {
  bool value = (_impl_._has_bits_[1] & 0x10000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_total_unit_death_count() const {
  return _internal_has_total_unit_death_count();
}
inline void CMsgDOTACombatLogEntry::clear_total_unit_death_count() {
  _impl_.total_unit_death_count_ = 0u;
  _impl_._has_bits_[1] &= ~0x10000000u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_total_unit_death_count() const {
  return _impl_.total_unit_death_count_;
}
inline uint32_t CMsgDOTACombatLogEntry::total_unit_death_count() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.total_unit_death_count)
  return _internal_total_unit_death_count();
}
inline void CMsgDOTACombatLogEntry::_internal_set_total_unit_death_count(uint32_t value) {
  _impl_._has_bits_[1] |= 0x10000000u;
  _impl_.total_unit_death_count_ = value;
}
inline void CMsgDOTACombatLogEntry::set_total_unit_death_count(uint32_t value) {
  _internal_set_total_unit_death_count(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.total_unit_death_count)
}

// optional bool aura_modifier = 65;
inline bool CMsgDOTACombatLogEntry::_internal_has_aura_modifier() const {
  bool value = (_impl_._has_bits_[1] & 0x40000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_aura_modifier() const {
  return _internal_has_aura_modifier();
}
inline void CMsgDOTACombatLogEntry::clear_aura_modifier() {
  _impl_.aura_modifier_ = false;
  _impl_._has_bits_[1] &= ~0x40000000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_aura_modifier() const {
  return _impl_.aura_modifier_;
}
inline bool CMsgDOTACombatLogEntry::aura_modifier() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.aura_modifier)
  return _internal_aura_modifier();
}
inline void CMsgDOTACombatLogEntry::_internal_set_aura_modifier(bool value) {
  _impl_._has_bits_[1] |= 0x40000000u;
  _impl_.aura_modifier_ = value;
}
inline void CMsgDOTACombatLogEntry::set_aura_modifier(bool value) {
  _internal_set_aura_modifier(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.aura_modifier)
}

// optional bool armor_debuff_modifier = 66;
inline bool CMsgDOTACombatLogEntry::_internal_has_armor_debuff_modifier() const {
  bool value = (_impl_._has_bits_[1] & 0x80000000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_armor_debuff_modifier() const {
  return _internal_has_armor_debuff_modifier();
}
inline void CMsgDOTACombatLogEntry::clear_armor_debuff_modifier() {
  _impl_.armor_debuff_modifier_ = false;
  _impl_._has_bits_[1] &= ~0x80000000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_armor_debuff_modifier() const {
  return _impl_.armor_debuff_modifier_;
}
inline bool CMsgDOTACombatLogEntry::armor_debuff_modifier() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.armor_debuff_modifier)
  return _internal_armor_debuff_modifier();
}
inline void CMsgDOTACombatLogEntry::_internal_set_armor_debuff_modifier(bool value) {
  _impl_._has_bits_[1] |= 0x80000000u;
  _impl_.armor_debuff_modifier_ = value;
}
inline void CMsgDOTACombatLogEntry::set_armor_debuff_modifier(bool value) {
  _internal_set_armor_debuff_modifier(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.armor_debuff_modifier)
}

// optional bool no_physical_damage_modifier = 67;
inline bool CMsgDOTACombatLogEntry::_internal_has_no_physical_damage_modifier() const {
  bool value = (_impl_._has_bits_[2] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_no_physical_damage_modifier() const {
  return _internal_has_no_physical_damage_modifier();
}
inline void CMsgDOTACombatLogEntry::clear_no_physical_damage_modifier() {
  _impl_.no_physical_damage_modifier_ = false;
  _impl_._has_bits_[2] &= ~0x00000001u;
}
inline bool CMsgDOTACombatLogEntry::_internal_no_physical_damage_modifier() const {
  return _impl_.no_physical_damage_modifier_;
}
inline bool CMsgDOTACombatLogEntry::no_physical_damage_modifier() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.no_physical_damage_modifier)
  return _internal_no_physical_damage_modifier();
}
inline void CMsgDOTACombatLogEntry::_internal_set_no_physical_damage_modifier(bool value) {
  _impl_._has_bits_[2] |= 0x00000001u;
  _impl_.no_physical_damage_modifier_ = value;
}
inline void CMsgDOTACombatLogEntry::set_no_physical_damage_modifier(bool value) {
  _internal_set_no_physical_damage_modifier(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.no_physical_damage_modifier)
}

// optional uint32 modifier_ability = 68;
inline bool CMsgDOTACombatLogEntry::_internal_has_modifier_ability() const {
  bool value = (_impl_._has_bits_[2] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_modifier_ability() const {
  return _internal_has_modifier_ability();
}
inline void CMsgDOTACombatLogEntry::clear_modifier_ability() {
  _impl_.modifier_ability_ = 0u;
  _impl_._has_bits_[2] &= ~0x00000002u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_modifier_ability() const {
  return _impl_.modifier_ability_;
}
inline uint32_t CMsgDOTACombatLogEntry::modifier_ability() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.modifier_ability)
  return _internal_modifier_ability();
}
inline void CMsgDOTACombatLogEntry::_internal_set_modifier_ability(uint32_t value) {
  _impl_._has_bits_[2] |= 0x00000002u;
  _impl_.modifier_ability_ = value;
}
inline void CMsgDOTACombatLogEntry::set_modifier_ability(uint32_t value) {
  _internal_set_modifier_ability(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.modifier_ability)
}

// optional bool modifier_hidden = 69;
inline bool CMsgDOTACombatLogEntry::_internal_has_modifier_hidden() const {
  bool value = (_impl_._has_bits_[2] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_modifier_hidden() const {
  return _internal_has_modifier_hidden();
}
inline void CMsgDOTACombatLogEntry::clear_modifier_hidden() {
  _impl_.modifier_hidden_ = false;
  _impl_._has_bits_[2] &= ~0x00000008u;
}
inline bool CMsgDOTACombatLogEntry::_internal_modifier_hidden() const {
  return _impl_.modifier_hidden_;
}
inline bool CMsgDOTACombatLogEntry::modifier_hidden() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.modifier_hidden)
  return _internal_modifier_hidden();
}
inline void CMsgDOTACombatLogEntry::_internal_set_modifier_hidden(bool value) {
  _impl_._has_bits_[2] |= 0x00000008u;
  _impl_.modifier_hidden_ = value;
}
inline void CMsgDOTACombatLogEntry::set_modifier_hidden(bool value) {
  _internal_set_modifier_hidden(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.modifier_hidden)
}

// optional bool inflictor_is_stolen_ability = 70;
inline bool CMsgDOTACombatLogEntry::_internal_has_inflictor_is_stolen_ability() const {
  bool value = (_impl_._has_bits_[2] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_inflictor_is_stolen_ability() const {
  return _internal_has_inflictor_is_stolen_ability();
}
inline void CMsgDOTACombatLogEntry::clear_inflictor_is_stolen_ability() {
  _impl_.inflictor_is_stolen_ability_ = false;
  _impl_._has_bits_[2] &= ~0x00000010u;
}
inline bool CMsgDOTACombatLogEntry::_internal_inflictor_is_stolen_ability() const {
  return _impl_.inflictor_is_stolen_ability_;
}
inline bool CMsgDOTACombatLogEntry::inflictor_is_stolen_ability() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.inflictor_is_stolen_ability)
  return _internal_inflictor_is_stolen_ability();
}
inline void CMsgDOTACombatLogEntry::_internal_set_inflictor_is_stolen_ability(bool value) {
  _impl_._has_bits_[2] |= 0x00000010u;
  _impl_.inflictor_is_stolen_ability_ = value;
}
inline void CMsgDOTACombatLogEntry::set_inflictor_is_stolen_ability(bool value) {
  _internal_set_inflictor_is_stolen_ability(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.inflictor_is_stolen_ability)
}

// optional uint32 kill_eater_event = 71;
inline bool CMsgDOTACombatLogEntry::_internal_has_kill_eater_event() const {
  bool value = (_impl_._has_bits_[2] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_kill_eater_event() const {
  return _internal_has_kill_eater_event();
}
inline void CMsgDOTACombatLogEntry::clear_kill_eater_event() {
  _impl_.kill_eater_event_ = 0u;
  _impl_._has_bits_[2] &= ~0x00000004u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_kill_eater_event() const {
  return _impl_.kill_eater_event_;
}
inline uint32_t CMsgDOTACombatLogEntry::kill_eater_event() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.kill_eater_event)
  return _internal_kill_eater_event();
}
inline void CMsgDOTACombatLogEntry::_internal_set_kill_eater_event(uint32_t value) {
  _impl_._has_bits_[2] |= 0x00000004u;
  _impl_.kill_eater_event_ = value;
}
inline void CMsgDOTACombatLogEntry::set_kill_eater_event(uint32_t value) {
  _internal_set_kill_eater_event(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.kill_eater_event)
}

// optional uint32 unit_status_label = 72;
inline bool CMsgDOTACombatLogEntry::_internal_has_unit_status_label() const {
  bool value = (_impl_._has_bits_[2] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_unit_status_label() const {
  return _internal_has_unit_status_label();
}
inline void CMsgDOTACombatLogEntry::clear_unit_status_label() {
  _impl_.unit_status_label_ = 0u;
  _impl_._has_bits_[2] &= ~0x00000080u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_unit_status_label() const {
  return _impl_.unit_status_label_;
}
inline uint32_t CMsgDOTACombatLogEntry::unit_status_label() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.unit_status_label)
  return _internal_unit_status_label();
}
inline void CMsgDOTACombatLogEntry::_internal_set_unit_status_label(uint32_t value) {
  _impl_._has_bits_[2] |= 0x00000080u;
  _impl_.unit_status_label_ = value;
}
inline void CMsgDOTACombatLogEntry::set_unit_status_label(uint32_t value) {
  _internal_set_unit_status_label(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.unit_status_label)
}

// optional bool spell_generated_attack = 73;
inline bool CMsgDOTACombatLogEntry::_internal_has_spell_generated_attack() const {
  bool value = (_impl_._has_bits_[2] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_spell_generated_attack() const {
  return _internal_has_spell_generated_attack();
}
inline void CMsgDOTACombatLogEntry::clear_spell_generated_attack() {
  _impl_.spell_generated_attack_ = false;
  _impl_._has_bits_[2] &= ~0x00000020u;
}
inline bool CMsgDOTACombatLogEntry::_internal_spell_generated_attack() const {
  return _impl_.spell_generated_attack_;
}
inline bool CMsgDOTACombatLogEntry::spell_generated_attack() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.spell_generated_attack)
  return _internal_spell_generated_attack();
}
inline void CMsgDOTACombatLogEntry::_internal_set_spell_generated_attack(bool value) {
  _impl_._has_bits_[2] |= 0x00000020u;
  _impl_.spell_generated_attack_ = value;
}
inline void CMsgDOTACombatLogEntry::set_spell_generated_attack(bool value) {
  _internal_set_spell_generated_attack(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.spell_generated_attack)
}

// optional bool at_night_time = 74;
inline bool CMsgDOTACombatLogEntry::_internal_has_at_night_time() const {
  bool value = (_impl_._has_bits_[2] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_at_night_time() const {
  return _internal_has_at_night_time();
}
inline void CMsgDOTACombatLogEntry::clear_at_night_time() {
  _impl_.at_night_time_ = false;
  _impl_._has_bits_[2] &= ~0x00000040u;
}
inline bool CMsgDOTACombatLogEntry::_internal_at_night_time() const {
  return _impl_.at_night_time_;
}
inline bool CMsgDOTACombatLogEntry::at_night_time() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.at_night_time)
  return _internal_at_night_time();
}
inline void CMsgDOTACombatLogEntry::_internal_set_at_night_time(bool value) {
  _impl_._has_bits_[2] |= 0x00000040u;
  _impl_.at_night_time_ = value;
}
inline void CMsgDOTACombatLogEntry::set_at_night_time(bool value) {
  _internal_set_at_night_time(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.at_night_time)
}

// optional bool attacker_has_scepter = 75;
inline bool CMsgDOTACombatLogEntry::_internal_has_attacker_has_scepter() const {
  bool value = (_impl_._has_bits_[2] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_attacker_has_scepter() const {
  return _internal_has_attacker_has_scepter();
}
inline void CMsgDOTACombatLogEntry::clear_attacker_has_scepter() {
  _impl_.attacker_has_scepter_ = false;
  _impl_._has_bits_[2] &= ~0x00000400u;
}
inline bool CMsgDOTACombatLogEntry::_internal_attacker_has_scepter() const {
  return _impl_.attacker_has_scepter_;
}
inline bool CMsgDOTACombatLogEntry::attacker_has_scepter() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.attacker_has_scepter)
  return _internal_attacker_has_scepter();
}
inline void CMsgDOTACombatLogEntry::_internal_set_attacker_has_scepter(bool value) {
  _impl_._has_bits_[2] |= 0x00000400u;
  _impl_.attacker_has_scepter_ = value;
}
inline void CMsgDOTACombatLogEntry::set_attacker_has_scepter(bool value) {
  _internal_set_attacker_has_scepter(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.attacker_has_scepter)
}

// optional uint32 neutral_camp_team = 76;
inline bool CMsgDOTACombatLogEntry::_internal_has_neutral_camp_team() const {
  bool value = (_impl_._has_bits_[2] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_neutral_camp_team() const {
  return _internal_has_neutral_camp_team();
}
inline void CMsgDOTACombatLogEntry::clear_neutral_camp_team() {
  _impl_.neutral_camp_team_ = 0u;
  _impl_._has_bits_[2] &= ~0x00000100u;
}
inline uint32_t CMsgDOTACombatLogEntry::_internal_neutral_camp_team() const {
  return _impl_.neutral_camp_team_;
}
inline uint32_t CMsgDOTACombatLogEntry::neutral_camp_team() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.neutral_camp_team)
  return _internal_neutral_camp_team();
}
inline void CMsgDOTACombatLogEntry::_internal_set_neutral_camp_team(uint32_t value) {
  _impl_._has_bits_[2] |= 0x00000100u;
  _impl_.neutral_camp_team_ = value;
}
inline void CMsgDOTACombatLogEntry::set_neutral_camp_team(uint32_t value) {
  _internal_set_neutral_camp_team(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.neutral_camp_team)
}

// optional float regenerated_health = 77;
inline bool CMsgDOTACombatLogEntry::_internal_has_regenerated_health() const {
  bool value = (_impl_._has_bits_[2] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_regenerated_health() const {
  return _internal_has_regenerated_health();
}
inline void CMsgDOTACombatLogEntry::clear_regenerated_health() {
  _impl_.regenerated_health_ = 0;
  _impl_._has_bits_[2] &= ~0x00000200u;
}
inline float CMsgDOTACombatLogEntry::_internal_regenerated_health() const {
  return _impl_.regenerated_health_;
}
inline float CMsgDOTACombatLogEntry::regenerated_health() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.regenerated_health)
  return _internal_regenerated_health();
}
inline void CMsgDOTACombatLogEntry::_internal_set_regenerated_health(float value) {
  _impl_._has_bits_[2] |= 0x00000200u;
  _impl_.regenerated_health_ = value;
}
inline void CMsgDOTACombatLogEntry::set_regenerated_health(float value) {
  _internal_set_regenerated_health(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.regenerated_health)
}

// optional bool will_reincarnate = 78;
inline bool CMsgDOTACombatLogEntry::_internal_has_will_reincarnate() const {
  bool value = (_impl_._has_bits_[2] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_will_reincarnate() const {
  return _internal_has_will_reincarnate();
}
inline void CMsgDOTACombatLogEntry::clear_will_reincarnate() {
  _impl_.will_reincarnate_ = false;
  _impl_._has_bits_[2] &= ~0x00000800u;
}
inline bool CMsgDOTACombatLogEntry::_internal_will_reincarnate() const {
  return _impl_.will_reincarnate_;
}
inline bool CMsgDOTACombatLogEntry::will_reincarnate() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.will_reincarnate)
  return _internal_will_reincarnate();
}
inline void CMsgDOTACombatLogEntry::_internal_set_will_reincarnate(bool value) {
  _impl_._has_bits_[2] |= 0x00000800u;
  _impl_.will_reincarnate_ = value;
}
inline void CMsgDOTACombatLogEntry::set_will_reincarnate(bool value) {
  _internal_set_will_reincarnate(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.will_reincarnate)
}

// optional bool uses_charges = 79;
inline bool CMsgDOTACombatLogEntry::_internal_has_uses_charges() const {
  bool value = (_impl_._has_bits_[2] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgDOTACombatLogEntry::has_uses_charges() const {
  return _internal_has_uses_charges();
}
inline void CMsgDOTACombatLogEntry::clear_uses_charges() {
  _impl_.uses_charges_ = false;
  _impl_._has_bits_[2] &= ~0x00001000u;
}
inline bool CMsgDOTACombatLogEntry::_internal_uses_charges() const {
  return _impl_.uses_charges_;
}
inline bool CMsgDOTACombatLogEntry::uses_charges() const {
  // @@protoc_insertion_point(field_get:CMsgDOTACombatLogEntry.uses_charges)
  return _internal_uses_charges();
}
inline void CMsgDOTACombatLogEntry::_internal_set_uses_charges(bool value) {
  _impl_._has_bits_[2] |= 0x00001000u;
  _impl_.uses_charges_ = value;
}
inline void CMsgDOTACombatLogEntry::set_uses_charges(bool value) {
  _internal_set_uses_charges(value);
  // @@protoc_insertion_point(field_set:CMsgDOTACombatLogEntry.uses_charges)
}

// -------------------------------------------------------------------

// CMsgPendingEventAward

// optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
inline bool CMsgPendingEventAward::_internal_has_event_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgPendingEventAward::has_event_id() const {
  return _internal_has_event_id();
}
inline void CMsgPendingEventAward::clear_event_id() {
  _impl_.event_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::EEvent CMsgPendingEventAward::_internal_event_id() const {
  return static_cast< ::EEvent >(_impl_.event_id_);
}
inline ::EEvent CMsgPendingEventAward::event_id() const {
  // @@protoc_insertion_point(field_get:CMsgPendingEventAward.event_id)
  return _internal_event_id();
}
inline void CMsgPendingEventAward::_internal_set_event_id(::EEvent value) {
  assert(::EEvent_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.event_id_ = value;
}
inline void CMsgPendingEventAward::set_event_id(::EEvent value) {
  _internal_set_event_id(value);
  // @@protoc_insertion_point(field_set:CMsgPendingEventAward.event_id)
}

// optional uint32 action_id = 2;
inline bool CMsgPendingEventAward::_internal_has_action_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgPendingEventAward::has_action_id() const {
  return _internal_has_action_id();
}
inline void CMsgPendingEventAward::clear_action_id() {
  _impl_.action_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgPendingEventAward::_internal_action_id() const {
  return _impl_.action_id_;
}
inline uint32_t CMsgPendingEventAward::action_id() const {
  // @@protoc_insertion_point(field_get:CMsgPendingEventAward.action_id)
  return _internal_action_id();
}
inline void CMsgPendingEventAward::_internal_set_action_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.action_id_ = value;
}
inline void CMsgPendingEventAward::set_action_id(uint32_t value) {
  _internal_set_action_id(value);
  // @@protoc_insertion_point(field_set:CMsgPendingEventAward.action_id)
}

// optional uint32 num_to_grant = 3;
inline bool CMsgPendingEventAward::_internal_has_num_to_grant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgPendingEventAward::has_num_to_grant() const {
  return _internal_has_num_to_grant();
}
inline void CMsgPendingEventAward::clear_num_to_grant() {
  _impl_.num_to_grant_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgPendingEventAward::_internal_num_to_grant() const {
  return _impl_.num_to_grant_;
}
inline uint32_t CMsgPendingEventAward::num_to_grant() const {
  // @@protoc_insertion_point(field_get:CMsgPendingEventAward.num_to_grant)
  return _internal_num_to_grant();
}
inline void CMsgPendingEventAward::_internal_set_num_to_grant(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.num_to_grant_ = value;
}
inline void CMsgPendingEventAward::set_num_to_grant(uint32_t value) {
  _internal_set_num_to_grant(value);
  // @@protoc_insertion_point(field_set:CMsgPendingEventAward.num_to_grant)
}

// optional .EEventActionScoreMode score_mode = 4 [default = k_eEventActionScoreMode_Add];
inline bool CMsgPendingEventAward::_internal_has_score_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgPendingEventAward::has_score_mode() const {
  return _internal_has_score_mode();
}
inline void CMsgPendingEventAward::clear_score_mode() {
  _impl_.score_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::EEventActionScoreMode CMsgPendingEventAward::_internal_score_mode() const {
  return static_cast< ::EEventActionScoreMode >(_impl_.score_mode_);
}
inline ::EEventActionScoreMode CMsgPendingEventAward::score_mode() const {
  // @@protoc_insertion_point(field_get:CMsgPendingEventAward.score_mode)
  return _internal_score_mode();
}
inline void CMsgPendingEventAward::_internal_set_score_mode(::EEventActionScoreMode value) {
  assert(::EEventActionScoreMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.score_mode_ = value;
}
inline void CMsgPendingEventAward::set_score_mode(::EEventActionScoreMode value) {
  _internal_set_score_mode(value);
  // @@protoc_insertion_point(field_set:CMsgPendingEventAward.score_mode)
}

// optional uint32 audit_action = 5;
inline bool CMsgPendingEventAward::_internal_has_audit_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgPendingEventAward::has_audit_action() const {
  return _internal_has_audit_action();
}
inline void CMsgPendingEventAward::clear_audit_action() {
  _impl_.audit_action_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgPendingEventAward::_internal_audit_action() const {
  return _impl_.audit_action_;
}
inline uint32_t CMsgPendingEventAward::audit_action() const {
  // @@protoc_insertion_point(field_get:CMsgPendingEventAward.audit_action)
  return _internal_audit_action();
}
inline void CMsgPendingEventAward::_internal_set_audit_action(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.audit_action_ = value;
}
inline void CMsgPendingEventAward::set_audit_action(uint32_t value) {
  _internal_set_audit_action(value);
  // @@protoc_insertion_point(field_set:CMsgPendingEventAward.audit_action)
}

// optional uint64 audit_data = 6;
inline bool CMsgPendingEventAward::_internal_has_audit_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgPendingEventAward::has_audit_data() const {
  return _internal_has_audit_data();
}
inline void CMsgPendingEventAward::clear_audit_data() {
  _impl_.audit_data_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t CMsgPendingEventAward::_internal_audit_data() const {
  return _impl_.audit_data_;
}
inline uint64_t CMsgPendingEventAward::audit_data() const {
  // @@protoc_insertion_point(field_get:CMsgPendingEventAward.audit_data)
  return _internal_audit_data();
}
inline void CMsgPendingEventAward::_internal_set_audit_data(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.audit_data_ = value;
}
inline void CMsgPendingEventAward::set_audit_data(uint64_t value) {
  _internal_set_audit_data(value);
  // @@protoc_insertion_point(field_set:CMsgPendingEventAward.audit_data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::DOTA_GameMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTA_GameMode>() {
  return ::DOTA_GameMode_descriptor();
}
template <> struct is_proto_enum< ::DOTA_GameState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTA_GameState>() {
  return ::DOTA_GameState_descriptor();
}
template <> struct is_proto_enum< ::DOTA_GC_TEAM> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTA_GC_TEAM>() {
  return ::DOTA_GC_TEAM_descriptor();
}
template <> struct is_proto_enum< ::EEvent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EEvent>() {
  return ::EEvent_descriptor();
}
template <> struct is_proto_enum< ::ERankType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ERankType>() {
  return ::ERankType_descriptor();
}
template <> struct is_proto_enum< ::DOTALeaverStatus_t> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTALeaverStatus_t>() {
  return ::DOTALeaverStatus_t_descriptor();
}
template <> struct is_proto_enum< ::DOTAConnectionState_t> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTAConnectionState_t>() {
  return ::DOTAConnectionState_t_descriptor();
}
template <> struct is_proto_enum< ::Fantasy_Roles> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Fantasy_Roles>() {
  return ::Fantasy_Roles_descriptor();
}
template <> struct is_proto_enum< ::Fantasy_Team_Slots> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Fantasy_Team_Slots>() {
  return ::Fantasy_Team_Slots_descriptor();
}
template <> struct is_proto_enum< ::Fantasy_Selection_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Fantasy_Selection_Mode>() {
  return ::Fantasy_Selection_Mode_descriptor();
}
template <> struct is_proto_enum< ::DOTAChatChannelType_t> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTAChatChannelType_t>() {
  return ::DOTAChatChannelType_t_descriptor();
}
template <> struct is_proto_enum< ::EChatSpecialPrivileges> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EChatSpecialPrivileges>() {
  return ::EChatSpecialPrivileges_descriptor();
}
template <> struct is_proto_enum< ::EProfileCardSlotType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EProfileCardSlotType>() {
  return ::EProfileCardSlotType_descriptor();
}
template <> struct is_proto_enum< ::EMatchGroupServerStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EMatchGroupServerStatus>() {
  return ::EMatchGroupServerStatus_descriptor();
}
template <> struct is_proto_enum< ::DOTA_CM_PICK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTA_CM_PICK>() {
  return ::DOTA_CM_PICK_descriptor();
}
template <> struct is_proto_enum< ::DOTALowPriorityBanType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTALowPriorityBanType>() {
  return ::DOTALowPriorityBanType_descriptor();
}
template <> struct is_proto_enum< ::DOTALobbyReadyState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTALobbyReadyState>() {
  return ::DOTALobbyReadyState_descriptor();
}
template <> struct is_proto_enum< ::DOTAJoinLobbyResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTAJoinLobbyResult>() {
  return ::DOTAJoinLobbyResult_descriptor();
}
template <> struct is_proto_enum< ::DOTASelectionPriorityRules> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTASelectionPriorityRules>() {
  return ::DOTASelectionPriorityRules_descriptor();
}
template <> struct is_proto_enum< ::DOTASelectionPriorityChoice> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTASelectionPriorityChoice>() {
  return ::DOTASelectionPriorityChoice_descriptor();
}
template <> struct is_proto_enum< ::DOTAMatchVote> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTAMatchVote>() {
  return ::DOTAMatchVote_descriptor();
}
template <> struct is_proto_enum< ::DOTALobbyVisibility> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTALobbyVisibility>() {
  return ::DOTALobbyVisibility_descriptor();
}
template <> struct is_proto_enum< ::EDOTAPlayerMMRType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EDOTAPlayerMMRType>() {
  return ::EDOTAPlayerMMRType_descriptor();
}
template <> struct is_proto_enum< ::EDOTAMMRBoostType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EDOTAMMRBoostType>() {
  return ::EDOTAMMRBoostType_descriptor();
}
template <> struct is_proto_enum< ::MatchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MatchType>() {
  return ::MatchType_descriptor();
}
template <> struct is_proto_enum< ::DOTABotDifficulty> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTABotDifficulty>() {
  return ::DOTABotDifficulty_descriptor();
}
template <> struct is_proto_enum< ::DOTA_BOT_MODE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTA_BOT_MODE>() {
  return ::DOTA_BOT_MODE_descriptor();
}
template <> struct is_proto_enum< ::MatchLanguages> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MatchLanguages>() {
  return ::MatchLanguages_descriptor();
}
template <> struct is_proto_enum< ::ETourneyQueueDeadlineState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ETourneyQueueDeadlineState>() {
  return ::ETourneyQueueDeadlineState_descriptor();
}
template <> struct is_proto_enum< ::EMatchOutcome> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EMatchOutcome>() {
  return ::EMatchOutcome_descriptor();
}
template <> struct is_proto_enum< ::ELaneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELaneType>() {
  return ::ELaneType_descriptor();
}
template <> struct is_proto_enum< ::EBadgeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBadgeType>() {
  return ::EBadgeType_descriptor();
}
template <> struct is_proto_enum< ::ELeagueStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELeagueStatus>() {
  return ::ELeagueStatus_descriptor();
}
template <> struct is_proto_enum< ::ELeagueRegion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELeagueRegion>() {
  return ::ELeagueRegion_descriptor();
}
template <> struct is_proto_enum< ::ELeagueTier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELeagueTier>() {
  return ::ELeagueTier_descriptor();
}
template <> struct is_proto_enum< ::ELeagueTierCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELeagueTierCategory>() {
  return ::ELeagueTierCategory_descriptor();
}
template <> struct is_proto_enum< ::ELeagueDivision> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELeagueDivision>() {
  return ::ELeagueDivision_descriptor();
}
template <> struct is_proto_enum< ::ELeagueBroadcastProvider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELeagueBroadcastProvider>() {
  return ::ELeagueBroadcastProvider_descriptor();
}
template <> struct is_proto_enum< ::ELeaguePhase> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELeaguePhase>() {
  return ::ELeaguePhase_descriptor();
}
template <> struct is_proto_enum< ::ELeagueAuditAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELeagueAuditAction>() {
  return ::ELeagueAuditAction_descriptor();
}
template <> struct is_proto_enum< ::DOTA_COMBATLOG_TYPES> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DOTA_COMBATLOG_TYPES>() {
  return ::DOTA_COMBATLOG_TYPES_descriptor();
}
template <> struct is_proto_enum< ::EDPCFavoriteType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EDPCFavoriteType>() {
  return ::EDPCFavoriteType_descriptor();
}
template <> struct is_proto_enum< ::EDPCPushNotification> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EDPCPushNotification>() {
  return ::EDPCPushNotification_descriptor();
}
template <> struct is_proto_enum< ::EEventActionScoreMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EEventActionScoreMode>() {
  return ::EEventActionScoreMode_descriptor();
}
template <> struct is_proto_enum< ::EPlayerChallengeHistoryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EPlayerChallengeHistoryType>() {
  return ::EPlayerChallengeHistoryType_descriptor();
}
template <> struct is_proto_enum< ::EOverwatchReportReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EOverwatchReportReason>() {
  return ::EOverwatchReportReason_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dota_5fshared_5fenums_2eproto
