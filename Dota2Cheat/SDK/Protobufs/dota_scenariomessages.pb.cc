// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_scenariomessages.proto

#include "dota_scenariomessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CScenario_Position::CScenario_Position(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct CScenario_PositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CScenario_PositionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CScenario_PositionDefaultTypeInternal() {}
  union {
    CScenario_Position _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CScenario_PositionDefaultTypeInternal _CScenario_Position_default_instance_;
PROTOBUF_CONSTEXPR CScenarioGame_RoshanSpawner::CScenarioGame_RoshanSpawner(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.kill_count_)*/0
  , /*decltype(_impl_.state_)*/0
  , /*decltype(_impl_.cooldown_)*/0} {}
struct CScenarioGame_RoshanSpawnerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CScenarioGame_RoshanSpawnerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CScenarioGame_RoshanSpawnerDefaultTypeInternal() {}
  union {
    CScenarioGame_RoshanSpawner _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CScenarioGame_RoshanSpawnerDefaultTypeInternal _CScenarioGame_RoshanSpawner_default_instance_;
PROTOBUF_CONSTEXPR CScenarioEnt_Courier::CScenarioEnt_Courier(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.team_number_)*/0
  , /*decltype(_impl_.owner_player_id_)*/-1
  , /*decltype(_impl_.cooldown_)*/-1} {}
struct CScenarioEnt_CourierDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CScenarioEnt_CourierDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CScenarioEnt_CourierDefaultTypeInternal() {}
  union {
    CScenarioEnt_Courier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CScenarioEnt_CourierDefaultTypeInternal _CScenarioEnt_Courier_default_instance_;
PROTOBUF_CONSTEXPR CScenarioEnt_NPC::CScenarioEnt_NPC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.unit_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owning_camp_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.invade_goal_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.owning_camp_position_)*/nullptr
  , /*decltype(_impl_.team_number_)*/0
  , /*decltype(_impl_.health_frac_)*/1} {}
struct CScenarioEnt_NPCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CScenarioEnt_NPCDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CScenarioEnt_NPCDefaultTypeInternal() {}
  union {
    CScenarioEnt_NPC _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CScenarioEnt_NPCDefaultTypeInternal _CScenarioEnt_NPC_default_instance_;
PROTOBUF_CONSTEXPR CScenarioEnt_SpiritBear::CScenarioEnt_SpiritBear(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.team_id_)*/0
  , /*decltype(_impl_.owner_id_)*/-1} {}
struct CScenarioEnt_SpiritBearDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CScenarioEnt_SpiritBearDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CScenarioEnt_SpiritBearDefaultTypeInternal() {}
  union {
    CScenarioEnt_SpiritBear _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CScenarioEnt_SpiritBearDefaultTypeInternal _CScenarioEnt_SpiritBear_default_instance_;
PROTOBUF_CONSTEXPR CScenarioEnt_DroppedItem::CScenarioEnt_DroppedItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr} {}
struct CScenarioEnt_DroppedItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CScenarioEnt_DroppedItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CScenarioEnt_DroppedItemDefaultTypeInternal() {}
  union {
    CScenarioEnt_DroppedItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CScenarioEnt_DroppedItemDefaultTypeInternal _CScenarioEnt_DroppedItem_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_EntityRef::CMsgDotaScenario_EntityRef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ability_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.roshan_)*/false
  , /*decltype(_impl_.entity_idx_)*/-1
  , /*decltype(_impl_.player_id_)*/-1
  , /*decltype(_impl_.neutral_stash_id_)*/-1} {}
struct CMsgDotaScenario_EntityRefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_EntityRefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_EntityRefDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_EntityRef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_EntityRefDefaultTypeInternal _CMsgDotaScenario_EntityRef_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_Game::CMsgDotaScenario_Game(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.roshan_)*/nullptr
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.game_mode_)*/0
  , /*decltype(_impl_.clock_time_)*/0
  , /*decltype(_impl_.internal_time_)*/0} {}
struct CMsgDotaScenario_GameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_GameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_GameDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_Game _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_GameDefaultTypeInternal _CMsgDotaScenario_Game_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_TeamNeutralItem::CMsgDotaScenario_TeamNeutralItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.consumed_)*/false} {}
struct CMsgDotaScenario_TeamNeutralItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_TeamNeutralItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_TeamNeutralItemDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_TeamNeutralItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_TeamNeutralItemDefaultTypeInternal _CMsgDotaScenario_TeamNeutralItem_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_Team::CMsgDotaScenario_Team(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.neutral_items_)*/{}
  , /*decltype(_impl_.team_number_)*/0
  , /*decltype(_impl_.hero_kills_)*/0
  , /*decltype(_impl_.tower_kills_)*/0
  , /*decltype(_impl_.barracks_kills_)*/0
  , /*decltype(_impl_.glyph_cooldown_)*/0
  , /*decltype(_impl_.radar_cooldown_)*/0} {}
struct CMsgDotaScenario_TeamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_TeamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_TeamDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_Team _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_TeamDefaultTypeInternal _CMsgDotaScenario_Team_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_HeroHeroInt::CMsgDotaScenario_HeroHeroInt(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/0
  , /*decltype(_impl_.player_id_)*/-1} {}
struct CMsgDotaScenario_HeroHeroIntDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_HeroHeroIntDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_HeroHeroIntDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_HeroHeroInt _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_HeroHeroIntDefaultTypeInternal _CMsgDotaScenario_HeroHeroInt_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_HeroHeroFloat::CMsgDotaScenario_HeroHeroFloat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/0
  , /*decltype(_impl_.player_id_)*/-1} {}
struct CMsgDotaScenario_HeroHeroFloatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_HeroHeroFloatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_HeroHeroFloatDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_HeroHeroFloat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_HeroHeroFloatDefaultTypeInternal _CMsgDotaScenario_HeroHeroFloat_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_DamageStatsByType::CMsgDotaScenario_DamageStatsByType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.damage_type_)*/0
  , /*decltype(_impl_.received_pre_reduction_)*/0
  , /*decltype(_impl_.received_post_reduction_)*/0
  , /*decltype(_impl_.outgoing_pre_reduction_)*/0
  , /*decltype(_impl_.outgoing_post_reduction_)*/0} {}
struct CMsgDotaScenario_DamageStatsByTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_DamageStatsByTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_DamageStatsByTypeDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_DamageStatsByType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_DamageStatsByTypeDefaultTypeInternal _CMsgDotaScenario_DamageStatsByType_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_HeroAbility::CMsgDotaScenario_HeroAbility(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.level_)*/0} {}
struct CMsgDotaScenario_HeroAbilityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_HeroAbilityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_HeroAbilityDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_HeroAbility _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_HeroAbilityDefaultTypeInternal _CMsgDotaScenario_HeroAbility_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_Hero::CMsgDotaScenario_Hero(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enemy_kills_)*/{}
  , /*decltype(_impl_.damage_stats_)*/{}
  , /*decltype(_impl_.abilities_)*/{}
  , /*decltype(_impl_.hero_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}
  , /*decltype(_impl_.team_id_)*/0
  , /*decltype(_impl_.total_xp_)*/0
  , /*decltype(_impl_.bkb_charges_used_)*/0
  , /*decltype(_impl_.aeon_charges_used_)*/0
  , /*decltype(_impl_.reliable_gold_)*/0
  , /*decltype(_impl_.unreliable_gold_)*/0
  , /*decltype(_impl_.total_earned_gold_)*/0
  , /*decltype(_impl_.shared_gold_)*/0
  , /*decltype(_impl_.hero_kill_gold_)*/0
  , /*decltype(_impl_.creep_kill_gold_)*/0
  , /*decltype(_impl_.neutral_kill_gold_)*/0
  , /*decltype(_impl_.courier_gold_)*/0
  , /*decltype(_impl_.bounty_gold_)*/0
  , /*decltype(_impl_.roshan_gold_)*/0
  , /*decltype(_impl_.building_gold_)*/0
  , /*decltype(_impl_.other_gold_)*/0
  , /*decltype(_impl_.income_gold_)*/0
  , /*decltype(_impl_.ward_kill_gold_)*/0
  , /*decltype(_impl_.ability_gold_)*/0
  , /*decltype(_impl_.denies_)*/0
  , /*decltype(_impl_.last_hits_)*/0
  , /*decltype(_impl_.last_hit_streak_)*/0
  , /*decltype(_impl_.last_hit_multikill_)*/0
  , /*decltype(_impl_.nearby_creep_death_count_)*/0
  , /*decltype(_impl_.claimed_deny_count_)*/0
  , /*decltype(_impl_.claimed_miss_count_)*/0
  , /*decltype(_impl_.miss_count_)*/0
  , /*decltype(_impl_.buyback_cooldown_time_)*/0
  , /*decltype(_impl_.buyback_gold_limit_time_)*/0
  , /*decltype(_impl_.stun_duration_)*/0
  , /*decltype(_impl_.healing_)*/0
  , /*decltype(_impl_.tower_kills_)*/0
  , /*decltype(_impl_.roshan_kills_)*/0
  , /*decltype(_impl_.observer_wards_placed_)*/0
  , /*decltype(_impl_.sentry_wards_placed_)*/0
  , /*decltype(_impl_.creeps_stacked_)*/0
  , /*decltype(_impl_.camps_stacked_)*/0
  , /*decltype(_impl_.rune_pickups_)*/0
  , /*decltype(_impl_.gold_spent_on_support_)*/0
  , /*decltype(_impl_.hero_damage_)*/0
  , /*decltype(_impl_.wards_purchased_)*/0
  , /*decltype(_impl_.wards_destroyed_)*/0
  , /*decltype(_impl_.gold_spent_on_consumables_)*/0
  , /*decltype(_impl_.gold_spent_on_items_)*/0
  , /*decltype(_impl_.gold_spent_on_buybacks_)*/0
  , /*decltype(_impl_.gold_lost_to_death_)*/0
  , /*decltype(_impl_.kills_)*/0
  , /*decltype(_impl_.assists_)*/0
  , /*decltype(_impl_.deaths_)*/0
  , /*decltype(_impl_.kill_streak_)*/0
  , /*decltype(_impl_.last_buyback_time_)*/0
  , /*decltype(_impl_.first_blood_claimed_)*/false
  , /*decltype(_impl_.first_blood_given_)*/false
  , /*decltype(_impl_.bounty_runes_)*/0
  , /*decltype(_impl_.outposts_captured_)*/0
  , /*decltype(_impl_.player_id_)*/-1
  , /*decltype(_impl_.respawn_seconds_)*/-1} {}
struct CMsgDotaScenario_HeroDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_HeroDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_HeroDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_Hero _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_HeroDefaultTypeInternal _CMsgDotaScenario_Hero_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_Stock::CMsgDotaScenario_Stock(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.current_stock_)*/0
  , /*decltype(_impl_.cooldown_)*/0
  , /*decltype(_impl_.bonus_stock_)*/0
  , /*decltype(_impl_.team_number_)*/-1
  , /*decltype(_impl_.player_id_)*/-1} {}
struct CMsgDotaScenario_StockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_StockDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_StockDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_Stock _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_StockDefaultTypeInternal _CMsgDotaScenario_Stock_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_Building::CMsgDotaScenario_Building(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entity_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.entity_class_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_id_)*/0
  , /*decltype(_impl_.is_destroyed_)*/false
  , /*decltype(_impl_.health_frac_)*/1} {}
struct CMsgDotaScenario_BuildingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_BuildingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_BuildingDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_Building _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_BuildingDefaultTypeInternal _CMsgDotaScenario_Building_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_Entity::CMsgDotaScenario_Entity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.courier_)*/nullptr
  , /*decltype(_impl_.npc_)*/nullptr
  , /*decltype(_impl_.spirit_bear_)*/nullptr
  , /*decltype(_impl_.dropped_item_)*/nullptr} {}
struct CMsgDotaScenario_EntityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_EntityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_EntityDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_Entity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_EntityDefaultTypeInternal _CMsgDotaScenario_Entity_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_Item::CMsgDotaScenario_Item(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.location_)*/nullptr
  , /*decltype(_impl_.item_slot_)*/0
  , /*decltype(_impl_.neutral_drop_team_)*/0
  , /*decltype(_impl_.charges_)*/0
  , /*decltype(_impl_.secondary_charges_)*/0
  , /*decltype(_impl_.stored_rune_type_)*/-1
  , /*decltype(_impl_.owner_id_)*/-1
  , /*decltype(_impl_.lifetime_)*/-1} {}
struct CMsgDotaScenario_ItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_ItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_ItemDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_Item _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_ItemDefaultTypeInternal _CMsgDotaScenario_Item_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario_Modifier::CMsgDotaScenario_Modifier(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.caster_)*/nullptr
  , /*decltype(_impl_.ability_)*/nullptr
  , /*decltype(_impl_.lifetime_remaining_)*/0
  , /*decltype(_impl_.stack_count_)*/0
  , /*decltype(_impl_.create_even_if_existing_)*/false
  , /*decltype(_impl_.create_without_caster_)*/false
  , /*decltype(_impl_.create_without_ability_)*/false
  , /*decltype(_impl_.moonshard_consumed_bonus_)*/0
  , /*decltype(_impl_.moonshard_consumed_bonus_night_vision_)*/0
  , /*decltype(_impl_.wardtruesight_range_)*/0
  , /*decltype(_impl_.ultimate_scepter_consumed_alchemist_bonus_all_stats_)*/0
  , /*decltype(_impl_.ultimate_scepter_consumed_alchemist_bonus_health_)*/0
  , /*decltype(_impl_.ultimate_scepter_consumed_alchemist_bonus_mana_)*/0
  , /*decltype(_impl_.duration_)*/-1} {}
struct CMsgDotaScenario_ModifierDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenario_ModifierDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenario_ModifierDefaultTypeInternal() {}
  union {
    CMsgDotaScenario_Modifier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenario_ModifierDefaultTypeInternal _CMsgDotaScenario_Modifier_default_instance_;
PROTOBUF_CONSTEXPR CMsgDotaScenario::CMsgDotaScenario(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.teams_)*/{}
  , /*decltype(_impl_.heroes_)*/{}
  , /*decltype(_impl_.stock_)*/{}
  , /*decltype(_impl_.buildings_)*/{}
  , /*decltype(_impl_.entities_)*/{}
  , /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_.modifiers_)*/{}
  , /*decltype(_impl_.game_)*/nullptr
  , /*decltype(_impl_.lobby_id_)*/uint64_t{0u}} {}
struct CMsgDotaScenarioDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDotaScenarioDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDotaScenarioDefaultTypeInternal() {}
  union {
    CMsgDotaScenario _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDotaScenarioDefaultTypeInternal _CMsgDotaScenario_default_instance_;
static ::_pb::Metadata file_level_metadata_dota_5fscenariomessages_2eproto[21];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_dota_5fscenariomessages_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_dota_5fscenariomessages_2eproto = nullptr;

const uint32_t TableStruct_dota_5fscenariomessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CScenario_Position, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CScenario_Position, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CScenario_Position, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::CScenario_Position, _impl_.y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CScenarioGame_RoshanSpawner, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CScenarioGame_RoshanSpawner, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CScenarioGame_RoshanSpawner, _impl_.kill_count_),
  PROTOBUF_FIELD_OFFSET(::CScenarioGame_RoshanSpawner, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::CScenarioGame_RoshanSpawner, _impl_.cooldown_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_Courier, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_Courier, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_Courier, _impl_.team_number_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_Courier, _impl_.owner_player_id_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_Courier, _impl_.cooldown_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_NPC, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_NPC, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_NPC, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_NPC, _impl_.unit_name_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_NPC, _impl_.team_number_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_NPC, _impl_.health_frac_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_NPC, _impl_.owning_camp_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_NPC, _impl_.owning_camp_position_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_NPC, _impl_.invade_goal_),
  3,
  0,
  5,
  6,
  1,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_SpiritBear, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_SpiritBear, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_SpiritBear, _impl_.owner_id_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_SpiritBear, _impl_.team_id_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_DroppedItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_DroppedItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CScenarioEnt_DroppedItem, _impl_.position_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_EntityRef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_EntityRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_EntityRef, _impl_.player_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_EntityRef, _impl_.neutral_stash_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_EntityRef, _impl_.entity_idx_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_EntityRef, _impl_.roshan_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_EntityRef, _impl_.ability_name_),
  3,
  4,
  2,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Game, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Game, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Game, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Game, _impl_.game_mode_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Game, _impl_.clock_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Game, _impl_.internal_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Game, _impl_.roshan_),
  1,
  2,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_TeamNeutralItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_TeamNeutralItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_TeamNeutralItem, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_TeamNeutralItem, _impl_.consumed_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Team, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Team, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Team, _impl_.team_number_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Team, _impl_.neutral_items_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Team, _impl_.hero_kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Team, _impl_.tower_kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Team, _impl_.barracks_kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Team, _impl_.glyph_cooldown_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Team, _impl_.radar_cooldown_),
  0,
  ~0u,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_HeroHeroInt, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_HeroHeroInt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_HeroHeroInt, _impl_.player_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_HeroHeroInt, _impl_.value_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_HeroHeroFloat, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_HeroHeroFloat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_HeroHeroFloat, _impl_.player_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_HeroHeroFloat, _impl_.value_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_DamageStatsByType, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_DamageStatsByType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_DamageStatsByType, _impl_.damage_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_DamageStatsByType, _impl_.received_pre_reduction_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_DamageStatsByType, _impl_.received_post_reduction_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_DamageStatsByType, _impl_.outgoing_pre_reduction_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_DamageStatsByType, _impl_.outgoing_post_reduction_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_HeroAbility, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_HeroAbility, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_HeroAbility, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_HeroAbility, _impl_.level_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.steam_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.player_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.hero_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.total_xp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.bkb_charges_used_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.aeon_charges_used_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.reliable_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.unreliable_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.total_earned_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.shared_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.hero_kill_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.creep_kill_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.neutral_kill_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.courier_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.bounty_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.roshan_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.building_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.other_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.income_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.ward_kill_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.ability_gold_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.denies_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.last_hits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.last_hit_streak_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.last_hit_multikill_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.nearby_creep_death_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.claimed_deny_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.claimed_miss_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.miss_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.buyback_cooldown_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.buyback_gold_limit_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.stun_duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.healing_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.tower_kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.roshan_kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.observer_wards_placed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.sentry_wards_placed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.creeps_stacked_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.camps_stacked_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.rune_pickups_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.gold_spent_on_support_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.hero_damage_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.wards_purchased_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.wards_destroyed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.gold_spent_on_consumables_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.gold_spent_on_items_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.gold_spent_on_buybacks_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.gold_lost_to_death_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.assists_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.deaths_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.kill_streak_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.respawn_seconds_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.last_buyback_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.first_blood_claimed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.first_blood_given_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.bounty_runes_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.outposts_captured_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.enemy_kills_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.damage_stats_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Hero, _impl_.abilities_),
  2,
  58,
  3,
  0,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  59,
  53,
  54,
  55,
  56,
  57,
  1,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Stock, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Stock, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Stock, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Stock, _impl_.team_number_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Stock, _impl_.player_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Stock, _impl_.current_stock_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Stock, _impl_.cooldown_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Stock, _impl_.bonus_stock_),
  0,
  4,
  5,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Building, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Building, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Building, _impl_.entity_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Building, _impl_.entity_class_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Building, _impl_.team_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Building, _impl_.is_destroyed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Building, _impl_.health_frac_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Entity, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Entity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Entity, _impl_.courier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Entity, _impl_.npc_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Entity, _impl_.spirit_bear_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Entity, _impl_.dropped_item_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Item, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Item, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Item, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Item, _impl_.location_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Item, _impl_.owner_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Item, _impl_.item_slot_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Item, _impl_.neutral_drop_team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Item, _impl_.charges_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Item, _impl_.secondary_charges_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Item, _impl_.lifetime_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Item, _impl_.stored_rune_type_),
  0,
  1,
  7,
  2,
  3,
  4,
  5,
  8,
  6,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.caster_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.ability_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.lifetime_remaining_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.stack_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.create_even_if_existing_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.create_without_caster_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.create_without_ability_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.moonshard_consumed_bonus_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.moonshard_consumed_bonus_night_vision_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.wardtruesight_range_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.ultimate_scepter_consumed_alchemist_bonus_all_stats_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.ultimate_scepter_consumed_alchemist_bonus_health_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario_Modifier, _impl_.ultimate_scepter_consumed_alchemist_bonus_mana_),
  0,
  1,
  2,
  3,
  15,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario, _impl_.lobby_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario, _impl_.game_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario, _impl_.teams_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario, _impl_.heroes_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario, _impl_.stock_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario, _impl_.buildings_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario, _impl_.entities_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::CMsgDotaScenario, _impl_.modifiers_),
  1,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::CScenario_Position)},
  { 10, 19, -1, sizeof(::CScenarioGame_RoshanSpawner)},
  { 22, 31, -1, sizeof(::CScenarioEnt_Courier)},
  { 34, 47, -1, sizeof(::CScenarioEnt_NPC)},
  { 54, 62, -1, sizeof(::CScenarioEnt_SpiritBear)},
  { 64, 71, -1, sizeof(::CScenarioEnt_DroppedItem)},
  { 72, 83, -1, sizeof(::CMsgDotaScenario_EntityRef)},
  { 88, 99, -1, sizeof(::CMsgDotaScenario_Game)},
  { 104, 112, -1, sizeof(::CMsgDotaScenario_TeamNeutralItem)},
  { 114, 127, -1, sizeof(::CMsgDotaScenario_Team)},
  { 134, 142, -1, sizeof(::CMsgDotaScenario_HeroHeroInt)},
  { 144, 152, -1, sizeof(::CMsgDotaScenario_HeroHeroFloat)},
  { 154, 165, -1, sizeof(::CMsgDotaScenario_DamageStatsByType)},
  { 170, 178, -1, sizeof(::CMsgDotaScenario_HeroAbility)},
  { 180, 249, -1, sizeof(::CMsgDotaScenario_Hero)},
  { 312, 324, -1, sizeof(::CMsgDotaScenario_Stock)},
  { 330, 341, -1, sizeof(::CMsgDotaScenario_Building)},
  { 346, 356, -1, sizeof(::CMsgDotaScenario_Entity)},
  { 360, 375, -1, sizeof(::CMsgDotaScenario_Item)},
  { 384, 406, -1, sizeof(::CMsgDotaScenario_Modifier)},
  { 422, 437, -1, sizeof(::CMsgDotaScenario)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CScenario_Position_default_instance_._instance,
  &::_CScenarioGame_RoshanSpawner_default_instance_._instance,
  &::_CScenarioEnt_Courier_default_instance_._instance,
  &::_CScenarioEnt_NPC_default_instance_._instance,
  &::_CScenarioEnt_SpiritBear_default_instance_._instance,
  &::_CScenarioEnt_DroppedItem_default_instance_._instance,
  &::_CMsgDotaScenario_EntityRef_default_instance_._instance,
  &::_CMsgDotaScenario_Game_default_instance_._instance,
  &::_CMsgDotaScenario_TeamNeutralItem_default_instance_._instance,
  &::_CMsgDotaScenario_Team_default_instance_._instance,
  &::_CMsgDotaScenario_HeroHeroInt_default_instance_._instance,
  &::_CMsgDotaScenario_HeroHeroFloat_default_instance_._instance,
  &::_CMsgDotaScenario_DamageStatsByType_default_instance_._instance,
  &::_CMsgDotaScenario_HeroAbility_default_instance_._instance,
  &::_CMsgDotaScenario_Hero_default_instance_._instance,
  &::_CMsgDotaScenario_Stock_default_instance_._instance,
  &::_CMsgDotaScenario_Building_default_instance_._instance,
  &::_CMsgDotaScenario_Entity_default_instance_._instance,
  &::_CMsgDotaScenario_Item_default_instance_._instance,
  &::_CMsgDotaScenario_Modifier_default_instance_._instance,
  &::_CMsgDotaScenario_default_instance_._instance,
};

const char descriptor_table_protodef_dota_5fscenariomessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\033dota_scenariomessages.proto\032\027dota_shar"
  "ed_enums.proto\"*\n\022CScenario_Position\022\t\n\001"
  "x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\"R\n\033CScenarioGame_Rosh"
  "anSpawner\022\022\n\nkill_count\030\001 \001(\005\022\r\n\005state\030\002"
  " \001(\005\022\020\n\010cooldown\030\003 \001(\002\"^\n\024CScenarioEnt_C"
  "ourier\022\023\n\013team_number\030\001 \001(\005\022\033\n\017owner_pla"
  "yer_id\030\002 \001(\005:\002-1\022\024\n\010cooldown\030\003 \001(\002:\002-1\"\326"
  "\001\n\020CScenarioEnt_NPC\022%\n\010position\030\001 \001(\0132\023."
  "CScenario_Position\022\021\n\tunit_name\030\002 \001(\t\022\023\n"
  "\013team_number\030\003 \001(\005\022\026\n\013health_frac\030\004 \001(\002:"
  "\0011\022\023\n\013owning_camp\030\n \001(\t\0221\n\024owning_camp_p"
  "osition\030\013 \001(\0132\023.CScenario_Position\022\023\n\013in"
  "vade_goal\030\024 \001(\t\"@\n\027CScenarioEnt_SpiritBe"
  "ar\022\024\n\010owner_id\030\001 \001(\005:\002-1\022\017\n\007team_id\030\002 \001("
  "\005\"A\n\030CScenarioEnt_DroppedItem\022%\n\010positio"
  "n\030\001 \001(\0132\023.CScenario_Position\"\244 \n\020CMsgDot"
  "aScenario\022\020\n\010lobby_id\030\001 \001(\004\022$\n\004game\030\002 \001("
  "\0132\026.CMsgDotaScenario.Game\022%\n\005teams\030\003 \003(\013"
  "2\026.CMsgDotaScenario.Team\022&\n\006heroes\030\004 \003(\013"
  "2\026.CMsgDotaScenario.Hero\022&\n\005stock\030\005 \003(\0132"
  "\027.CMsgDotaScenario.Stock\022-\n\tbuildings\030\006 "
  "\003(\0132\032.CMsgDotaScenario.Building\022*\n\010entit"
  "ies\030\007 \003(\0132\030.CMsgDotaScenario.Entity\022%\n\005i"
  "tems\030\010 \003(\0132\026.CMsgDotaScenario.Item\022-\n\tmo"
  "difiers\030\t \003(\0132\032.CMsgDotaScenario.Modifie"
  "r\032\205\001\n\tEntityRef\022\025\n\tplayer_id\030\001 \001(\005:\002-1\022\034"
  "\n\020neutral_stash_id\030\002 \001(\005:\002-1\022\026\n\nentity_i"
  "dx\030\003 \001(\005:\002-1\022\025\n\006roshan\030\004 \001(\010:\005false\022\024\n\014a"
  "bility_name\030\n \001(\t\032\204\001\n\004Game\022\020\n\010match_id\030\001"
  " \001(\004\022\021\n\tgame_mode\030\002 \001(\005\022\022\n\nclock_time\030\003 "
  "\001(\002\022\025\n\rinternal_time\030\004 \001(\002\022,\n\006roshan\030\005 \001"
  "(\0132\034.CScenarioGame_RoshanSpawner\0321\n\017Team"
  "NeutralItem\022\014\n\004name\030\001 \001(\t\022\020\n\010consumed\030\002 "
  "\001(\010\032\306\001\n\004Team\022\023\n\013team_number\030\001 \001(\005\0228\n\rneu"
  "tral_items\030\002 \003(\0132!.CMsgDotaScenario.Team"
  "NeutralItem\022\022\n\nhero_kills\030\003 \001(\005\022\023\n\013tower"
  "_kills\030\004 \001(\005\022\026\n\016barracks_kills\030\005 \001(\005\022\026\n\016"
  "glyph_cooldown\030\006 \001(\002\022\026\n\016radar_cooldown\030\007"
  " \001(\002\0323\n\013HeroHeroInt\022\025\n\tplayer_id\030\001 \001(\005:\002"
  "-1\022\r\n\005value\030\002 \001(\005\0325\n\rHeroHeroFloat\022\025\n\tpl"
  "ayer_id\030\001 \001(\005:\002-1\022\r\n\005value\030\002 \001(\002\032\252\001\n\021Dam"
  "ageStatsByType\022\023\n\013damage_type\030\001 \001(\005\022\036\n\026r"
  "eceived_pre_reduction\030\002 \001(\005\022\037\n\027received_"
  "post_reduction\030\003 \001(\005\022\036\n\026outgoing_pre_red"
  "uction\030\004 \001(\005\022\037\n\027outgoing_post_reduction\030"
  "\005 \001(\005\032*\n\013HeroAbility\022\014\n\004name\030\001 \001(\t\022\r\n\005le"
  "vel\030\002 \001(\005\032\334\014\n\004Hero\022\020\n\010steam_id\030\001 \001(\006\022\025\n\t"
  "player_id\030\002 \001(\005:\002-1\022\017\n\007team_id\030\003 \001(\005\022\014\n\004"
  "hero\030\004 \001(\t\022\020\n\010total_xp\030\005 \001(\005\022\030\n\020bkb_char"
  "ges_used\030\006 \001(\005\022\031\n\021aeon_charges_used\030\007 \001("
  "\005\022\025\n\rreliable_gold\030\010 \001(\005\022\027\n\017unreliable_g"
  "old\030\t \001(\005\022\031\n\021total_earned_gold\030\n \001(\005\022\023\n\013"
  "shared_gold\030\013 \001(\005\022\026\n\016hero_kill_gold\030\014 \001("
  "\005\022\027\n\017creep_kill_gold\030\r \001(\005\022\031\n\021neutral_ki"
  "ll_gold\030\016 \001(\005\022\024\n\014courier_gold\030\017 \001(\005\022\023\n\013b"
  "ounty_gold\030\020 \001(\005\022\023\n\013roshan_gold\030\021 \001(\005\022\025\n"
  "\rbuilding_gold\030\022 \001(\005\022\022\n\nother_gold\030\023 \001(\005"
  "\022\023\n\013income_gold\030\032 \001(\005\022\026\n\016ward_kill_gold\030"
  "\033 \001(\005\022\024\n\014ability_gold\030\034 \001(\005\022\016\n\006denies\030\035 "
  "\001(\005\022\021\n\tlast_hits\030\036 \001(\005\022\027\n\017last_hit_strea"
  "k\030\037 \001(\005\022\032\n\022last_hit_multikill\030  \001(\005\022 \n\030n"
  "earby_creep_death_count\030! \001(\005\022\032\n\022claimed"
  "_deny_count\030\" \001(\005\022\032\n\022claimed_miss_count\030"
  "# \001(\005\022\022\n\nmiss_count\030$ \001(\005\022\035\n\025buyback_coo"
  "ldown_time\030( \001(\002\022\037\n\027buyback_gold_limit_t"
  "ime\030) \001(\002\022\025\n\rstun_duration\030, \001(\002\022\017\n\007heal"
  "ing\030- \001(\002\022\023\n\013tower_kills\030. \001(\005\022\024\n\014roshan"
  "_kills\030/ \001(\005\022\035\n\025observer_wards_placed\0300 "
  "\001(\005\022\033\n\023sentry_wards_placed\0301 \001(\005\022\026\n\016cree"
  "ps_stacked\0302 \001(\005\022\025\n\rcamps_stacked\0303 \001(\005\022"
  "\024\n\014rune_pickups\0304 \001(\005\022\035\n\025gold_spent_on_s"
  "upport\0305 \001(\005\022\023\n\013hero_damage\0306 \001(\005\022\027\n\017war"
  "ds_purchased\0307 \001(\005\022\027\n\017wards_destroyed\0308 "
  "\001(\005\022!\n\031gold_spent_on_consumables\030: \001(\005\022\033"
  "\n\023gold_spent_on_items\030; \001(\005\022\036\n\026gold_spen"
  "t_on_buybacks\030< \001(\005\022\032\n\022gold_lost_to_deat"
  "h\030= \001(\005\022\r\n\005kills\030> \001(\005\022\017\n\007assists\030\? \001(\005\022"
  "\016\n\006deaths\030@ \001(\005\022\023\n\013kill_streak\030A \001(\005\022\033\n\017"
  "respawn_seconds\030D \001(\005:\002-1\022\031\n\021last_buybac"
  "k_time\030E \001(\005\022\033\n\023first_blood_claimed\030G \001("
  "\010\022\031\n\021first_blood_given\030H \001(\010\022\024\n\014bounty_r"
  "unes\030I \001(\005\022\031\n\021outposts_captured\030J \001(\005\022%\n"
  "\010position\030K \001(\0132\023.CScenario_Position\0223\n\013"
  "enemy_kills\030\226\001 \003(\0132\035.CMsgDotaScenario.He"
  "roHeroInt\022:\n\014damage_stats\030\227\001 \003(\0132#.CMsgD"
  "otaScenario.DamageStatsByType\0221\n\tabiliti"
  "es\030\230\001 \003(\0132\035.CMsgDotaScenario.HeroAbility"
  "\032\203\001\n\005Stock\022\014\n\004name\030\001 \001(\t\022\027\n\013team_number\030"
  "\002 \001(\005:\002-1\022\025\n\tplayer_id\030\003 \001(\005:\002-1\022\025\n\rcurr"
  "ent_stock\030\004 \001(\005\022\020\n\010cooldown\030\005 \001(\002\022\023\n\013bon"
  "us_stock\030\006 \001(\005\032t\n\010Building\022\023\n\013entity_nam"
  "e\030\001 \001(\t\022\024\n\014entity_class\030\002 \001(\t\022\017\n\007team_id"
  "\030\003 \001(\005\022\024\n\014is_destroyed\030\004 \001(\010\022\026\n\013health_f"
  "rac\030\005 \001(\002:\0011\032\260\001\n\006Entity\022&\n\007courier\030\001 \001(\013"
  "2\025.CScenarioEnt_Courier\022\036\n\003npc\030\002 \001(\0132\021.C"
  "ScenarioEnt_NPC\022-\n\013spirit_bear\030\003 \001(\0132\030.C"
  "ScenarioEnt_SpiritBear\022/\n\014dropped_item\030\004"
  " \001(\0132\031.CScenarioEnt_DroppedItem\032\347\001\n\004Item"
  "\022\014\n\004name\030\001 \001(\t\022-\n\010location\030\002 \001(\0132\033.CMsgD"
  "otaScenario.EntityRef\022\024\n\010owner_id\030\003 \001(\005:"
  "\002-1\022\021\n\titem_slot\030\004 \001(\005\022\031\n\021neutral_drop_t"
  "eam\030\005 \001(\005\022\017\n\007charges\030\006 \001(\005\022\031\n\021secondary_"
  "charges\030\007 \001(\005\022\024\n\010lifetime\030\010 \001(\002:\002-1\022\034\n\020s"
  "tored_rune_type\030\t \001(\005:\002-1\032\347\004\n\010Modifier\022\014"
  "\n\004name\030\001 \001(\t\022+\n\006parent\030\002 \001(\0132\033.CMsgDotaS"
  "cenario.EntityRef\022+\n\006caster\030\003 \001(\0132\033.CMsg"
  "DotaScenario.EntityRef\022,\n\007ability\030\004 \001(\0132"
  "\033.CMsgDotaScenario.EntityRef\022\024\n\010duration"
  "\030\005 \001(\002:\002-1\022\035\n\022lifetime_remaining\030\006 \001(\002:\001"
  "0\022\023\n\013stack_count\030\007 \001(\005\022\037\n\027create_even_if"
  "_existing\030\010 \001(\010\022\035\n\025create_without_caster"
  "\030\t \001(\010\022\036\n\026create_without_ability\030\n \001(\010\022 "
  "\n\030moonshard_consumed_bonus\030d \001(\005\022-\n%moon"
  "shard_consumed_bonus_night_vision\030e \001(\005\022"
  "\033\n\023wardtruesight_range\030n \001(\005\022;\n3ultimate"
  "_scepter_consumed_alchemist_bonus_all_st"
  "ats\030x \001(\005\0228\n0ultimate_scepter_consumed_a"
  "lchemist_bonus_health\030y \001(\005\0226\n.ultimate_"
  "scepter_consumed_alchemist_bonus_mana\030z "
  "\001(\005"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_dota_5fscenariomessages_2eproto_deps[1] = {
  &::descriptor_table_dota_5fshared_5fenums_2eproto,
};
static ::_pbi::once_flag descriptor_table_dota_5fscenariomessages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_dota_5fscenariomessages_2eproto = {
    false, false, 4763, descriptor_table_protodef_dota_5fscenariomessages_2eproto,
    "dota_scenariomessages.proto",
    &descriptor_table_dota_5fscenariomessages_2eproto_once, descriptor_table_dota_5fscenariomessages_2eproto_deps, 1, 21,
    schemas, file_default_instances, TableStruct_dota_5fscenariomessages_2eproto::offsets,
    file_level_metadata_dota_5fscenariomessages_2eproto, file_level_enum_descriptors_dota_5fscenariomessages_2eproto,
    file_level_service_descriptors_dota_5fscenariomessages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_dota_5fscenariomessages_2eproto_getter() {
  return &descriptor_table_dota_5fscenariomessages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_dota_5fscenariomessages_2eproto(&descriptor_table_dota_5fscenariomessages_2eproto);

// ===================================================================

class CScenario_Position::_Internal {
 public:
  using HasBits = decltype(std::declval<CScenario_Position>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CScenario_Position::CScenario_Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CScenario_Position)
}
CScenario_Position::CScenario_Position(const CScenario_Position& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CScenario_Position* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:CScenario_Position)
}

inline void CScenario_Position::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

CScenario_Position::~CScenario_Position() {
  // @@protoc_insertion_point(destructor:CScenario_Position)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CScenario_Position::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CScenario_Position::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CScenario_Position::Clear() {
// @@protoc_insertion_point(message_clear_start:CScenario_Position)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CScenario_Position::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CScenario_Position::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CScenario_Position)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CScenario_Position)
  return target;
}

size_t CScenario_Position::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CScenario_Position)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CScenario_Position::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CScenario_Position::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CScenario_Position::GetClassData() const { return &_class_data_; }


void CScenario_Position::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CScenario_Position*>(&to_msg);
  auto& from = static_cast<const CScenario_Position&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CScenario_Position)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CScenario_Position::CopyFrom(const CScenario_Position& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CScenario_Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CScenario_Position::IsInitialized() const {
  return true;
}

void CScenario_Position::InternalSwap(CScenario_Position* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CScenario_Position, _impl_.y_)
      + sizeof(CScenario_Position::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(CScenario_Position, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CScenario_Position::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[0]);
}

// ===================================================================

class CScenarioGame_RoshanSpawner::_Internal {
 public:
  using HasBits = decltype(std::declval<CScenarioGame_RoshanSpawner>()._impl_._has_bits_);
  static void set_has_kill_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cooldown(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CScenarioGame_RoshanSpawner::CScenarioGame_RoshanSpawner(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CScenarioGame_RoshanSpawner)
}
CScenarioGame_RoshanSpawner::CScenarioGame_RoshanSpawner(const CScenarioGame_RoshanSpawner& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CScenarioGame_RoshanSpawner* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.kill_count_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.cooldown_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.kill_count_, &from._impl_.kill_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cooldown_) -
    reinterpret_cast<char*>(&_impl_.kill_count_)) + sizeof(_impl_.cooldown_));
  // @@protoc_insertion_point(copy_constructor:CScenarioGame_RoshanSpawner)
}

inline void CScenarioGame_RoshanSpawner::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.kill_count_){0}
    , decltype(_impl_.state_){0}
    , decltype(_impl_.cooldown_){0}
  };
}

CScenarioGame_RoshanSpawner::~CScenarioGame_RoshanSpawner() {
  // @@protoc_insertion_point(destructor:CScenarioGame_RoshanSpawner)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CScenarioGame_RoshanSpawner::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CScenarioGame_RoshanSpawner::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CScenarioGame_RoshanSpawner::Clear() {
// @@protoc_insertion_point(message_clear_start:CScenarioGame_RoshanSpawner)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.kill_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cooldown_) -
        reinterpret_cast<char*>(&_impl_.kill_count_)) + sizeof(_impl_.cooldown_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CScenarioGame_RoshanSpawner::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 kill_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_kill_count(&has_bits);
          _impl_.kill_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_state(&has_bits);
          _impl_.state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float cooldown = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_cooldown(&has_bits);
          _impl_.cooldown_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CScenarioGame_RoshanSpawner::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CScenarioGame_RoshanSpawner)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 kill_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_kill_count(), target);
  }

  // optional int32 state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_state(), target);
  }

  // optional float cooldown = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_cooldown(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CScenarioGame_RoshanSpawner)
  return target;
}

size_t CScenarioGame_RoshanSpawner::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CScenarioGame_RoshanSpawner)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 kill_count = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_kill_count());
    }

    // optional int32 state = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_state());
    }

    // optional float cooldown = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CScenarioGame_RoshanSpawner::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CScenarioGame_RoshanSpawner::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CScenarioGame_RoshanSpawner::GetClassData() const { return &_class_data_; }


void CScenarioGame_RoshanSpawner::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CScenarioGame_RoshanSpawner*>(&to_msg);
  auto& from = static_cast<const CScenarioGame_RoshanSpawner&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CScenarioGame_RoshanSpawner)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.kill_count_ = from._impl_.kill_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cooldown_ = from._impl_.cooldown_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CScenarioGame_RoshanSpawner::CopyFrom(const CScenarioGame_RoshanSpawner& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CScenarioGame_RoshanSpawner)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CScenarioGame_RoshanSpawner::IsInitialized() const {
  return true;
}

void CScenarioGame_RoshanSpawner::InternalSwap(CScenarioGame_RoshanSpawner* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CScenarioGame_RoshanSpawner, _impl_.cooldown_)
      + sizeof(CScenarioGame_RoshanSpawner::_impl_.cooldown_)
      - PROTOBUF_FIELD_OFFSET(CScenarioGame_RoshanSpawner, _impl_.kill_count_)>(
          reinterpret_cast<char*>(&_impl_.kill_count_),
          reinterpret_cast<char*>(&other->_impl_.kill_count_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CScenarioGame_RoshanSpawner::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[1]);
}

// ===================================================================

class CScenarioEnt_Courier::_Internal {
 public:
  using HasBits = decltype(std::declval<CScenarioEnt_Courier>()._impl_._has_bits_);
  static void set_has_team_number(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_owner_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cooldown(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CScenarioEnt_Courier::CScenarioEnt_Courier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CScenarioEnt_Courier)
}
CScenarioEnt_Courier::CScenarioEnt_Courier(const CScenarioEnt_Courier& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CScenarioEnt_Courier* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_number_){}
    , decltype(_impl_.owner_player_id_){}
    , decltype(_impl_.cooldown_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.team_number_, &from._impl_.team_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cooldown_) -
    reinterpret_cast<char*>(&_impl_.team_number_)) + sizeof(_impl_.cooldown_));
  // @@protoc_insertion_point(copy_constructor:CScenarioEnt_Courier)
}

inline void CScenarioEnt_Courier::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_number_){0}
    , decltype(_impl_.owner_player_id_){-1}
    , decltype(_impl_.cooldown_){-1}
  };
}

CScenarioEnt_Courier::~CScenarioEnt_Courier() {
  // @@protoc_insertion_point(destructor:CScenarioEnt_Courier)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CScenarioEnt_Courier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CScenarioEnt_Courier::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CScenarioEnt_Courier::Clear() {
// @@protoc_insertion_point(message_clear_start:CScenarioEnt_Courier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    _impl_.team_number_ = 0;
    _impl_.owner_player_id_ = -1;
    _impl_.cooldown_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CScenarioEnt_Courier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 team_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_team_number(&has_bits);
          _impl_.team_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 owner_player_id = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_owner_player_id(&has_bits);
          _impl_.owner_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float cooldown = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_cooldown(&has_bits);
          _impl_.cooldown_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CScenarioEnt_Courier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CScenarioEnt_Courier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 team_number = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_team_number(), target);
  }

  // optional int32 owner_player_id = 2 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_owner_player_id(), target);
  }

  // optional float cooldown = 3 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_cooldown(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CScenarioEnt_Courier)
  return target;
}

size_t CScenarioEnt_Courier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CScenarioEnt_Courier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 team_number = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_team_number());
    }

    // optional int32 owner_player_id = 2 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_owner_player_id());
    }

    // optional float cooldown = 3 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CScenarioEnt_Courier::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CScenarioEnt_Courier::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CScenarioEnt_Courier::GetClassData() const { return &_class_data_; }


void CScenarioEnt_Courier::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CScenarioEnt_Courier*>(&to_msg);
  auto& from = static_cast<const CScenarioEnt_Courier&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CScenarioEnt_Courier)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.team_number_ = from._impl_.team_number_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.owner_player_id_ = from._impl_.owner_player_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cooldown_ = from._impl_.cooldown_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CScenarioEnt_Courier::CopyFrom(const CScenarioEnt_Courier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CScenarioEnt_Courier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CScenarioEnt_Courier::IsInitialized() const {
  return true;
}

void CScenarioEnt_Courier::InternalSwap(CScenarioEnt_Courier* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.team_number_, other->_impl_.team_number_);
  swap(_impl_.owner_player_id_, other->_impl_.owner_player_id_);
  swap(_impl_.cooldown_, other->_impl_.cooldown_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CScenarioEnt_Courier::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[2]);
}

// ===================================================================

class CScenarioEnt_NPC::_Internal {
 public:
  using HasBits = decltype(std::declval<CScenarioEnt_NPC>()._impl_._has_bits_);
  static const ::CScenario_Position& position(const CScenarioEnt_NPC* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_unit_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_number(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_health_frac(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_owning_camp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CScenario_Position& owning_camp_position(const CScenarioEnt_NPC* msg);
  static void set_has_owning_camp_position(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_invade_goal(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CScenario_Position&
CScenarioEnt_NPC::_Internal::position(const CScenarioEnt_NPC* msg) {
  return *msg->_impl_.position_;
}
const ::CScenario_Position&
CScenarioEnt_NPC::_Internal::owning_camp_position(const CScenarioEnt_NPC* msg) {
  return *msg->_impl_.owning_camp_position_;
}
CScenarioEnt_NPC::CScenarioEnt_NPC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CScenarioEnt_NPC)
}
CScenarioEnt_NPC::CScenarioEnt_NPC(const CScenarioEnt_NPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CScenarioEnt_NPC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unit_name_){}
    , decltype(_impl_.owning_camp_){}
    , decltype(_impl_.invade_goal_){}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.owning_camp_position_){nullptr}
    , decltype(_impl_.team_number_){}
    , decltype(_impl_.health_frac_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.unit_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unit_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_unit_name()) {
    _this->_impl_.unit_name_.Set(from._internal_unit_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.owning_camp_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owning_camp_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_owning_camp()) {
    _this->_impl_.owning_camp_.Set(from._internal_owning_camp(), 
      _this->GetArenaForAllocation());
  }
  _impl_.invade_goal_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invade_goal_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_invade_goal()) {
    _this->_impl_.invade_goal_.Set(from._internal_invade_goal(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::CScenario_Position(*from._impl_.position_);
  }
  if (from._internal_has_owning_camp_position()) {
    _this->_impl_.owning_camp_position_ = new ::CScenario_Position(*from._impl_.owning_camp_position_);
  }
  ::memcpy(&_impl_.team_number_, &from._impl_.team_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.health_frac_) -
    reinterpret_cast<char*>(&_impl_.team_number_)) + sizeof(_impl_.health_frac_));
  // @@protoc_insertion_point(copy_constructor:CScenarioEnt_NPC)
}

inline void CScenarioEnt_NPC::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unit_name_){}
    , decltype(_impl_.owning_camp_){}
    , decltype(_impl_.invade_goal_){}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.owning_camp_position_){nullptr}
    , decltype(_impl_.team_number_){0}
    , decltype(_impl_.health_frac_){1}
  };
  _impl_.unit_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unit_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owning_camp_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owning_camp_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.invade_goal_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invade_goal_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CScenarioEnt_NPC::~CScenarioEnt_NPC() {
  // @@protoc_insertion_point(destructor:CScenarioEnt_NPC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CScenarioEnt_NPC::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.unit_name_.Destroy();
  _impl_.owning_camp_.Destroy();
  _impl_.invade_goal_.Destroy();
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.owning_camp_position_;
}

void CScenarioEnt_NPC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CScenarioEnt_NPC::Clear() {
// @@protoc_insertion_point(message_clear_start:CScenarioEnt_NPC)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.unit_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.owning_camp_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.invade_goal_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.owning_camp_position_ != nullptr);
      _impl_.owning_camp_position_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    _impl_.team_number_ = 0;
    _impl_.health_frac_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CScenarioEnt_NPC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CScenario_Position position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string unit_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_unit_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CScenarioEnt_NPC.unit_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 team_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_team_number(&has_bits);
          _impl_.team_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float health_frac = 4 [default = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_health_frac(&has_bits);
          _impl_.health_frac_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string owning_camp = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_owning_camp();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CScenarioEnt_NPC.owning_camp");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .CScenario_Position owning_camp_position = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_owning_camp_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string invade_goal = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_invade_goal();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CScenarioEnt_NPC.invade_goal");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CScenarioEnt_NPC::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CScenarioEnt_NPC)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CScenario_Position position = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional string unit_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_unit_name().data(), static_cast<int>(this->_internal_unit_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CScenarioEnt_NPC.unit_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_unit_name(), target);
  }

  // optional int32 team_number = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_team_number(), target);
  }

  // optional float health_frac = 4 [default = 1];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_health_frac(), target);
  }

  // optional string owning_camp = 10;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_owning_camp().data(), static_cast<int>(this->_internal_owning_camp().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CScenarioEnt_NPC.owning_camp");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_owning_camp(), target);
  }

  // optional .CScenario_Position owning_camp_position = 11;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::owning_camp_position(this),
        _Internal::owning_camp_position(this).GetCachedSize(), target, stream);
  }

  // optional string invade_goal = 20;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_invade_goal().data(), static_cast<int>(this->_internal_invade_goal().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CScenarioEnt_NPC.invade_goal");
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_invade_goal(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CScenarioEnt_NPC)
  return target;
}

size_t CScenarioEnt_NPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CScenarioEnt_NPC)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string unit_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_unit_name());
    }

    // optional string owning_camp = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_owning_camp());
    }

    // optional string invade_goal = 20;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_invade_goal());
    }

    // optional .CScenario_Position position = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional .CScenario_Position owning_camp_position = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owning_camp_position_);
    }

    // optional int32 team_number = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_team_number());
    }

    // optional float health_frac = 4 [default = 1];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CScenarioEnt_NPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CScenarioEnt_NPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CScenarioEnt_NPC::GetClassData() const { return &_class_data_; }


void CScenarioEnt_NPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CScenarioEnt_NPC*>(&to_msg);
  auto& from = static_cast<const CScenarioEnt_NPC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CScenarioEnt_NPC)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_unit_name(from._internal_unit_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_owning_camp(from._internal_owning_camp());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_invade_goal(from._internal_invade_goal());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_position()->::CScenario_Position::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_owning_camp_position()->::CScenario_Position::MergeFrom(
          from._internal_owning_camp_position());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.team_number_ = from._impl_.team_number_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.health_frac_ = from._impl_.health_frac_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CScenarioEnt_NPC::CopyFrom(const CScenarioEnt_NPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CScenarioEnt_NPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CScenarioEnt_NPC::IsInitialized() const {
  return true;
}

void CScenarioEnt_NPC::InternalSwap(CScenarioEnt_NPC* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.unit_name_, lhs_arena,
      &other->_impl_.unit_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.owning_camp_, lhs_arena,
      &other->_impl_.owning_camp_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.invade_goal_, lhs_arena,
      &other->_impl_.invade_goal_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CScenarioEnt_NPC, _impl_.team_number_)
      + sizeof(CScenarioEnt_NPC::_impl_.team_number_)
      - PROTOBUF_FIELD_OFFSET(CScenarioEnt_NPC, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
  swap(_impl_.health_frac_, other->_impl_.health_frac_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CScenarioEnt_NPC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[3]);
}

// ===================================================================

class CScenarioEnt_SpiritBear::_Internal {
 public:
  using HasBits = decltype(std::declval<CScenarioEnt_SpiritBear>()._impl_._has_bits_);
  static void set_has_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CScenarioEnt_SpiritBear::CScenarioEnt_SpiritBear(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CScenarioEnt_SpiritBear)
}
CScenarioEnt_SpiritBear::CScenarioEnt_SpiritBear(const CScenarioEnt_SpiritBear& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CScenarioEnt_SpiritBear* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.owner_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.team_id_, &from._impl_.team_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.owner_id_) -
    reinterpret_cast<char*>(&_impl_.team_id_)) + sizeof(_impl_.owner_id_));
  // @@protoc_insertion_point(copy_constructor:CScenarioEnt_SpiritBear)
}

inline void CScenarioEnt_SpiritBear::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.team_id_){0}
    , decltype(_impl_.owner_id_){-1}
  };
}

CScenarioEnt_SpiritBear::~CScenarioEnt_SpiritBear() {
  // @@protoc_insertion_point(destructor:CScenarioEnt_SpiritBear)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CScenarioEnt_SpiritBear::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CScenarioEnt_SpiritBear::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CScenarioEnt_SpiritBear::Clear() {
// @@protoc_insertion_point(message_clear_start:CScenarioEnt_SpiritBear)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.team_id_ = 0;
    _impl_.owner_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CScenarioEnt_SpiritBear::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 owner_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_owner_id(&has_bits);
          _impl_.owner_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 team_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CScenarioEnt_SpiritBear::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CScenarioEnt_SpiritBear)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 owner_id = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_owner_id(), target);
  }

  // optional int32 team_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_team_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CScenarioEnt_SpiritBear)
  return target;
}

size_t CScenarioEnt_SpiritBear::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CScenarioEnt_SpiritBear)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 team_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_team_id());
    }

    // optional int32 owner_id = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_owner_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CScenarioEnt_SpiritBear::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CScenarioEnt_SpiritBear::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CScenarioEnt_SpiritBear::GetClassData() const { return &_class_data_; }


void CScenarioEnt_SpiritBear::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CScenarioEnt_SpiritBear*>(&to_msg);
  auto& from = static_cast<const CScenarioEnt_SpiritBear&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CScenarioEnt_SpiritBear)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.owner_id_ = from._impl_.owner_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CScenarioEnt_SpiritBear::CopyFrom(const CScenarioEnt_SpiritBear& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CScenarioEnt_SpiritBear)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CScenarioEnt_SpiritBear::IsInitialized() const {
  return true;
}

void CScenarioEnt_SpiritBear::InternalSwap(CScenarioEnt_SpiritBear* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.team_id_, other->_impl_.team_id_);
  swap(_impl_.owner_id_, other->_impl_.owner_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CScenarioEnt_SpiritBear::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[4]);
}

// ===================================================================

class CScenarioEnt_DroppedItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CScenarioEnt_DroppedItem>()._impl_._has_bits_);
  static const ::CScenario_Position& position(const CScenarioEnt_DroppedItem* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CScenario_Position&
CScenarioEnt_DroppedItem::_Internal::position(const CScenarioEnt_DroppedItem* msg) {
  return *msg->_impl_.position_;
}
CScenarioEnt_DroppedItem::CScenarioEnt_DroppedItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CScenarioEnt_DroppedItem)
}
CScenarioEnt_DroppedItem::CScenarioEnt_DroppedItem(const CScenarioEnt_DroppedItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CScenarioEnt_DroppedItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::CScenario_Position(*from._impl_.position_);
  }
  // @@protoc_insertion_point(copy_constructor:CScenarioEnt_DroppedItem)
}

inline void CScenarioEnt_DroppedItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
  };
}

CScenarioEnt_DroppedItem::~CScenarioEnt_DroppedItem() {
  // @@protoc_insertion_point(destructor:CScenarioEnt_DroppedItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CScenarioEnt_DroppedItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void CScenarioEnt_DroppedItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CScenarioEnt_DroppedItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CScenarioEnt_DroppedItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CScenarioEnt_DroppedItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CScenario_Position position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CScenarioEnt_DroppedItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CScenarioEnt_DroppedItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CScenario_Position position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CScenarioEnt_DroppedItem)
  return target;
}

size_t CScenarioEnt_DroppedItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CScenarioEnt_DroppedItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CScenario_Position position = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CScenarioEnt_DroppedItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CScenarioEnt_DroppedItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CScenarioEnt_DroppedItem::GetClassData() const { return &_class_data_; }


void CScenarioEnt_DroppedItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CScenarioEnt_DroppedItem*>(&to_msg);
  auto& from = static_cast<const CScenarioEnt_DroppedItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CScenarioEnt_DroppedItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::CScenario_Position::MergeFrom(
        from._internal_position());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CScenarioEnt_DroppedItem::CopyFrom(const CScenarioEnt_DroppedItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CScenarioEnt_DroppedItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CScenarioEnt_DroppedItem::IsInitialized() const {
  return true;
}

void CScenarioEnt_DroppedItem::InternalSwap(CScenarioEnt_DroppedItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.position_, other->_impl_.position_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CScenarioEnt_DroppedItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[5]);
}

// ===================================================================

class CMsgDotaScenario_EntityRef::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_EntityRef>()._impl_._has_bits_);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_neutral_stash_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_entity_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_roshan(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ability_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDotaScenario_EntityRef::CMsgDotaScenario_EntityRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.EntityRef)
}
CMsgDotaScenario_EntityRef::CMsgDotaScenario_EntityRef(const CMsgDotaScenario_EntityRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_EntityRef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ability_name_){}
    , decltype(_impl_.roshan_){}
    , decltype(_impl_.entity_idx_){}
    , decltype(_impl_.player_id_){}
    , decltype(_impl_.neutral_stash_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ability_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ability_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ability_name()) {
    _this->_impl_.ability_name_.Set(from._internal_ability_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.roshan_, &from._impl_.roshan_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.neutral_stash_id_) -
    reinterpret_cast<char*>(&_impl_.roshan_)) + sizeof(_impl_.neutral_stash_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.EntityRef)
}

inline void CMsgDotaScenario_EntityRef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ability_name_){}
    , decltype(_impl_.roshan_){false}
    , decltype(_impl_.entity_idx_){-1}
    , decltype(_impl_.player_id_){-1}
    , decltype(_impl_.neutral_stash_id_){-1}
  };
  _impl_.ability_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ability_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDotaScenario_EntityRef::~CMsgDotaScenario_EntityRef() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.EntityRef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_EntityRef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ability_name_.Destroy();
}

void CMsgDotaScenario_EntityRef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_EntityRef::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.EntityRef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.ability_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    _impl_.roshan_ = false;
    _impl_.entity_idx_ = -1;
    _impl_.player_id_ = -1;
    _impl_.neutral_stash_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_EntityRef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 neutral_stash_id = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_neutral_stash_id(&has_bits);
          _impl_.neutral_stash_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 entity_idx = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_entity_idx(&has_bits);
          _impl_.entity_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool roshan = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_roshan(&has_bits);
          _impl_.roshan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ability_name = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_ability_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDotaScenario.EntityRef.ability_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_EntityRef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.EntityRef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_id(), target);
  }

  // optional int32 neutral_stash_id = 2 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_neutral_stash_id(), target);
  }

  // optional int32 entity_idx = 3 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_entity_idx(), target);
  }

  // optional bool roshan = 4 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_roshan(), target);
  }

  // optional string ability_name = 10;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ability_name().data(), static_cast<int>(this->_internal_ability_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDotaScenario.EntityRef.ability_name");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_ability_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.EntityRef)
  return target;
}

size_t CMsgDotaScenario_EntityRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.EntityRef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string ability_name = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ability_name());
    }

    // optional bool roshan = 4 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional int32 entity_idx = 3 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity_idx());
    }

    // optional int32 player_id = 1 [default = -1];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
    }

    // optional int32 neutral_stash_id = 2 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_neutral_stash_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_EntityRef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_EntityRef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_EntityRef::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_EntityRef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_EntityRef*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_EntityRef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.EntityRef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ability_name(from._internal_ability_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.roshan_ = from._impl_.roshan_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.entity_idx_ = from._impl_.entity_idx_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.player_id_ = from._impl_.player_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.neutral_stash_id_ = from._impl_.neutral_stash_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_EntityRef::CopyFrom(const CMsgDotaScenario_EntityRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.EntityRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_EntityRef::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_EntityRef::InternalSwap(CMsgDotaScenario_EntityRef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ability_name_, lhs_arena,
      &other->_impl_.ability_name_, rhs_arena
  );
  swap(_impl_.roshan_, other->_impl_.roshan_);
  swap(_impl_.entity_idx_, other->_impl_.entity_idx_);
  swap(_impl_.player_id_, other->_impl_.player_id_);
  swap(_impl_.neutral_stash_id_, other->_impl_.neutral_stash_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_EntityRef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[6]);
}

// ===================================================================

class CMsgDotaScenario_Game::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_Game>()._impl_._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_game_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_clock_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_internal_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CScenarioGame_RoshanSpawner& roshan(const CMsgDotaScenario_Game* msg);
  static void set_has_roshan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CScenarioGame_RoshanSpawner&
CMsgDotaScenario_Game::_Internal::roshan(const CMsgDotaScenario_Game* msg) {
  return *msg->_impl_.roshan_;
}
CMsgDotaScenario_Game::CMsgDotaScenario_Game(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.Game)
}
CMsgDotaScenario_Game::CMsgDotaScenario_Game(const CMsgDotaScenario_Game& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_Game* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roshan_){nullptr}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.game_mode_){}
    , decltype(_impl_.clock_time_){}
    , decltype(_impl_.internal_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_roshan()) {
    _this->_impl_.roshan_ = new ::CScenarioGame_RoshanSpawner(*from._impl_.roshan_);
  }
  ::memcpy(&_impl_.match_id_, &from._impl_.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.internal_time_) -
    reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.internal_time_));
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.Game)
}

inline void CMsgDotaScenario_Game::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roshan_){nullptr}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.game_mode_){0}
    , decltype(_impl_.clock_time_){0}
    , decltype(_impl_.internal_time_){0}
  };
}

CMsgDotaScenario_Game::~CMsgDotaScenario_Game() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.Game)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_Game::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.roshan_;
}

void CMsgDotaScenario_Game::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_Game::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.Game)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.roshan_ != nullptr);
    _impl_.roshan_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.internal_time_) -
        reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.internal_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_Game::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 match_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 game_mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_game_mode(&has_bits);
          _impl_.game_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float clock_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_clock_time(&has_bits);
          _impl_.clock_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float internal_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_internal_time(&has_bits);
          _impl_.internal_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .CScenarioGame_RoshanSpawner roshan = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_roshan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_Game::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.Game)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 match_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_match_id(), target);
  }

  // optional int32 game_mode = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_game_mode(), target);
  }

  // optional float clock_time = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_clock_time(), target);
  }

  // optional float internal_time = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_internal_time(), target);
  }

  // optional .CScenarioGame_RoshanSpawner roshan = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::roshan(this),
        _Internal::roshan(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.Game)
  return target;
}

size_t CMsgDotaScenario_Game::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.Game)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CScenarioGame_RoshanSpawner roshan = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.roshan_);
    }

    // optional uint64 match_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional int32 game_mode = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_game_mode());
    }

    // optional float clock_time = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float internal_time = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_Game::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_Game::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_Game::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_Game::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_Game*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_Game&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.Game)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_roshan()->::CScenarioGame_RoshanSpawner::MergeFrom(
          from._internal_roshan());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.game_mode_ = from._impl_.game_mode_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.clock_time_ = from._impl_.clock_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.internal_time_ = from._impl_.internal_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_Game::CopyFrom(const CMsgDotaScenario_Game& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.Game)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_Game::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_Game::InternalSwap(CMsgDotaScenario_Game* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Game, _impl_.internal_time_)
      + sizeof(CMsgDotaScenario_Game::_impl_.internal_time_)
      - PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Game, _impl_.roshan_)>(
          reinterpret_cast<char*>(&_impl_.roshan_),
          reinterpret_cast<char*>(&other->_impl_.roshan_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_Game::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[7]);
}

// ===================================================================

class CMsgDotaScenario_TeamNeutralItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_TeamNeutralItem>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_consumed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDotaScenario_TeamNeutralItem::CMsgDotaScenario_TeamNeutralItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.TeamNeutralItem)
}
CMsgDotaScenario_TeamNeutralItem::CMsgDotaScenario_TeamNeutralItem(const CMsgDotaScenario_TeamNeutralItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_TeamNeutralItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.consumed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.consumed_ = from._impl_.consumed_;
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.TeamNeutralItem)
}

inline void CMsgDotaScenario_TeamNeutralItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.consumed_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDotaScenario_TeamNeutralItem::~CMsgDotaScenario_TeamNeutralItem() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.TeamNeutralItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_TeamNeutralItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgDotaScenario_TeamNeutralItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_TeamNeutralItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.TeamNeutralItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.consumed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_TeamNeutralItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDotaScenario.TeamNeutralItem.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool consumed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_consumed(&has_bits);
          _impl_.consumed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_TeamNeutralItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.TeamNeutralItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDotaScenario.TeamNeutralItem.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bool consumed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_consumed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.TeamNeutralItem)
  return target;
}

size_t CMsgDotaScenario_TeamNeutralItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.TeamNeutralItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bool consumed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_TeamNeutralItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_TeamNeutralItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_TeamNeutralItem::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_TeamNeutralItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_TeamNeutralItem*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_TeamNeutralItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.TeamNeutralItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.consumed_ = from._impl_.consumed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_TeamNeutralItem::CopyFrom(const CMsgDotaScenario_TeamNeutralItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.TeamNeutralItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_TeamNeutralItem::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_TeamNeutralItem::InternalSwap(CMsgDotaScenario_TeamNeutralItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.consumed_, other->_impl_.consumed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_TeamNeutralItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[8]);
}

// ===================================================================

class CMsgDotaScenario_Team::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_Team>()._impl_._has_bits_);
  static void set_has_team_number(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hero_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tower_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_barracks_kills(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_glyph_cooldown(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_radar_cooldown(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CMsgDotaScenario_Team::CMsgDotaScenario_Team(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.Team)
}
CMsgDotaScenario_Team::CMsgDotaScenario_Team(const CMsgDotaScenario_Team& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_Team* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.neutral_items_){from._impl_.neutral_items_}
    , decltype(_impl_.team_number_){}
    , decltype(_impl_.hero_kills_){}
    , decltype(_impl_.tower_kills_){}
    , decltype(_impl_.barracks_kills_){}
    , decltype(_impl_.glyph_cooldown_){}
    , decltype(_impl_.radar_cooldown_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.team_number_, &from._impl_.team_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.radar_cooldown_) -
    reinterpret_cast<char*>(&_impl_.team_number_)) + sizeof(_impl_.radar_cooldown_));
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.Team)
}

inline void CMsgDotaScenario_Team::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.neutral_items_){arena}
    , decltype(_impl_.team_number_){0}
    , decltype(_impl_.hero_kills_){0}
    , decltype(_impl_.tower_kills_){0}
    , decltype(_impl_.barracks_kills_){0}
    , decltype(_impl_.glyph_cooldown_){0}
    , decltype(_impl_.radar_cooldown_){0}
  };
}

CMsgDotaScenario_Team::~CMsgDotaScenario_Team() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.Team)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_Team::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.neutral_items_.~RepeatedPtrField();
}

void CMsgDotaScenario_Team::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_Team::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.Team)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.neutral_items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.team_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.radar_cooldown_) -
        reinterpret_cast<char*>(&_impl_.team_number_)) + sizeof(_impl_.radar_cooldown_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_Team::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 team_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_team_number(&has_bits);
          _impl_.team_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDotaScenario.TeamNeutralItem neutral_items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_neutral_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 hero_kills = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hero_kills(&has_bits);
          _impl_.hero_kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tower_kills = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_tower_kills(&has_bits);
          _impl_.tower_kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 barracks_kills = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_barracks_kills(&has_bits);
          _impl_.barracks_kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float glyph_cooldown = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_glyph_cooldown(&has_bits);
          _impl_.glyph_cooldown_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float radar_cooldown = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_radar_cooldown(&has_bits);
          _impl_.radar_cooldown_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_Team::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.Team)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 team_number = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_team_number(), target);
  }

  // repeated .CMsgDotaScenario.TeamNeutralItem neutral_items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_neutral_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_neutral_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 hero_kills = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_hero_kills(), target);
  }

  // optional int32 tower_kills = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_tower_kills(), target);
  }

  // optional int32 barracks_kills = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_barracks_kills(), target);
  }

  // optional float glyph_cooldown = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_glyph_cooldown(), target);
  }

  // optional float radar_cooldown = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_radar_cooldown(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.Team)
  return target;
}

size_t CMsgDotaScenario_Team::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.Team)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDotaScenario.TeamNeutralItem neutral_items = 2;
  total_size += 1UL * this->_internal_neutral_items_size();
  for (const auto& msg : this->_impl_.neutral_items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int32 team_number = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_team_number());
    }

    // optional int32 hero_kills = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hero_kills());
    }

    // optional int32 tower_kills = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tower_kills());
    }

    // optional int32 barracks_kills = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_barracks_kills());
    }

    // optional float glyph_cooldown = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float radar_cooldown = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_Team::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_Team::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_Team::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_Team::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_Team*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_Team&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.Team)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.neutral_items_.MergeFrom(from._impl_.neutral_items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.team_number_ = from._impl_.team_number_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hero_kills_ = from._impl_.hero_kills_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tower_kills_ = from._impl_.tower_kills_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.barracks_kills_ = from._impl_.barracks_kills_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.glyph_cooldown_ = from._impl_.glyph_cooldown_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.radar_cooldown_ = from._impl_.radar_cooldown_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_Team::CopyFrom(const CMsgDotaScenario_Team& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.Team)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_Team::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_Team::InternalSwap(CMsgDotaScenario_Team* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.neutral_items_.InternalSwap(&other->_impl_.neutral_items_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Team, _impl_.radar_cooldown_)
      + sizeof(CMsgDotaScenario_Team::_impl_.radar_cooldown_)
      - PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Team, _impl_.team_number_)>(
          reinterpret_cast<char*>(&_impl_.team_number_),
          reinterpret_cast<char*>(&other->_impl_.team_number_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_Team::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[9]);
}

// ===================================================================

class CMsgDotaScenario_HeroHeroInt::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_HeroHeroInt>()._impl_._has_bits_);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDotaScenario_HeroHeroInt::CMsgDotaScenario_HeroHeroInt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.HeroHeroInt)
}
CMsgDotaScenario_HeroHeroInt::CMsgDotaScenario_HeroHeroInt(const CMsgDotaScenario_HeroHeroInt& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_HeroHeroInt* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.value_, &from._impl_.value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_id_) -
    reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.player_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.HeroHeroInt)
}

inline void CMsgDotaScenario_HeroHeroInt::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){0}
    , decltype(_impl_.player_id_){-1}
  };
}

CMsgDotaScenario_HeroHeroInt::~CMsgDotaScenario_HeroHeroInt() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.HeroHeroInt)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_HeroHeroInt::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDotaScenario_HeroHeroInt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_HeroHeroInt::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.HeroHeroInt)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.value_ = 0;
    _impl_.player_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_HeroHeroInt::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_HeroHeroInt::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.HeroHeroInt)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_id(), target);
  }

  // optional int32 value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.HeroHeroInt)
  return target;
}

size_t CMsgDotaScenario_HeroHeroInt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.HeroHeroInt)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 value = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_value());
    }

    // optional int32 player_id = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_HeroHeroInt::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_HeroHeroInt::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_HeroHeroInt::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_HeroHeroInt::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_HeroHeroInt*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_HeroHeroInt&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.HeroHeroInt)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.player_id_ = from._impl_.player_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_HeroHeroInt::CopyFrom(const CMsgDotaScenario_HeroHeroInt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.HeroHeroInt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_HeroHeroInt::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_HeroHeroInt::InternalSwap(CMsgDotaScenario_HeroHeroInt* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
  swap(_impl_.player_id_, other->_impl_.player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_HeroHeroInt::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[10]);
}

// ===================================================================

class CMsgDotaScenario_HeroHeroFloat::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_HeroHeroFloat>()._impl_._has_bits_);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgDotaScenario_HeroHeroFloat::CMsgDotaScenario_HeroHeroFloat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.HeroHeroFloat)
}
CMsgDotaScenario_HeroHeroFloat::CMsgDotaScenario_HeroHeroFloat(const CMsgDotaScenario_HeroHeroFloat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_HeroHeroFloat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.value_, &from._impl_.value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_id_) -
    reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.player_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.HeroHeroFloat)
}

inline void CMsgDotaScenario_HeroHeroFloat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){0}
    , decltype(_impl_.player_id_){-1}
  };
}

CMsgDotaScenario_HeroHeroFloat::~CMsgDotaScenario_HeroHeroFloat() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.HeroHeroFloat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_HeroHeroFloat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDotaScenario_HeroHeroFloat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_HeroHeroFloat::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.HeroHeroFloat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.value_ = 0;
    _impl_.player_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_HeroHeroFloat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_HeroHeroFloat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.HeroHeroFloat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_id(), target);
  }

  // optional float value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.HeroHeroFloat)
  return target;
}

size_t CMsgDotaScenario_HeroHeroFloat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.HeroHeroFloat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float value = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional int32 player_id = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_HeroHeroFloat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_HeroHeroFloat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_HeroHeroFloat::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_HeroHeroFloat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_HeroHeroFloat*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_HeroHeroFloat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.HeroHeroFloat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.player_id_ = from._impl_.player_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_HeroHeroFloat::CopyFrom(const CMsgDotaScenario_HeroHeroFloat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.HeroHeroFloat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_HeroHeroFloat::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_HeroHeroFloat::InternalSwap(CMsgDotaScenario_HeroHeroFloat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
  swap(_impl_.player_id_, other->_impl_.player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_HeroHeroFloat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[11]);
}

// ===================================================================

class CMsgDotaScenario_DamageStatsByType::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_DamageStatsByType>()._impl_._has_bits_);
  static void set_has_damage_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_received_pre_reduction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_received_post_reduction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_outgoing_pre_reduction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_outgoing_post_reduction(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgDotaScenario_DamageStatsByType::CMsgDotaScenario_DamageStatsByType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.DamageStatsByType)
}
CMsgDotaScenario_DamageStatsByType::CMsgDotaScenario_DamageStatsByType(const CMsgDotaScenario_DamageStatsByType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_DamageStatsByType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.damage_type_){}
    , decltype(_impl_.received_pre_reduction_){}
    , decltype(_impl_.received_post_reduction_){}
    , decltype(_impl_.outgoing_pre_reduction_){}
    , decltype(_impl_.outgoing_post_reduction_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.damage_type_, &from._impl_.damage_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.outgoing_post_reduction_) -
    reinterpret_cast<char*>(&_impl_.damage_type_)) + sizeof(_impl_.outgoing_post_reduction_));
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.DamageStatsByType)
}

inline void CMsgDotaScenario_DamageStatsByType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.damage_type_){0}
    , decltype(_impl_.received_pre_reduction_){0}
    , decltype(_impl_.received_post_reduction_){0}
    , decltype(_impl_.outgoing_pre_reduction_){0}
    , decltype(_impl_.outgoing_post_reduction_){0}
  };
}

CMsgDotaScenario_DamageStatsByType::~CMsgDotaScenario_DamageStatsByType() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.DamageStatsByType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_DamageStatsByType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgDotaScenario_DamageStatsByType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_DamageStatsByType::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.DamageStatsByType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.damage_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.outgoing_post_reduction_) -
        reinterpret_cast<char*>(&_impl_.damage_type_)) + sizeof(_impl_.outgoing_post_reduction_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_DamageStatsByType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 damage_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_damage_type(&has_bits);
          _impl_.damage_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 received_pre_reduction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_received_pre_reduction(&has_bits);
          _impl_.received_pre_reduction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 received_post_reduction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_received_post_reduction(&has_bits);
          _impl_.received_post_reduction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 outgoing_pre_reduction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_outgoing_pre_reduction(&has_bits);
          _impl_.outgoing_pre_reduction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 outgoing_post_reduction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_outgoing_post_reduction(&has_bits);
          _impl_.outgoing_post_reduction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_DamageStatsByType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.DamageStatsByType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 damage_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_damage_type(), target);
  }

  // optional int32 received_pre_reduction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_received_pre_reduction(), target);
  }

  // optional int32 received_post_reduction = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_received_post_reduction(), target);
  }

  // optional int32 outgoing_pre_reduction = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_outgoing_pre_reduction(), target);
  }

  // optional int32 outgoing_post_reduction = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_outgoing_post_reduction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.DamageStatsByType)
  return target;
}

size_t CMsgDotaScenario_DamageStatsByType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.DamageStatsByType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 damage_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_damage_type());
    }

    // optional int32 received_pre_reduction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_received_pre_reduction());
    }

    // optional int32 received_post_reduction = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_received_post_reduction());
    }

    // optional int32 outgoing_pre_reduction = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_outgoing_pre_reduction());
    }

    // optional int32 outgoing_post_reduction = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_outgoing_post_reduction());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_DamageStatsByType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_DamageStatsByType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_DamageStatsByType::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_DamageStatsByType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_DamageStatsByType*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_DamageStatsByType&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.DamageStatsByType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.damage_type_ = from._impl_.damage_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.received_pre_reduction_ = from._impl_.received_pre_reduction_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.received_post_reduction_ = from._impl_.received_post_reduction_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.outgoing_pre_reduction_ = from._impl_.outgoing_pre_reduction_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.outgoing_post_reduction_ = from._impl_.outgoing_post_reduction_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_DamageStatsByType::CopyFrom(const CMsgDotaScenario_DamageStatsByType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.DamageStatsByType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_DamageStatsByType::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_DamageStatsByType::InternalSwap(CMsgDotaScenario_DamageStatsByType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_DamageStatsByType, _impl_.outgoing_post_reduction_)
      + sizeof(CMsgDotaScenario_DamageStatsByType::_impl_.outgoing_post_reduction_)
      - PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_DamageStatsByType, _impl_.damage_type_)>(
          reinterpret_cast<char*>(&_impl_.damage_type_),
          reinterpret_cast<char*>(&other->_impl_.damage_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_DamageStatsByType::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[12]);
}

// ===================================================================

class CMsgDotaScenario_HeroAbility::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_HeroAbility>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgDotaScenario_HeroAbility::CMsgDotaScenario_HeroAbility(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.HeroAbility)
}
CMsgDotaScenario_HeroAbility::CMsgDotaScenario_HeroAbility(const CMsgDotaScenario_HeroAbility& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_HeroAbility* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.level_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.level_ = from._impl_.level_;
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.HeroAbility)
}

inline void CMsgDotaScenario_HeroAbility::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.level_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDotaScenario_HeroAbility::~CMsgDotaScenario_HeroAbility() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.HeroAbility)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_HeroAbility::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgDotaScenario_HeroAbility::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_HeroAbility::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.HeroAbility)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.level_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_HeroAbility::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDotaScenario.HeroAbility.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_HeroAbility::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.HeroAbility)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDotaScenario.HeroAbility.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.HeroAbility)
  return target;
}

size_t CMsgDotaScenario_HeroAbility::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.HeroAbility)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_level());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_HeroAbility::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_HeroAbility::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_HeroAbility::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_HeroAbility::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_HeroAbility*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_HeroAbility&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.HeroAbility)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_HeroAbility::CopyFrom(const CMsgDotaScenario_HeroAbility& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.HeroAbility)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_HeroAbility::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_HeroAbility::InternalSwap(CMsgDotaScenario_HeroAbility* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.level_, other->_impl_.level_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_HeroAbility::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[13]);
}

// ===================================================================

class CMsgDotaScenario_Hero::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_Hero>()._impl_._has_bits_);
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[1] |= 67108864u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hero(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_total_xp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_bkb_charges_used(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_aeon_charges_used(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_reliable_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_unreliable_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_total_earned_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_shared_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_hero_kill_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_creep_kill_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_neutral_kill_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_courier_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_bounty_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_roshan_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_building_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_other_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_income_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_ward_kill_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_ability_gold(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_denies(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_last_hits(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_last_hit_streak(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_last_hit_multikill(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_nearby_creep_death_count(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_claimed_deny_count(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_claimed_miss_count(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_miss_count(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_buyback_cooldown_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_buyback_gold_limit_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_stun_duration(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_healing(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_tower_kills(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_roshan_kills(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_observer_wards_placed(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_sentry_wards_placed(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_creeps_stacked(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_camps_stacked(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_rune_pickups(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_gold_spent_on_support(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_hero_damage(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_wards_purchased(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_wards_destroyed(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_gold_spent_on_consumables(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_gold_spent_on_items(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_gold_spent_on_buybacks(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_gold_lost_to_death(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static void set_has_kills(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static void set_has_assists(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static void set_has_deaths(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static void set_has_kill_streak(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static void set_has_respawn_seconds(HasBits* has_bits) {
    (*has_bits)[1] |= 134217728u;
  }
  static void set_has_last_buyback_time(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static void set_has_first_blood_claimed(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static void set_has_first_blood_given(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static void set_has_bounty_runes(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static void set_has_outposts_captured(HasBits* has_bits) {
    (*has_bits)[1] |= 33554432u;
  }
  static const ::CScenario_Position& position(const CMsgDotaScenario_Hero* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CScenario_Position&
CMsgDotaScenario_Hero::_Internal::position(const CMsgDotaScenario_Hero* msg) {
  return *msg->_impl_.position_;
}
CMsgDotaScenario_Hero::CMsgDotaScenario_Hero(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.Hero)
}
CMsgDotaScenario_Hero::CMsgDotaScenario_Hero(const CMsgDotaScenario_Hero& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_Hero* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enemy_kills_){from._impl_.enemy_kills_}
    , decltype(_impl_.damage_stats_){from._impl_.damage_stats_}
    , decltype(_impl_.abilities_){from._impl_.abilities_}
    , decltype(_impl_.hero_){}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.steam_id_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.total_xp_){}
    , decltype(_impl_.bkb_charges_used_){}
    , decltype(_impl_.aeon_charges_used_){}
    , decltype(_impl_.reliable_gold_){}
    , decltype(_impl_.unreliable_gold_){}
    , decltype(_impl_.total_earned_gold_){}
    , decltype(_impl_.shared_gold_){}
    , decltype(_impl_.hero_kill_gold_){}
    , decltype(_impl_.creep_kill_gold_){}
    , decltype(_impl_.neutral_kill_gold_){}
    , decltype(_impl_.courier_gold_){}
    , decltype(_impl_.bounty_gold_){}
    , decltype(_impl_.roshan_gold_){}
    , decltype(_impl_.building_gold_){}
    , decltype(_impl_.other_gold_){}
    , decltype(_impl_.income_gold_){}
    , decltype(_impl_.ward_kill_gold_){}
    , decltype(_impl_.ability_gold_){}
    , decltype(_impl_.denies_){}
    , decltype(_impl_.last_hits_){}
    , decltype(_impl_.last_hit_streak_){}
    , decltype(_impl_.last_hit_multikill_){}
    , decltype(_impl_.nearby_creep_death_count_){}
    , decltype(_impl_.claimed_deny_count_){}
    , decltype(_impl_.claimed_miss_count_){}
    , decltype(_impl_.miss_count_){}
    , decltype(_impl_.buyback_cooldown_time_){}
    , decltype(_impl_.buyback_gold_limit_time_){}
    , decltype(_impl_.stun_duration_){}
    , decltype(_impl_.healing_){}
    , decltype(_impl_.tower_kills_){}
    , decltype(_impl_.roshan_kills_){}
    , decltype(_impl_.observer_wards_placed_){}
    , decltype(_impl_.sentry_wards_placed_){}
    , decltype(_impl_.creeps_stacked_){}
    , decltype(_impl_.camps_stacked_){}
    , decltype(_impl_.rune_pickups_){}
    , decltype(_impl_.gold_spent_on_support_){}
    , decltype(_impl_.hero_damage_){}
    , decltype(_impl_.wards_purchased_){}
    , decltype(_impl_.wards_destroyed_){}
    , decltype(_impl_.gold_spent_on_consumables_){}
    , decltype(_impl_.gold_spent_on_items_){}
    , decltype(_impl_.gold_spent_on_buybacks_){}
    , decltype(_impl_.gold_lost_to_death_){}
    , decltype(_impl_.kills_){}
    , decltype(_impl_.assists_){}
    , decltype(_impl_.deaths_){}
    , decltype(_impl_.kill_streak_){}
    , decltype(_impl_.last_buyback_time_){}
    , decltype(_impl_.first_blood_claimed_){}
    , decltype(_impl_.first_blood_given_){}
    , decltype(_impl_.bounty_runes_){}
    , decltype(_impl_.outposts_captured_){}
    , decltype(_impl_.player_id_){}
    , decltype(_impl_.respawn_seconds_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hero_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hero_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hero()) {
    _this->_impl_.hero_.Set(from._internal_hero(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::CScenario_Position(*from._impl_.position_);
  }
  ::memcpy(&_impl_.steam_id_, &from._impl_.steam_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.respawn_seconds_) -
    reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.respawn_seconds_));
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.Hero)
}

inline void CMsgDotaScenario_Hero::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enemy_kills_){arena}
    , decltype(_impl_.damage_stats_){arena}
    , decltype(_impl_.abilities_){arena}
    , decltype(_impl_.hero_){}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
    , decltype(_impl_.team_id_){0}
    , decltype(_impl_.total_xp_){0}
    , decltype(_impl_.bkb_charges_used_){0}
    , decltype(_impl_.aeon_charges_used_){0}
    , decltype(_impl_.reliable_gold_){0}
    , decltype(_impl_.unreliable_gold_){0}
    , decltype(_impl_.total_earned_gold_){0}
    , decltype(_impl_.shared_gold_){0}
    , decltype(_impl_.hero_kill_gold_){0}
    , decltype(_impl_.creep_kill_gold_){0}
    , decltype(_impl_.neutral_kill_gold_){0}
    , decltype(_impl_.courier_gold_){0}
    , decltype(_impl_.bounty_gold_){0}
    , decltype(_impl_.roshan_gold_){0}
    , decltype(_impl_.building_gold_){0}
    , decltype(_impl_.other_gold_){0}
    , decltype(_impl_.income_gold_){0}
    , decltype(_impl_.ward_kill_gold_){0}
    , decltype(_impl_.ability_gold_){0}
    , decltype(_impl_.denies_){0}
    , decltype(_impl_.last_hits_){0}
    , decltype(_impl_.last_hit_streak_){0}
    , decltype(_impl_.last_hit_multikill_){0}
    , decltype(_impl_.nearby_creep_death_count_){0}
    , decltype(_impl_.claimed_deny_count_){0}
    , decltype(_impl_.claimed_miss_count_){0}
    , decltype(_impl_.miss_count_){0}
    , decltype(_impl_.buyback_cooldown_time_){0}
    , decltype(_impl_.buyback_gold_limit_time_){0}
    , decltype(_impl_.stun_duration_){0}
    , decltype(_impl_.healing_){0}
    , decltype(_impl_.tower_kills_){0}
    , decltype(_impl_.roshan_kills_){0}
    , decltype(_impl_.observer_wards_placed_){0}
    , decltype(_impl_.sentry_wards_placed_){0}
    , decltype(_impl_.creeps_stacked_){0}
    , decltype(_impl_.camps_stacked_){0}
    , decltype(_impl_.rune_pickups_){0}
    , decltype(_impl_.gold_spent_on_support_){0}
    , decltype(_impl_.hero_damage_){0}
    , decltype(_impl_.wards_purchased_){0}
    , decltype(_impl_.wards_destroyed_){0}
    , decltype(_impl_.gold_spent_on_consumables_){0}
    , decltype(_impl_.gold_spent_on_items_){0}
    , decltype(_impl_.gold_spent_on_buybacks_){0}
    , decltype(_impl_.gold_lost_to_death_){0}
    , decltype(_impl_.kills_){0}
    , decltype(_impl_.assists_){0}
    , decltype(_impl_.deaths_){0}
    , decltype(_impl_.kill_streak_){0}
    , decltype(_impl_.last_buyback_time_){0}
    , decltype(_impl_.first_blood_claimed_){false}
    , decltype(_impl_.first_blood_given_){false}
    , decltype(_impl_.bounty_runes_){0}
    , decltype(_impl_.outposts_captured_){0}
    , decltype(_impl_.player_id_){-1}
    , decltype(_impl_.respawn_seconds_){-1}
  };
  _impl_.hero_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hero_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDotaScenario_Hero::~CMsgDotaScenario_Hero() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.Hero)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_Hero::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.enemy_kills_.~RepeatedPtrField();
  _impl_.damage_stats_.~RepeatedPtrField();
  _impl_.abilities_.~RepeatedPtrField();
  _impl_.hero_.Destroy();
  if (this != internal_default_instance()) delete _impl_.position_;
}

void CMsgDotaScenario_Hero::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_Hero::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.Hero)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enemy_kills_.Clear();
  _impl_.damage_stats_.Clear();
  _impl_.abilities_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hero_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.steam_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.reliable_gold_) -
        reinterpret_cast<char*>(&_impl_.steam_id_)) + sizeof(_impl_.reliable_gold_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.unreliable_gold_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bounty_gold_) -
        reinterpret_cast<char*>(&_impl_.unreliable_gold_)) + sizeof(_impl_.bounty_gold_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.roshan_gold_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.last_hits_) -
        reinterpret_cast<char*>(&_impl_.roshan_gold_)) + sizeof(_impl_.last_hits_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.last_hit_streak_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.buyback_gold_limit_time_) -
        reinterpret_cast<char*>(&_impl_.last_hit_streak_)) + sizeof(_impl_.buyback_gold_limit_time_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.stun_duration_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.camps_stacked_) -
        reinterpret_cast<char*>(&_impl_.stun_duration_)) + sizeof(_impl_.camps_stacked_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.rune_pickups_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gold_spent_on_buybacks_) -
        reinterpret_cast<char*>(&_impl_.rune_pickups_)) + sizeof(_impl_.gold_spent_on_buybacks_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.gold_lost_to_death_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.first_blood_given_) -
        reinterpret_cast<char*>(&_impl_.gold_lost_to_death_)) + sizeof(_impl_.first_blood_given_));
  }
  if (cached_has_bits & 0x0f000000u) {
    ::memset(&_impl_.bounty_runes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.outposts_captured_) -
        reinterpret_cast<char*>(&_impl_.bounty_runes_)) + sizeof(_impl_.outposts_captured_));
    _impl_.player_id_ = -1;
    _impl_.respawn_seconds_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_Hero::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steam_id(&_impl_._has_bits_);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 player_id = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_player_id(&_impl_._has_bits_);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 team_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_team_id(&_impl_._has_bits_);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string hero = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_hero();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDotaScenario.Hero.hero");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 total_xp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_total_xp(&_impl_._has_bits_);
          _impl_.total_xp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bkb_charges_used = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_bkb_charges_used(&_impl_._has_bits_);
          _impl_.bkb_charges_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 aeon_charges_used = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_aeon_charges_used(&_impl_._has_bits_);
          _impl_.aeon_charges_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reliable_gold = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_reliable_gold(&_impl_._has_bits_);
          _impl_.reliable_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 unreliable_gold = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_unreliable_gold(&_impl_._has_bits_);
          _impl_.unreliable_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 total_earned_gold = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_total_earned_gold(&_impl_._has_bits_);
          _impl_.total_earned_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 shared_gold = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_shared_gold(&_impl_._has_bits_);
          _impl_.shared_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 hero_kill_gold = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_hero_kill_gold(&_impl_._has_bits_);
          _impl_.hero_kill_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 creep_kill_gold = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_creep_kill_gold(&_impl_._has_bits_);
          _impl_.creep_kill_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 neutral_kill_gold = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_neutral_kill_gold(&_impl_._has_bits_);
          _impl_.neutral_kill_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 courier_gold = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_courier_gold(&_impl_._has_bits_);
          _impl_.courier_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bounty_gold = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_bounty_gold(&_impl_._has_bits_);
          _impl_.bounty_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 roshan_gold = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_roshan_gold(&_impl_._has_bits_);
          _impl_.roshan_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 building_gold = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_building_gold(&_impl_._has_bits_);
          _impl_.building_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 other_gold = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_other_gold(&_impl_._has_bits_);
          _impl_.other_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 income_gold = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_income_gold(&_impl_._has_bits_);
          _impl_.income_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ward_kill_gold = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_ward_kill_gold(&_impl_._has_bits_);
          _impl_.ward_kill_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ability_gold = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_ability_gold(&_impl_._has_bits_);
          _impl_.ability_gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 denies = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_denies(&_impl_._has_bits_);
          _impl_.denies_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 last_hits = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_last_hits(&_impl_._has_bits_);
          _impl_.last_hits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 last_hit_streak = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_last_hit_streak(&_impl_._has_bits_);
          _impl_.last_hit_streak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 last_hit_multikill = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_last_hit_multikill(&_impl_._has_bits_);
          _impl_.last_hit_multikill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nearby_creep_death_count = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_nearby_creep_death_count(&_impl_._has_bits_);
          _impl_.nearby_creep_death_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 claimed_deny_count = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_claimed_deny_count(&_impl_._has_bits_);
          _impl_.claimed_deny_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 claimed_miss_count = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_claimed_miss_count(&_impl_._has_bits_);
          _impl_.claimed_miss_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 miss_count = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_miss_count(&_impl_._has_bits_);
          _impl_.miss_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float buyback_cooldown_time = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_buyback_cooldown_time(&_impl_._has_bits_);
          _impl_.buyback_cooldown_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float buyback_gold_limit_time = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_buyback_gold_limit_time(&_impl_._has_bits_);
          _impl_.buyback_gold_limit_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float stun_duration = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_stun_duration(&_impl_._has_bits_);
          _impl_.stun_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float healing = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_healing(&_impl_._has_bits_);
          _impl_.healing_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tower_kills = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_tower_kills(&_impl_._has_bits_);
          _impl_.tower_kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 roshan_kills = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_roshan_kills(&_impl_._has_bits_);
          _impl_.roshan_kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 observer_wards_placed = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_observer_wards_placed(&_impl_._has_bits_);
          _impl_.observer_wards_placed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sentry_wards_placed = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_sentry_wards_placed(&_impl_._has_bits_);
          _impl_.sentry_wards_placed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 creeps_stacked = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_creeps_stacked(&_impl_._has_bits_);
          _impl_.creeps_stacked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 camps_stacked = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_camps_stacked(&_impl_._has_bits_);
          _impl_.camps_stacked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rune_pickups = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_rune_pickups(&_impl_._has_bits_);
          _impl_.rune_pickups_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gold_spent_on_support = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_gold_spent_on_support(&_impl_._has_bits_);
          _impl_.gold_spent_on_support_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 hero_damage = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_hero_damage(&_impl_._has_bits_);
          _impl_.hero_damage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 wards_purchased = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_wards_purchased(&_impl_._has_bits_);
          _impl_.wards_purchased_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 wards_destroyed = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_wards_destroyed(&_impl_._has_bits_);
          _impl_.wards_destroyed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gold_spent_on_consumables = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_gold_spent_on_consumables(&_impl_._has_bits_);
          _impl_.gold_spent_on_consumables_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gold_spent_on_items = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_gold_spent_on_items(&_impl_._has_bits_);
          _impl_.gold_spent_on_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gold_spent_on_buybacks = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_gold_spent_on_buybacks(&_impl_._has_bits_);
          _impl_.gold_spent_on_buybacks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gold_lost_to_death = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_gold_lost_to_death(&_impl_._has_bits_);
          _impl_.gold_lost_to_death_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 kills = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_kills(&_impl_._has_bits_);
          _impl_.kills_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 assists = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_assists(&_impl_._has_bits_);
          _impl_.assists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 deaths = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_deaths(&_impl_._has_bits_);
          _impl_.deaths_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 kill_streak = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_kill_streak(&_impl_._has_bits_);
          _impl_.kill_streak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 respawn_seconds = 68 [default = -1];
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_respawn_seconds(&_impl_._has_bits_);
          _impl_.respawn_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 last_buyback_time = 69;
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_last_buyback_time(&_impl_._has_bits_);
          _impl_.last_buyback_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool first_blood_claimed = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_first_blood_claimed(&_impl_._has_bits_);
          _impl_.first_blood_claimed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool first_blood_given = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_first_blood_given(&_impl_._has_bits_);
          _impl_.first_blood_given_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bounty_runes = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_bounty_runes(&_impl_._has_bits_);
          _impl_.bounty_runes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 outposts_captured = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_outposts_captured(&_impl_._has_bits_);
          _impl_.outposts_captured_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CScenario_Position position = 75;
      case 75:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDotaScenario.HeroHeroInt enemy_kills = 150;
      case 150:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_enemy_kills(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<1202>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDotaScenario.DamageStatsByType damage_stats = 151;
      case 151:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_damage_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<1210>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDotaScenario.HeroAbility abilities = 152;
      case 152:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_abilities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<1218>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_Hero::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.Hero)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steam_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steam_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional int32 player_id = 2 [default = -1];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_player_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 team_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_team_id(), target);
  }

  // optional string hero = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hero().data(), static_cast<int>(this->_internal_hero().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDotaScenario.Hero.hero");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_hero(), target);
  }

  // optional int32 total_xp = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_total_xp(), target);
  }

  // optional int32 bkb_charges_used = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_bkb_charges_used(), target);
  }

  // optional int32 aeon_charges_used = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_aeon_charges_used(), target);
  }

  // optional int32 reliable_gold = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_reliable_gold(), target);
  }

  // optional int32 unreliable_gold = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_unreliable_gold(), target);
  }

  // optional int32 total_earned_gold = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_total_earned_gold(), target);
  }

  // optional int32 shared_gold = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_shared_gold(), target);
  }

  // optional int32 hero_kill_gold = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_hero_kill_gold(), target);
  }

  // optional int32 creep_kill_gold = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_creep_kill_gold(), target);
  }

  // optional int32 neutral_kill_gold = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_neutral_kill_gold(), target);
  }

  // optional int32 courier_gold = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_courier_gold(), target);
  }

  // optional int32 bounty_gold = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_bounty_gold(), target);
  }

  // optional int32 roshan_gold = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_roshan_gold(), target);
  }

  // optional int32 building_gold = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_building_gold(), target);
  }

  // optional int32 other_gold = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(19, this->_internal_other_gold(), target);
  }

  // optional int32 income_gold = 26;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(26, this->_internal_income_gold(), target);
  }

  // optional int32 ward_kill_gold = 27;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(27, this->_internal_ward_kill_gold(), target);
  }

  // optional int32 ability_gold = 28;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(28, this->_internal_ability_gold(), target);
  }

  // optional int32 denies = 29;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(29, this->_internal_denies(), target);
  }

  // optional int32 last_hits = 30;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(30, this->_internal_last_hits(), target);
  }

  // optional int32 last_hit_streak = 31;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(31, this->_internal_last_hit_streak(), target);
  }

  // optional int32 last_hit_multikill = 32;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(32, this->_internal_last_hit_multikill(), target);
  }

  // optional int32 nearby_creep_death_count = 33;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(33, this->_internal_nearby_creep_death_count(), target);
  }

  // optional int32 claimed_deny_count = 34;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(34, this->_internal_claimed_deny_count(), target);
  }

  // optional int32 claimed_miss_count = 35;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(35, this->_internal_claimed_miss_count(), target);
  }

  // optional int32 miss_count = 36;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(36, this->_internal_miss_count(), target);
  }

  // optional float buyback_cooldown_time = 40;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(40, this->_internal_buyback_cooldown_time(), target);
  }

  // optional float buyback_gold_limit_time = 41;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(41, this->_internal_buyback_gold_limit_time(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional float stun_duration = 44;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(44, this->_internal_stun_duration(), target);
  }

  // optional float healing = 45;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(45, this->_internal_healing(), target);
  }

  // optional int32 tower_kills = 46;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(46, this->_internal_tower_kills(), target);
  }

  // optional int32 roshan_kills = 47;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(47, this->_internal_roshan_kills(), target);
  }

  // optional int32 observer_wards_placed = 48;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(48, this->_internal_observer_wards_placed(), target);
  }

  // optional int32 sentry_wards_placed = 49;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(49, this->_internal_sentry_wards_placed(), target);
  }

  // optional int32 creeps_stacked = 50;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(50, this->_internal_creeps_stacked(), target);
  }

  // optional int32 camps_stacked = 51;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(51, this->_internal_camps_stacked(), target);
  }

  // optional int32 rune_pickups = 52;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(52, this->_internal_rune_pickups(), target);
  }

  // optional int32 gold_spent_on_support = 53;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(53, this->_internal_gold_spent_on_support(), target);
  }

  // optional int32 hero_damage = 54;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(54, this->_internal_hero_damage(), target);
  }

  // optional int32 wards_purchased = 55;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(55, this->_internal_wards_purchased(), target);
  }

  // optional int32 wards_destroyed = 56;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(56, this->_internal_wards_destroyed(), target);
  }

  // optional int32 gold_spent_on_consumables = 58;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(58, this->_internal_gold_spent_on_consumables(), target);
  }

  // optional int32 gold_spent_on_items = 59;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(59, this->_internal_gold_spent_on_items(), target);
  }

  // optional int32 gold_spent_on_buybacks = 60;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(60, this->_internal_gold_spent_on_buybacks(), target);
  }

  // optional int32 gold_lost_to_death = 61;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(61, this->_internal_gold_lost_to_death(), target);
  }

  // optional int32 kills = 62;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(62, this->_internal_kills(), target);
  }

  // optional int32 assists = 63;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(63, this->_internal_assists(), target);
  }

  // optional int32 deaths = 64;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(64, this->_internal_deaths(), target);
  }

  // optional int32 kill_streak = 65;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(65, this->_internal_kill_streak(), target);
  }

  // optional int32 respawn_seconds = 68 [default = -1];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(68, this->_internal_respawn_seconds(), target);
  }

  // optional int32 last_buyback_time = 69;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(69, this->_internal_last_buyback_time(), target);
  }

  // optional bool first_blood_claimed = 71;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(71, this->_internal_first_blood_claimed(), target);
  }

  // optional bool first_blood_given = 72;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(72, this->_internal_first_blood_given(), target);
  }

  // optional int32 bounty_runes = 73;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(73, this->_internal_bounty_runes(), target);
  }

  // optional int32 outposts_captured = 74;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(74, this->_internal_outposts_captured(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CScenario_Position position = 75;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(75, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // repeated .CMsgDotaScenario.HeroHeroInt enemy_kills = 150;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_enemy_kills_size()); i < n; i++) {
    const auto& repfield = this->_internal_enemy_kills(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(150, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDotaScenario.DamageStatsByType damage_stats = 151;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_damage_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_damage_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(151, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDotaScenario.HeroAbility abilities = 152;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_abilities_size()); i < n; i++) {
    const auto& repfield = this->_internal_abilities(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(152, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.Hero)
  return target;
}

size_t CMsgDotaScenario_Hero::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.Hero)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDotaScenario.HeroHeroInt enemy_kills = 150;
  total_size += 2UL * this->_internal_enemy_kills_size();
  for (const auto& msg : this->_impl_.enemy_kills_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDotaScenario.DamageStatsByType damage_stats = 151;
  total_size += 2UL * this->_internal_damage_stats_size();
  for (const auto& msg : this->_impl_.damage_stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDotaScenario.HeroAbility abilities = 152;
  total_size += 2UL * this->_internal_abilities_size();
  for (const auto& msg : this->_impl_.abilities_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string hero = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hero());
    }

    // optional .CScenario_Position position = 75;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional fixed64 steam_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional int32 team_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_team_id());
    }

    // optional int32 total_xp = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_total_xp());
    }

    // optional int32 bkb_charges_used = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bkb_charges_used());
    }

    // optional int32 aeon_charges_used = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_aeon_charges_used());
    }

    // optional int32 reliable_gold = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reliable_gold());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 unreliable_gold = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_unreliable_gold());
    }

    // optional int32 total_earned_gold = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_total_earned_gold());
    }

    // optional int32 shared_gold = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_shared_gold());
    }

    // optional int32 hero_kill_gold = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hero_kill_gold());
    }

    // optional int32 creep_kill_gold = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_creep_kill_gold());
    }

    // optional int32 neutral_kill_gold = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_neutral_kill_gold());
    }

    // optional int32 courier_gold = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_courier_gold());
    }

    // optional int32 bounty_gold = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_bounty_gold());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int32 roshan_gold = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_roshan_gold());
    }

    // optional int32 building_gold = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_building_gold());
    }

    // optional int32 other_gold = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_other_gold());
    }

    // optional int32 income_gold = 26;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_income_gold());
    }

    // optional int32 ward_kill_gold = 27;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_ward_kill_gold());
    }

    // optional int32 ability_gold = 28;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_ability_gold());
    }

    // optional int32 denies = 29;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_denies());
    }

    // optional int32 last_hits = 30;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_last_hits());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional int32 last_hit_streak = 31;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_last_hit_streak());
    }

    // optional int32 last_hit_multikill = 32;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_last_hit_multikill());
    }

    // optional int32 nearby_creep_death_count = 33;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_nearby_creep_death_count());
    }

    // optional int32 claimed_deny_count = 34;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_claimed_deny_count());
    }

    // optional int32 claimed_miss_count = 35;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_claimed_miss_count());
    }

    // optional int32 miss_count = 36;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_miss_count());
    }

    // optional float buyback_cooldown_time = 40;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 4;
    }

    // optional float buyback_gold_limit_time = 41;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 4;
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional float stun_duration = 44;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 4;
    }

    // optional float healing = 45;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 4;
    }

    // optional int32 tower_kills = 46;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_tower_kills());
    }

    // optional int32 roshan_kills = 47;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_roshan_kills());
    }

    // optional int32 observer_wards_placed = 48;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_observer_wards_placed());
    }

    // optional int32 sentry_wards_placed = 49;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_sentry_wards_placed());
    }

    // optional int32 creeps_stacked = 50;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_creeps_stacked());
    }

    // optional int32 camps_stacked = 51;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_camps_stacked());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 rune_pickups = 52;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_rune_pickups());
    }

    // optional int32 gold_spent_on_support = 53;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_gold_spent_on_support());
    }

    // optional int32 hero_damage = 54;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_hero_damage());
    }

    // optional int32 wards_purchased = 55;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_wards_purchased());
    }

    // optional int32 wards_destroyed = 56;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_wards_destroyed());
    }

    // optional int32 gold_spent_on_consumables = 58;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_gold_spent_on_consumables());
    }

    // optional int32 gold_spent_on_items = 59;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_gold_spent_on_items());
    }

    // optional int32 gold_spent_on_buybacks = 60;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_gold_spent_on_buybacks());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int32 gold_lost_to_death = 61;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_gold_lost_to_death());
    }

    // optional int32 kills = 62;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_kills());
    }

    // optional int32 assists = 63;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_assists());
    }

    // optional int32 deaths = 64;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_deaths());
    }

    // optional int32 kill_streak = 65;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_kill_streak());
    }

    // optional int32 last_buyback_time = 69;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_last_buyback_time());
    }

    // optional bool first_blood_claimed = 71;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool first_blood_given = 72;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x0f000000u) {
    // optional int32 bounty_runes = 73;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_bounty_runes());
    }

    // optional int32 outposts_captured = 74;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_outposts_captured());
    }

    // optional int32 player_id = 2 [default = -1];
    if (cached_has_bits & 0x04000000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
    }

    // optional int32 respawn_seconds = 68 [default = -1];
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_respawn_seconds());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_Hero::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_Hero::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_Hero::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_Hero::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_Hero*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_Hero&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.Hero)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.enemy_kills_.MergeFrom(from._impl_.enemy_kills_);
  _this->_impl_.damage_stats_.MergeFrom(from._impl_.damage_stats_);
  _this->_impl_.abilities_.MergeFrom(from._impl_.abilities_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hero(from._internal_hero());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_position()->::CScenario_Position::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.steam_id_ = from._impl_.steam_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.total_xp_ = from._impl_.total_xp_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.bkb_charges_used_ = from._impl_.bkb_charges_used_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.aeon_charges_used_ = from._impl_.aeon_charges_used_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.reliable_gold_ = from._impl_.reliable_gold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.unreliable_gold_ = from._impl_.unreliable_gold_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.total_earned_gold_ = from._impl_.total_earned_gold_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.shared_gold_ = from._impl_.shared_gold_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.hero_kill_gold_ = from._impl_.hero_kill_gold_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.creep_kill_gold_ = from._impl_.creep_kill_gold_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.neutral_kill_gold_ = from._impl_.neutral_kill_gold_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.courier_gold_ = from._impl_.courier_gold_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.bounty_gold_ = from._impl_.bounty_gold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.roshan_gold_ = from._impl_.roshan_gold_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.building_gold_ = from._impl_.building_gold_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.other_gold_ = from._impl_.other_gold_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.income_gold_ = from._impl_.income_gold_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.ward_kill_gold_ = from._impl_.ward_kill_gold_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.ability_gold_ = from._impl_.ability_gold_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.denies_ = from._impl_.denies_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.last_hits_ = from._impl_.last_hits_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.last_hit_streak_ = from._impl_.last_hit_streak_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.last_hit_multikill_ = from._impl_.last_hit_multikill_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.nearby_creep_death_count_ = from._impl_.nearby_creep_death_count_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.claimed_deny_count_ = from._impl_.claimed_deny_count_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.claimed_miss_count_ = from._impl_.claimed_miss_count_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.miss_count_ = from._impl_.miss_count_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.buyback_cooldown_time_ = from._impl_.buyback_cooldown_time_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.buyback_gold_limit_time_ = from._impl_.buyback_gold_limit_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.stun_duration_ = from._impl_.stun_duration_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.healing_ = from._impl_.healing_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tower_kills_ = from._impl_.tower_kills_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.roshan_kills_ = from._impl_.roshan_kills_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.observer_wards_placed_ = from._impl_.observer_wards_placed_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.sentry_wards_placed_ = from._impl_.sentry_wards_placed_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.creeps_stacked_ = from._impl_.creeps_stacked_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.camps_stacked_ = from._impl_.camps_stacked_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.rune_pickups_ = from._impl_.rune_pickups_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.gold_spent_on_support_ = from._impl_.gold_spent_on_support_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.hero_damage_ = from._impl_.hero_damage_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.wards_purchased_ = from._impl_.wards_purchased_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.wards_destroyed_ = from._impl_.wards_destroyed_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.gold_spent_on_consumables_ = from._impl_.gold_spent_on_consumables_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.gold_spent_on_items_ = from._impl_.gold_spent_on_items_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.gold_spent_on_buybacks_ = from._impl_.gold_spent_on_buybacks_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.gold_lost_to_death_ = from._impl_.gold_lost_to_death_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.kills_ = from._impl_.kills_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.assists_ = from._impl_.assists_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.deaths_ = from._impl_.deaths_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.kill_streak_ = from._impl_.kill_streak_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.last_buyback_time_ = from._impl_.last_buyback_time_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.first_blood_claimed_ = from._impl_.first_blood_claimed_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.first_blood_given_ = from._impl_.first_blood_given_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0f000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.bounty_runes_ = from._impl_.bounty_runes_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.outposts_captured_ = from._impl_.outposts_captured_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.player_id_ = from._impl_.player_id_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.respawn_seconds_ = from._impl_.respawn_seconds_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_Hero::CopyFrom(const CMsgDotaScenario_Hero& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.Hero)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_Hero::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_Hero::InternalSwap(CMsgDotaScenario_Hero* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  _impl_.enemy_kills_.InternalSwap(&other->_impl_.enemy_kills_);
  _impl_.damage_stats_.InternalSwap(&other->_impl_.damage_stats_);
  _impl_.abilities_.InternalSwap(&other->_impl_.abilities_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hero_, lhs_arena,
      &other->_impl_.hero_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Hero, _impl_.outposts_captured_)
      + sizeof(CMsgDotaScenario_Hero::_impl_.outposts_captured_)
      - PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Hero, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
  swap(_impl_.player_id_, other->_impl_.player_id_);
  swap(_impl_.respawn_seconds_, other->_impl_.respawn_seconds_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_Hero::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[14]);
}

// ===================================================================

class CMsgDotaScenario_Stock::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_Stock>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team_number(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_current_stock(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cooldown(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bonus_stock(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgDotaScenario_Stock::CMsgDotaScenario_Stock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.Stock)
}
CMsgDotaScenario_Stock::CMsgDotaScenario_Stock(const CMsgDotaScenario_Stock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_Stock* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.current_stock_){}
    , decltype(_impl_.cooldown_){}
    , decltype(_impl_.bonus_stock_){}
    , decltype(_impl_.team_number_){}
    , decltype(_impl_.player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.current_stock_, &from._impl_.current_stock_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_id_) -
    reinterpret_cast<char*>(&_impl_.current_stock_)) + sizeof(_impl_.player_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.Stock)
}

inline void CMsgDotaScenario_Stock::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.current_stock_){0}
    , decltype(_impl_.cooldown_){0}
    , decltype(_impl_.bonus_stock_){0}
    , decltype(_impl_.team_number_){-1}
    , decltype(_impl_.player_id_){-1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDotaScenario_Stock::~CMsgDotaScenario_Stock() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.Stock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_Stock::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgDotaScenario_Stock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_Stock::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.Stock)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.current_stock_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bonus_stock_) -
        reinterpret_cast<char*>(&_impl_.current_stock_)) + sizeof(_impl_.bonus_stock_));
    _impl_.team_number_ = -1;
    _impl_.player_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_Stock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDotaScenario.Stock.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 team_number = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_team_number(&has_bits);
          _impl_.team_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 player_id = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 current_stock = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_current_stock(&has_bits);
          _impl_.current_stock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float cooldown = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_cooldown(&has_bits);
          _impl_.cooldown_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bonus_stock = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_bonus_stock(&has_bits);
          _impl_.bonus_stock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_Stock::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.Stock)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDotaScenario.Stock.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 team_number = 2 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_team_number(), target);
  }

  // optional int32 player_id = 3 [default = -1];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_player_id(), target);
  }

  // optional int32 current_stock = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_current_stock(), target);
  }

  // optional float cooldown = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_cooldown(), target);
  }

  // optional int32 bonus_stock = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_bonus_stock(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.Stock)
  return target;
}

size_t CMsgDotaScenario_Stock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.Stock)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 current_stock = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_current_stock());
    }

    // optional float cooldown = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional int32 bonus_stock = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bonus_stock());
    }

    // optional int32 team_number = 2 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_team_number());
    }

    // optional int32 player_id = 3 [default = -1];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_Stock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_Stock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_Stock::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_Stock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_Stock*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_Stock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.Stock)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.current_stock_ = from._impl_.current_stock_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cooldown_ = from._impl_.cooldown_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bonus_stock_ = from._impl_.bonus_stock_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.team_number_ = from._impl_.team_number_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.player_id_ = from._impl_.player_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_Stock::CopyFrom(const CMsgDotaScenario_Stock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.Stock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_Stock::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_Stock::InternalSwap(CMsgDotaScenario_Stock* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Stock, _impl_.bonus_stock_)
      + sizeof(CMsgDotaScenario_Stock::_impl_.bonus_stock_)
      - PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Stock, _impl_.current_stock_)>(
          reinterpret_cast<char*>(&_impl_.current_stock_),
          reinterpret_cast<char*>(&other->_impl_.current_stock_));
  swap(_impl_.team_number_, other->_impl_.team_number_);
  swap(_impl_.player_id_, other->_impl_.player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_Stock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[15]);
}

// ===================================================================

class CMsgDotaScenario_Building::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_Building>()._impl_._has_bits_);
  static void set_has_entity_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_entity_class(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_destroyed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_health_frac(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgDotaScenario_Building::CMsgDotaScenario_Building(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.Building)
}
CMsgDotaScenario_Building::CMsgDotaScenario_Building(const CMsgDotaScenario_Building& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_Building* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_name_){}
    , decltype(_impl_.entity_class_){}
    , decltype(_impl_.team_id_){}
    , decltype(_impl_.is_destroyed_){}
    , decltype(_impl_.health_frac_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.entity_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_entity_name()) {
    _this->_impl_.entity_name_.Set(from._internal_entity_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.entity_class_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_class_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_entity_class()) {
    _this->_impl_.entity_class_.Set(from._internal_entity_class(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.team_id_, &from._impl_.team_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.health_frac_) -
    reinterpret_cast<char*>(&_impl_.team_id_)) + sizeof(_impl_.health_frac_));
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.Building)
}

inline void CMsgDotaScenario_Building::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_name_){}
    , decltype(_impl_.entity_class_){}
    , decltype(_impl_.team_id_){0}
    , decltype(_impl_.is_destroyed_){false}
    , decltype(_impl_.health_frac_){1}
  };
  _impl_.entity_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.entity_class_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_class_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDotaScenario_Building::~CMsgDotaScenario_Building() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.Building)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_Building::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entity_name_.Destroy();
  _impl_.entity_class_.Destroy();
}

void CMsgDotaScenario_Building::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_Building::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.Building)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.entity_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.entity_class_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.team_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_destroyed_) -
        reinterpret_cast<char*>(&_impl_.team_id_)) + sizeof(_impl_.is_destroyed_));
    _impl_.health_frac_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_Building::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string entity_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_entity_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDotaScenario.Building.entity_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string entity_class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_entity_class();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDotaScenario.Building.entity_class");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 team_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_team_id(&has_bits);
          _impl_.team_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_destroyed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_destroyed(&has_bits);
          _impl_.is_destroyed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float health_frac = 5 [default = 1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_health_frac(&has_bits);
          _impl_.health_frac_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_Building::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.Building)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string entity_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_entity_name().data(), static_cast<int>(this->_internal_entity_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDotaScenario.Building.entity_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_entity_name(), target);
  }

  // optional string entity_class = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_entity_class().data(), static_cast<int>(this->_internal_entity_class().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDotaScenario.Building.entity_class");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_entity_class(), target);
  }

  // optional int32 team_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_team_id(), target);
  }

  // optional bool is_destroyed = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_destroyed(), target);
  }

  // optional float health_frac = 5 [default = 1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_health_frac(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.Building)
  return target;
}

size_t CMsgDotaScenario_Building::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.Building)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string entity_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_entity_name());
    }

    // optional string entity_class = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_entity_class());
    }

    // optional int32 team_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_team_id());
    }

    // optional bool is_destroyed = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional float health_frac = 5 [default = 1];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_Building::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_Building::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_Building::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_Building::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_Building*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_Building&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.Building)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_entity_name(from._internal_entity_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_entity_class(from._internal_entity_class());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.team_id_ = from._impl_.team_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_destroyed_ = from._impl_.is_destroyed_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.health_frac_ = from._impl_.health_frac_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_Building::CopyFrom(const CMsgDotaScenario_Building& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.Building)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_Building::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_Building::InternalSwap(CMsgDotaScenario_Building* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.entity_name_, lhs_arena,
      &other->_impl_.entity_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.entity_class_, lhs_arena,
      &other->_impl_.entity_class_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Building, _impl_.is_destroyed_)
      + sizeof(CMsgDotaScenario_Building::_impl_.is_destroyed_)
      - PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Building, _impl_.team_id_)>(
          reinterpret_cast<char*>(&_impl_.team_id_),
          reinterpret_cast<char*>(&other->_impl_.team_id_));
  swap(_impl_.health_frac_, other->_impl_.health_frac_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_Building::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[16]);
}

// ===================================================================

class CMsgDotaScenario_Entity::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_Entity>()._impl_._has_bits_);
  static const ::CScenarioEnt_Courier& courier(const CMsgDotaScenario_Entity* msg);
  static void set_has_courier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CScenarioEnt_NPC& npc(const CMsgDotaScenario_Entity* msg);
  static void set_has_npc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CScenarioEnt_SpiritBear& spirit_bear(const CMsgDotaScenario_Entity* msg);
  static void set_has_spirit_bear(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CScenarioEnt_DroppedItem& dropped_item(const CMsgDotaScenario_Entity* msg);
  static void set_has_dropped_item(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CScenarioEnt_Courier&
CMsgDotaScenario_Entity::_Internal::courier(const CMsgDotaScenario_Entity* msg) {
  return *msg->_impl_.courier_;
}
const ::CScenarioEnt_NPC&
CMsgDotaScenario_Entity::_Internal::npc(const CMsgDotaScenario_Entity* msg) {
  return *msg->_impl_.npc_;
}
const ::CScenarioEnt_SpiritBear&
CMsgDotaScenario_Entity::_Internal::spirit_bear(const CMsgDotaScenario_Entity* msg) {
  return *msg->_impl_.spirit_bear_;
}
const ::CScenarioEnt_DroppedItem&
CMsgDotaScenario_Entity::_Internal::dropped_item(const CMsgDotaScenario_Entity* msg) {
  return *msg->_impl_.dropped_item_;
}
CMsgDotaScenario_Entity::CMsgDotaScenario_Entity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.Entity)
}
CMsgDotaScenario_Entity::CMsgDotaScenario_Entity(const CMsgDotaScenario_Entity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_Entity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.courier_){nullptr}
    , decltype(_impl_.npc_){nullptr}
    , decltype(_impl_.spirit_bear_){nullptr}
    , decltype(_impl_.dropped_item_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_courier()) {
    _this->_impl_.courier_ = new ::CScenarioEnt_Courier(*from._impl_.courier_);
  }
  if (from._internal_has_npc()) {
    _this->_impl_.npc_ = new ::CScenarioEnt_NPC(*from._impl_.npc_);
  }
  if (from._internal_has_spirit_bear()) {
    _this->_impl_.spirit_bear_ = new ::CScenarioEnt_SpiritBear(*from._impl_.spirit_bear_);
  }
  if (from._internal_has_dropped_item()) {
    _this->_impl_.dropped_item_ = new ::CScenarioEnt_DroppedItem(*from._impl_.dropped_item_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.Entity)
}

inline void CMsgDotaScenario_Entity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.courier_){nullptr}
    , decltype(_impl_.npc_){nullptr}
    , decltype(_impl_.spirit_bear_){nullptr}
    , decltype(_impl_.dropped_item_){nullptr}
  };
}

CMsgDotaScenario_Entity::~CMsgDotaScenario_Entity() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.Entity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_Entity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.courier_;
  if (this != internal_default_instance()) delete _impl_.npc_;
  if (this != internal_default_instance()) delete _impl_.spirit_bear_;
  if (this != internal_default_instance()) delete _impl_.dropped_item_;
}

void CMsgDotaScenario_Entity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_Entity::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.Entity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.courier_ != nullptr);
      _impl_.courier_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.npc_ != nullptr);
      _impl_.npc_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.spirit_bear_ != nullptr);
      _impl_.spirit_bear_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.dropped_item_ != nullptr);
      _impl_.dropped_item_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_Entity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CScenarioEnt_Courier courier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_courier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CScenarioEnt_NPC npc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_npc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CScenarioEnt_SpiritBear spirit_bear = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_spirit_bear(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CScenarioEnt_DroppedItem dropped_item = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_dropped_item(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_Entity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.Entity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CScenarioEnt_Courier courier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::courier(this),
        _Internal::courier(this).GetCachedSize(), target, stream);
  }

  // optional .CScenarioEnt_NPC npc = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::npc(this),
        _Internal::npc(this).GetCachedSize(), target, stream);
  }

  // optional .CScenarioEnt_SpiritBear spirit_bear = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::spirit_bear(this),
        _Internal::spirit_bear(this).GetCachedSize(), target, stream);
  }

  // optional .CScenarioEnt_DroppedItem dropped_item = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::dropped_item(this),
        _Internal::dropped_item(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.Entity)
  return target;
}

size_t CMsgDotaScenario_Entity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.Entity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CScenarioEnt_Courier courier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.courier_);
    }

    // optional .CScenarioEnt_NPC npc = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.npc_);
    }

    // optional .CScenarioEnt_SpiritBear spirit_bear = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spirit_bear_);
    }

    // optional .CScenarioEnt_DroppedItem dropped_item = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dropped_item_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_Entity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_Entity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_Entity::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_Entity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_Entity*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_Entity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.Entity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_courier()->::CScenarioEnt_Courier::MergeFrom(
          from._internal_courier());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_npc()->::CScenarioEnt_NPC::MergeFrom(
          from._internal_npc());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_spirit_bear()->::CScenarioEnt_SpiritBear::MergeFrom(
          from._internal_spirit_bear());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_dropped_item()->::CScenarioEnt_DroppedItem::MergeFrom(
          from._internal_dropped_item());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_Entity::CopyFrom(const CMsgDotaScenario_Entity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.Entity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_Entity::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_Entity::InternalSwap(CMsgDotaScenario_Entity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Entity, _impl_.dropped_item_)
      + sizeof(CMsgDotaScenario_Entity::_impl_.dropped_item_)
      - PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Entity, _impl_.courier_)>(
          reinterpret_cast<char*>(&_impl_.courier_),
          reinterpret_cast<char*>(&other->_impl_.courier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_Entity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[17]);
}

// ===================================================================

class CMsgDotaScenario_Item::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_Item>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgDotaScenario_EntityRef& location(const CMsgDotaScenario_Item* msg);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_item_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_neutral_drop_team(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_charges(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_secondary_charges(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_lifetime(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_stored_rune_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::CMsgDotaScenario_EntityRef&
CMsgDotaScenario_Item::_Internal::location(const CMsgDotaScenario_Item* msg) {
  return *msg->_impl_.location_;
}
CMsgDotaScenario_Item::CMsgDotaScenario_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.Item)
}
CMsgDotaScenario_Item::CMsgDotaScenario_Item(const CMsgDotaScenario_Item& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_Item* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.item_slot_){}
    , decltype(_impl_.neutral_drop_team_){}
    , decltype(_impl_.charges_){}
    , decltype(_impl_.secondary_charges_){}
    , decltype(_impl_.stored_rune_type_){}
    , decltype(_impl_.owner_id_){}
    , decltype(_impl_.lifetime_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_location()) {
    _this->_impl_.location_ = new ::CMsgDotaScenario_EntityRef(*from._impl_.location_);
  }
  ::memcpy(&_impl_.item_slot_, &from._impl_.item_slot_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lifetime_) -
    reinterpret_cast<char*>(&_impl_.item_slot_)) + sizeof(_impl_.lifetime_));
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.Item)
}

inline void CMsgDotaScenario_Item::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.item_slot_){0}
    , decltype(_impl_.neutral_drop_team_){0}
    , decltype(_impl_.charges_){0}
    , decltype(_impl_.secondary_charges_){0}
    , decltype(_impl_.stored_rune_type_){-1}
    , decltype(_impl_.owner_id_){-1}
    , decltype(_impl_.lifetime_){-1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDotaScenario_Item::~CMsgDotaScenario_Item() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.Item)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_Item::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.location_;
}

void CMsgDotaScenario_Item::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_Item::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.Item)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.location_ != nullptr);
      _impl_.location_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.item_slot_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.secondary_charges_) -
        reinterpret_cast<char*>(&_impl_.item_slot_)) + sizeof(_impl_.secondary_charges_));
    _impl_.stored_rune_type_ = -1;
    _impl_.owner_id_ = -1;
  }
  _impl_.lifetime_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_Item::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDotaScenario.Item.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDotaScenario.EntityRef location = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 owner_id = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_owner_id(&has_bits);
          _impl_.owner_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_slot = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_item_slot(&has_bits);
          _impl_.item_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 neutral_drop_team = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_neutral_drop_team(&has_bits);
          _impl_.neutral_drop_team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 charges = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_charges(&has_bits);
          _impl_.charges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 secondary_charges = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_secondary_charges(&has_bits);
          _impl_.secondary_charges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float lifetime = 8 [default = -1];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_lifetime(&has_bits);
          _impl_.lifetime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 stored_rune_type = 9 [default = -1];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_stored_rune_type(&has_bits);
          _impl_.stored_rune_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_Item::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.Item)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDotaScenario.Item.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .CMsgDotaScenario.EntityRef location = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::location(this),
        _Internal::location(this).GetCachedSize(), target, stream);
  }

  // optional int32 owner_id = 3 [default = -1];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_owner_id(), target);
  }

  // optional int32 item_slot = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_item_slot(), target);
  }

  // optional int32 neutral_drop_team = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_neutral_drop_team(), target);
  }

  // optional int32 charges = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_charges(), target);
  }

  // optional int32 secondary_charges = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_secondary_charges(), target);
  }

  // optional float lifetime = 8 [default = -1];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_lifetime(), target);
  }

  // optional int32 stored_rune_type = 9 [default = -1];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_stored_rune_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.Item)
  return target;
}

size_t CMsgDotaScenario_Item::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.Item)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .CMsgDotaScenario.EntityRef location = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.location_);
    }

    // optional int32 item_slot = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_slot());
    }

    // optional int32 neutral_drop_team = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_neutral_drop_team());
    }

    // optional int32 charges = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_charges());
    }

    // optional int32 secondary_charges = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_secondary_charges());
    }

    // optional int32 stored_rune_type = 9 [default = -1];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_stored_rune_type());
    }

    // optional int32 owner_id = 3 [default = -1];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_owner_id());
    }

  }
  // optional float lifetime = 8 [default = -1];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_Item::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_Item::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_Item::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_Item::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_Item*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_Item&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.Item)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_location()->::CMsgDotaScenario_EntityRef::MergeFrom(
          from._internal_location());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_slot_ = from._impl_.item_slot_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.neutral_drop_team_ = from._impl_.neutral_drop_team_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.charges_ = from._impl_.charges_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.secondary_charges_ = from._impl_.secondary_charges_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.stored_rune_type_ = from._impl_.stored_rune_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.owner_id_ = from._impl_.owner_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_lifetime(from._internal_lifetime());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_Item::CopyFrom(const CMsgDotaScenario_Item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.Item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_Item::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_Item::InternalSwap(CMsgDotaScenario_Item* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Item, _impl_.secondary_charges_)
      + sizeof(CMsgDotaScenario_Item::_impl_.secondary_charges_)
      - PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Item, _impl_.location_)>(
          reinterpret_cast<char*>(&_impl_.location_),
          reinterpret_cast<char*>(&other->_impl_.location_));
  swap(_impl_.stored_rune_type_, other->_impl_.stored_rune_type_);
  swap(_impl_.owner_id_, other->_impl_.owner_id_);
  swap(_impl_.lifetime_, other->_impl_.lifetime_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_Item::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[18]);
}

// ===================================================================

class CMsgDotaScenario_Modifier::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario_Modifier>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgDotaScenario_EntityRef& parent(const CMsgDotaScenario_Modifier* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgDotaScenario_EntityRef& caster(const CMsgDotaScenario_Modifier* msg);
  static void set_has_caster(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgDotaScenario_EntityRef& ability(const CMsgDotaScenario_Modifier* msg);
  static void set_has_ability(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_lifetime_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_stack_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_create_even_if_existing(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_create_without_caster(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_create_without_ability(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_moonshard_consumed_bonus(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_moonshard_consumed_bonus_night_vision(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_wardtruesight_range(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_ultimate_scepter_consumed_alchemist_bonus_all_stats(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_ultimate_scepter_consumed_alchemist_bonus_health(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_ultimate_scepter_consumed_alchemist_bonus_mana(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

const ::CMsgDotaScenario_EntityRef&
CMsgDotaScenario_Modifier::_Internal::parent(const CMsgDotaScenario_Modifier* msg) {
  return *msg->_impl_.parent_;
}
const ::CMsgDotaScenario_EntityRef&
CMsgDotaScenario_Modifier::_Internal::caster(const CMsgDotaScenario_Modifier* msg) {
  return *msg->_impl_.caster_;
}
const ::CMsgDotaScenario_EntityRef&
CMsgDotaScenario_Modifier::_Internal::ability(const CMsgDotaScenario_Modifier* msg) {
  return *msg->_impl_.ability_;
}
CMsgDotaScenario_Modifier::CMsgDotaScenario_Modifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario.Modifier)
}
CMsgDotaScenario_Modifier::CMsgDotaScenario_Modifier(const CMsgDotaScenario_Modifier& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario_Modifier* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.caster_){nullptr}
    , decltype(_impl_.ability_){nullptr}
    , decltype(_impl_.lifetime_remaining_){}
    , decltype(_impl_.stack_count_){}
    , decltype(_impl_.create_even_if_existing_){}
    , decltype(_impl_.create_without_caster_){}
    , decltype(_impl_.create_without_ability_){}
    , decltype(_impl_.moonshard_consumed_bonus_){}
    , decltype(_impl_.moonshard_consumed_bonus_night_vision_){}
    , decltype(_impl_.wardtruesight_range_){}
    , decltype(_impl_.ultimate_scepter_consumed_alchemist_bonus_all_stats_){}
    , decltype(_impl_.ultimate_scepter_consumed_alchemist_bonus_health_){}
    , decltype(_impl_.ultimate_scepter_consumed_alchemist_bonus_mana_){}
    , decltype(_impl_.duration_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::CMsgDotaScenario_EntityRef(*from._impl_.parent_);
  }
  if (from._internal_has_caster()) {
    _this->_impl_.caster_ = new ::CMsgDotaScenario_EntityRef(*from._impl_.caster_);
  }
  if (from._internal_has_ability()) {
    _this->_impl_.ability_ = new ::CMsgDotaScenario_EntityRef(*from._impl_.ability_);
  }
  ::memcpy(&_impl_.lifetime_remaining_, &from._impl_.lifetime_remaining_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.duration_) -
    reinterpret_cast<char*>(&_impl_.lifetime_remaining_)) + sizeof(_impl_.duration_));
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario.Modifier)
}

inline void CMsgDotaScenario_Modifier::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.caster_){nullptr}
    , decltype(_impl_.ability_){nullptr}
    , decltype(_impl_.lifetime_remaining_){0}
    , decltype(_impl_.stack_count_){0}
    , decltype(_impl_.create_even_if_existing_){false}
    , decltype(_impl_.create_without_caster_){false}
    , decltype(_impl_.create_without_ability_){false}
    , decltype(_impl_.moonshard_consumed_bonus_){0}
    , decltype(_impl_.moonshard_consumed_bonus_night_vision_){0}
    , decltype(_impl_.wardtruesight_range_){0}
    , decltype(_impl_.ultimate_scepter_consumed_alchemist_bonus_all_stats_){0}
    , decltype(_impl_.ultimate_scepter_consumed_alchemist_bonus_health_){0}
    , decltype(_impl_.ultimate_scepter_consumed_alchemist_bonus_mana_){0}
    , decltype(_impl_.duration_){-1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgDotaScenario_Modifier::~CMsgDotaScenario_Modifier() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario.Modifier)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario_Modifier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (this != internal_default_instance()) delete _impl_.caster_;
  if (this != internal_default_instance()) delete _impl_.ability_;
}

void CMsgDotaScenario_Modifier::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario_Modifier::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario.Modifier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.parent_ != nullptr);
      _impl_.parent_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.caster_ != nullptr);
      _impl_.caster_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.ability_ != nullptr);
      _impl_.ability_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.lifetime_remaining_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.create_without_caster_) -
        reinterpret_cast<char*>(&_impl_.lifetime_remaining_)) + sizeof(_impl_.create_without_caster_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.create_without_ability_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ultimate_scepter_consumed_alchemist_bonus_mana_) -
        reinterpret_cast<char*>(&_impl_.create_without_ability_)) + sizeof(_impl_.ultimate_scepter_consumed_alchemist_bonus_mana_));
    _impl_.duration_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario_Modifier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgDotaScenario.Modifier.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDotaScenario.EntityRef parent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDotaScenario.EntityRef caster = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_caster(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDotaScenario.EntityRef ability = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ability(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float duration = 5 [default = -1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_duration(&has_bits);
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float lifetime_remaining = 6 [default = 0];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_lifetime_remaining(&has_bits);
          _impl_.lifetime_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 stack_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_stack_count(&has_bits);
          _impl_.stack_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool create_even_if_existing = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_create_even_if_existing(&has_bits);
          _impl_.create_even_if_existing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool create_without_caster = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_create_without_caster(&has_bits);
          _impl_.create_without_caster_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool create_without_ability = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_create_without_ability(&has_bits);
          _impl_.create_without_ability_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 moonshard_consumed_bonus = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_moonshard_consumed_bonus(&has_bits);
          _impl_.moonshard_consumed_bonus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 moonshard_consumed_bonus_night_vision = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_moonshard_consumed_bonus_night_vision(&has_bits);
          _impl_.moonshard_consumed_bonus_night_vision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 wardtruesight_range = 110;
      case 110:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_wardtruesight_range(&has_bits);
          _impl_.wardtruesight_range_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ultimate_scepter_consumed_alchemist_bonus_all_stats = 120;
      case 120:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_ultimate_scepter_consumed_alchemist_bonus_all_stats(&has_bits);
          _impl_.ultimate_scepter_consumed_alchemist_bonus_all_stats_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ultimate_scepter_consumed_alchemist_bonus_health = 121;
      case 121:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_ultimate_scepter_consumed_alchemist_bonus_health(&has_bits);
          _impl_.ultimate_scepter_consumed_alchemist_bonus_health_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ultimate_scepter_consumed_alchemist_bonus_mana = 122;
      case 122:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_ultimate_scepter_consumed_alchemist_bonus_mana(&has_bits);
          _impl_.ultimate_scepter_consumed_alchemist_bonus_mana_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario_Modifier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario.Modifier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgDotaScenario.Modifier.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .CMsgDotaScenario.EntityRef parent = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgDotaScenario.EntityRef caster = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::caster(this),
        _Internal::caster(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgDotaScenario.EntityRef ability = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::ability(this),
        _Internal::ability(this).GetCachedSize(), target, stream);
  }

  // optional float duration = 5 [default = -1];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_duration(), target);
  }

  // optional float lifetime_remaining = 6 [default = 0];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_lifetime_remaining(), target);
  }

  // optional int32 stack_count = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_stack_count(), target);
  }

  // optional bool create_even_if_existing = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_create_even_if_existing(), target);
  }

  // optional bool create_without_caster = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_create_without_caster(), target);
  }

  // optional bool create_without_ability = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_create_without_ability(), target);
  }

  // optional int32 moonshard_consumed_bonus = 100;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(100, this->_internal_moonshard_consumed_bonus(), target);
  }

  // optional int32 moonshard_consumed_bonus_night_vision = 101;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(101, this->_internal_moonshard_consumed_bonus_night_vision(), target);
  }

  // optional int32 wardtruesight_range = 110;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(110, this->_internal_wardtruesight_range(), target);
  }

  // optional int32 ultimate_scepter_consumed_alchemist_bonus_all_stats = 120;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(120, this->_internal_ultimate_scepter_consumed_alchemist_bonus_all_stats(), target);
  }

  // optional int32 ultimate_scepter_consumed_alchemist_bonus_health = 121;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(121, this->_internal_ultimate_scepter_consumed_alchemist_bonus_health(), target);
  }

  // optional int32 ultimate_scepter_consumed_alchemist_bonus_mana = 122;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(122, this->_internal_ultimate_scepter_consumed_alchemist_bonus_mana(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario.Modifier)
  return target;
}

size_t CMsgDotaScenario_Modifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario.Modifier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .CMsgDotaScenario.EntityRef parent = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.parent_);
    }

    // optional .CMsgDotaScenario.EntityRef caster = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.caster_);
    }

    // optional .CMsgDotaScenario.EntityRef ability = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ability_);
    }

    // optional float lifetime_remaining = 6 [default = 0];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional int32 stack_count = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_stack_count());
    }

    // optional bool create_even_if_existing = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool create_without_caster = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool create_without_ability = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional int32 moonshard_consumed_bonus = 100;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_moonshard_consumed_bonus());
    }

    // optional int32 moonshard_consumed_bonus_night_vision = 101;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_moonshard_consumed_bonus_night_vision());
    }

    // optional int32 wardtruesight_range = 110;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_wardtruesight_range());
    }

    // optional int32 ultimate_scepter_consumed_alchemist_bonus_all_stats = 120;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_ultimate_scepter_consumed_alchemist_bonus_all_stats());
    }

    // optional int32 ultimate_scepter_consumed_alchemist_bonus_health = 121;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_ultimate_scepter_consumed_alchemist_bonus_health());
    }

    // optional int32 ultimate_scepter_consumed_alchemist_bonus_mana = 122;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_ultimate_scepter_consumed_alchemist_bonus_mana());
    }

    // optional float duration = 5 [default = -1];
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario_Modifier::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario_Modifier::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario_Modifier::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario_Modifier::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario_Modifier*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario_Modifier&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario.Modifier)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_parent()->::CMsgDotaScenario_EntityRef::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_caster()->::CMsgDotaScenario_EntityRef::MergeFrom(
          from._internal_caster());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_ability()->::CMsgDotaScenario_EntityRef::MergeFrom(
          from._internal_ability());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.lifetime_remaining_ = from._impl_.lifetime_remaining_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.stack_count_ = from._impl_.stack_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.create_even_if_existing_ = from._impl_.create_even_if_existing_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.create_without_caster_ = from._impl_.create_without_caster_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.create_without_ability_ = from._impl_.create_without_ability_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.moonshard_consumed_bonus_ = from._impl_.moonshard_consumed_bonus_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.moonshard_consumed_bonus_night_vision_ = from._impl_.moonshard_consumed_bonus_night_vision_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.wardtruesight_range_ = from._impl_.wardtruesight_range_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.ultimate_scepter_consumed_alchemist_bonus_all_stats_ = from._impl_.ultimate_scepter_consumed_alchemist_bonus_all_stats_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.ultimate_scepter_consumed_alchemist_bonus_health_ = from._impl_.ultimate_scepter_consumed_alchemist_bonus_health_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.ultimate_scepter_consumed_alchemist_bonus_mana_ = from._impl_.ultimate_scepter_consumed_alchemist_bonus_mana_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.duration_ = from._impl_.duration_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario_Modifier::CopyFrom(const CMsgDotaScenario_Modifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario.Modifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario_Modifier::IsInitialized() const {
  return true;
}

void CMsgDotaScenario_Modifier::InternalSwap(CMsgDotaScenario_Modifier* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Modifier, _impl_.ultimate_scepter_consumed_alchemist_bonus_mana_)
      + sizeof(CMsgDotaScenario_Modifier::_impl_.ultimate_scepter_consumed_alchemist_bonus_mana_)
      - PROTOBUF_FIELD_OFFSET(CMsgDotaScenario_Modifier, _impl_.parent_)>(
          reinterpret_cast<char*>(&_impl_.parent_),
          reinterpret_cast<char*>(&other->_impl_.parent_));
  swap(_impl_.duration_, other->_impl_.duration_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario_Modifier::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[19]);
}

// ===================================================================

class CMsgDotaScenario::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDotaScenario>()._impl_._has_bits_);
  static void set_has_lobby_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgDotaScenario_Game& game(const CMsgDotaScenario* msg);
  static void set_has_game(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgDotaScenario_Game&
CMsgDotaScenario::_Internal::game(const CMsgDotaScenario* msg) {
  return *msg->_impl_.game_;
}
CMsgDotaScenario::CMsgDotaScenario(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDotaScenario)
}
CMsgDotaScenario::CMsgDotaScenario(const CMsgDotaScenario& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDotaScenario* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teams_){from._impl_.teams_}
    , decltype(_impl_.heroes_){from._impl_.heroes_}
    , decltype(_impl_.stock_){from._impl_.stock_}
    , decltype(_impl_.buildings_){from._impl_.buildings_}
    , decltype(_impl_.entities_){from._impl_.entities_}
    , decltype(_impl_.items_){from._impl_.items_}
    , decltype(_impl_.modifiers_){from._impl_.modifiers_}
    , decltype(_impl_.game_){nullptr}
    , decltype(_impl_.lobby_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_game()) {
    _this->_impl_.game_ = new ::CMsgDotaScenario_Game(*from._impl_.game_);
  }
  _this->_impl_.lobby_id_ = from._impl_.lobby_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgDotaScenario)
}

inline void CMsgDotaScenario::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.teams_){arena}
    , decltype(_impl_.heroes_){arena}
    , decltype(_impl_.stock_){arena}
    , decltype(_impl_.buildings_){arena}
    , decltype(_impl_.entities_){arena}
    , decltype(_impl_.items_){arena}
    , decltype(_impl_.modifiers_){arena}
    , decltype(_impl_.game_){nullptr}
    , decltype(_impl_.lobby_id_){uint64_t{0u}}
  };
}

CMsgDotaScenario::~CMsgDotaScenario() {
  // @@protoc_insertion_point(destructor:CMsgDotaScenario)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDotaScenario::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.teams_.~RepeatedPtrField();
  _impl_.heroes_.~RepeatedPtrField();
  _impl_.stock_.~RepeatedPtrField();
  _impl_.buildings_.~RepeatedPtrField();
  _impl_.entities_.~RepeatedPtrField();
  _impl_.items_.~RepeatedPtrField();
  _impl_.modifiers_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.game_;
}

void CMsgDotaScenario::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDotaScenario::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDotaScenario)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.teams_.Clear();
  _impl_.heroes_.Clear();
  _impl_.stock_.Clear();
  _impl_.buildings_.Clear();
  _impl_.entities_.Clear();
  _impl_.items_.Clear();
  _impl_.modifiers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.game_ != nullptr);
    _impl_.game_->Clear();
  }
  _impl_.lobby_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDotaScenario::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 lobby_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_lobby_id(&has_bits);
          _impl_.lobby_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDotaScenario.Game game = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_game(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDotaScenario.Team teams = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_teams(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDotaScenario.Hero heroes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_heroes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDotaScenario.Stock stock = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stock(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDotaScenario.Building buildings = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buildings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDotaScenario.Entity entities = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDotaScenario.Item items = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgDotaScenario.Modifier modifiers = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_modifiers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDotaScenario::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDotaScenario)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 lobby_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_lobby_id(), target);
  }

  // optional .CMsgDotaScenario.Game game = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::game(this),
        _Internal::game(this).GetCachedSize(), target, stream);
  }

  // repeated .CMsgDotaScenario.Team teams = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_teams_size()); i < n; i++) {
    const auto& repfield = this->_internal_teams(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDotaScenario.Hero heroes = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_heroes_size()); i < n; i++) {
    const auto& repfield = this->_internal_heroes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDotaScenario.Stock stock = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stock_size()); i < n; i++) {
    const auto& repfield = this->_internal_stock(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDotaScenario.Building buildings = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buildings_size()); i < n; i++) {
    const auto& repfield = this->_internal_buildings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDotaScenario.Entity entities = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entities_size()); i < n; i++) {
    const auto& repfield = this->_internal_entities(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDotaScenario.Item items = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgDotaScenario.Modifier modifiers = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_modifiers_size()); i < n; i++) {
    const auto& repfield = this->_internal_modifiers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDotaScenario)
  return target;
}

size_t CMsgDotaScenario::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDotaScenario)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgDotaScenario.Team teams = 3;
  total_size += 1UL * this->_internal_teams_size();
  for (const auto& msg : this->_impl_.teams_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDotaScenario.Hero heroes = 4;
  total_size += 1UL * this->_internal_heroes_size();
  for (const auto& msg : this->_impl_.heroes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDotaScenario.Stock stock = 5;
  total_size += 1UL * this->_internal_stock_size();
  for (const auto& msg : this->_impl_.stock_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDotaScenario.Building buildings = 6;
  total_size += 1UL * this->_internal_buildings_size();
  for (const auto& msg : this->_impl_.buildings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDotaScenario.Entity entities = 7;
  total_size += 1UL * this->_internal_entities_size();
  for (const auto& msg : this->_impl_.entities_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDotaScenario.Item items = 8;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgDotaScenario.Modifier modifiers = 9;
  total_size += 1UL * this->_internal_modifiers_size();
  for (const auto& msg : this->_impl_.modifiers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgDotaScenario.Game game = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.game_);
    }

    // optional uint64 lobby_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_lobby_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDotaScenario::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDotaScenario::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDotaScenario::GetClassData() const { return &_class_data_; }


void CMsgDotaScenario::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDotaScenario*>(&to_msg);
  auto& from = static_cast<const CMsgDotaScenario&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDotaScenario)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.teams_.MergeFrom(from._impl_.teams_);
  _this->_impl_.heroes_.MergeFrom(from._impl_.heroes_);
  _this->_impl_.stock_.MergeFrom(from._impl_.stock_);
  _this->_impl_.buildings_.MergeFrom(from._impl_.buildings_);
  _this->_impl_.entities_.MergeFrom(from._impl_.entities_);
  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_impl_.modifiers_.MergeFrom(from._impl_.modifiers_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_game()->::CMsgDotaScenario_Game::MergeFrom(
          from._internal_game());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.lobby_id_ = from._impl_.lobby_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDotaScenario::CopyFrom(const CMsgDotaScenario& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDotaScenario)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDotaScenario::IsInitialized() const {
  return true;
}

void CMsgDotaScenario::InternalSwap(CMsgDotaScenario* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.teams_.InternalSwap(&other->_impl_.teams_);
  _impl_.heroes_.InternalSwap(&other->_impl_.heroes_);
  _impl_.stock_.InternalSwap(&other->_impl_.stock_);
  _impl_.buildings_.InternalSwap(&other->_impl_.buildings_);
  _impl_.entities_.InternalSwap(&other->_impl_.entities_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  _impl_.modifiers_.InternalSwap(&other->_impl_.modifiers_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDotaScenario, _impl_.lobby_id_)
      + sizeof(CMsgDotaScenario::_impl_.lobby_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDotaScenario, _impl_.game_)>(
          reinterpret_cast<char*>(&_impl_.game_),
          reinterpret_cast<char*>(&other->_impl_.game_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDotaScenario::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fscenariomessages_2eproto_getter, &descriptor_table_dota_5fscenariomessages_2eproto_once,
      file_level_metadata_dota_5fscenariomessages_2eproto[20]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CScenario_Position*
Arena::CreateMaybeMessage< ::CScenario_Position >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CScenario_Position >(arena);
}
template<> PROTOBUF_NOINLINE ::CScenarioGame_RoshanSpawner*
Arena::CreateMaybeMessage< ::CScenarioGame_RoshanSpawner >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CScenarioGame_RoshanSpawner >(arena);
}
template<> PROTOBUF_NOINLINE ::CScenarioEnt_Courier*
Arena::CreateMaybeMessage< ::CScenarioEnt_Courier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CScenarioEnt_Courier >(arena);
}
template<> PROTOBUF_NOINLINE ::CScenarioEnt_NPC*
Arena::CreateMaybeMessage< ::CScenarioEnt_NPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CScenarioEnt_NPC >(arena);
}
template<> PROTOBUF_NOINLINE ::CScenarioEnt_SpiritBear*
Arena::CreateMaybeMessage< ::CScenarioEnt_SpiritBear >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CScenarioEnt_SpiritBear >(arena);
}
template<> PROTOBUF_NOINLINE ::CScenarioEnt_DroppedItem*
Arena::CreateMaybeMessage< ::CScenarioEnt_DroppedItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CScenarioEnt_DroppedItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_EntityRef*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_EntityRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_EntityRef >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_Game*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_Game >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_Game >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_TeamNeutralItem*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_TeamNeutralItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_TeamNeutralItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_Team*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_Team >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_Team >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_HeroHeroInt*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_HeroHeroInt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_HeroHeroInt >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_HeroHeroFloat*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_HeroHeroFloat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_HeroHeroFloat >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_DamageStatsByType*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_DamageStatsByType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_DamageStatsByType >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_HeroAbility*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_HeroAbility >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_HeroAbility >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_Hero*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_Hero >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_Hero >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_Stock*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_Stock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_Stock >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_Building*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_Building >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_Building >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_Entity*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_Entity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_Entity >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_Item*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_Item >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_Item >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario_Modifier*
Arena::CreateMaybeMessage< ::CMsgDotaScenario_Modifier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario_Modifier >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDotaScenario*
Arena::CreateMaybeMessage< ::CMsgDotaScenario >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDotaScenario >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
