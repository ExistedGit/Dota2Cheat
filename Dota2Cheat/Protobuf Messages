// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_clientmessages.proto

#include "dota_clientmessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CDOTAClientMsg_MapPing::CDOTAClientMsg_MapPing(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.location_ping_)*/nullptr} {}
struct CDOTAClientMsg_MapPingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_MapPingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_MapPingDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_MapPing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_MapPingDefaultTypeInternal _CDOTAClientMsg_MapPing_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ItemAlert::CDOTAClientMsg_ItemAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_alert_)*/nullptr} {}
struct CDOTAClientMsg_ItemAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ItemAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ItemAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ItemAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ItemAlertDefaultTypeInternal _CDOTAClientMsg_ItemAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_EnemyItemAlert::CDOTAClientMsg_EnemyItemAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.secondary_charges_)*/-1
  , /*decltype(_impl_.item_entindex_)*/-1
  , /*decltype(_impl_.rune_type_)*/-1
  , /*decltype(_impl_.item_level_)*/-1
  , /*decltype(_impl_.primary_charges_)*/-1} {}
struct CDOTAClientMsg_EnemyItemAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_EnemyItemAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_EnemyItemAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_EnemyItemAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_EnemyItemAlertDefaultTypeInternal _CDOTAClientMsg_EnemyItemAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ModifierAlert::CDOTAClientMsg_ModifierAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.buff_internal_index_)*/0
  , /*decltype(_impl_.target_entindex_)*/-1} {}
struct CDOTAClientMsg_ModifierAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ModifierAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ModifierAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ModifierAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ModifierAlertDefaultTypeInternal _CDOTAClientMsg_ModifierAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ClickedBuff::CDOTAClientMsg_ClickedBuff(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.buff_internal_index_)*/0
  , /*decltype(_impl_.target_entindex_)*/-1} {}
struct CDOTAClientMsg_ClickedBuffDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ClickedBuffDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ClickedBuffDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ClickedBuff _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ClickedBuffDefaultTypeInternal _CDOTAClientMsg_ClickedBuff_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_HPManaAlert::CDOTAClientMsg_HPManaAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.show_raw_values_)*/false
  , /*decltype(_impl_.target_entindex_)*/-1} {}
struct CDOTAClientMsg_HPManaAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_HPManaAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_HPManaAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_HPManaAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_HPManaAlertDefaultTypeInternal _CDOTAClientMsg_HPManaAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_NeutralCampAlert::CDOTAClientMsg_NeutralCampAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stack_request_)*/false
  , /*decltype(_impl_.spawner_entindex_)*/-1
  , /*decltype(_impl_.unit_entindex_)*/-1} {}
struct CDOTAClientMsg_NeutralCampAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_NeutralCampAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_NeutralCampAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_NeutralCampAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_NeutralCampAlertDefaultTypeInternal _CDOTAClientMsg_NeutralCampAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_GlyphAlert::CDOTAClientMsg_GlyphAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.negative_)*/false} {}
struct CDOTAClientMsg_GlyphAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_GlyphAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_GlyphAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_GlyphAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_GlyphAlertDefaultTypeInternal _CDOTAClientMsg_GlyphAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_RadarAlert::CDOTAClientMsg_RadarAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.negative_)*/false} {}
struct CDOTAClientMsg_RadarAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_RadarAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_RadarAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_RadarAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_RadarAlertDefaultTypeInternal _CDOTAClientMsg_RadarAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_MapLine::CDOTAClientMsg_MapLine(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mapline_)*/nullptr} {}
struct CDOTAClientMsg_MapLineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_MapLineDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_MapLineDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_MapLine _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_MapLineDefaultTypeInternal _CDOTAClientMsg_MapLine_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_AspectRatio::CDOTAClientMsg_AspectRatio(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ratio_)*/0} {}
struct CDOTAClientMsg_AspectRatioDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_AspectRatioDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_AspectRatioDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_AspectRatio _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_AspectRatioDefaultTypeInternal _CDOTAClientMsg_AspectRatio_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_UnitsAutoAttackMode::CDOTAClientMsg_UnitsAutoAttackMode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.unit_type_)*/0
  , /*decltype(_impl_.mode_)*/-1} {}
struct CDOTAClientMsg_UnitsAutoAttackModeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_UnitsAutoAttackModeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_UnitsAutoAttackModeDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_UnitsAutoAttackMode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_UnitsAutoAttackModeDefaultTypeInternal _CDOTAClientMsg_UnitsAutoAttackMode_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_UnitsAutoAttackAfterSpell::CDOTAClientMsg_UnitsAutoAttackAfterSpell(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct CDOTAClientMsg_UnitsAutoAttackAfterSpellDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_UnitsAutoAttackAfterSpellDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_UnitsAutoAttackAfterSpellDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_UnitsAutoAttackAfterSpell _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_UnitsAutoAttackAfterSpellDefaultTypeInternal _CDOTAClientMsg_UnitsAutoAttackAfterSpell_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_TeleportRequiresHalt::CDOTAClientMsg_TeleportRequiresHalt(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct CDOTAClientMsg_TeleportRequiresHaltDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_TeleportRequiresHaltDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_TeleportRequiresHaltDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_TeleportRequiresHalt _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_TeleportRequiresHaltDefaultTypeInternal _CDOTAClientMsg_TeleportRequiresHalt_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ChannelRequiresHalt::CDOTAClientMsg_ChannelRequiresHalt(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct CDOTAClientMsg_ChannelRequiresHaltDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ChannelRequiresHaltDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ChannelRequiresHaltDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ChannelRequiresHalt _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ChannelRequiresHaltDefaultTypeInternal _CDOTAClientMsg_ChannelRequiresHalt_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_SearchString::CDOTAClientMsg_SearchString(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.search_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CDOTAClientMsg_SearchStringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_SearchStringDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_SearchStringDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_SearchString _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_SearchStringDefaultTypeInternal _CDOTAClientMsg_SearchString_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_Pause::CDOTAClientMsg_Pause(
    ::_pbi::ConstantInitialized) {}
struct CDOTAClientMsg_PauseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_PauseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_PauseDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_Pause _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_PauseDefaultTypeInternal _CDOTAClientMsg_Pause_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ShopViewMode::CDOTAClientMsg_ShopViewMode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mode_)*/0u} {}
struct CDOTAClientMsg_ShopViewModeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ShopViewModeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ShopViewModeDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ShopViewMode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ShopViewModeDefaultTypeInternal _CDOTAClientMsg_ShopViewMode_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_SetUnitShareFlag::CDOTAClientMsg_SetUnitShareFlag(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.flag_)*/0u
  , /*decltype(_impl_.state_)*/false
  , /*decltype(_impl_.player_id_)*/-1} {}
struct CDOTAClientMsg_SetUnitShareFlagDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_SetUnitShareFlagDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_SetUnitShareFlagDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_SetUnitShareFlag _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_SetUnitShareFlagDefaultTypeInternal _CDOTAClientMsg_SetUnitShareFlag_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_SwapRequest::CDOTAClientMsg_SwapRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/-1} {}
struct CDOTAClientMsg_SwapRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_SwapRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_SwapRequestDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_SwapRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_SwapRequestDefaultTypeInternal _CDOTAClientMsg_SwapRequest_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_SwapAccept::CDOTAClientMsg_SwapAccept(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/-1} {}
struct CDOTAClientMsg_SwapAcceptDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_SwapAcceptDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_SwapAcceptDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_SwapAccept _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_SwapAcceptDefaultTypeInternal _CDOTAClientMsg_SwapAccept_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_WorldLine::CDOTAClientMsg_WorldLine(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.worldline_)*/nullptr} {}
struct CDOTAClientMsg_WorldLineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_WorldLineDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_WorldLineDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_WorldLine _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_WorldLineDefaultTypeInternal _CDOTAClientMsg_WorldLine_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_RequestGraphUpdate::CDOTAClientMsg_RequestGraphUpdate(
    ::_pbi::ConstantInitialized) {}
struct CDOTAClientMsg_RequestGraphUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_RequestGraphUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_RequestGraphUpdateDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_RequestGraphUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_RequestGraphUpdateDefaultTypeInternal _CDOTAClientMsg_RequestGraphUpdate_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ChatWheel::CDOTAClientMsg_ChatWheel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.param_hero_id_)*/0u
  , /*decltype(_impl_.emoticon_id_)*/0u
  , /*decltype(_impl_.chat_message_id_)*/4294967295u} {}
struct CDOTAClientMsg_ChatWheelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ChatWheelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ChatWheelDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ChatWheel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ChatWheelDefaultTypeInternal _CDOTAClientMsg_ChatWheel_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_SendStatPopup::CDOTAClientMsg_SendStatPopup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.statpopup_)*/nullptr} {}
struct CDOTAClientMsg_SendStatPopupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_SendStatPopupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_SendStatPopupDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_SendStatPopup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_SendStatPopupDefaultTypeInternal _CDOTAClientMsg_SendStatPopup_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_DismissAllStatPopups::CDOTAClientMsg_DismissAllStatPopups(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dismissallmsg_)*/nullptr} {}
struct CDOTAClientMsg_DismissAllStatPopupsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_DismissAllStatPopupsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_DismissAllStatPopupsDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_DismissAllStatPopups _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_DismissAllStatPopupsDefaultTypeInternal _CDOTAClientMsg_DismissAllStatPopups_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_BeginLastHitChallenge::CDOTAClientMsg_BeginLastHitChallenge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chosen_lane_)*/0u
  , /*decltype(_impl_.helper_enabled_)*/false} {}
struct CDOTAClientMsg_BeginLastHitChallengeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_BeginLastHitChallengeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_BeginLastHitChallengeDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_BeginLastHitChallenge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_BeginLastHitChallengeDefaultTypeInternal _CDOTAClientMsg_BeginLastHitChallenge_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_UpdateQuickBuyItem::CDOTAClientMsg_UpdateQuickBuyItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.purchasable_)*/false
  , /*decltype(_impl_.item_ability_id_)*/-1} {}
struct CDOTAClientMsg_UpdateQuickBuyItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_UpdateQuickBuyItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_UpdateQuickBuyItemDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_UpdateQuickBuyItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_UpdateQuickBuyItemDefaultTypeInternal _CDOTAClientMsg_UpdateQuickBuyItem_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_UpdateQuickBuy::CDOTAClientMsg_UpdateQuickBuy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CDOTAClientMsg_UpdateQuickBuyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_UpdateQuickBuyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_UpdateQuickBuyDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_UpdateQuickBuy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_UpdateQuickBuyDefaultTypeInternal _CDOTAClientMsg_UpdateQuickBuy_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_RecordVote::CDOTAClientMsg_RecordVote(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.choice_index_)*/0} {}
struct CDOTAClientMsg_RecordVoteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_RecordVoteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_RecordVoteDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_RecordVote _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_RecordVoteDefaultTypeInternal _CDOTAClientMsg_RecordVote_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_WillPurchaseAlert::CDOTAClientMsg_WillPurchaseAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gold_remaining_)*/0u
  , /*decltype(_impl_.item_ability_id_)*/-1
  , /*decltype(_impl_.suggestion_player_id_)*/-1} {}
struct CDOTAClientMsg_WillPurchaseAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_WillPurchaseAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_WillPurchaseAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_WillPurchaseAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_WillPurchaseAlertDefaultTypeInternal _CDOTAClientMsg_WillPurchaseAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_BuyBackStateAlert::CDOTAClientMsg_BuyBackStateAlert(
    ::_pbi::ConstantInitialized) {}
struct CDOTAClientMsg_BuyBackStateAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_BuyBackStateAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_BuyBackStateAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_BuyBackStateAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_BuyBackStateAlertDefaultTypeInternal _CDOTAClientMsg_BuyBackStateAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_QuickBuyAlert::CDOTAClientMsg_QuickBuyAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gold_cost_)*/0
  , /*decltype(_impl_.item_cooldown_seconds_)*/0
  , /*decltype(_impl_.show_buyback_)*/false
  , /*decltype(_impl_.item_ability_id_)*/-1} {}
struct CDOTAClientMsg_QuickBuyAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_QuickBuyAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_QuickBuyAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_QuickBuyAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_QuickBuyAlertDefaultTypeInternal _CDOTAClientMsg_QuickBuyAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_PlayerShowCase::CDOTAClientMsg_PlayerShowCase(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.showcase_)*/false} {}
struct CDOTAClientMsg_PlayerShowCaseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_PlayerShowCaseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_PlayerShowCaseDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_PlayerShowCase _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_PlayerShowCaseDefaultTypeInternal _CDOTAClientMsg_PlayerShowCase_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_CameraZoomAmount::CDOTAClientMsg_CameraZoomAmount(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.zoom_amount_)*/0} {}
struct CDOTAClientMsg_CameraZoomAmountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_CameraZoomAmountDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_CameraZoomAmountDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_CameraZoomAmount _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_CameraZoomAmountDefaultTypeInternal _CDOTAClientMsg_CameraZoomAmount_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_BroadcasterUsingCameraman::CDOTAClientMsg_BroadcasterUsingCameraman(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cameraman_)*/false} {}
struct CDOTAClientMsg_BroadcasterUsingCameramanDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_BroadcasterUsingCameramanDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_BroadcasterUsingCameramanDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_BroadcasterUsingCameraman _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_BroadcasterUsingCameramanDefaultTypeInternal _CDOTAClientMsg_BroadcasterUsingCameraman_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct CDOTAClientMsg_BroadcasterUsingAssistedCameraOperatorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_BroadcasterUsingAssistedCameraOperatorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_BroadcasterUsingAssistedCameraOperatorDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_BroadcasterUsingAssistedCameraOperatorDefaultTypeInternal _CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_FillEmptySlotsWithBots::CDOTAClientMsg_FillEmptySlotsWithBots(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fillwithbots_)*/false} {}
struct CDOTAClientMsg_FillEmptySlotsWithBotsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_FillEmptySlotsWithBotsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_FillEmptySlotsWithBotsDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_FillEmptySlotsWithBots _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_FillEmptySlotsWithBotsDefaultTypeInternal _CDOTAClientMsg_FillEmptySlotsWithBots_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_HeroStatueLike::CDOTAClientMsg_HeroStatueLike(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.owner_player_id_)*/-1} {}
struct CDOTAClientMsg_HeroStatueLikeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_HeroStatueLikeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_HeroStatueLikeDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_HeroStatueLike _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_HeroStatueLikeDefaultTypeInternal _CDOTAClientMsg_HeroStatueLike_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_EventCNY2015Cmd::CDOTAClientMsg_EventCNY2015Cmd(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CDOTAClientMsg_EventCNY2015CmdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_EventCNY2015CmdDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_EventCNY2015CmdDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_EventCNY2015Cmd _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_EventCNY2015CmdDefaultTypeInternal _CDOTAClientMsg_EventCNY2015Cmd_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_DemoHero::CDOTAClientMsg_DemoHero(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_defs_)*/{}
  , /*decltype(_impl_.item_ids_)*/{}
  , /*decltype(_impl_.hero_id_)*/0
  , /*decltype(_impl_.hero_id_to_spawn_)*/0
  , /*decltype(_impl_.keep_existing_demohero_)*/false
  , /*decltype(_impl_.style_index_)*/255u} {}
struct CDOTAClientMsg_DemoHeroDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_DemoHeroDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_DemoHeroDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_DemoHero _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_DemoHeroDefaultTypeInternal _CDOTAClientMsg_DemoHero_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ChallengeSelect::CDOTAClientMsg_ChallengeSelect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.event_id_)*/0u
  , /*decltype(_impl_.slot_id_)*/0u
  , /*decltype(_impl_.sequence_id_)*/0u} {}
struct CDOTAClientMsg_ChallengeSelectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ChallengeSelectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ChallengeSelectDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ChallengeSelect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ChallengeSelectDefaultTypeInternal _CDOTAClientMsg_ChallengeSelect_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ChallengeReroll::CDOTAClientMsg_ChallengeReroll(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.event_id_)*/0
  , /*decltype(_impl_.slot_id_)*/0u
  , /*decltype(_impl_.sequence_id_)*/0u
  , /*decltype(_impl_.hero_id_)*/0u} {}
struct CDOTAClientMsg_ChallengeRerollDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ChallengeRerollDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ChallengeRerollDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ChallengeReroll _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ChallengeRerollDefaultTypeInternal _CDOTAClientMsg_ChallengeReroll_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_CoinWager::CDOTAClientMsg_CoinWager(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.wager_amount_)*/0u} {}
struct CDOTAClientMsg_CoinWagerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_CoinWagerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_CoinWagerDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_CoinWager _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_CoinWagerDefaultTypeInternal _CDOTAClientMsg_CoinWager_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_CoinWagerToken::CDOTAClientMsg_CoinWagerToken(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.wager_token_item_id_)*/uint64_t{0u}} {}
struct CDOTAClientMsg_CoinWagerTokenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_CoinWagerTokenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_CoinWagerTokenDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_CoinWagerToken _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_CoinWagerTokenDefaultTypeInternal _CDOTAClientMsg_CoinWagerToken_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_RankWager::CDOTAClientMsg_RankWager(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.announce_wager_)*/false} {}
struct CDOTAClientMsg_RankWagerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_RankWagerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_RankWagerDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_RankWager _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_RankWagerDefaultTypeInternal _CDOTAClientMsg_RankWager_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_PlayerBounty::CDOTAClientMsg_PlayerBounty(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/-1} {}
struct CDOTAClientMsg_PlayerBountyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_PlayerBountyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_PlayerBountyDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_PlayerBounty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_PlayerBountyDefaultTypeInternal _CDOTAClientMsg_PlayerBounty_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_EventPointsTip::CDOTAClientMsg_EventPointsTip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.recipient_player_id_)*/-1} {}
struct CDOTAClientMsg_EventPointsTipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_EventPointsTipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_EventPointsTipDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_EventPointsTip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_EventPointsTipDefaultTypeInternal _CDOTAClientMsg_EventPointsTip_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ExecuteOrders::CDOTAClientMsg_ExecuteOrders(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.orders_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CDOTAClientMsg_ExecuteOrdersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ExecuteOrdersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ExecuteOrdersDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ExecuteOrders _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ExecuteOrdersDefaultTypeInternal _CDOTAClientMsg_ExecuteOrders_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_XPAlert::CDOTAClientMsg_XPAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.damage_taken_)*/0u
  , /*decltype(_impl_.target_entindex_)*/-1} {}
struct CDOTAClientMsg_XPAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_XPAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_XPAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_XPAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_XPAlertDefaultTypeInternal _CDOTAClientMsg_XPAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_TalentTreeAlert::CDOTAClientMsg_TalentTreeAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.slot_)*/0
  , /*decltype(_impl_.learned_)*/false
  , /*decltype(_impl_.target_entindex_)*/-1
  , /*decltype(_impl_.ability_id_)*/-1} {}
struct CDOTAClientMsg_TalentTreeAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_TalentTreeAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_TalentTreeAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_TalentTreeAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_TalentTreeAlertDefaultTypeInternal _CDOTAClientMsg_TalentTreeAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_KillcamDamageTaken::CDOTAClientMsg_KillcamDamageTaken(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hero_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.damage_color_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.damage_taken_)*/0u
  , /*decltype(_impl_.item_type_)*/0u
  , /*decltype(_impl_.target_entindex_)*/-1
  , /*decltype(_impl_.item_ability_id_)*/-1} {}
struct CDOTAClientMsg_KillcamDamageTakenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_KillcamDamageTakenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_KillcamDamageTakenDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_KillcamDamageTaken _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_KillcamDamageTakenDefaultTypeInternal _CDOTAClientMsg_KillcamDamageTaken_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_KillMyHero::CDOTAClientMsg_KillMyHero(
    ::_pbi::ConstantInitialized) {}
struct CDOTAClientMsg_KillMyHeroDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_KillMyHeroDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_KillMyHeroDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_KillMyHero _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_KillMyHeroDefaultTypeInternal _CDOTAClientMsg_KillMyHero_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_QuestStatus::CDOTAClientMsg_QuestStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.quest_id_)*/0u
  , /*decltype(_impl_.challenge_id_)*/0u
  , /*decltype(_impl_.progress_)*/0u
  , /*decltype(_impl_.goal_)*/0u
  , /*decltype(_impl_.query_)*/0u
  , /*decltype(_impl_.fail_gametime_)*/0
  , /*decltype(_impl_.item_ability_id_)*/-1} {}
struct CDOTAClientMsg_QuestStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_QuestStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_QuestStatusDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_QuestStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_QuestStatusDefaultTypeInternal _CDOTAClientMsg_QuestStatus_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ToggleAutoattack::CDOTAClientMsg_ToggleAutoattack(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mode_)*/0
  , /*decltype(_impl_.show_message_)*/false} {}
struct CDOTAClientMsg_ToggleAutoattackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ToggleAutoattackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ToggleAutoattackDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ToggleAutoattack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ToggleAutoattackDefaultTypeInternal _CDOTAClientMsg_ToggleAutoattack_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_SpecialAbility::CDOTAClientMsg_SpecialAbility(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ability_index_)*/0u
  , /*decltype(_impl_.target_entindex_)*/-1} {}
struct CDOTAClientMsg_SpecialAbilityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_SpecialAbilityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_SpecialAbilityDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_SpecialAbility _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_SpecialAbilityDefaultTypeInternal _CDOTAClientMsg_SpecialAbility_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_SetEnemyStartingPosition::CDOTAClientMsg_SetEnemyStartingPosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enemy_starting_position_)*/0u
  , /*decltype(_impl_.enemy_player_id_)*/-1} {}
struct CDOTAClientMsg_SetEnemyStartingPositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_SetEnemyStartingPositionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_SetEnemyStartingPositionDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_SetEnemyStartingPosition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_SetEnemyStartingPositionDefaultTypeInternal _CDOTAClientMsg_SetEnemyStartingPosition_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_SetDesiredWardPlacement::CDOTAClientMsg_SetDesiredWardPlacement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ward_index_)*/0u
  , /*decltype(_impl_.ward_x_)*/0
  , /*decltype(_impl_.ward_y_)*/0} {}
struct CDOTAClientMsg_SetDesiredWardPlacementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_SetDesiredWardPlacementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_SetDesiredWardPlacementDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_SetDesiredWardPlacement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_SetDesiredWardPlacementDefaultTypeInternal _CDOTAClientMsg_SetDesiredWardPlacement_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_RollDice::CDOTAClientMsg_RollDice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.channel_type_)*/0u
  , /*decltype(_impl_.roll_min_)*/0u
  , /*decltype(_impl_.roll_max_)*/0u} {}
struct CDOTAClientMsg_RollDiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_RollDiceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_RollDiceDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_RollDice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_RollDiceDefaultTypeInternal _CDOTAClientMsg_RollDice_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_FlipCoin::CDOTAClientMsg_FlipCoin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.channel_type_)*/0u} {}
struct CDOTAClientMsg_FlipCoinDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_FlipCoinDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_FlipCoinDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_FlipCoin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_FlipCoinDefaultTypeInternal _CDOTAClientMsg_FlipCoin_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_RequestItemSuggestions::CDOTAClientMsg_RequestItemSuggestions(
    ::_pbi::ConstantInitialized) {}
struct CDOTAClientMsg_RequestItemSuggestionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_RequestItemSuggestionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_RequestItemSuggestionsDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_RequestItemSuggestions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_RequestItemSuggestionsDefaultTypeInternal _CDOTAClientMsg_RequestItemSuggestions_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_MakeTeamCaptain::CDOTAClientMsg_MakeTeamCaptain(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/-1} {}
struct CDOTAClientMsg_MakeTeamCaptainDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_MakeTeamCaptainDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_MakeTeamCaptainDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_MakeTeamCaptain _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_MakeTeamCaptainDefaultTypeInternal _CDOTAClientMsg_MakeTeamCaptain_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_HelpTipSystemStateChanged::CDOTAClientMsg_HelpTipSystemStateChanged(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tip_displayed_)*/false} {}
struct CDOTAClientMsg_HelpTipSystemStateChangedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_HelpTipSystemStateChangedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_HelpTipSystemStateChangedDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_HelpTipSystemStateChanged _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_HelpTipSystemStateChangedDefaultTypeInternal _CDOTAClientMsg_HelpTipSystemStateChanged_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_RequestBulkCombatLog::CDOTAClientMsg_RequestBulkCombatLog(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.game_time_)*/0
  , /*decltype(_impl_.duration_)*/0
  , /*decltype(_impl_.recent_player_death_)*/false
  , /*decltype(_impl_.player_id_)*/-1} {}
struct CDOTAClientMsg_RequestBulkCombatLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_RequestBulkCombatLogDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_RequestBulkCombatLogDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_RequestBulkCombatLog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_RequestBulkCombatLogDefaultTypeInternal _CDOTAClientMsg_RequestBulkCombatLog_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_AbilityDraftRequestAbility::CDOTAClientMsg_AbilityDraftRequestAbility(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ctrl_is_down_)*/false
  , /*decltype(_impl_.requested_ability_id_)*/-1} {}
struct CDOTAClientMsg_AbilityDraftRequestAbilityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_AbilityDraftRequestAbilityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_AbilityDraftRequestAbilityDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_AbilityDraftRequestAbility _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_AbilityDraftRequestAbilityDefaultTypeInternal _CDOTAClientMsg_AbilityDraftRequestAbility_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_GuideSelectOption::CDOTAClientMsg_GuideSelectOption(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.option_)*/0u
  , /*decltype(_impl_.force_recalculate_)*/false} {}
struct CDOTAClientMsg_GuideSelectOptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_GuideSelectOptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_GuideSelectOptionDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_GuideSelectOption _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_GuideSelectOptionDefaultTypeInternal _CDOTAClientMsg_GuideSelectOption_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_GuideSelected::CDOTAClientMsg_GuideSelected(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.guide_workshop_id_)*/uint64_t{0u}
  , /*decltype(_impl_.is_plus_guide_)*/false} {}
struct CDOTAClientMsg_GuideSelectedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_GuideSelectedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_GuideSelectedDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_GuideSelected _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_GuideSelectedDefaultTypeInternal _CDOTAClientMsg_GuideSelected_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_DamageReport::CDOTAClientMsg_DamageReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_hero_id_)*/0u
  , /*decltype(_impl_.source_hero_id_)*/0u
  , /*decltype(_impl_.damage_amount_)*/0
  , /*decltype(_impl_.broadcast_)*/false} {}
struct CDOTAClientMsg_DamageReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_DamageReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_DamageReportDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_DamageReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_DamageReportDefaultTypeInternal _CDOTAClientMsg_DamageReport_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_SalutePlayer::CDOTAClientMsg_SalutePlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.event_id_)*/0
  , /*decltype(_impl_.target_player_id_)*/-1} {}
struct CDOTAClientMsg_SalutePlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_SalutePlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_SalutePlayerDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_SalutePlayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_SalutePlayerDefaultTypeInternal _CDOTAClientMsg_SalutePlayer_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_TipAlert::CDOTAClientMsg_TipAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tip_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CDOTAClientMsg_TipAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_TipAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_TipAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_TipAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_TipAlertDefaultTypeInternal _CDOTAClientMsg_TipAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_EmptyTeleportAlert::CDOTAClientMsg_EmptyTeleportAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_entindex_)*/-1} {}
struct CDOTAClientMsg_EmptyTeleportAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_EmptyTeleportAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_EmptyTeleportAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_EmptyTeleportAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_EmptyTeleportAlertDefaultTypeInternal _CDOTAClientMsg_EmptyTeleportAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_SetCavernMapVariant::CDOTAClientMsg_SetCavernMapVariant(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.map_variant_)*/255u} {}
struct CDOTAClientMsg_SetCavernMapVariantDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_SetCavernMapVariantDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_SetCavernMapVariantDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_SetCavernMapVariant _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_SetCavernMapVariantDefaultTypeInternal _CDOTAClientMsg_SetCavernMapVariant_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_PauseGameOrder::CDOTAClientMsg_PauseGameOrder(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.order_id_)*/0
  , /*decltype(_impl_.data_)*/0} {}
struct CDOTAClientMsg_PauseGameOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_PauseGameOrderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_PauseGameOrderDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_PauseGameOrder _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_PauseGameOrderDefaultTypeInternal _CDOTAClientMsg_PauseGameOrder_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_VersusScene_PlayerBehavior::CDOTAClientMsg_VersusScene_PlayerBehavior(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.play_activity_)*/nullptr
  , /*decltype(_impl_.chat_wheel_)*/nullptr
  , /*decltype(_impl_.playback_rate_)*/nullptr
  , /*decltype(_impl_.behavior_)*/1} {}
struct CDOTAClientMsg_VersusScene_PlayerBehaviorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_VersusScene_PlayerBehaviorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_VersusScene_PlayerBehaviorDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_VersusScene_PlayerBehavior _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_VersusScene_PlayerBehaviorDefaultTypeInternal _CDOTAClientMsg_VersusScene_PlayerBehavior_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_EmptyItemSlotAlert::CDOTAClientMsg_EmptyItemSlotAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.slot_index_)*/0
  , /*decltype(_impl_.target_entindex_)*/-1} {}
struct CDOTAClientMsg_EmptyItemSlotAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_EmptyItemSlotAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_EmptyItemSlotAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_EmptyItemSlotAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_EmptyItemSlotAlertDefaultTypeInternal _CDOTAClientMsg_EmptyItemSlotAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_AddOverwatchReportMarker::CDOTAClientMsg_AddOverwatchReportMarker(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reason_)*/0
  , /*decltype(_impl_.seconds_ago_)*/0u
  , /*decltype(_impl_.target_player_id_)*/-1} {}
struct CDOTAClientMsg_AddOverwatchReportMarkerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_AddOverwatchReportMarkerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_AddOverwatchReportMarkerDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_AddOverwatchReportMarker _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_AddOverwatchReportMarkerDefaultTypeInternal _CDOTAClientMsg_AddOverwatchReportMarker_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_AddCommunicationsReportMarker::CDOTAClientMsg_AddCommunicationsReportMarker(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_player_id_)*/-1} {}
struct CDOTAClientMsg_AddCommunicationsReportMarkerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_AddCommunicationsReportMarkerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_AddCommunicationsReportMarkerDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_AddCommunicationsReportMarker _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_AddCommunicationsReportMarkerDefaultTypeInternal _CDOTAClientMsg_AddCommunicationsReportMarker_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_AddCommunicationsBlockMarker::CDOTAClientMsg_AddCommunicationsBlockMarker(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.target_player_id_)*/-1} {}
struct CDOTAClientMsg_AddCommunicationsBlockMarkerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_AddCommunicationsBlockMarkerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_AddCommunicationsBlockMarkerDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_AddCommunicationsBlockMarker _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_AddCommunicationsBlockMarkerDefaultTypeInternal _CDOTAClientMsg_AddCommunicationsBlockMarker_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_AghsStatusAlert::CDOTAClientMsg_AghsStatusAlert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.alert_type_)*/0u
  , /*decltype(_impl_.target_entindex_)*/-1
  , /*decltype(_impl_.source_player_id_)*/-1
  , /*decltype(_impl_.target_player_id_)*/-1} {}
struct CDOTAClientMsg_AghsStatusAlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_AghsStatusAlertDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_AghsStatusAlertDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_AghsStatusAlert _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_AghsStatusAlertDefaultTypeInternal _CDOTAClientMsg_AghsStatusAlert_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_PerfReport::CDOTAClientMsg_PerfReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.average_frame_time_)*/0
  , /*decltype(_impl_.max_frame_time_)*/0
  , /*decltype(_impl_.average_compute_time_)*/0
  , /*decltype(_impl_.max_compute_time_)*/0
  , /*decltype(_impl_.average_client_tick_time_)*/0
  , /*decltype(_impl_.max_client_tick_time_)*/0
  , /*decltype(_impl_.average_client_simulate_time_)*/0
  , /*decltype(_impl_.max_client_simulate_time_)*/0
  , /*decltype(_impl_.average_output_time_)*/0
  , /*decltype(_impl_.max_output_time_)*/0
  , /*decltype(_impl_.average_wait_for_rendering_to_complete_time_)*/0
  , /*decltype(_impl_.max_wait_for_rendering_to_complete_time_)*/0
  , /*decltype(_impl_.average_swap_time_)*/0
  , /*decltype(_impl_.max_swap_time_)*/0
  , /*decltype(_impl_.average_frame_update_time_)*/0
  , /*decltype(_impl_.max_frame_update_time_)*/0
  , /*decltype(_impl_.average_idle_time_)*/0
  , /*decltype(_impl_.max_idle_time_)*/0
  , /*decltype(_impl_.average_input_processing_time_)*/0
  , /*decltype(_impl_.max_input_processing_time_)*/0} {}
struct CDOTAClientMsg_PerfReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_PerfReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_PerfReportDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_PerfReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_PerfReportDefaultTypeInternal _CDOTAClientMsg_PerfReport_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ContextualTips_Subscribe_Entry::CDOTAClientMsg_ContextualTips_Subscribe_Entry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.variants_seen_)*/{}
  , /*decltype(_impl_.unsubscribe_)*/false
  , /*decltype(_impl_.tip_id_)*/0
  , /*decltype(_impl_.prior_display_count_)*/0} {}
struct CDOTAClientMsg_ContextualTips_Subscribe_EntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ContextualTips_Subscribe_EntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ContextualTips_Subscribe_EntryDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ContextualTips_Subscribe_Entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ContextualTips_Subscribe_EntryDefaultTypeInternal _CDOTAClientMsg_ContextualTips_Subscribe_Entry_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ContextualTips_Subscribe::CDOTAClientMsg_ContextualTips_Subscribe(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tips_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CDOTAClientMsg_ContextualTips_SubscribeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ContextualTips_SubscribeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ContextualTips_SubscribeDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ContextualTips_Subscribe _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ContextualTips_SubscribeDefaultTypeInternal _CDOTAClientMsg_ContextualTips_Subscribe_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_ChatMessage::CDOTAClientMsg_ChatMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.channel_type_)*/0u} {}
struct CDOTAClientMsg_ChatMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_ChatMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_ChatMessageDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_ChatMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_ChatMessageDefaultTypeInternal _CDOTAClientMsg_ChatMessage_default_instance_;
PROTOBUF_CONSTEXPR CDOTAClientMsg_DuelAccepted::CDOTAClientMsg_DuelAccepted(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.challenger_player_id_)*/-1
  , /*decltype(_impl_.accepter_player_id_)*/-1} {}
struct CDOTAClientMsg_DuelAcceptedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientMsg_DuelAcceptedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientMsg_DuelAcceptedDefaultTypeInternal() {}
  union {
    CDOTAClientMsg_DuelAccepted _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientMsg_DuelAcceptedDefaultTypeInternal _CDOTAClientMsg_DuelAccepted_default_instance_;
static ::_pb::Metadata file_level_metadata_dota_5fclientmessages_2eproto[84];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_dota_5fclientmessages_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_dota_5fclientmessages_2eproto = nullptr;

const uint32_t TableStruct_dota_5fclientmessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_MapPing, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_MapPing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_MapPing, _impl_.location_ping_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ItemAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ItemAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ItemAlert, _impl_.item_alert_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EnemyItemAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EnemyItemAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EnemyItemAlert, _impl_.item_entindex_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EnemyItemAlert, _impl_.rune_type_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EnemyItemAlert, _impl_.item_level_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EnemyItemAlert, _impl_.primary_charges_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EnemyItemAlert, _impl_.secondary_charges_),
  1,
  2,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ModifierAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ModifierAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ModifierAlert, _impl_.buff_internal_index_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ModifierAlert, _impl_.target_entindex_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ClickedBuff, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ClickedBuff, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ClickedBuff, _impl_.buff_internal_index_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ClickedBuff, _impl_.target_entindex_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_HPManaAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_HPManaAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_HPManaAlert, _impl_.target_entindex_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_HPManaAlert, _impl_.show_raw_values_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_NeutralCampAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_NeutralCampAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_NeutralCampAlert, _impl_.spawner_entindex_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_NeutralCampAlert, _impl_.unit_entindex_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_NeutralCampAlert, _impl_.stack_request_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_GlyphAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_GlyphAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_GlyphAlert, _impl_.negative_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RadarAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RadarAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RadarAlert, _impl_.negative_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_MapLine, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_MapLine, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_MapLine, _impl_.mapline_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AspectRatio, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AspectRatio, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AspectRatio, _impl_.ratio_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UnitsAutoAttackMode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UnitsAutoAttackMode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UnitsAutoAttackMode, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UnitsAutoAttackMode, _impl_.unit_type_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UnitsAutoAttackAfterSpell, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UnitsAutoAttackAfterSpell, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UnitsAutoAttackAfterSpell, _impl_.enabled_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_TeleportRequiresHalt, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_TeleportRequiresHalt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_TeleportRequiresHalt, _impl_.enabled_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChannelRequiresHalt, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChannelRequiresHalt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChannelRequiresHalt, _impl_.enabled_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SearchString, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SearchString, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SearchString, _impl_.search_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_Pause, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ShopViewMode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ShopViewMode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ShopViewMode, _impl_.mode_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetUnitShareFlag, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetUnitShareFlag, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetUnitShareFlag, _impl_.player_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetUnitShareFlag, _impl_.flag_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetUnitShareFlag, _impl_.state_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SwapRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SwapRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SwapRequest, _impl_.player_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SwapAccept, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SwapAccept, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SwapAccept, _impl_.player_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_WorldLine, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_WorldLine, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_WorldLine, _impl_.worldline_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RequestGraphUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChatWheel, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChatWheel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChatWheel, _impl_.chat_message_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChatWheel, _impl_.param_hero_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChatWheel, _impl_.emoticon_id_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SendStatPopup, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SendStatPopup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SendStatPopup, _impl_.statpopup_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DismissAllStatPopups, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DismissAllStatPopups, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DismissAllStatPopups, _impl_.dismissallmsg_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_BeginLastHitChallenge, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_BeginLastHitChallenge, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_BeginLastHitChallenge, _impl_.chosen_lane_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_BeginLastHitChallenge, _impl_.helper_enabled_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UpdateQuickBuyItem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UpdateQuickBuyItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UpdateQuickBuyItem, _impl_.item_ability_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UpdateQuickBuyItem, _impl_.purchasable_),
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UpdateQuickBuy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_UpdateQuickBuy, _impl_.items_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RecordVote, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RecordVote, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RecordVote, _impl_.choice_index_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_WillPurchaseAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_WillPurchaseAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_WillPurchaseAlert, _impl_.item_ability_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_WillPurchaseAlert, _impl_.gold_remaining_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_WillPurchaseAlert, _impl_.suggestion_player_id_),
  1,
  0,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_BuyBackStateAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuickBuyAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuickBuyAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuickBuyAlert, _impl_.item_ability_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuickBuyAlert, _impl_.gold_cost_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuickBuyAlert, _impl_.item_cooldown_seconds_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuickBuyAlert, _impl_.show_buyback_),
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PlayerShowCase, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PlayerShowCase, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PlayerShowCase, _impl_.showcase_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_CameraZoomAmount, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_CameraZoomAmount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_CameraZoomAmount, _impl_.zoom_amount_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_BroadcasterUsingCameraman, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_BroadcasterUsingCameraman, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_BroadcasterUsingCameraman, _impl_.cameraman_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator, _impl_.enabled_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_FillEmptySlotsWithBots, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_FillEmptySlotsWithBots, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_FillEmptySlotsWithBots, _impl_.fillwithbots_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_HeroStatueLike, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_HeroStatueLike, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_HeroStatueLike, _impl_.owner_player_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EventCNY2015Cmd, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EventCNY2015Cmd, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EventCNY2015Cmd, _impl_.data_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DemoHero, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DemoHero, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DemoHero, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DemoHero, _impl_.hero_id_to_spawn_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DemoHero, _impl_.item_defs_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DemoHero, _impl_.item_ids_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DemoHero, _impl_.style_index_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DemoHero, _impl_.keep_existing_demohero_),
  0,
  1,
  ~0u,
  ~0u,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChallengeSelect, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChallengeSelect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChallengeSelect, _impl_.event_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChallengeSelect, _impl_.slot_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChallengeSelect, _impl_.sequence_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChallengeReroll, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChallengeReroll, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChallengeReroll, _impl_.event_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChallengeReroll, _impl_.slot_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChallengeReroll, _impl_.sequence_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChallengeReroll, _impl_.hero_id_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_CoinWager, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_CoinWager, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_CoinWager, _impl_.wager_amount_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_CoinWagerToken, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_CoinWagerToken, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_CoinWagerToken, _impl_.wager_token_item_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RankWager, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RankWager, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RankWager, _impl_.announce_wager_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PlayerBounty, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PlayerBounty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PlayerBounty, _impl_.player_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EventPointsTip, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EventPointsTip, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EventPointsTip, _impl_.recipient_player_id_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ExecuteOrders, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ExecuteOrders, _impl_.orders_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_XPAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_XPAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_XPAlert, _impl_.target_entindex_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_XPAlert, _impl_.damage_taken_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_TalentTreeAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_TalentTreeAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_TalentTreeAlert, _impl_.target_entindex_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_TalentTreeAlert, _impl_.ability_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_TalentTreeAlert, _impl_.slot_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_TalentTreeAlert, _impl_.learned_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_KillcamDamageTaken, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_KillcamDamageTaken, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_KillcamDamageTaken, _impl_.target_entindex_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_KillcamDamageTaken, _impl_.damage_taken_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_KillcamDamageTaken, _impl_.item_type_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_KillcamDamageTaken, _impl_.item_ability_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_KillcamDamageTaken, _impl_.hero_name_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_KillcamDamageTaken, _impl_.damage_color_),
  4,
  2,
  3,
  5,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_KillMyHero, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuestStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuestStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuestStatus, _impl_.quest_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuestStatus, _impl_.challenge_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuestStatus, _impl_.progress_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuestStatus, _impl_.goal_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuestStatus, _impl_.query_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuestStatus, _impl_.fail_gametime_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_QuestStatus, _impl_.item_ability_id_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ToggleAutoattack, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ToggleAutoattack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ToggleAutoattack, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ToggleAutoattack, _impl_.show_message_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SpecialAbility, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SpecialAbility, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SpecialAbility, _impl_.ability_index_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SpecialAbility, _impl_.target_entindex_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetEnemyStartingPosition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetEnemyStartingPosition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetEnemyStartingPosition, _impl_.enemy_player_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetEnemyStartingPosition, _impl_.enemy_starting_position_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetDesiredWardPlacement, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetDesiredWardPlacement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetDesiredWardPlacement, _impl_.ward_index_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetDesiredWardPlacement, _impl_.ward_x_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetDesiredWardPlacement, _impl_.ward_y_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RollDice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RollDice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RollDice, _impl_.channel_type_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RollDice, _impl_.roll_min_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RollDice, _impl_.roll_max_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_FlipCoin, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_FlipCoin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_FlipCoin, _impl_.channel_type_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RequestItemSuggestions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_MakeTeamCaptain, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_MakeTeamCaptain, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_MakeTeamCaptain, _impl_.player_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_HelpTipSystemStateChanged, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_HelpTipSystemStateChanged, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_HelpTipSystemStateChanged, _impl_.tip_displayed_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RequestBulkCombatLog, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RequestBulkCombatLog, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RequestBulkCombatLog, _impl_.game_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RequestBulkCombatLog, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RequestBulkCombatLog, _impl_.recent_player_death_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_RequestBulkCombatLog, _impl_.player_id_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AbilityDraftRequestAbility, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AbilityDraftRequestAbility, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AbilityDraftRequestAbility, _impl_.requested_ability_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AbilityDraftRequestAbility, _impl_.ctrl_is_down_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_GuideSelectOption, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_GuideSelectOption, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_GuideSelectOption, _impl_.option_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_GuideSelectOption, _impl_.force_recalculate_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_GuideSelected, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_GuideSelected, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_GuideSelected, _impl_.guide_workshop_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_GuideSelected, _impl_.is_plus_guide_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DamageReport, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DamageReport, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DamageReport, _impl_.target_hero_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DamageReport, _impl_.source_hero_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DamageReport, _impl_.damage_amount_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DamageReport, _impl_.broadcast_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SalutePlayer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SalutePlayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SalutePlayer, _impl_.target_player_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SalutePlayer, _impl_.event_id_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_TipAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_TipAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_TipAlert, _impl_.tip_text_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EmptyTeleportAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EmptyTeleportAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EmptyTeleportAlert, _impl_.target_entindex_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetCavernMapVariant, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetCavernMapVariant, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_SetCavernMapVariant, _impl_.map_variant_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PauseGameOrder, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PauseGameOrder, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PauseGameOrder, _impl_.order_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PauseGameOrder, _impl_.data_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_VersusScene_PlayerBehavior, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_VersusScene_PlayerBehavior, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_VersusScene_PlayerBehavior, _impl_.behavior_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_VersusScene_PlayerBehavior, _impl_.play_activity_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_VersusScene_PlayerBehavior, _impl_.chat_wheel_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_VersusScene_PlayerBehavior, _impl_.playback_rate_),
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EmptyItemSlotAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EmptyItemSlotAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EmptyItemSlotAlert, _impl_.target_entindex_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_EmptyItemSlotAlert, _impl_.slot_index_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AddOverwatchReportMarker, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AddOverwatchReportMarker, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AddOverwatchReportMarker, _impl_.target_player_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AddOverwatchReportMarker, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AddOverwatchReportMarker, _impl_.seconds_ago_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AddCommunicationsReportMarker, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AddCommunicationsReportMarker, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AddCommunicationsReportMarker, _impl_.target_player_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AddCommunicationsBlockMarker, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AddCommunicationsBlockMarker, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AddCommunicationsBlockMarker, _impl_.target_player_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AghsStatusAlert, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AghsStatusAlert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AghsStatusAlert, _impl_.source_player_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AghsStatusAlert, _impl_.target_player_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AghsStatusAlert, _impl_.target_entindex_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_AghsStatusAlert, _impl_.alert_type_),
  2,
  3,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.average_frame_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.max_frame_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.average_compute_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.max_compute_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.average_client_tick_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.max_client_tick_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.average_client_simulate_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.max_client_simulate_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.average_output_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.max_output_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.average_wait_for_rendering_to_complete_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.max_wait_for_rendering_to_complete_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.average_swap_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.max_swap_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.average_frame_update_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.max_frame_update_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.average_idle_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.max_idle_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.average_input_processing_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_PerfReport, _impl_.max_input_processing_time_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ContextualTips_Subscribe_Entry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ContextualTips_Subscribe_Entry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ContextualTips_Subscribe_Entry, _impl_.unsubscribe_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ContextualTips_Subscribe_Entry, _impl_.tip_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ContextualTips_Subscribe_Entry, _impl_.prior_display_count_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ContextualTips_Subscribe_Entry, _impl_.variants_seen_),
  0,
  1,
  2,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ContextualTips_Subscribe, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ContextualTips_Subscribe, _impl_.tips_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChatMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChatMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChatMessage, _impl_.channel_type_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_ChatMessage, _impl_.message_text_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DuelAccepted, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DuelAccepted, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DuelAccepted, _impl_.challenger_player_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientMsg_DuelAccepted, _impl_.accepter_player_id_),
  0,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::CDOTAClientMsg_MapPing)},
  { 8, 15, -1, sizeof(::CDOTAClientMsg_ItemAlert)},
  { 16, 27, -1, sizeof(::CDOTAClientMsg_EnemyItemAlert)},
  { 32, 40, -1, sizeof(::CDOTAClientMsg_ModifierAlert)},
  { 42, 50, -1, sizeof(::CDOTAClientMsg_ClickedBuff)},
  { 52, 60, -1, sizeof(::CDOTAClientMsg_HPManaAlert)},
  { 62, 71, -1, sizeof(::CDOTAClientMsg_NeutralCampAlert)},
  { 74, 81, -1, sizeof(::CDOTAClientMsg_GlyphAlert)},
  { 82, 89, -1, sizeof(::CDOTAClientMsg_RadarAlert)},
  { 90, 97, -1, sizeof(::CDOTAClientMsg_MapLine)},
  { 98, 105, -1, sizeof(::CDOTAClientMsg_AspectRatio)},
  { 106, 114, -1, sizeof(::CDOTAClientMsg_UnitsAutoAttackMode)},
  { 116, 123, -1, sizeof(::CDOTAClientMsg_UnitsAutoAttackAfterSpell)},
  { 124, 131, -1, sizeof(::CDOTAClientMsg_TeleportRequiresHalt)},
  { 132, 139, -1, sizeof(::CDOTAClientMsg_ChannelRequiresHalt)},
  { 140, 147, -1, sizeof(::CDOTAClientMsg_SearchString)},
  { 148, -1, -1, sizeof(::CDOTAClientMsg_Pause)},
  { 154, 161, -1, sizeof(::CDOTAClientMsg_ShopViewMode)},
  { 162, 171, -1, sizeof(::CDOTAClientMsg_SetUnitShareFlag)},
  { 174, 181, -1, sizeof(::CDOTAClientMsg_SwapRequest)},
  { 182, 189, -1, sizeof(::CDOTAClientMsg_SwapAccept)},
  { 190, 197, -1, sizeof(::CDOTAClientMsg_WorldLine)},
  { 198, -1, -1, sizeof(::CDOTAClientMsg_RequestGraphUpdate)},
  { 204, 213, -1, sizeof(::CDOTAClientMsg_ChatWheel)},
  { 216, 223, -1, sizeof(::CDOTAClientMsg_SendStatPopup)},
  { 224, 231, -1, sizeof(::CDOTAClientMsg_DismissAllStatPopups)},
  { 232, 240, -1, sizeof(::CDOTAClientMsg_BeginLastHitChallenge)},
  { 242, 250, -1, sizeof(::CDOTAClientMsg_UpdateQuickBuyItem)},
  { 252, -1, -1, sizeof(::CDOTAClientMsg_UpdateQuickBuy)},
  { 259, 266, -1, sizeof(::CDOTAClientMsg_RecordVote)},
  { 267, 276, -1, sizeof(::CDOTAClientMsg_WillPurchaseAlert)},
  { 279, -1, -1, sizeof(::CDOTAClientMsg_BuyBackStateAlert)},
  { 285, 295, -1, sizeof(::CDOTAClientMsg_QuickBuyAlert)},
  { 299, 306, -1, sizeof(::CDOTAClientMsg_PlayerShowCase)},
  { 307, 314, -1, sizeof(::CDOTAClientMsg_CameraZoomAmount)},
  { 315, 322, -1, sizeof(::CDOTAClientMsg_BroadcasterUsingCameraman)},
  { 323, 330, -1, sizeof(::CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)},
  { 331, 338, -1, sizeof(::CDOTAClientMsg_FillEmptySlotsWithBots)},
  { 339, 346, -1, sizeof(::CDOTAClientMsg_HeroStatueLike)},
  { 347, 354, -1, sizeof(::CDOTAClientMsg_EventCNY2015Cmd)},
  { 355, 367, -1, sizeof(::CDOTAClientMsg_DemoHero)},
  { 373, 382, -1, sizeof(::CDOTAClientMsg_ChallengeSelect)},
  { 385, 395, -1, sizeof(::CDOTAClientMsg_ChallengeReroll)},
  { 399, 406, -1, sizeof(::CDOTAClientMsg_CoinWager)},
  { 407, 414, -1, sizeof(::CDOTAClientMsg_CoinWagerToken)},
  { 415, 422, -1, sizeof(::CDOTAClientMsg_RankWager)},
  { 423, 430, -1, sizeof(::CDOTAClientMsg_PlayerBounty)},
  { 431, 438, -1, sizeof(::CDOTAClientMsg_EventPointsTip)},
  { 439, -1, -1, sizeof(::CDOTAClientMsg_ExecuteOrders)},
  { 446, 454, -1, sizeof(::CDOTAClientMsg_XPAlert)},
  { 456, 466, -1, sizeof(::CDOTAClientMsg_TalentTreeAlert)},
  { 470, 482, -1, sizeof(::CDOTAClientMsg_KillcamDamageTaken)},
  { 488, -1, -1, sizeof(::CDOTAClientMsg_KillMyHero)},
  { 494, 507, -1, sizeof(::CDOTAClientMsg_QuestStatus)},
  { 514, 522, -1, sizeof(::CDOTAClientMsg_ToggleAutoattack)},
  { 524, 532, -1, sizeof(::CDOTAClientMsg_SpecialAbility)},
  { 534, 542, -1, sizeof(::CDOTAClientMsg_SetEnemyStartingPosition)},
  { 544, 553, -1, sizeof(::CDOTAClientMsg_SetDesiredWardPlacement)},
  { 556, 565, -1, sizeof(::CDOTAClientMsg_RollDice)},
  { 568, 575, -1, sizeof(::CDOTAClientMsg_FlipCoin)},
  { 576, -1, -1, sizeof(::CDOTAClientMsg_RequestItemSuggestions)},
  { 582, 589, -1, sizeof(::CDOTAClientMsg_MakeTeamCaptain)},
  { 590, 597, -1, sizeof(::CDOTAClientMsg_HelpTipSystemStateChanged)},
  { 598, 608, -1, sizeof(::CDOTAClientMsg_RequestBulkCombatLog)},
  { 612, 620, -1, sizeof(::CDOTAClientMsg_AbilityDraftRequestAbility)},
  { 622, 630, -1, sizeof(::CDOTAClientMsg_GuideSelectOption)},
  { 632, 640, -1, sizeof(::CDOTAClientMsg_GuideSelected)},
  { 642, 652, -1, sizeof(::CDOTAClientMsg_DamageReport)},
  { 656, 664, -1, sizeof(::CDOTAClientMsg_SalutePlayer)},
  { 666, 673, -1, sizeof(::CDOTAClientMsg_TipAlert)},
  { 674, 681, -1, sizeof(::CDOTAClientMsg_EmptyTeleportAlert)},
  { 682, 689, -1, sizeof(::CDOTAClientMsg_SetCavernMapVariant)},
  { 690, 698, -1, sizeof(::CDOTAClientMsg_PauseGameOrder)},
  { 700, 710, -1, sizeof(::CDOTAClientMsg_VersusScene_PlayerBehavior)},
  { 714, 722, -1, sizeof(::CDOTAClientMsg_EmptyItemSlotAlert)},
  { 724, 733, -1, sizeof(::CDOTAClientMsg_AddOverwatchReportMarker)},
  { 736, 743, -1, sizeof(::CDOTAClientMsg_AddCommunicationsReportMarker)},
  { 744, 751, -1, sizeof(::CDOTAClientMsg_AddCommunicationsBlockMarker)},
  { 752, 762, -1, sizeof(::CDOTAClientMsg_AghsStatusAlert)},
  { 766, 792, -1, sizeof(::CDOTAClientMsg_PerfReport)},
  { 812, 822, -1, sizeof(::CDOTAClientMsg_ContextualTips_Subscribe_Entry)},
  { 826, -1, -1, sizeof(::CDOTAClientMsg_ContextualTips_Subscribe)},
  { 833, 841, -1, sizeof(::CDOTAClientMsg_ChatMessage)},
  { 843, 851, -1, sizeof(::CDOTAClientMsg_DuelAccepted)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CDOTAClientMsg_MapPing_default_instance_._instance,
  &::_CDOTAClientMsg_ItemAlert_default_instance_._instance,
  &::_CDOTAClientMsg_EnemyItemAlert_default_instance_._instance,
  &::_CDOTAClientMsg_ModifierAlert_default_instance_._instance,
  &::_CDOTAClientMsg_ClickedBuff_default_instance_._instance,
  &::_CDOTAClientMsg_HPManaAlert_default_instance_._instance,
  &::_CDOTAClientMsg_NeutralCampAlert_default_instance_._instance,
  &::_CDOTAClientMsg_GlyphAlert_default_instance_._instance,
  &::_CDOTAClientMsg_RadarAlert_default_instance_._instance,
  &::_CDOTAClientMsg_MapLine_default_instance_._instance,
  &::_CDOTAClientMsg_AspectRatio_default_instance_._instance,
  &::_CDOTAClientMsg_UnitsAutoAttackMode_default_instance_._instance,
  &::_CDOTAClientMsg_UnitsAutoAttackAfterSpell_default_instance_._instance,
  &::_CDOTAClientMsg_TeleportRequiresHalt_default_instance_._instance,
  &::_CDOTAClientMsg_ChannelRequiresHalt_default_instance_._instance,
  &::_CDOTAClientMsg_SearchString_default_instance_._instance,
  &::_CDOTAClientMsg_Pause_default_instance_._instance,
  &::_CDOTAClientMsg_ShopViewMode_default_instance_._instance,
  &::_CDOTAClientMsg_SetUnitShareFlag_default_instance_._instance,
  &::_CDOTAClientMsg_SwapRequest_default_instance_._instance,
  &::_CDOTAClientMsg_SwapAccept_default_instance_._instance,
  &::_CDOTAClientMsg_WorldLine_default_instance_._instance,
  &::_CDOTAClientMsg_RequestGraphUpdate_default_instance_._instance,
  &::_CDOTAClientMsg_ChatWheel_default_instance_._instance,
  &::_CDOTAClientMsg_SendStatPopup_default_instance_._instance,
  &::_CDOTAClientMsg_DismissAllStatPopups_default_instance_._instance,
  &::_CDOTAClientMsg_BeginLastHitChallenge_default_instance_._instance,
  &::_CDOTAClientMsg_UpdateQuickBuyItem_default_instance_._instance,
  &::_CDOTAClientMsg_UpdateQuickBuy_default_instance_._instance,
  &::_CDOTAClientMsg_RecordVote_default_instance_._instance,
  &::_CDOTAClientMsg_WillPurchaseAlert_default_instance_._instance,
  &::_CDOTAClientMsg_BuyBackStateAlert_default_instance_._instance,
  &::_CDOTAClientMsg_QuickBuyAlert_default_instance_._instance,
  &::_CDOTAClientMsg_PlayerShowCase_default_instance_._instance,
  &::_CDOTAClientMsg_CameraZoomAmount_default_instance_._instance,
  &::_CDOTAClientMsg_BroadcasterUsingCameraman_default_instance_._instance,
  &::_CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator_default_instance_._instance,
  &::_CDOTAClientMsg_FillEmptySlotsWithBots_default_instance_._instance,
  &::_CDOTAClientMsg_HeroStatueLike_default_instance_._instance,
  &::_CDOTAClientMsg_EventCNY2015Cmd_default_instance_._instance,
  &::_CDOTAClientMsg_DemoHero_default_instance_._instance,
  &::_CDOTAClientMsg_ChallengeSelect_default_instance_._instance,
  &::_CDOTAClientMsg_ChallengeReroll_default_instance_._instance,
  &::_CDOTAClientMsg_CoinWager_default_instance_._instance,
  &::_CDOTAClientMsg_CoinWagerToken_default_instance_._instance,
  &::_CDOTAClientMsg_RankWager_default_instance_._instance,
  &::_CDOTAClientMsg_PlayerBounty_default_instance_._instance,
  &::_CDOTAClientMsg_EventPointsTip_default_instance_._instance,
  &::_CDOTAClientMsg_ExecuteOrders_default_instance_._instance,
  &::_CDOTAClientMsg_XPAlert_default_instance_._instance,
  &::_CDOTAClientMsg_TalentTreeAlert_default_instance_._instance,
  &::_CDOTAClientMsg_KillcamDamageTaken_default_instance_._instance,
  &::_CDOTAClientMsg_KillMyHero_default_instance_._instance,
  &::_CDOTAClientMsg_QuestStatus_default_instance_._instance,
  &::_CDOTAClientMsg_ToggleAutoattack_default_instance_._instance,
  &::_CDOTAClientMsg_SpecialAbility_default_instance_._instance,
  &::_CDOTAClientMsg_SetEnemyStartingPosition_default_instance_._instance,
  &::_CDOTAClientMsg_SetDesiredWardPlacement_default_instance_._instance,
  &::_CDOTAClientMsg_RollDice_default_instance_._instance,
  &::_CDOTAClientMsg_FlipCoin_default_instance_._instance,
  &::_CDOTAClientMsg_RequestItemSuggestions_default_instance_._instance,
  &::_CDOTAClientMsg_MakeTeamCaptain_default_instance_._instance,
  &::_CDOTAClientMsg_HelpTipSystemStateChanged_default_instance_._instance,
  &::_CDOTAClientMsg_RequestBulkCombatLog_default_instance_._instance,
  &::_CDOTAClientMsg_AbilityDraftRequestAbility_default_instance_._instance,
  &::_CDOTAClientMsg_GuideSelectOption_default_instance_._instance,
  &::_CDOTAClientMsg_GuideSelected_default_instance_._instance,
  &::_CDOTAClientMsg_DamageReport_default_instance_._instance,
  &::_CDOTAClientMsg_SalutePlayer_default_instance_._instance,
  &::_CDOTAClientMsg_TipAlert_default_instance_._instance,
  &::_CDOTAClientMsg_EmptyTeleportAlert_default_instance_._instance,
  &::_CDOTAClientMsg_SetCavernMapVariant_default_instance_._instance,
  &::_CDOTAClientMsg_PauseGameOrder_default_instance_._instance,
  &::_CDOTAClientMsg_VersusScene_PlayerBehavior_default_instance_._instance,
  &::_CDOTAClientMsg_EmptyItemSlotAlert_default_instance_._instance,
  &::_CDOTAClientMsg_AddOverwatchReportMarker_default_instance_._instance,
  &::_CDOTAClientMsg_AddCommunicationsReportMarker_default_instance_._instance,
  &::_CDOTAClientMsg_AddCommunicationsBlockMarker_default_instance_._instance,
  &::_CDOTAClientMsg_AghsStatusAlert_default_instance_._instance,
  &::_CDOTAClientMsg_PerfReport_default_instance_._instance,
  &::_CDOTAClientMsg_ContextualTips_Subscribe_Entry_default_instance_._instance,
  &::_CDOTAClientMsg_ContextualTips_Subscribe_default_instance_._instance,
  &::_CDOTAClientMsg_ChatMessage_default_instance_._instance,
  &::_CDOTAClientMsg_DuelAccepted_default_instance_._instance,
};

const char descriptor_table_protodef_dota_5fclientmessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\031dota_clientmessages.proto\032\031dota_common"
  "messages.proto\032\027dota_shared_enums.proto\""
  "G\n\026CDOTAClientMsg_MapPing\022-\n\rlocation_pi"
  "ng\030\001 \001(\0132\026.CDOTAMsg_LocationPing\"C\n\030CDOT"
  "AClientMsg_ItemAlert\022\'\n\nitem_alert\030\001 \001(\013"
  "2\023.CDOTAMsg_ItemAlert\"\245\001\n\035CDOTAClientMsg"
  "_EnemyItemAlert\022\031\n\ritem_entindex\030\001 \001(\005:\002"
  "-1\022\025\n\trune_type\030\002 \001(\005:\002-1\022\026\n\nitem_level\030"
  "\003 \001(\005:\002-1\022\033\n\017primary_charges\030\004 \001(\005:\002-1\022\035"
  "\n\021secondary_charges\030\005 \001(\005:\002-1\"X\n\034CDOTACl"
  "ientMsg_ModifierAlert\022\033\n\023buff_internal_i"
  "ndex\030\001 \001(\005\022\033\n\017target_entindex\030\002 \001(\005:\002-1\""
  "V\n\032CDOTAClientMsg_ClickedBuff\022\033\n\023buff_in"
  "ternal_index\030\001 \001(\005\022\033\n\017target_entindex\030\002 "
  "\001(\005:\002-1\"R\n\032CDOTAClientMsg_HPManaAlert\022\033\n"
  "\017target_entindex\030\001 \001(\005:\002-1\022\027\n\017show_raw_v"
  "alues\030\002 \001(\010\"q\n\037CDOTAClientMsg_NeutralCam"
  "pAlert\022\034\n\020spawner_entindex\030\001 \001(\005:\002-1\022\031\n\r"
  "unit_entindex\030\002 \001(\005:\002-1\022\025\n\rstack_request"
  "\030\003 \001(\010\"-\n\031CDOTAClientMsg_GlyphAlert\022\020\n\010n"
  "egative\030\001 \001(\010\"-\n\031CDOTAClientMsg_RadarAle"
  "rt\022\020\n\010negative\030\001 \001(\010\"<\n\026CDOTAClientMsg_M"
  "apLine\022\"\n\007mapline\030\001 \001(\0132\021.CDOTAMsg_MapLi"
  "ne\"+\n\032CDOTAClientMsg_AspectRatio\022\r\n\005rati"
  "o\030\001 \001(\002\"\242\002\n\"CDOTAClientMsg_UnitsAutoAtta"
  "ckMode\022@\n\004mode\030\001 \001(\0162).CDOTAClientMsg_Un"
  "itsAutoAttackMode.EMode:\007INVALID\022H\n\tunit"
  "_type\030\002 \001(\0162-.CDOTAClientMsg_UnitsAutoAt"
  "tackMode.EUnitType:\006NORMAL\"I\n\005EMode\022\024\n\007I"
  "NVALID\020\377\377\377\377\377\377\377\377\377\001\022\t\n\005NEVER\020\000\022\023\n\017AFTER_SP"
  "ELLCAST\020\001\022\n\n\006ALWAYS\020\002\"%\n\tEUnitType\022\n\n\006NO"
  "RMAL\020\000\022\014\n\010SUMMONED\020\001\";\n(CDOTAClientMsg_U"
  "nitsAutoAttackAfterSpell\022\017\n\007enabled\030\001 \001("
  "\010\"6\n#CDOTAClientMsg_TeleportRequiresHalt"
  "\022\017\n\007enabled\030\001 \001(\010\"5\n\"CDOTAClientMsg_Chan"
  "nelRequiresHalt\022\017\n\007enabled\030\001 \001(\010\"-\n\033CDOT"
  "AClientMsg_SearchString\022\016\n\006search\030\001 \001(\t\""
  "\026\n\024CDOTAClientMsg_Pause\"+\n\033CDOTAClientMs"
  "g_ShopViewMode\022\014\n\004mode\030\001 \001(\r\"U\n\037CDOTACli"
  "entMsg_SetUnitShareFlag\022\025\n\tplayer_id\030\001 \001"
  "(\005:\002-1\022\014\n\004flag\030\002 \001(\r\022\r\n\005state\030\003 \001(\010\"3\n\032C"
  "DOTAClientMsg_SwapRequest\022\025\n\tplayer_id\030\001"
  " \001(\005:\002-1\"2\n\031CDOTAClientMsg_SwapAccept\022\025\n"
  "\tplayer_id\030\001 \001(\005:\002-1\"B\n\030CDOTAClientMsg_W"
  "orldLine\022&\n\tworldline\030\001 \001(\0132\023.CDOTAMsg_W"
  "orldLine\"#\n!CDOTAClientMsg_RequestGraphU"
  "pdate\"k\n\030CDOTAClientMsg_ChatWheel\022#\n\017cha"
  "t_message_id\030\001 \001(\r:\n4294967295\022\025\n\rparam_"
  "hero_id\030\002 \001(\r\022\023\n\013emoticon_id\030\003 \001(\r\"J\n\034CD"
  "OTAClientMsg_SendStatPopup\022*\n\tstatpopup\030"
  "\001 \001(\0132\027.CDOTAMsg_SendStatPopup\"\\\n#CDOTAC"
  "lientMsg_DismissAllStatPopups\0225\n\rdismiss"
  "allmsg\030\001 \001(\0132\036.CDOTAMsg_DismissAllStatPo"
  "pups\"S\n$CDOTAClientMsg_BeginLastHitChall"
  "enge\022\023\n\013chosen_lane\030\001 \001(\r\022\026\n\016helper_enab"
  "led\030\002 \001(\010\"\\\n!CDOTAClientMsg_UpdateQuickB"
  "uyItem\022\033\n\017item_ability_id\030\001 \001(\005:\002-1\022\032\n\013p"
  "urchasable\030\002 \001(\010:\005false\"R\n\035CDOTAClientMs"
  "g_UpdateQuickBuy\0221\n\005items\030\001 \003(\0132\".CDOTAC"
  "lientMsg_UpdateQuickBuyItem\"1\n\031CDOTAClie"
  "ntMsg_RecordVote\022\024\n\014choice_index\030\001 \001(\005\"y"
  "\n CDOTAClientMsg_WillPurchaseAlert\022\033\n\017it"
  "em_ability_id\030\001 \001(\005:\002-1\022\026\n\016gold_remainin"
  "g\030\002 \001(\r\022 \n\024suggestion_player_id\030\003 \001(\005:\002-"
  "1\"\"\n CDOTAClientMsg_BuyBackStateAlert\"\203\001"
  "\n\034CDOTAClientMsg_QuickBuyAlert\022\033\n\017item_a"
  "bility_id\030\001 \001(\005:\002-1\022\021\n\tgold_cost\030\002 \001(\005\022\035"
  "\n\025item_cooldown_seconds\030\003 \001(\005\022\024\n\014show_bu"
  "yback\030\004 \001(\010\"1\n\035CDOTAClientMsg_PlayerShow"
  "Case\022\020\n\010showcase\030\001 \001(\010\"6\n\037CDOTAClientMsg"
  "_CameraZoomAmount\022\023\n\013zoom_amount\030\001 \001(\002\"="
  "\n(CDOTAClientMsg_BroadcasterUsingCameram"
  "an\022\021\n\tcameraman\030\001 \001(\010\"H\n5CDOTAClientMsg_"
  "BroadcasterUsingAssistedCameraOperator\022\017"
  "\n\007enabled\030\001 \001(\010\"=\n%CDOTAClientMsg_FillEm"
  "ptySlotsWithBots\022\024\n\014fillwithbots\030\001 \001(\010\"<"
  "\n\035CDOTAClientMsg_HeroStatueLike\022\033\n\017owner"
  "_player_id\030\001 \001(\005:\002-1\".\n\036CDOTAClientMsg_E"
  "ventCNY2015Cmd\022\014\n\004data\030\001 \001(\014\"\243\001\n\027CDOTACl"
  "ientMsg_DemoHero\022\017\n\007hero_id\030\001 \001(\005\022\030\n\020her"
  "o_id_to_spawn\030\002 \001(\005\022\021\n\titem_defs\030\003 \003(\r\022\020"
  "\n\010item_ids\030\004 \003(\004\022\030\n\013style_index\030\005 \001(\r:\0032"
  "55\022\036\n\026keep_existing_demohero\030\006 \001(\010\"X\n\036CD"
  "OTAClientMsg_ChallengeSelect\022\020\n\010event_id"
  "\030\001 \001(\r\022\017\n\007slot_id\030\002 \001(\r\022\023\n\013sequence_id\030\003"
  " \001(\r\"\201\001\n\036CDOTAClientMsg_ChallengeReroll\022"
  "(\n\010event_id\030\001 \001(\0162\007.EEvent:\rEVENT_ID_NON"
  "E\022\017\n\007slot_id\030\002 \001(\r\022\023\n\013sequence_id\030\003 \001(\r\022"
  "\017\n\007hero_id\030\004 \001(\r\"0\n\030CDOTAClientMsg_CoinW"
  "ager\022\024\n\014wager_amount\030\001 \001(\r\"<\n\035CDOTAClien"
  "tMsg_CoinWagerToken\022\033\n\023wager_token_item_"
  "id\030\001 \001(\004\"2\n\030CDOTAClientMsg_RankWager\022\026\n\016"
  "announce_wager\030\001 \001(\010\"4\n\033CDOTAClientMsg_P"
  "layerBounty\022\025\n\tplayer_id\030\001 \001(\005:\002-1\"@\n\035CD"
  "OTAClientMsg_EventPointsTip\022\037\n\023recipient"
  "_player_id\030\001 \001(\005:\002-1\"C\n\034CDOTAClientMsg_E"
  "xecuteOrders\022#\n\006orders\030\001 \003(\0132\023.CDOTAMsg_"
  "UnitOrder\"K\n\026CDOTAClientMsg_XPAlert\022\033\n\017t"
  "arget_entindex\030\001 \001(\005:\002-1\022\024\n\014damage_taken"
  "\030\002 \001(\r\"t\n\036CDOTAClientMsg_TalentTreeAlert"
  "\022\033\n\017target_entindex\030\001 \001(\005:\002-1\022\026\n\nability"
  "_id\030\002 \001(\005:\002-1\022\014\n\004slot\030\003 \001(\005\022\017\n\007learned\030\004"
  " \001(\010\"\257\001\n!CDOTAClientMsg_KillcamDamageTak"
  "en\022\033\n\017target_entindex\030\001 \001(\005:\002-1\022\024\n\014damag"
  "e_taken\030\002 \001(\r\022\021\n\titem_type\030\003 \001(\r\022\033\n\017item"
  "_ability_id\030\004 \001(\005:\002-1\022\021\n\thero_name\030\005 \001(\t"
  "\022\024\n\014damage_color\030\006 \001(\t\"\033\n\031CDOTAClientMsg"
  "_KillMyHero\"\247\001\n\032CDOTAClientMsg_QuestStat"
  "us\022\020\n\010quest_id\030\001 \001(\r\022\024\n\014challenge_id\030\002 \001"
  "(\r\022\020\n\010progress\030\003 \001(\r\022\014\n\004goal\030\004 \001(\r\022\r\n\005qu"
  "ery\030\005 \001(\r\022\025\n\rfail_gametime\030\006 \001(\002\022\033\n\017item"
  "_ability_id\030\007 \001(\005:\002-1\"E\n\037CDOTAClientMsg_"
  "ToggleAutoattack\022\014\n\004mode\030\001 \001(\005\022\024\n\014show_m"
  "essage\030\002 \001(\010\"S\n\035CDOTAClientMsg_SpecialAb"
  "ility\022\025\n\rability_index\030\001 \001(\r\022\033\n\017target_e"
  "ntindex\030\002 \001(\005:\002-1\"g\n\'CDOTAClientMsg_SetE"
  "nemyStartingPosition\022\033\n\017enemy_player_id\030"
  "\001 \001(\005:\002-1\022\037\n\027enemy_starting_position\030\002 \001"
  "(\r\"\\\n&CDOTAClientMsg_SetDesiredWardPlace"
  "ment\022\022\n\nward_index\030\001 \001(\r\022\016\n\006ward_x\030\002 \001(\002"
  "\022\016\n\006ward_y\030\003 \001(\002\"S\n\027CDOTAClientMsg_RollD"
  "ice\022\024\n\014channel_type\030\001 \001(\r\022\020\n\010roll_min\030\002 "
  "\001(\r\022\020\n\010roll_max\030\003 \001(\r\"/\n\027CDOTAClientMsg_"
  "FlipCoin\022\024\n\014channel_type\030\001 \001(\r\"\'\n%CDOTAC"
  "lientMsg_RequestItemSuggestions\"7\n\036CDOTA"
  "ClientMsg_MakeTeamCaptain\022\025\n\tplayer_id\030\001"
  " \001(\005:\002-1\"A\n(CDOTAClientMsg_HelpTipSystem"
  "StateChanged\022\025\n\rtip_displayed\030\001 \001(\010\"~\n#C"
  "DOTAClientMsg_RequestBulkCombatLog\022\021\n\tga"
  "me_time\030\001 \001(\002\022\020\n\010duration\030\002 \001(\002\022\033\n\023recen"
  "t_player_death\030\003 \001(\010\022\025\n\tplayer_id\030\004 \001(\005:"
  "\002-1\"c\n)CDOTAClientMsg_AbilityDraftReques"
  "tAbility\022 \n\024requested_ability_id\030\001 \001(\005:\002"
  "-1\022\024\n\014ctrl_is_down\030\002 \001(\010\"M\n CDOTAClientM"
  "sg_GuideSelectOption\022\016\n\006option\030\001 \001(\r\022\031\n\021"
  "force_recalculate\030\002 \001(\010\"P\n\034CDOTAClientMs"
  "g_GuideSelected\022\031\n\021guide_workshop_id\030\001 \001"
  "(\004\022\025\n\ris_plus_guide\030\002 \001(\010\"w\n\033CDOTAClient"
  "Msg_DamageReport\022\026\n\016target_hero_id\030\001 \001(\r"
  "\022\026\n\016source_hero_id\030\002 \001(\r\022\025\n\rdamage_amoun"
  "t\030\003 \001(\005\022\021\n\tbroadcast\030\004 \001(\010\"M\n\033CDOTAClien"
  "tMsg_SalutePlayer\022\034\n\020target_player_id\030\001 "
  "\001(\005:\002-1\022\020\n\010event_id\030\002 \001(\005\"+\n\027CDOTAClient"
  "Msg_TipAlert\022\020\n\010tip_text\030\001 \001(\t\"@\n!CDOTAC"
  "lientMsg_EmptyTeleportAlert\022\033\n\017target_en"
  "tindex\030\001 \001(\005:\002-1\">\n\"CDOTAClientMsg_SetCa"
  "vernMapVariant\022\030\n\013map_variant\030\001 \001(\r:\003255"
  "\"\?\n\035CDOTAClientMsg_PauseGameOrder\022\020\n\010ord"
  "er_id\030\001 \001(\005\022\014\n\004data\030\002 \001(\005\"\220\002\n)CDOTAClien"
  "tMsg_VersusScene_PlayerBehavior\022S\n\010behav"
  "ior\030\001 \001(\0162\037.EDOTAVersusScenePlayerBehavi"
  "or: VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY\0220\n\r"
  "play_activity\030\002 \001(\0132\031.VersusScene_PlayAc"
  "tivity\022*\n\nchat_wheel\030\003 \001(\0132\026.VersusScene"
  "_ChatWheel\0220\n\rplayback_rate\030\004 \001(\0132\031.Vers"
  "usScene_PlaybackRate\"T\n!CDOTAClientMsg_E"
  "mptyItemSlotAlert\022\033\n\017target_entindex\030\001 \001"
  "(\005:\002-1\022\022\n\nslot_index\030\002 \001(\005\"\247\001\n\'CDOTAClie"
  "ntMsg_AddOverwatchReportMarker\022\034\n\020target"
  "_player_id\030\001 \001(\005:\002-1\022I\n\006reason\030\002 \001(\0162\027.E"
  "OverwatchReportReason: k_EOverwatchRepor"
  "tReason_Unknown\022\023\n\013seconds_ago\030\004 \001(\r\"L\n,"
  "CDOTAClientMsg_AddCommunicationsReportMa"
  "rker\022\034\n\020target_player_id\030\001 \001(\005:\002-1\"K\n+CD"
  "OTAClientMsg_AddCommunicationsBlockMarke"
  "r\022\034\n\020target_player_id\030\001 \001(\005:\002-1\"\215\001\n\036CDOT"
  "AClientMsg_AghsStatusAlert\022\034\n\020source_pla"
  "yer_id\030\001 \001(\005:\002-1\022\034\n\020target_player_id\030\002 \001"
  "(\005:\002-1\022\033\n\017target_entindex\030\003 \001(\005:\002-1\022\022\n\na"
  "lert_type\030\004 \001(\r\"\233\005\n\031CDOTAClientMsg_PerfR"
  "eport\022\032\n\022average_frame_time\030\001 \001(\002\022\026\n\016max"
  "_frame_time\030\002 \001(\002\022\034\n\024average_compute_tim"
  "e\030\003 \001(\002\022\030\n\020max_compute_time\030\004 \001(\002\022 \n\030ave"
  "rage_client_tick_time\030\005 \001(\002\022\034\n\024max_clien"
  "t_tick_time\030\006 \001(\002\022$\n\034average_client_simu"
  "late_time\030\007 \001(\002\022 \n\030max_client_simulate_t"
  "ime\030\010 \001(\002\022\033\n\023average_output_time\030\t \001(\002\022\027"
  "\n\017max_output_time\030\n \001(\002\0223\n+average_wait_"
  "for_rendering_to_complete_time\030\013 \001(\002\022/\n\'"
  "max_wait_for_rendering_to_complete_time\030"
  "\014 \001(\002\022\031\n\021average_swap_time\030\r \001(\002\022\025\n\rmax_"
  "swap_time\030\016 \001(\002\022!\n\031average_frame_update_"
  "time\030\017 \001(\002\022\035\n\025max_frame_update_time\030\020 \001("
  "\002\022\031\n\021average_idle_time\030\021 \001(\002\022\025\n\rmax_idle"
  "_time\030\022 \001(\002\022%\n\035average_input_processing_"
  "time\030\023 \001(\002\022!\n\031max_input_processing_time\030"
  "\024 \001(\002\"\210\001\n-CDOTAClientMsg_ContextualTips_"
  "Subscribe_Entry\022\023\n\013unsubscribe\030\001 \001(\010\022\016\n\006"
  "tip_id\030\002 \001(\005\022\033\n\023prior_display_count\030\003 \001("
  "\005\022\025\n\rvariants_seen\030\004 \003(\005\"g\n\'CDOTAClientM"
  "sg_ContextualTips_Subscribe\022<\n\004tips\030\001 \003("
  "\0132..CDOTAClientMsg_ContextualTips_Subscr"
  "ibe_Entry\"H\n\032CDOTAClientMsg_ChatMessage\022"
  "\024\n\014channel_type\030\001 \001(\r\022\024\n\014message_text\030\002 "
  "\001(\t\"_\n\033CDOTAClientMsg_DuelAccepted\022 \n\024ch"
  "allenger_player_id\030\001 \001(\005:\002-1\022\036\n\022accepter"
  "_player_id\030\002 \001(\005:\002-1*\376\025\n\023EDotaClientMess"
  "ages\022\024\n\017DOTA_CM_MapLine\020\255\002\022\030\n\023DOTA_CM_As"
  "pectRatio\020\256\002\022\024\n\017DOTA_CM_MapPing\020\257\002\022\034\n\027DO"
  "TA_CM_UnitsAutoAttack\020\260\002\022\031\n\024DOTA_CM_Sear"
  "chString\020\263\002\022\022\n\rDOTA_CM_Pause\020\264\002\022\031\n\024DOTA_"
  "CM_ShopViewMode\020\265\002\022\035\n\030DOTA_CM_SetUnitSha"
  "reFlag\020\266\002\022\030\n\023DOTA_CM_SwapRequest\020\267\002\022\027\n\022D"
  "OTA_CM_SwapAccept\020\270\002\022\026\n\021DOTA_CM_WorldLin"
  "e\020\271\002\022\037\n\032DOTA_CM_RequestGraphUpdate\020\272\002\022\026\n"
  "\021DOTA_CM_ItemAlert\020\273\002\022\026\n\021DOTA_CM_ChatWhe"
  "el\020\274\002\022\032\n\025DOTA_CM_SendStatPopup\020\275\002\022\"\n\035DOT"
  "A_CM_BeginLastHitChallenge\020\276\002\022\033\n\026DOTA_CM"
  "_UpdateQuickBuy\020\277\002\022\036\n\031DOTA_CM_UpdateCoac"
  "hListen\020\300\002\022\031\n\024DOTA_CM_CoachHUDPing\020\301\002\022\027\n"
  "\022DOTA_CM_RecordVote\020\302\002\022&\n!DOTA_CM_UnitsA"
  "utoAttackAfterSpell\020\303\002\022\036\n\031DOTA_CM_WillPu"
  "rchaseAlert\020\304\002\022\033\n\026DOTA_CM_PlayerShowCase"
  "\020\305\002\022!\n\034DOTA_CM_TeleportRequiresHalt\020\306\002\022\035"
  "\n\030DOTA_CM_CameraZoomAmount\020\307\002\022%\n DOTA_CM"
  "_BroadcasterUsingCamerman\020\310\002\0223\n.DOTA_CM_"
  "BroadcasterUsingAssistedCameraOperator\020\311"
  "\002\022\033\n\026DOTA_CM_EnemyItemAlert\020\312\002\022\032\n\025DOTA_C"
  "M_FreeInventory\020\313\002\022\036\n\031DOTA_CM_BuyBackSta"
  "teAlert\020\314\002\022\032\n\025DOTA_CM_QuickBuyAlert\020\315\002\022\033"
  "\n\026DOTA_CM_HeroStatueLike\020\316\002\022\032\n\025DOTA_CM_M"
  "odifierAlert\020\317\002\022\037\n\032DOTA_CM_TeamShowcaseE"
  "ditor\020\320\002\022\030\n\023DOTA_CM_HPManaAlert\020\321\002\022\027\n\022DO"
  "TA_CM_GlyphAlert\020\322\002\022#\n\036DOTA_CM_TeamShowc"
  "aseClientData\020\323\002\022\035\n\030DOTA_CM_PlayTeamShow"
  "case\020\324\002\022\034\n\027DOTA_CM_EventCNY2015Cmd\020\325\002\022#\n"
  "\036DOTA_CM_FillEmptySlotsWithBots\020\326\002\022\025\n\020DO"
  "TA_CM_DemoHero\020\327\002\022$\n\037DOTA_CM_AbilityLear"
  "nModeToggled\020\330\002\022\034\n\027DOTA_CM_AbilityStartU"
  "se\020\331\002\022\034\n\027DOTA_CM_ChallengeSelect\020\332\002\022\034\n\027D"
  "OTA_CM_ChallengeReroll\020\333\002\022\030\n\023DOTA_CM_Cli"
  "ckedBuff\020\334\002\022\026\n\021DOTA_CM_CoinWager\020\335\002\022\032\n\025D"
  "OTA_CM_ExecuteOrders\020\336\002\022\024\n\017DOTA_CM_XPAle"
  "rt\020\337\002\022\033\n\026DOTA_CM_EventPointsTip\020\341\002\022\027\n\022DO"
  "TA_CM_KillMyHero\020\343\002\022\030\n\023DOTA_CM_QuestStat"
  "us\020\344\002\022\035\n\030DOTA_CM_ToggleAutoattack\020\345\002\022\033\n\026"
  "DOTA_CM_SpecialAbility\020\346\002\022\037\n\032DOTA_CM_Kil"
  "lcamDamageTaken\020\347\002\022%\n DOTA_CM_SetEnemySt"
  "artingPosition\020\350\002\022$\n\037DOTA_CM_SetDesiredW"
  "ardPlacement\020\351\002\022\025\n\020DOTA_CM_RollDice\020\352\002\022\025"
  "\n\020DOTA_CM_FlipCoin\020\353\002\022#\n\036DOTA_CM_Request"
  "ItemSuggestions\020\354\002\022\034\n\027DOTA_CM_MakeTeamCa"
  "ptain\020\355\002\022\033\n\026DOTA_CM_CoinWagerToken\020\356\002\022\026\n"
  "\021DOTA_CM_RankWager\020\357\002\022!\n\034DOTA_CM_Dismiss"
  "AllStatPopups\020\360\002\022&\n!DOTA_CM_HelpTipSyste"
  "mStateChanged\020\361\002\022 \n\033DOTA_CM_ChannelRequi"
  "resHalt\020\362\002\022!\n\034DOTA_CM_RequestBulkCombatL"
  "og\020\363\002\022\'\n\"DOTA_CM_AbilityDraftRequestAbil"
  "ity\020\364\002\022\036\n\031DOTA_CM_GuideSelectOption\020\365\002\022\032"
  "\n\025DOTA_CM_GuideSelected\020\366\002\022\031\n\024DOTA_CM_Da"
  "mageReport\020\367\002\022\031\n\024DOTA_CM_SalutePlayer\020\370\002"
  "\022\027\n\022DOTA_CM_SprayWheel\020\371\002\022\025\n\020DOTA_CM_Tip"
  "Alert\020\372\002\022\037\n\032DOTA_CM_EmptyTeleportAlert\020\373"
  "\002\022\027\n\022DOTA_CM_RadarAlert\020\374\002\022\034\n\027DOTA_CM_Ta"
  "lentTreeAlert\020\375\002\022 \n\033DOTA_CM_SetCavernMap"
  "Variant\020\376\002\022\033\n\026DOTA_CM_PauseGameOrder\020\377\002\022"
  "\'\n\"DOTA_CM_VersusScene_PlayerBehavior\020\200\003"
  "\022\031\n\024DOTA_CM_PlayerBounty\020\201\003\022\037\n\032DOTA_CM_P"
  "layerBountyCancel\020\202\003\022\037\n\032DOTA_CM_EmptyIte"
  "mSlotAlert\020\204\003\022%\n DOTA_CM_AddOverwatchRep"
  "ortMarker\020\205\003\022\034\n\027DOTA_CM_AghsStatusAlert\020"
  "\206\003\022\027\n\022DOTA_CM_PerfReport\020\207\003\022%\n DOTA_CM_C"
  "ontextualTips_Subscribe\020\211\003\022\030\n\023DOTA_CM_Ch"
  "atMessage\020\212\003\022*\n%DOTA_CM_AddCommunication"
  "sReportMarker\020\213\003\022)\n$DOTA_CM_AddCommunica"
  "tionsBlockMarker\020\214\003\022\035\n\030DOTA_CM_NeutralCa"
  "mpAlert\020\215\003\022\031\n\024DOTA_CM_DuelAccepted\020\216\003"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_dota_5fclientmessages_2eproto_deps[2] = {
  &::descriptor_table_dota_5fcommonmessages_2eproto,
  &::descriptor_table_dota_5fshared_5fenums_2eproto,
};
static ::_pbi::once_flag descriptor_table_dota_5fclientmessages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_dota_5fclientmessages_2eproto = {
    false, false, 10677, descriptor_table_protodef_dota_5fclientmessages_2eproto,
    "dota_clientmessages.proto",
    &descriptor_table_dota_5fclientmessages_2eproto_once, descriptor_table_dota_5fclientmessages_2eproto_deps, 2, 84,
    schemas, file_default_instances, TableStruct_dota_5fclientmessages_2eproto::offsets,
    file_level_metadata_dota_5fclientmessages_2eproto, file_level_enum_descriptors_dota_5fclientmessages_2eproto,
    file_level_service_descriptors_dota_5fclientmessages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_dota_5fclientmessages_2eproto_getter() {
  return &descriptor_table_dota_5fclientmessages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_dota_5fclientmessages_2eproto(&descriptor_table_dota_5fclientmessages_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CDOTAClientMsg_UnitsAutoAttackMode_EMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fclientmessages_2eproto);
  return file_level_enum_descriptors_dota_5fclientmessages_2eproto[0];
}
bool CDOTAClientMsg_UnitsAutoAttackMode_EMode_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CDOTAClientMsg_UnitsAutoAttackMode_EMode CDOTAClientMsg_UnitsAutoAttackMode::INVALID;
constexpr CDOTAClientMsg_UnitsAutoAttackMode_EMode CDOTAClientMsg_UnitsAutoAttackMode::NEVER;
constexpr CDOTAClientMsg_UnitsAutoAttackMode_EMode CDOTAClientMsg_UnitsAutoAttackMode::AFTER_SPELLCAST;
constexpr CDOTAClientMsg_UnitsAutoAttackMode_EMode CDOTAClientMsg_UnitsAutoAttackMode::ALWAYS;
constexpr CDOTAClientMsg_UnitsAutoAttackMode_EMode CDOTAClientMsg_UnitsAutoAttackMode::EMode_MIN;
constexpr CDOTAClientMsg_UnitsAutoAttackMode_EMode CDOTAClientMsg_UnitsAutoAttackMode::EMode_MAX;
constexpr int CDOTAClientMsg_UnitsAutoAttackMode::EMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CDOTAClientMsg_UnitsAutoAttackMode_EUnitType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fclientmessages_2eproto);
  return file_level_enum_descriptors_dota_5fclientmessages_2eproto[1];
}
bool CDOTAClientMsg_UnitsAutoAttackMode_EUnitType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CDOTAClientMsg_UnitsAutoAttackMode_EUnitType CDOTAClientMsg_UnitsAutoAttackMode::NORMAL;
constexpr CDOTAClientMsg_UnitsAutoAttackMode_EUnitType CDOTAClientMsg_UnitsAutoAttackMode::SUMMONED;
constexpr CDOTAClientMsg_UnitsAutoAttackMode_EUnitType CDOTAClientMsg_UnitsAutoAttackMode::EUnitType_MIN;
constexpr CDOTAClientMsg_UnitsAutoAttackMode_EUnitType CDOTAClientMsg_UnitsAutoAttackMode::EUnitType_MAX;
constexpr int CDOTAClientMsg_UnitsAutoAttackMode::EUnitType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDotaClientMessages_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fclientmessages_2eproto);
  return file_level_enum_descriptors_dota_5fclientmessages_2eproto[2];
}
bool EDotaClientMessages_IsValid(int value) {
  switch (value) {
    case 301:
    case 302:
    case 303:
    case 304:
    case 307:
    case 308:
    case 309:
    case 310:
    case 311:
    case 312:
    case 313:
    case 314:
    case 315:
    case 316:
    case 317:
    case 318:
    case 319:
    case 320:
    case 321:
    case 322:
    case 323:
    case 324:
    case 325:
    case 326:
    case 327:
    case 328:
    case 329:
    case 330:
    case 331:
    case 332:
    case 333:
    case 334:
    case 335:
    case 336:
    case 337:
    case 338:
    case 339:
    case 340:
    case 341:
    case 342:
    case 343:
    case 344:
    case 345:
    case 346:
    case 347:
    case 348:
    case 349:
    case 350:
    case 351:
    case 353:
    case 355:
    case 356:
    case 357:
    case 358:
    case 359:
    case 360:
    case 361:
    case 362:
    case 363:
    case 364:
    case 365:
    case 366:
    case 367:
    case 368:
    case 369:
    case 370:
    case 371:
    case 372:
    case 373:
    case 374:
    case 375:
    case 376:
    case 377:
    case 378:
    case 379:
    case 380:
    case 381:
    case 382:
    case 383:
    case 384:
    case 385:
    case 386:
    case 388:
    case 389:
    case 390:
    case 391:
    case 393:
    case 394:
    case 395:
    case 396:
    case 397:
    case 398:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CDOTAClientMsg_MapPing::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_MapPing>()._impl_._has_bits_);
  static const ::CDOTAMsg_LocationPing& location_ping(const CDOTAClientMsg_MapPing* msg);
  static void set_has_location_ping(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CDOTAMsg_LocationPing&
CDOTAClientMsg_MapPing::_Internal::location_ping(const CDOTAClientMsg_MapPing* msg) {
  return *msg->_impl_.location_ping_;
}
void CDOTAClientMsg_MapPing::clear_location_ping() {
  if (_impl_.location_ping_ != nullptr) _impl_.location_ping_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CDOTAClientMsg_MapPing::CDOTAClientMsg_MapPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_MapPing)
}
CDOTAClientMsg_MapPing::CDOTAClientMsg_MapPing(const CDOTAClientMsg_MapPing& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_MapPing* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.location_ping_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_location_ping()) {
    _this->_impl_.location_ping_ = new ::CDOTAMsg_LocationPing(*from._impl_.location_ping_);
  }
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_MapPing)
}

inline void CDOTAClientMsg_MapPing::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.location_ping_){nullptr}
  };
}

CDOTAClientMsg_MapPing::~CDOTAClientMsg_MapPing() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_MapPing)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_MapPing::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.location_ping_;
}

void CDOTAClientMsg_MapPing::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_MapPing::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_MapPing)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.location_ping_ != nullptr);
    _impl_.location_ping_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_MapPing::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CDOTAMsg_LocationPing location_ping = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_location_ping(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_MapPing::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_MapPing)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CDOTAMsg_LocationPing location_ping = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::location_ping(this),
        _Internal::location_ping(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_MapPing)
  return target;
}

size_t CDOTAClientMsg_MapPing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_MapPing)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CDOTAMsg_LocationPing location_ping = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.location_ping_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_MapPing::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_MapPing::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_MapPing::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_MapPing::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_MapPing*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_MapPing&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_MapPing)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_location_ping()) {
    _this->_internal_mutable_location_ping()->::CDOTAMsg_LocationPing::MergeFrom(
        from._internal_location_ping());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_MapPing::CopyFrom(const CDOTAClientMsg_MapPing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_MapPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_MapPing::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_MapPing::InternalSwap(CDOTAClientMsg_MapPing* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.location_ping_, other->_impl_.location_ping_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_MapPing::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[0]);
}

// ===================================================================

class CDOTAClientMsg_ItemAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_ItemAlert>()._impl_._has_bits_);
  static const ::CDOTAMsg_ItemAlert& item_alert(const CDOTAClientMsg_ItemAlert* msg);
  static void set_has_item_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CDOTAMsg_ItemAlert&
CDOTAClientMsg_ItemAlert::_Internal::item_alert(const CDOTAClientMsg_ItemAlert* msg) {
  return *msg->_impl_.item_alert_;
}
void CDOTAClientMsg_ItemAlert::clear_item_alert() {
  if (_impl_.item_alert_ != nullptr) _impl_.item_alert_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CDOTAClientMsg_ItemAlert::CDOTAClientMsg_ItemAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ItemAlert)
}
CDOTAClientMsg_ItemAlert::CDOTAClientMsg_ItemAlert(const CDOTAClientMsg_ItemAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ItemAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_alert_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_item_alert()) {
    _this->_impl_.item_alert_ = new ::CDOTAMsg_ItemAlert(*from._impl_.item_alert_);
  }
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ItemAlert)
}

inline void CDOTAClientMsg_ItemAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_alert_){nullptr}
  };
}

CDOTAClientMsg_ItemAlert::~CDOTAClientMsg_ItemAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ItemAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ItemAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.item_alert_;
}

void CDOTAClientMsg_ItemAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ItemAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ItemAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.item_alert_ != nullptr);
    _impl_.item_alert_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ItemAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CDOTAMsg_ItemAlert item_alert = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_item_alert(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ItemAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ItemAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CDOTAMsg_ItemAlert item_alert = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::item_alert(this),
        _Internal::item_alert(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ItemAlert)
  return target;
}

size_t CDOTAClientMsg_ItemAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ItemAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CDOTAMsg_ItemAlert item_alert = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.item_alert_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ItemAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ItemAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ItemAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ItemAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ItemAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ItemAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ItemAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_item_alert()) {
    _this->_internal_mutable_item_alert()->::CDOTAMsg_ItemAlert::MergeFrom(
        from._internal_item_alert());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ItemAlert::CopyFrom(const CDOTAClientMsg_ItemAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ItemAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ItemAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ItemAlert::InternalSwap(CDOTAClientMsg_ItemAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.item_alert_, other->_impl_.item_alert_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ItemAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[1]);
}

// ===================================================================

class CDOTAClientMsg_EnemyItemAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_EnemyItemAlert>()._impl_._has_bits_);
  static void set_has_item_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rune_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_item_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_primary_charges(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_secondary_charges(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_EnemyItemAlert::CDOTAClientMsg_EnemyItemAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_EnemyItemAlert)
}
CDOTAClientMsg_EnemyItemAlert::CDOTAClientMsg_EnemyItemAlert(const CDOTAClientMsg_EnemyItemAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_EnemyItemAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secondary_charges_){}
    , decltype(_impl_.item_entindex_){}
    , decltype(_impl_.rune_type_){}
    , decltype(_impl_.item_level_){}
    , decltype(_impl_.primary_charges_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.secondary_charges_, &from._impl_.secondary_charges_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.primary_charges_) -
    reinterpret_cast<char*>(&_impl_.secondary_charges_)) + sizeof(_impl_.primary_charges_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_EnemyItemAlert)
}

inline void CDOTAClientMsg_EnemyItemAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secondary_charges_){-1}
    , decltype(_impl_.item_entindex_){-1}
    , decltype(_impl_.rune_type_){-1}
    , decltype(_impl_.item_level_){-1}
    , decltype(_impl_.primary_charges_){-1}
  };
}

CDOTAClientMsg_EnemyItemAlert::~CDOTAClientMsg_EnemyItemAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_EnemyItemAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_EnemyItemAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_EnemyItemAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_EnemyItemAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_EnemyItemAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    _impl_.secondary_charges_ = -1;
    _impl_.item_entindex_ = -1;
    _impl_.rune_type_ = -1;
    _impl_.item_level_ = -1;
    _impl_.primary_charges_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_EnemyItemAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 item_entindex = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_entindex(&has_bits);
          _impl_.item_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rune_type = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rune_type(&has_bits);
          _impl_.rune_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_level = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_level(&has_bits);
          _impl_.item_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 primary_charges = 4 [default = -1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_primary_charges(&has_bits);
          _impl_.primary_charges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 secondary_charges = 5 [default = -1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_secondary_charges(&has_bits);
          _impl_.secondary_charges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_EnemyItemAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_EnemyItemAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 item_entindex = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_item_entindex(), target);
  }

  // optional int32 rune_type = 2 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_rune_type(), target);
  }

  // optional int32 item_level = 3 [default = -1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_item_level(), target);
  }

  // optional int32 primary_charges = 4 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_primary_charges(), target);
  }

  // optional int32 secondary_charges = 5 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_secondary_charges(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_EnemyItemAlert)
  return target;
}

size_t CDOTAClientMsg_EnemyItemAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_EnemyItemAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 secondary_charges = 5 [default = -1];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_secondary_charges());
    }

    // optional int32 item_entindex = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_entindex());
    }

    // optional int32 rune_type = 2 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rune_type());
    }

    // optional int32 item_level = 3 [default = -1];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_level());
    }

    // optional int32 primary_charges = 4 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_primary_charges());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_EnemyItemAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_EnemyItemAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_EnemyItemAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_EnemyItemAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_EnemyItemAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_EnemyItemAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_EnemyItemAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.secondary_charges_ = from._impl_.secondary_charges_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_entindex_ = from._impl_.item_entindex_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rune_type_ = from._impl_.rune_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.item_level_ = from._impl_.item_level_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.primary_charges_ = from._impl_.primary_charges_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_EnemyItemAlert::CopyFrom(const CDOTAClientMsg_EnemyItemAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_EnemyItemAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_EnemyItemAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_EnemyItemAlert::InternalSwap(CDOTAClientMsg_EnemyItemAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.secondary_charges_, other->_impl_.secondary_charges_);
  swap(_impl_.item_entindex_, other->_impl_.item_entindex_);
  swap(_impl_.rune_type_, other->_impl_.rune_type_);
  swap(_impl_.item_level_, other->_impl_.item_level_);
  swap(_impl_.primary_charges_, other->_impl_.primary_charges_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_EnemyItemAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[2]);
}

// ===================================================================

class CDOTAClientMsg_ModifierAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_ModifierAlert>()._impl_._has_bits_);
  static void set_has_buff_internal_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_target_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_ModifierAlert::CDOTAClientMsg_ModifierAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ModifierAlert)
}
CDOTAClientMsg_ModifierAlert::CDOTAClientMsg_ModifierAlert(const CDOTAClientMsg_ModifierAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ModifierAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buff_internal_index_){}
    , decltype(_impl_.target_entindex_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.buff_internal_index_, &from._impl_.buff_internal_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_entindex_) -
    reinterpret_cast<char*>(&_impl_.buff_internal_index_)) + sizeof(_impl_.target_entindex_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ModifierAlert)
}

inline void CDOTAClientMsg_ModifierAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buff_internal_index_){0}
    , decltype(_impl_.target_entindex_){-1}
  };
}

CDOTAClientMsg_ModifierAlert::~CDOTAClientMsg_ModifierAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ModifierAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ModifierAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_ModifierAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ModifierAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ModifierAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.buff_internal_index_ = 0;
    _impl_.target_entindex_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ModifierAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 buff_internal_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_buff_internal_index(&has_bits);
          _impl_.buff_internal_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_entindex = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_target_entindex(&has_bits);
          _impl_.target_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ModifierAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ModifierAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 buff_internal_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_buff_internal_index(), target);
  }

  // optional int32 target_entindex = 2 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_target_entindex(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ModifierAlert)
  return target;
}

size_t CDOTAClientMsg_ModifierAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ModifierAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 buff_internal_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_buff_internal_index());
    }

    // optional int32 target_entindex = 2 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_entindex());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ModifierAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ModifierAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ModifierAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ModifierAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ModifierAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ModifierAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ModifierAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.buff_internal_index_ = from._impl_.buff_internal_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_entindex_ = from._impl_.target_entindex_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ModifierAlert::CopyFrom(const CDOTAClientMsg_ModifierAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ModifierAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ModifierAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ModifierAlert::InternalSwap(CDOTAClientMsg_ModifierAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.buff_internal_index_, other->_impl_.buff_internal_index_);
  swap(_impl_.target_entindex_, other->_impl_.target_entindex_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ModifierAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[3]);
}

// ===================================================================

class CDOTAClientMsg_ClickedBuff::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_ClickedBuff>()._impl_._has_bits_);
  static void set_has_buff_internal_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_target_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_ClickedBuff::CDOTAClientMsg_ClickedBuff(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ClickedBuff)
}
CDOTAClientMsg_ClickedBuff::CDOTAClientMsg_ClickedBuff(const CDOTAClientMsg_ClickedBuff& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ClickedBuff* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buff_internal_index_){}
    , decltype(_impl_.target_entindex_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.buff_internal_index_, &from._impl_.buff_internal_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_entindex_) -
    reinterpret_cast<char*>(&_impl_.buff_internal_index_)) + sizeof(_impl_.target_entindex_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ClickedBuff)
}

inline void CDOTAClientMsg_ClickedBuff::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buff_internal_index_){0}
    , decltype(_impl_.target_entindex_){-1}
  };
}

CDOTAClientMsg_ClickedBuff::~CDOTAClientMsg_ClickedBuff() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ClickedBuff)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ClickedBuff::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_ClickedBuff::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ClickedBuff::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ClickedBuff)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.buff_internal_index_ = 0;
    _impl_.target_entindex_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ClickedBuff::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 buff_internal_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_buff_internal_index(&has_bits);
          _impl_.buff_internal_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_entindex = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_target_entindex(&has_bits);
          _impl_.target_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ClickedBuff::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ClickedBuff)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 buff_internal_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_buff_internal_index(), target);
  }

  // optional int32 target_entindex = 2 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_target_entindex(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ClickedBuff)
  return target;
}

size_t CDOTAClientMsg_ClickedBuff::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ClickedBuff)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 buff_internal_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_buff_internal_index());
    }

    // optional int32 target_entindex = 2 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_entindex());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ClickedBuff::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ClickedBuff::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ClickedBuff::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ClickedBuff::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ClickedBuff*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ClickedBuff&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ClickedBuff)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.buff_internal_index_ = from._impl_.buff_internal_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_entindex_ = from._impl_.target_entindex_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ClickedBuff::CopyFrom(const CDOTAClientMsg_ClickedBuff& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ClickedBuff)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ClickedBuff::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ClickedBuff::InternalSwap(CDOTAClientMsg_ClickedBuff* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.buff_internal_index_, other->_impl_.buff_internal_index_);
  swap(_impl_.target_entindex_, other->_impl_.target_entindex_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ClickedBuff::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[4]);
}

// ===================================================================

class CDOTAClientMsg_HPManaAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_HPManaAlert>()._impl_._has_bits_);
  static void set_has_target_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_show_raw_values(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_HPManaAlert::CDOTAClientMsg_HPManaAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_HPManaAlert)
}
CDOTAClientMsg_HPManaAlert::CDOTAClientMsg_HPManaAlert(const CDOTAClientMsg_HPManaAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_HPManaAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.show_raw_values_){}
    , decltype(_impl_.target_entindex_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.show_raw_values_, &from._impl_.show_raw_values_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_entindex_) -
    reinterpret_cast<char*>(&_impl_.show_raw_values_)) + sizeof(_impl_.target_entindex_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_HPManaAlert)
}

inline void CDOTAClientMsg_HPManaAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.show_raw_values_){false}
    , decltype(_impl_.target_entindex_){-1}
  };
}

CDOTAClientMsg_HPManaAlert::~CDOTAClientMsg_HPManaAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_HPManaAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_HPManaAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_HPManaAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_HPManaAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_HPManaAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.show_raw_values_ = false;
    _impl_.target_entindex_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_HPManaAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 target_entindex = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_target_entindex(&has_bits);
          _impl_.target_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_raw_values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_show_raw_values(&has_bits);
          _impl_.show_raw_values_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_HPManaAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_HPManaAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 target_entindex = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_target_entindex(), target);
  }

  // optional bool show_raw_values = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_show_raw_values(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_HPManaAlert)
  return target;
}

size_t CDOTAClientMsg_HPManaAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_HPManaAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool show_raw_values = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 target_entindex = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_entindex());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_HPManaAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_HPManaAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_HPManaAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_HPManaAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_HPManaAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_HPManaAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_HPManaAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.show_raw_values_ = from._impl_.show_raw_values_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_entindex_ = from._impl_.target_entindex_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_HPManaAlert::CopyFrom(const CDOTAClientMsg_HPManaAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_HPManaAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_HPManaAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_HPManaAlert::InternalSwap(CDOTAClientMsg_HPManaAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.show_raw_values_, other->_impl_.show_raw_values_);
  swap(_impl_.target_entindex_, other->_impl_.target_entindex_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_HPManaAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[5]);
}

// ===================================================================

class CDOTAClientMsg_NeutralCampAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_NeutralCampAlert>()._impl_._has_bits_);
  static void set_has_spawner_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_unit_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stack_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_NeutralCampAlert::CDOTAClientMsg_NeutralCampAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_NeutralCampAlert)
}
CDOTAClientMsg_NeutralCampAlert::CDOTAClientMsg_NeutralCampAlert(const CDOTAClientMsg_NeutralCampAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_NeutralCampAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stack_request_){}
    , decltype(_impl_.spawner_entindex_){}
    , decltype(_impl_.unit_entindex_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.stack_request_, &from._impl_.stack_request_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.unit_entindex_) -
    reinterpret_cast<char*>(&_impl_.stack_request_)) + sizeof(_impl_.unit_entindex_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_NeutralCampAlert)
}

inline void CDOTAClientMsg_NeutralCampAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stack_request_){false}
    , decltype(_impl_.spawner_entindex_){-1}
    , decltype(_impl_.unit_entindex_){-1}
  };
}

CDOTAClientMsg_NeutralCampAlert::~CDOTAClientMsg_NeutralCampAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_NeutralCampAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_NeutralCampAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_NeutralCampAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_NeutralCampAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_NeutralCampAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    _impl_.stack_request_ = false;
    _impl_.spawner_entindex_ = -1;
    _impl_.unit_entindex_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_NeutralCampAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 spawner_entindex = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_spawner_entindex(&has_bits);
          _impl_.spawner_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 unit_entindex = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_unit_entindex(&has_bits);
          _impl_.unit_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool stack_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_stack_request(&has_bits);
          _impl_.stack_request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_NeutralCampAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_NeutralCampAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 spawner_entindex = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_spawner_entindex(), target);
  }

  // optional int32 unit_entindex = 2 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_unit_entindex(), target);
  }

  // optional bool stack_request = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_stack_request(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_NeutralCampAlert)
  return target;
}

size_t CDOTAClientMsg_NeutralCampAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_NeutralCampAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool stack_request = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 spawner_entindex = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_spawner_entindex());
    }

    // optional int32 unit_entindex = 2 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_unit_entindex());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_NeutralCampAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_NeutralCampAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_NeutralCampAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_NeutralCampAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_NeutralCampAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_NeutralCampAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_NeutralCampAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.stack_request_ = from._impl_.stack_request_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.spawner_entindex_ = from._impl_.spawner_entindex_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.unit_entindex_ = from._impl_.unit_entindex_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_NeutralCampAlert::CopyFrom(const CDOTAClientMsg_NeutralCampAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_NeutralCampAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_NeutralCampAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_NeutralCampAlert::InternalSwap(CDOTAClientMsg_NeutralCampAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.stack_request_, other->_impl_.stack_request_);
  swap(_impl_.spawner_entindex_, other->_impl_.spawner_entindex_);
  swap(_impl_.unit_entindex_, other->_impl_.unit_entindex_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_NeutralCampAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[6]);
}

// ===================================================================

class CDOTAClientMsg_GlyphAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_GlyphAlert>()._impl_._has_bits_);
  static void set_has_negative(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_GlyphAlert::CDOTAClientMsg_GlyphAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_GlyphAlert)
}
CDOTAClientMsg_GlyphAlert::CDOTAClientMsg_GlyphAlert(const CDOTAClientMsg_GlyphAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_GlyphAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.negative_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.negative_ = from._impl_.negative_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_GlyphAlert)
}

inline void CDOTAClientMsg_GlyphAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.negative_){false}
  };
}

CDOTAClientMsg_GlyphAlert::~CDOTAClientMsg_GlyphAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_GlyphAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_GlyphAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_GlyphAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_GlyphAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_GlyphAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.negative_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_GlyphAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool negative = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_negative(&has_bits);
          _impl_.negative_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_GlyphAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_GlyphAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool negative = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_negative(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_GlyphAlert)
  return target;
}

size_t CDOTAClientMsg_GlyphAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_GlyphAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool negative = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_GlyphAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_GlyphAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_GlyphAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_GlyphAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_GlyphAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_GlyphAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_GlyphAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_negative()) {
    _this->_internal_set_negative(from._internal_negative());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_GlyphAlert::CopyFrom(const CDOTAClientMsg_GlyphAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_GlyphAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_GlyphAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_GlyphAlert::InternalSwap(CDOTAClientMsg_GlyphAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.negative_, other->_impl_.negative_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_GlyphAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[7]);
}

// ===================================================================

class CDOTAClientMsg_RadarAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_RadarAlert>()._impl_._has_bits_);
  static void set_has_negative(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_RadarAlert::CDOTAClientMsg_RadarAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_RadarAlert)
}
CDOTAClientMsg_RadarAlert::CDOTAClientMsg_RadarAlert(const CDOTAClientMsg_RadarAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_RadarAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.negative_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.negative_ = from._impl_.negative_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_RadarAlert)
}

inline void CDOTAClientMsg_RadarAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.negative_){false}
  };
}

CDOTAClientMsg_RadarAlert::~CDOTAClientMsg_RadarAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_RadarAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_RadarAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_RadarAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_RadarAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_RadarAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.negative_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_RadarAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool negative = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_negative(&has_bits);
          _impl_.negative_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_RadarAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_RadarAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool negative = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_negative(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_RadarAlert)
  return target;
}

size_t CDOTAClientMsg_RadarAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_RadarAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool negative = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_RadarAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_RadarAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_RadarAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_RadarAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_RadarAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_RadarAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_RadarAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_negative()) {
    _this->_internal_set_negative(from._internal_negative());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_RadarAlert::CopyFrom(const CDOTAClientMsg_RadarAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_RadarAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_RadarAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_RadarAlert::InternalSwap(CDOTAClientMsg_RadarAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.negative_, other->_impl_.negative_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_RadarAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[8]);
}

// ===================================================================

class CDOTAClientMsg_MapLine::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_MapLine>()._impl_._has_bits_);
  static const ::CDOTAMsg_MapLine& mapline(const CDOTAClientMsg_MapLine* msg);
  static void set_has_mapline(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CDOTAMsg_MapLine&
CDOTAClientMsg_MapLine::_Internal::mapline(const CDOTAClientMsg_MapLine* msg) {
  return *msg->_impl_.mapline_;
}
void CDOTAClientMsg_MapLine::clear_mapline() {
  if (_impl_.mapline_ != nullptr) _impl_.mapline_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CDOTAClientMsg_MapLine::CDOTAClientMsg_MapLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_MapLine)
}
CDOTAClientMsg_MapLine::CDOTAClientMsg_MapLine(const CDOTAClientMsg_MapLine& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_MapLine* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mapline_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_mapline()) {
    _this->_impl_.mapline_ = new ::CDOTAMsg_MapLine(*from._impl_.mapline_);
  }
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_MapLine)
}

inline void CDOTAClientMsg_MapLine::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mapline_){nullptr}
  };
}

CDOTAClientMsg_MapLine::~CDOTAClientMsg_MapLine() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_MapLine)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_MapLine::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.mapline_;
}

void CDOTAClientMsg_MapLine::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_MapLine::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_MapLine)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.mapline_ != nullptr);
    _impl_.mapline_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_MapLine::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CDOTAMsg_MapLine mapline = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_mapline(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_MapLine::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_MapLine)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CDOTAMsg_MapLine mapline = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::mapline(this),
        _Internal::mapline(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_MapLine)
  return target;
}

size_t CDOTAClientMsg_MapLine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_MapLine)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CDOTAMsg_MapLine mapline = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.mapline_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_MapLine::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_MapLine::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_MapLine::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_MapLine::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_MapLine*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_MapLine&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_MapLine)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mapline()) {
    _this->_internal_mutable_mapline()->::CDOTAMsg_MapLine::MergeFrom(
        from._internal_mapline());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_MapLine::CopyFrom(const CDOTAClientMsg_MapLine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_MapLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_MapLine::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_MapLine::InternalSwap(CDOTAClientMsg_MapLine* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.mapline_, other->_impl_.mapline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_MapLine::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[9]);
}

// ===================================================================

class CDOTAClientMsg_AspectRatio::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_AspectRatio>()._impl_._has_bits_);
  static void set_has_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_AspectRatio::CDOTAClientMsg_AspectRatio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_AspectRatio)
}
CDOTAClientMsg_AspectRatio::CDOTAClientMsg_AspectRatio(const CDOTAClientMsg_AspectRatio& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_AspectRatio* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ratio_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.ratio_ = from._impl_.ratio_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_AspectRatio)
}

inline void CDOTAClientMsg_AspectRatio::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ratio_){0}
  };
}

CDOTAClientMsg_AspectRatio::~CDOTAClientMsg_AspectRatio() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_AspectRatio)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_AspectRatio::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_AspectRatio::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_AspectRatio::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_AspectRatio)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ratio_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_AspectRatio::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float ratio = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_ratio(&has_bits);
          _impl_.ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_AspectRatio::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_AspectRatio)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float ratio = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_ratio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_AspectRatio)
  return target;
}

size_t CDOTAClientMsg_AspectRatio::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_AspectRatio)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float ratio = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_AspectRatio::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_AspectRatio::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_AspectRatio::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_AspectRatio::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_AspectRatio*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_AspectRatio&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_AspectRatio)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ratio()) {
    _this->_internal_set_ratio(from._internal_ratio());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_AspectRatio::CopyFrom(const CDOTAClientMsg_AspectRatio& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_AspectRatio)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_AspectRatio::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_AspectRatio::InternalSwap(CDOTAClientMsg_AspectRatio* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.ratio_, other->_impl_.ratio_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_AspectRatio::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[10]);
}

// ===================================================================

class CDOTAClientMsg_UnitsAutoAttackMode::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_UnitsAutoAttackMode>()._impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_unit_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_UnitsAutoAttackMode::CDOTAClientMsg_UnitsAutoAttackMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_UnitsAutoAttackMode)
}
CDOTAClientMsg_UnitsAutoAttackMode::CDOTAClientMsg_UnitsAutoAttackMode(const CDOTAClientMsg_UnitsAutoAttackMode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_UnitsAutoAttackMode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unit_type_){}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.unit_type_, &from._impl_.unit_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mode_) -
    reinterpret_cast<char*>(&_impl_.unit_type_)) + sizeof(_impl_.mode_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_UnitsAutoAttackMode)
}

inline void CDOTAClientMsg_UnitsAutoAttackMode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unit_type_){0}
    , decltype(_impl_.mode_){-1}
  };
}

CDOTAClientMsg_UnitsAutoAttackMode::~CDOTAClientMsg_UnitsAutoAttackMode() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_UnitsAutoAttackMode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_UnitsAutoAttackMode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_UnitsAutoAttackMode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_UnitsAutoAttackMode::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_UnitsAutoAttackMode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.unit_type_ = 0;
    _impl_.mode_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_UnitsAutoAttackMode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CDOTAClientMsg_UnitsAutoAttackMode.EMode mode = 1 [default = INVALID];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CDOTAClientMsg_UnitsAutoAttackMode_EMode_IsValid(val))) {
            _internal_set_mode(static_cast<::CDOTAClientMsg_UnitsAutoAttackMode_EMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CDOTAClientMsg_UnitsAutoAttackMode.EUnitType unit_type = 2 [default = NORMAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CDOTAClientMsg_UnitsAutoAttackMode_EUnitType_IsValid(val))) {
            _internal_set_unit_type(static_cast<::CDOTAClientMsg_UnitsAutoAttackMode_EUnitType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_UnitsAutoAttackMode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_UnitsAutoAttackMode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CDOTAClientMsg_UnitsAutoAttackMode.EMode mode = 1 [default = INVALID];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  // optional .CDOTAClientMsg_UnitsAutoAttackMode.EUnitType unit_type = 2 [default = NORMAL];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_unit_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_UnitsAutoAttackMode)
  return target;
}

size_t CDOTAClientMsg_UnitsAutoAttackMode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_UnitsAutoAttackMode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CDOTAClientMsg_UnitsAutoAttackMode.EUnitType unit_type = 2 [default = NORMAL];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_unit_type());
    }

    // optional .CDOTAClientMsg_UnitsAutoAttackMode.EMode mode = 1 [default = INVALID];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_UnitsAutoAttackMode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_UnitsAutoAttackMode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_UnitsAutoAttackMode::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_UnitsAutoAttackMode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_UnitsAutoAttackMode*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_UnitsAutoAttackMode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_UnitsAutoAttackMode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.unit_type_ = from._impl_.unit_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_UnitsAutoAttackMode::CopyFrom(const CDOTAClientMsg_UnitsAutoAttackMode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_UnitsAutoAttackMode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_UnitsAutoAttackMode::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_UnitsAutoAttackMode::InternalSwap(CDOTAClientMsg_UnitsAutoAttackMode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.unit_type_, other->_impl_.unit_type_);
  swap(_impl_.mode_, other->_impl_.mode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_UnitsAutoAttackMode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[11]);
}

// ===================================================================

class CDOTAClientMsg_UnitsAutoAttackAfterSpell::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_UnitsAutoAttackAfterSpell>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_UnitsAutoAttackAfterSpell::CDOTAClientMsg_UnitsAutoAttackAfterSpell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_UnitsAutoAttackAfterSpell)
}
CDOTAClientMsg_UnitsAutoAttackAfterSpell::CDOTAClientMsg_UnitsAutoAttackAfterSpell(const CDOTAClientMsg_UnitsAutoAttackAfterSpell& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_UnitsAutoAttackAfterSpell* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_UnitsAutoAttackAfterSpell)
}

inline void CDOTAClientMsg_UnitsAutoAttackAfterSpell::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

CDOTAClientMsg_UnitsAutoAttackAfterSpell::~CDOTAClientMsg_UnitsAutoAttackAfterSpell() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_UnitsAutoAttackAfterSpell)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_UnitsAutoAttackAfterSpell::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_UnitsAutoAttackAfterSpell::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_UnitsAutoAttackAfterSpell::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_UnitsAutoAttackAfterSpell)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_UnitsAutoAttackAfterSpell::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_UnitsAutoAttackAfterSpell::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_UnitsAutoAttackAfterSpell)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_UnitsAutoAttackAfterSpell)
  return target;
}

size_t CDOTAClientMsg_UnitsAutoAttackAfterSpell::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_UnitsAutoAttackAfterSpell)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_UnitsAutoAttackAfterSpell::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_UnitsAutoAttackAfterSpell::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_UnitsAutoAttackAfterSpell::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_UnitsAutoAttackAfterSpell::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_UnitsAutoAttackAfterSpell*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_UnitsAutoAttackAfterSpell&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_UnitsAutoAttackAfterSpell)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_UnitsAutoAttackAfterSpell::CopyFrom(const CDOTAClientMsg_UnitsAutoAttackAfterSpell& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_UnitsAutoAttackAfterSpell)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_UnitsAutoAttackAfterSpell::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_UnitsAutoAttackAfterSpell::InternalSwap(CDOTAClientMsg_UnitsAutoAttackAfterSpell* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_UnitsAutoAttackAfterSpell::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[12]);
}

// ===================================================================

class CDOTAClientMsg_TeleportRequiresHalt::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_TeleportRequiresHalt>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_TeleportRequiresHalt::CDOTAClientMsg_TeleportRequiresHalt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_TeleportRequiresHalt)
}
CDOTAClientMsg_TeleportRequiresHalt::CDOTAClientMsg_TeleportRequiresHalt(const CDOTAClientMsg_TeleportRequiresHalt& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_TeleportRequiresHalt* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_TeleportRequiresHalt)
}

inline void CDOTAClientMsg_TeleportRequiresHalt::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

CDOTAClientMsg_TeleportRequiresHalt::~CDOTAClientMsg_TeleportRequiresHalt() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_TeleportRequiresHalt)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_TeleportRequiresHalt::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_TeleportRequiresHalt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_TeleportRequiresHalt::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_TeleportRequiresHalt)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_TeleportRequiresHalt::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_TeleportRequiresHalt::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_TeleportRequiresHalt)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_TeleportRequiresHalt)
  return target;
}

size_t CDOTAClientMsg_TeleportRequiresHalt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_TeleportRequiresHalt)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_TeleportRequiresHalt::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_TeleportRequiresHalt::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_TeleportRequiresHalt::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_TeleportRequiresHalt::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_TeleportRequiresHalt*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_TeleportRequiresHalt&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_TeleportRequiresHalt)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_TeleportRequiresHalt::CopyFrom(const CDOTAClientMsg_TeleportRequiresHalt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_TeleportRequiresHalt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_TeleportRequiresHalt::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_TeleportRequiresHalt::InternalSwap(CDOTAClientMsg_TeleportRequiresHalt* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_TeleportRequiresHalt::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[13]);
}

// ===================================================================

class CDOTAClientMsg_ChannelRequiresHalt::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_ChannelRequiresHalt>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_ChannelRequiresHalt::CDOTAClientMsg_ChannelRequiresHalt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ChannelRequiresHalt)
}
CDOTAClientMsg_ChannelRequiresHalt::CDOTAClientMsg_ChannelRequiresHalt(const CDOTAClientMsg_ChannelRequiresHalt& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ChannelRequiresHalt* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ChannelRequiresHalt)
}

inline void CDOTAClientMsg_ChannelRequiresHalt::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

CDOTAClientMsg_ChannelRequiresHalt::~CDOTAClientMsg_ChannelRequiresHalt() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ChannelRequiresHalt)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ChannelRequiresHalt::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_ChannelRequiresHalt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ChannelRequiresHalt::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ChannelRequiresHalt)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ChannelRequiresHalt::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ChannelRequiresHalt::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ChannelRequiresHalt)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ChannelRequiresHalt)
  return target;
}

size_t CDOTAClientMsg_ChannelRequiresHalt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ChannelRequiresHalt)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ChannelRequiresHalt::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ChannelRequiresHalt::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ChannelRequiresHalt::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ChannelRequiresHalt::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ChannelRequiresHalt*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ChannelRequiresHalt&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ChannelRequiresHalt)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ChannelRequiresHalt::CopyFrom(const CDOTAClientMsg_ChannelRequiresHalt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ChannelRequiresHalt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ChannelRequiresHalt::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ChannelRequiresHalt::InternalSwap(CDOTAClientMsg_ChannelRequiresHalt* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ChannelRequiresHalt::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[14]);
}

// ===================================================================

class CDOTAClientMsg_SearchString::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_SearchString>()._impl_._has_bits_);
  static void set_has_search(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_SearchString::CDOTAClientMsg_SearchString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_SearchString)
}
CDOTAClientMsg_SearchString::CDOTAClientMsg_SearchString(const CDOTAClientMsg_SearchString& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_SearchString* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.search_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.search_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.search_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_search()) {
    _this->_impl_.search_.Set(from._internal_search(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_SearchString)
}

inline void CDOTAClientMsg_SearchString::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.search_){}
  };
  _impl_.search_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.search_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CDOTAClientMsg_SearchString::~CDOTAClientMsg_SearchString() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_SearchString)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_SearchString::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.search_.Destroy();
}

void CDOTAClientMsg_SearchString::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_SearchString::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_SearchString)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.search_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_SearchString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string search = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_search();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CDOTAClientMsg_SearchString.search");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_SearchString::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_SearchString)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string search = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_search().data(), static_cast<int>(this->_internal_search().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDOTAClientMsg_SearchString.search");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_search(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_SearchString)
  return target;
}

size_t CDOTAClientMsg_SearchString::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_SearchString)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string search = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_search());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_SearchString::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_SearchString::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_SearchString::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_SearchString::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_SearchString*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_SearchString&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_SearchString)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_search()) {
    _this->_internal_set_search(from._internal_search());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_SearchString::CopyFrom(const CDOTAClientMsg_SearchString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_SearchString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_SearchString::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_SearchString::InternalSwap(CDOTAClientMsg_SearchString* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.search_, lhs_arena,
      &other->_impl_.search_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_SearchString::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[15]);
}

// ===================================================================

class CDOTAClientMsg_Pause::_Internal {
 public:
};

CDOTAClientMsg_Pause::CDOTAClientMsg_Pause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_Pause)
}
CDOTAClientMsg_Pause::CDOTAClientMsg_Pause(const CDOTAClientMsg_Pause& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CDOTAClientMsg_Pause* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_Pause)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_Pause::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_Pause::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_Pause::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[16]);
}

// ===================================================================

class CDOTAClientMsg_ShopViewMode::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_ShopViewMode>()._impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_ShopViewMode::CDOTAClientMsg_ShopViewMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ShopViewMode)
}
CDOTAClientMsg_ShopViewMode::CDOTAClientMsg_ShopViewMode(const CDOTAClientMsg_ShopViewMode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ShopViewMode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ShopViewMode)
}

inline void CDOTAClientMsg_ShopViewMode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){0u}
  };
}

CDOTAClientMsg_ShopViewMode::~CDOTAClientMsg_ShopViewMode() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ShopViewMode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ShopViewMode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_ShopViewMode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ShopViewMode::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ShopViewMode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mode_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ShopViewMode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ShopViewMode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ShopViewMode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ShopViewMode)
  return target;
}

size_t CDOTAClientMsg_ShopViewMode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ShopViewMode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 mode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ShopViewMode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ShopViewMode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ShopViewMode::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ShopViewMode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ShopViewMode*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ShopViewMode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ShopViewMode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mode()) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ShopViewMode::CopyFrom(const CDOTAClientMsg_ShopViewMode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ShopViewMode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ShopViewMode::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ShopViewMode::InternalSwap(CDOTAClientMsg_ShopViewMode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.mode_, other->_impl_.mode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ShopViewMode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[17]);
}

// ===================================================================

class CDOTAClientMsg_SetUnitShareFlag::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_SetUnitShareFlag>()._impl_._has_bits_);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_SetUnitShareFlag::CDOTAClientMsg_SetUnitShareFlag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_SetUnitShareFlag)
}
CDOTAClientMsg_SetUnitShareFlag::CDOTAClientMsg_SetUnitShareFlag(const CDOTAClientMsg_SetUnitShareFlag& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_SetUnitShareFlag* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.flag_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.flag_, &from._impl_.flag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_id_) -
    reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.player_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_SetUnitShareFlag)
}

inline void CDOTAClientMsg_SetUnitShareFlag::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.flag_){0u}
    , decltype(_impl_.state_){false}
    , decltype(_impl_.player_id_){-1}
  };
}

CDOTAClientMsg_SetUnitShareFlag::~CDOTAClientMsg_SetUnitShareFlag() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_SetUnitShareFlag)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_SetUnitShareFlag::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_SetUnitShareFlag::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_SetUnitShareFlag::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_SetUnitShareFlag)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.flag_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.state_) -
        reinterpret_cast<char*>(&_impl_.flag_)) + sizeof(_impl_.state_));
    _impl_.player_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_SetUnitShareFlag::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flag(&has_bits);
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_state(&has_bits);
          _impl_.state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_SetUnitShareFlag::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_SetUnitShareFlag)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_id(), target);
  }

  // optional uint32 flag = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_flag(), target);
  }

  // optional bool state = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_SetUnitShareFlag)
  return target;
}

size_t CDOTAClientMsg_SetUnitShareFlag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_SetUnitShareFlag)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 flag = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flag());
    }

    // optional bool state = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional int32 player_id = 1 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_SetUnitShareFlag::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_SetUnitShareFlag::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_SetUnitShareFlag::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_SetUnitShareFlag::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_SetUnitShareFlag*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_SetUnitShareFlag&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_SetUnitShareFlag)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.flag_ = from._impl_.flag_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.player_id_ = from._impl_.player_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_SetUnitShareFlag::CopyFrom(const CDOTAClientMsg_SetUnitShareFlag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_SetUnitShareFlag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_SetUnitShareFlag::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_SetUnitShareFlag::InternalSwap(CDOTAClientMsg_SetUnitShareFlag* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_SetUnitShareFlag, _impl_.state_)
      + sizeof(CDOTAClientMsg_SetUnitShareFlag::_impl_.state_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_SetUnitShareFlag, _impl_.flag_)>(
          reinterpret_cast<char*>(&_impl_.flag_),
          reinterpret_cast<char*>(&other->_impl_.flag_));
  swap(_impl_.player_id_, other->_impl_.player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_SetUnitShareFlag::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[18]);
}

// ===================================================================

class CDOTAClientMsg_SwapRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_SwapRequest>()._impl_._has_bits_);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_SwapRequest::CDOTAClientMsg_SwapRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_SwapRequest)
}
CDOTAClientMsg_SwapRequest::CDOTAClientMsg_SwapRequest(const CDOTAClientMsg_SwapRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_SwapRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.player_id_ = from._impl_.player_id_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_SwapRequest)
}

inline void CDOTAClientMsg_SwapRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){-1}
  };
}

CDOTAClientMsg_SwapRequest::~CDOTAClientMsg_SwapRequest() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_SwapRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_SwapRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_SwapRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_SwapRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_SwapRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_id_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_SwapRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_SwapRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_SwapRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_SwapRequest)
  return target;
}

size_t CDOTAClientMsg_SwapRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_SwapRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 player_id = 1 [default = -1];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_SwapRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_SwapRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_SwapRequest::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_SwapRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_SwapRequest*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_SwapRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_SwapRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_player_id()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_SwapRequest::CopyFrom(const CDOTAClientMsg_SwapRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_SwapRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_SwapRequest::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_SwapRequest::InternalSwap(CDOTAClientMsg_SwapRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.player_id_, other->_impl_.player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_SwapRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[19]);
}

// ===================================================================

class CDOTAClientMsg_SwapAccept::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_SwapAccept>()._impl_._has_bits_);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_SwapAccept::CDOTAClientMsg_SwapAccept(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_SwapAccept)
}
CDOTAClientMsg_SwapAccept::CDOTAClientMsg_SwapAccept(const CDOTAClientMsg_SwapAccept& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_SwapAccept* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.player_id_ = from._impl_.player_id_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_SwapAccept)
}

inline void CDOTAClientMsg_SwapAccept::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){-1}
  };
}

CDOTAClientMsg_SwapAccept::~CDOTAClientMsg_SwapAccept() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_SwapAccept)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_SwapAccept::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_SwapAccept::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_SwapAccept::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_SwapAccept)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_id_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_SwapAccept::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_SwapAccept::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_SwapAccept)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_SwapAccept)
  return target;
}

size_t CDOTAClientMsg_SwapAccept::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_SwapAccept)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 player_id = 1 [default = -1];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_SwapAccept::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_SwapAccept::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_SwapAccept::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_SwapAccept::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_SwapAccept*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_SwapAccept&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_SwapAccept)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_player_id()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_SwapAccept::CopyFrom(const CDOTAClientMsg_SwapAccept& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_SwapAccept)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_SwapAccept::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_SwapAccept::InternalSwap(CDOTAClientMsg_SwapAccept* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.player_id_, other->_impl_.player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_SwapAccept::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[20]);
}

// ===================================================================

class CDOTAClientMsg_WorldLine::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_WorldLine>()._impl_._has_bits_);
  static const ::CDOTAMsg_WorldLine& worldline(const CDOTAClientMsg_WorldLine* msg);
  static void set_has_worldline(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CDOTAMsg_WorldLine&
CDOTAClientMsg_WorldLine::_Internal::worldline(const CDOTAClientMsg_WorldLine* msg) {
  return *msg->_impl_.worldline_;
}
void CDOTAClientMsg_WorldLine::clear_worldline() {
  if (_impl_.worldline_ != nullptr) _impl_.worldline_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CDOTAClientMsg_WorldLine::CDOTAClientMsg_WorldLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_WorldLine)
}
CDOTAClientMsg_WorldLine::CDOTAClientMsg_WorldLine(const CDOTAClientMsg_WorldLine& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_WorldLine* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.worldline_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_worldline()) {
    _this->_impl_.worldline_ = new ::CDOTAMsg_WorldLine(*from._impl_.worldline_);
  }
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_WorldLine)
}

inline void CDOTAClientMsg_WorldLine::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.worldline_){nullptr}
  };
}

CDOTAClientMsg_WorldLine::~CDOTAClientMsg_WorldLine() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_WorldLine)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_WorldLine::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.worldline_;
}

void CDOTAClientMsg_WorldLine::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_WorldLine::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_WorldLine)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.worldline_ != nullptr);
    _impl_.worldline_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_WorldLine::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CDOTAMsg_WorldLine worldline = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_worldline(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_WorldLine::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_WorldLine)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CDOTAMsg_WorldLine worldline = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::worldline(this),
        _Internal::worldline(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_WorldLine)
  return target;
}

size_t CDOTAClientMsg_WorldLine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_WorldLine)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CDOTAMsg_WorldLine worldline = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.worldline_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_WorldLine::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_WorldLine::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_WorldLine::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_WorldLine::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_WorldLine*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_WorldLine&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_WorldLine)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_worldline()) {
    _this->_internal_mutable_worldline()->::CDOTAMsg_WorldLine::MergeFrom(
        from._internal_worldline());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_WorldLine::CopyFrom(const CDOTAClientMsg_WorldLine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_WorldLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_WorldLine::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_WorldLine::InternalSwap(CDOTAClientMsg_WorldLine* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.worldline_, other->_impl_.worldline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_WorldLine::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[21]);
}

// ===================================================================

class CDOTAClientMsg_RequestGraphUpdate::_Internal {
 public:
};

CDOTAClientMsg_RequestGraphUpdate::CDOTAClientMsg_RequestGraphUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_RequestGraphUpdate)
}
CDOTAClientMsg_RequestGraphUpdate::CDOTAClientMsg_RequestGraphUpdate(const CDOTAClientMsg_RequestGraphUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CDOTAClientMsg_RequestGraphUpdate* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_RequestGraphUpdate)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_RequestGraphUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_RequestGraphUpdate::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_RequestGraphUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[22]);
}

// ===================================================================

class CDOTAClientMsg_ChatWheel::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_ChatWheel>()._impl_._has_bits_);
  static void set_has_chat_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_param_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_emoticon_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_ChatWheel::CDOTAClientMsg_ChatWheel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ChatWheel)
}
CDOTAClientMsg_ChatWheel::CDOTAClientMsg_ChatWheel(const CDOTAClientMsg_ChatWheel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ChatWheel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.param_hero_id_){}
    , decltype(_impl_.emoticon_id_){}
    , decltype(_impl_.chat_message_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.param_hero_id_, &from._impl_.param_hero_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.chat_message_id_) -
    reinterpret_cast<char*>(&_impl_.param_hero_id_)) + sizeof(_impl_.chat_message_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ChatWheel)
}

inline void CDOTAClientMsg_ChatWheel::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.param_hero_id_){0u}
    , decltype(_impl_.emoticon_id_){0u}
    , decltype(_impl_.chat_message_id_){4294967295u}
  };
}

CDOTAClientMsg_ChatWheel::~CDOTAClientMsg_ChatWheel() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ChatWheel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ChatWheel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_ChatWheel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ChatWheel::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ChatWheel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.param_hero_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.emoticon_id_) -
        reinterpret_cast<char*>(&_impl_.param_hero_id_)) + sizeof(_impl_.emoticon_id_));
    _impl_.chat_message_id_ = 4294967295u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ChatWheel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 chat_message_id = 1 [default = 4294967295];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_chat_message_id(&has_bits);
          _impl_.chat_message_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 param_hero_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_param_hero_id(&has_bits);
          _impl_.param_hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 emoticon_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_emoticon_id(&has_bits);
          _impl_.emoticon_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ChatWheel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ChatWheel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 chat_message_id = 1 [default = 4294967295];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_chat_message_id(), target);
  }

  // optional uint32 param_hero_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_param_hero_id(), target);
  }

  // optional uint32 emoticon_id = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_emoticon_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ChatWheel)
  return target;
}

size_t CDOTAClientMsg_ChatWheel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ChatWheel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 param_hero_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_param_hero_id());
    }

    // optional uint32 emoticon_id = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_emoticon_id());
    }

    // optional uint32 chat_message_id = 1 [default = 4294967295];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_chat_message_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ChatWheel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ChatWheel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ChatWheel::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ChatWheel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ChatWheel*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ChatWheel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ChatWheel)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.param_hero_id_ = from._impl_.param_hero_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.emoticon_id_ = from._impl_.emoticon_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.chat_message_id_ = from._impl_.chat_message_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ChatWheel::CopyFrom(const CDOTAClientMsg_ChatWheel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ChatWheel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ChatWheel::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ChatWheel::InternalSwap(CDOTAClientMsg_ChatWheel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_ChatWheel, _impl_.emoticon_id_)
      + sizeof(CDOTAClientMsg_ChatWheel::_impl_.emoticon_id_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_ChatWheel, _impl_.param_hero_id_)>(
          reinterpret_cast<char*>(&_impl_.param_hero_id_),
          reinterpret_cast<char*>(&other->_impl_.param_hero_id_));
  swap(_impl_.chat_message_id_, other->_impl_.chat_message_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ChatWheel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[23]);
}

// ===================================================================

class CDOTAClientMsg_SendStatPopup::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_SendStatPopup>()._impl_._has_bits_);
  static const ::CDOTAMsg_SendStatPopup& statpopup(const CDOTAClientMsg_SendStatPopup* msg);
  static void set_has_statpopup(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CDOTAMsg_SendStatPopup&
CDOTAClientMsg_SendStatPopup::_Internal::statpopup(const CDOTAClientMsg_SendStatPopup* msg) {
  return *msg->_impl_.statpopup_;
}
void CDOTAClientMsg_SendStatPopup::clear_statpopup() {
  if (_impl_.statpopup_ != nullptr) _impl_.statpopup_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CDOTAClientMsg_SendStatPopup::CDOTAClientMsg_SendStatPopup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_SendStatPopup)
}
CDOTAClientMsg_SendStatPopup::CDOTAClientMsg_SendStatPopup(const CDOTAClientMsg_SendStatPopup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_SendStatPopup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.statpopup_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_statpopup()) {
    _this->_impl_.statpopup_ = new ::CDOTAMsg_SendStatPopup(*from._impl_.statpopup_);
  }
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_SendStatPopup)
}

inline void CDOTAClientMsg_SendStatPopup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.statpopup_){nullptr}
  };
}

CDOTAClientMsg_SendStatPopup::~CDOTAClientMsg_SendStatPopup() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_SendStatPopup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_SendStatPopup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.statpopup_;
}

void CDOTAClientMsg_SendStatPopup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_SendStatPopup::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_SendStatPopup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.statpopup_ != nullptr);
    _impl_.statpopup_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_SendStatPopup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CDOTAMsg_SendStatPopup statpopup = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_statpopup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_SendStatPopup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_SendStatPopup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CDOTAMsg_SendStatPopup statpopup = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::statpopup(this),
        _Internal::statpopup(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_SendStatPopup)
  return target;
}

size_t CDOTAClientMsg_SendStatPopup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_SendStatPopup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CDOTAMsg_SendStatPopup statpopup = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.statpopup_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_SendStatPopup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_SendStatPopup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_SendStatPopup::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_SendStatPopup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_SendStatPopup*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_SendStatPopup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_SendStatPopup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_statpopup()) {
    _this->_internal_mutable_statpopup()->::CDOTAMsg_SendStatPopup::MergeFrom(
        from._internal_statpopup());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_SendStatPopup::CopyFrom(const CDOTAClientMsg_SendStatPopup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_SendStatPopup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_SendStatPopup::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_SendStatPopup::InternalSwap(CDOTAClientMsg_SendStatPopup* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.statpopup_, other->_impl_.statpopup_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_SendStatPopup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[24]);
}

// ===================================================================

class CDOTAClientMsg_DismissAllStatPopups::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_DismissAllStatPopups>()._impl_._has_bits_);
  static const ::CDOTAMsg_DismissAllStatPopups& dismissallmsg(const CDOTAClientMsg_DismissAllStatPopups* msg);
  static void set_has_dismissallmsg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CDOTAMsg_DismissAllStatPopups&
CDOTAClientMsg_DismissAllStatPopups::_Internal::dismissallmsg(const CDOTAClientMsg_DismissAllStatPopups* msg) {
  return *msg->_impl_.dismissallmsg_;
}
void CDOTAClientMsg_DismissAllStatPopups::clear_dismissallmsg() {
  if (_impl_.dismissallmsg_ != nullptr) _impl_.dismissallmsg_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CDOTAClientMsg_DismissAllStatPopups::CDOTAClientMsg_DismissAllStatPopups(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_DismissAllStatPopups)
}
CDOTAClientMsg_DismissAllStatPopups::CDOTAClientMsg_DismissAllStatPopups(const CDOTAClientMsg_DismissAllStatPopups& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_DismissAllStatPopups* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dismissallmsg_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dismissallmsg()) {
    _this->_impl_.dismissallmsg_ = new ::CDOTAMsg_DismissAllStatPopups(*from._impl_.dismissallmsg_);
  }
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_DismissAllStatPopups)
}

inline void CDOTAClientMsg_DismissAllStatPopups::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dismissallmsg_){nullptr}
  };
}

CDOTAClientMsg_DismissAllStatPopups::~CDOTAClientMsg_DismissAllStatPopups() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_DismissAllStatPopups)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_DismissAllStatPopups::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.dismissallmsg_;
}

void CDOTAClientMsg_DismissAllStatPopups::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_DismissAllStatPopups::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_DismissAllStatPopups)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.dismissallmsg_ != nullptr);
    _impl_.dismissallmsg_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_DismissAllStatPopups::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CDOTAMsg_DismissAllStatPopups dismissallmsg = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dismissallmsg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_DismissAllStatPopups::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_DismissAllStatPopups)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CDOTAMsg_DismissAllStatPopups dismissallmsg = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::dismissallmsg(this),
        _Internal::dismissallmsg(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_DismissAllStatPopups)
  return target;
}

size_t CDOTAClientMsg_DismissAllStatPopups::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_DismissAllStatPopups)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CDOTAMsg_DismissAllStatPopups dismissallmsg = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dismissallmsg_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_DismissAllStatPopups::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_DismissAllStatPopups::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_DismissAllStatPopups::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_DismissAllStatPopups::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_DismissAllStatPopups*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_DismissAllStatPopups&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_DismissAllStatPopups)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dismissallmsg()) {
    _this->_internal_mutable_dismissallmsg()->::CDOTAMsg_DismissAllStatPopups::MergeFrom(
        from._internal_dismissallmsg());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_DismissAllStatPopups::CopyFrom(const CDOTAClientMsg_DismissAllStatPopups& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_DismissAllStatPopups)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_DismissAllStatPopups::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_DismissAllStatPopups::InternalSwap(CDOTAClientMsg_DismissAllStatPopups* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.dismissallmsg_, other->_impl_.dismissallmsg_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_DismissAllStatPopups::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[25]);
}

// ===================================================================

class CDOTAClientMsg_BeginLastHitChallenge::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_BeginLastHitChallenge>()._impl_._has_bits_);
  static void set_has_chosen_lane(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_helper_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_BeginLastHitChallenge::CDOTAClientMsg_BeginLastHitChallenge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_BeginLastHitChallenge)
}
CDOTAClientMsg_BeginLastHitChallenge::CDOTAClientMsg_BeginLastHitChallenge(const CDOTAClientMsg_BeginLastHitChallenge& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_BeginLastHitChallenge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chosen_lane_){}
    , decltype(_impl_.helper_enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.chosen_lane_, &from._impl_.chosen_lane_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.helper_enabled_) -
    reinterpret_cast<char*>(&_impl_.chosen_lane_)) + sizeof(_impl_.helper_enabled_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_BeginLastHitChallenge)
}

inline void CDOTAClientMsg_BeginLastHitChallenge::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chosen_lane_){0u}
    , decltype(_impl_.helper_enabled_){false}
  };
}

CDOTAClientMsg_BeginLastHitChallenge::~CDOTAClientMsg_BeginLastHitChallenge() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_BeginLastHitChallenge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_BeginLastHitChallenge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_BeginLastHitChallenge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_BeginLastHitChallenge::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_BeginLastHitChallenge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.chosen_lane_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.helper_enabled_) -
        reinterpret_cast<char*>(&_impl_.chosen_lane_)) + sizeof(_impl_.helper_enabled_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_BeginLastHitChallenge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 chosen_lane = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_chosen_lane(&has_bits);
          _impl_.chosen_lane_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool helper_enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_helper_enabled(&has_bits);
          _impl_.helper_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_BeginLastHitChallenge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_BeginLastHitChallenge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 chosen_lane = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_chosen_lane(), target);
  }

  // optional bool helper_enabled = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_helper_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_BeginLastHitChallenge)
  return target;
}

size_t CDOTAClientMsg_BeginLastHitChallenge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_BeginLastHitChallenge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 chosen_lane = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_chosen_lane());
    }

    // optional bool helper_enabled = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_BeginLastHitChallenge::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_BeginLastHitChallenge::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_BeginLastHitChallenge::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_BeginLastHitChallenge::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_BeginLastHitChallenge*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_BeginLastHitChallenge&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_BeginLastHitChallenge)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.chosen_lane_ = from._impl_.chosen_lane_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.helper_enabled_ = from._impl_.helper_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_BeginLastHitChallenge::CopyFrom(const CDOTAClientMsg_BeginLastHitChallenge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_BeginLastHitChallenge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_BeginLastHitChallenge::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_BeginLastHitChallenge::InternalSwap(CDOTAClientMsg_BeginLastHitChallenge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_BeginLastHitChallenge, _impl_.helper_enabled_)
      + sizeof(CDOTAClientMsg_BeginLastHitChallenge::_impl_.helper_enabled_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_BeginLastHitChallenge, _impl_.chosen_lane_)>(
          reinterpret_cast<char*>(&_impl_.chosen_lane_),
          reinterpret_cast<char*>(&other->_impl_.chosen_lane_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_BeginLastHitChallenge::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[26]);
}

// ===================================================================

class CDOTAClientMsg_UpdateQuickBuyItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_UpdateQuickBuyItem>()._impl_._has_bits_);
  static void set_has_item_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_purchasable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_UpdateQuickBuyItem::CDOTAClientMsg_UpdateQuickBuyItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_UpdateQuickBuyItem)
}
CDOTAClientMsg_UpdateQuickBuyItem::CDOTAClientMsg_UpdateQuickBuyItem(const CDOTAClientMsg_UpdateQuickBuyItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_UpdateQuickBuyItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.purchasable_){}
    , decltype(_impl_.item_ability_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.purchasable_, &from._impl_.purchasable_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_ability_id_) -
    reinterpret_cast<char*>(&_impl_.purchasable_)) + sizeof(_impl_.item_ability_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_UpdateQuickBuyItem)
}

inline void CDOTAClientMsg_UpdateQuickBuyItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.purchasable_){false}
    , decltype(_impl_.item_ability_id_){-1}
  };
}

CDOTAClientMsg_UpdateQuickBuyItem::~CDOTAClientMsg_UpdateQuickBuyItem() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_UpdateQuickBuyItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_UpdateQuickBuyItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_UpdateQuickBuyItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_UpdateQuickBuyItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_UpdateQuickBuyItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.purchasable_ = false;
    _impl_.item_ability_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_UpdateQuickBuyItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 item_ability_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_ability_id(&has_bits);
          _impl_.item_ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool purchasable = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_purchasable(&has_bits);
          _impl_.purchasable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_UpdateQuickBuyItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_UpdateQuickBuyItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 item_ability_id = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_item_ability_id(), target);
  }

  // optional bool purchasable = 2 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_purchasable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_UpdateQuickBuyItem)
  return target;
}

size_t CDOTAClientMsg_UpdateQuickBuyItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_UpdateQuickBuyItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool purchasable = 2 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 item_ability_id = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_ability_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_UpdateQuickBuyItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_UpdateQuickBuyItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_UpdateQuickBuyItem::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_UpdateQuickBuyItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_UpdateQuickBuyItem*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_UpdateQuickBuyItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_UpdateQuickBuyItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.purchasable_ = from._impl_.purchasable_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_ability_id_ = from._impl_.item_ability_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_UpdateQuickBuyItem::CopyFrom(const CDOTAClientMsg_UpdateQuickBuyItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_UpdateQuickBuyItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_UpdateQuickBuyItem::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_UpdateQuickBuyItem::InternalSwap(CDOTAClientMsg_UpdateQuickBuyItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.purchasable_, other->_impl_.purchasable_);
  swap(_impl_.item_ability_id_, other->_impl_.item_ability_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_UpdateQuickBuyItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[27]);
}

// ===================================================================

class CDOTAClientMsg_UpdateQuickBuy::_Internal {
 public:
};

CDOTAClientMsg_UpdateQuickBuy::CDOTAClientMsg_UpdateQuickBuy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_UpdateQuickBuy)
}
CDOTAClientMsg_UpdateQuickBuy::CDOTAClientMsg_UpdateQuickBuy(const CDOTAClientMsg_UpdateQuickBuy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_UpdateQuickBuy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_UpdateQuickBuy)
}

inline void CDOTAClientMsg_UpdateQuickBuy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CDOTAClientMsg_UpdateQuickBuy::~CDOTAClientMsg_UpdateQuickBuy() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_UpdateQuickBuy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_UpdateQuickBuy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void CDOTAClientMsg_UpdateQuickBuy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_UpdateQuickBuy::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_UpdateQuickBuy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_UpdateQuickBuy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CDOTAClientMsg_UpdateQuickBuyItem items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_UpdateQuickBuy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_UpdateQuickBuy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CDOTAClientMsg_UpdateQuickBuyItem items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_UpdateQuickBuy)
  return target;
}

size_t CDOTAClientMsg_UpdateQuickBuy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_UpdateQuickBuy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CDOTAClientMsg_UpdateQuickBuyItem items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_UpdateQuickBuy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_UpdateQuickBuy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_UpdateQuickBuy::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_UpdateQuickBuy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_UpdateQuickBuy*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_UpdateQuickBuy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_UpdateQuickBuy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_UpdateQuickBuy::CopyFrom(const CDOTAClientMsg_UpdateQuickBuy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_UpdateQuickBuy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_UpdateQuickBuy::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_UpdateQuickBuy::InternalSwap(CDOTAClientMsg_UpdateQuickBuy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_UpdateQuickBuy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[28]);
}

// ===================================================================

class CDOTAClientMsg_RecordVote::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_RecordVote>()._impl_._has_bits_);
  static void set_has_choice_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_RecordVote::CDOTAClientMsg_RecordVote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_RecordVote)
}
CDOTAClientMsg_RecordVote::CDOTAClientMsg_RecordVote(const CDOTAClientMsg_RecordVote& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_RecordVote* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.choice_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.choice_index_ = from._impl_.choice_index_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_RecordVote)
}

inline void CDOTAClientMsg_RecordVote::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.choice_index_){0}
  };
}

CDOTAClientMsg_RecordVote::~CDOTAClientMsg_RecordVote() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_RecordVote)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_RecordVote::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_RecordVote::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_RecordVote::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_RecordVote)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.choice_index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_RecordVote::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 choice_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_choice_index(&has_bits);
          _impl_.choice_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_RecordVote::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_RecordVote)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 choice_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_choice_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_RecordVote)
  return target;
}

size_t CDOTAClientMsg_RecordVote::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_RecordVote)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 choice_index = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_choice_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_RecordVote::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_RecordVote::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_RecordVote::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_RecordVote::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_RecordVote*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_RecordVote&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_RecordVote)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_choice_index()) {
    _this->_internal_set_choice_index(from._internal_choice_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_RecordVote::CopyFrom(const CDOTAClientMsg_RecordVote& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_RecordVote)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_RecordVote::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_RecordVote::InternalSwap(CDOTAClientMsg_RecordVote* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.choice_index_, other->_impl_.choice_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_RecordVote::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[29]);
}

// ===================================================================

class CDOTAClientMsg_WillPurchaseAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_WillPurchaseAlert>()._impl_._has_bits_);
  static void set_has_item_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gold_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_suggestion_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CDOTAClientMsg_WillPurchaseAlert::CDOTAClientMsg_WillPurchaseAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_WillPurchaseAlert)
}
CDOTAClientMsg_WillPurchaseAlert::CDOTAClientMsg_WillPurchaseAlert(const CDOTAClientMsg_WillPurchaseAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_WillPurchaseAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gold_remaining_){}
    , decltype(_impl_.item_ability_id_){}
    , decltype(_impl_.suggestion_player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.gold_remaining_, &from._impl_.gold_remaining_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.suggestion_player_id_) -
    reinterpret_cast<char*>(&_impl_.gold_remaining_)) + sizeof(_impl_.suggestion_player_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_WillPurchaseAlert)
}

inline void CDOTAClientMsg_WillPurchaseAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gold_remaining_){0u}
    , decltype(_impl_.item_ability_id_){-1}
    , decltype(_impl_.suggestion_player_id_){-1}
  };
}

CDOTAClientMsg_WillPurchaseAlert::~CDOTAClientMsg_WillPurchaseAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_WillPurchaseAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_WillPurchaseAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_WillPurchaseAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_WillPurchaseAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_WillPurchaseAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    _impl_.gold_remaining_ = 0u;
    _impl_.item_ability_id_ = -1;
    _impl_.suggestion_player_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_WillPurchaseAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 item_ability_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_ability_id(&has_bits);
          _impl_.item_ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gold_remaining = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gold_remaining(&has_bits);
          _impl_.gold_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 suggestion_player_id = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_suggestion_player_id(&has_bits);
          _impl_.suggestion_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_WillPurchaseAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_WillPurchaseAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 item_ability_id = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_item_ability_id(), target);
  }

  // optional uint32 gold_remaining = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_gold_remaining(), target);
  }

  // optional int32 suggestion_player_id = 3 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_suggestion_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_WillPurchaseAlert)
  return target;
}

size_t CDOTAClientMsg_WillPurchaseAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_WillPurchaseAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 gold_remaining = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gold_remaining());
    }

    // optional int32 item_ability_id = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_ability_id());
    }

    // optional int32 suggestion_player_id = 3 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_suggestion_player_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_WillPurchaseAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_WillPurchaseAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_WillPurchaseAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_WillPurchaseAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_WillPurchaseAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_WillPurchaseAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_WillPurchaseAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gold_remaining_ = from._impl_.gold_remaining_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_ability_id_ = from._impl_.item_ability_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.suggestion_player_id_ = from._impl_.suggestion_player_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_WillPurchaseAlert::CopyFrom(const CDOTAClientMsg_WillPurchaseAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_WillPurchaseAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_WillPurchaseAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_WillPurchaseAlert::InternalSwap(CDOTAClientMsg_WillPurchaseAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.gold_remaining_, other->_impl_.gold_remaining_);
  swap(_impl_.item_ability_id_, other->_impl_.item_ability_id_);
  swap(_impl_.suggestion_player_id_, other->_impl_.suggestion_player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_WillPurchaseAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[30]);
}

// ===================================================================

class CDOTAClientMsg_BuyBackStateAlert::_Internal {
 public:
};

CDOTAClientMsg_BuyBackStateAlert::CDOTAClientMsg_BuyBackStateAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_BuyBackStateAlert)
}
CDOTAClientMsg_BuyBackStateAlert::CDOTAClientMsg_BuyBackStateAlert(const CDOTAClientMsg_BuyBackStateAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CDOTAClientMsg_BuyBackStateAlert* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_BuyBackStateAlert)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_BuyBackStateAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_BuyBackStateAlert::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_BuyBackStateAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[31]);
}

// ===================================================================

class CDOTAClientMsg_QuickBuyAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_QuickBuyAlert>()._impl_._has_bits_);
  static void set_has_item_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gold_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_item_cooldown_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_show_buyback(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CDOTAClientMsg_QuickBuyAlert::CDOTAClientMsg_QuickBuyAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_QuickBuyAlert)
}
CDOTAClientMsg_QuickBuyAlert::CDOTAClientMsg_QuickBuyAlert(const CDOTAClientMsg_QuickBuyAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_QuickBuyAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gold_cost_){}
    , decltype(_impl_.item_cooldown_seconds_){}
    , decltype(_impl_.show_buyback_){}
    , decltype(_impl_.item_ability_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.gold_cost_, &from._impl_.gold_cost_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_ability_id_) -
    reinterpret_cast<char*>(&_impl_.gold_cost_)) + sizeof(_impl_.item_ability_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_QuickBuyAlert)
}

inline void CDOTAClientMsg_QuickBuyAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gold_cost_){0}
    , decltype(_impl_.item_cooldown_seconds_){0}
    , decltype(_impl_.show_buyback_){false}
    , decltype(_impl_.item_ability_id_){-1}
  };
}

CDOTAClientMsg_QuickBuyAlert::~CDOTAClientMsg_QuickBuyAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_QuickBuyAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_QuickBuyAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_QuickBuyAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_QuickBuyAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_QuickBuyAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.gold_cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.show_buyback_) -
        reinterpret_cast<char*>(&_impl_.gold_cost_)) + sizeof(_impl_.show_buyback_));
    _impl_.item_ability_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_QuickBuyAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 item_ability_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_ability_id(&has_bits);
          _impl_.item_ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gold_cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gold_cost(&has_bits);
          _impl_.gold_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_cooldown_seconds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_cooldown_seconds(&has_bits);
          _impl_.item_cooldown_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_buyback = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_show_buyback(&has_bits);
          _impl_.show_buyback_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_QuickBuyAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_QuickBuyAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 item_ability_id = 1 [default = -1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_item_ability_id(), target);
  }

  // optional int32 gold_cost = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_gold_cost(), target);
  }

  // optional int32 item_cooldown_seconds = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_item_cooldown_seconds(), target);
  }

  // optional bool show_buyback = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_show_buyback(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_QuickBuyAlert)
  return target;
}

size_t CDOTAClientMsg_QuickBuyAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_QuickBuyAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 gold_cost = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gold_cost());
    }

    // optional int32 item_cooldown_seconds = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_cooldown_seconds());
    }

    // optional bool show_buyback = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional int32 item_ability_id = 1 [default = -1];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_ability_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_QuickBuyAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_QuickBuyAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_QuickBuyAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_QuickBuyAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_QuickBuyAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_QuickBuyAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_QuickBuyAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gold_cost_ = from._impl_.gold_cost_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.item_cooldown_seconds_ = from._impl_.item_cooldown_seconds_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.show_buyback_ = from._impl_.show_buyback_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.item_ability_id_ = from._impl_.item_ability_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_QuickBuyAlert::CopyFrom(const CDOTAClientMsg_QuickBuyAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_QuickBuyAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_QuickBuyAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_QuickBuyAlert::InternalSwap(CDOTAClientMsg_QuickBuyAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_QuickBuyAlert, _impl_.show_buyback_)
      + sizeof(CDOTAClientMsg_QuickBuyAlert::_impl_.show_buyback_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_QuickBuyAlert, _impl_.gold_cost_)>(
          reinterpret_cast<char*>(&_impl_.gold_cost_),
          reinterpret_cast<char*>(&other->_impl_.gold_cost_));
  swap(_impl_.item_ability_id_, other->_impl_.item_ability_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_QuickBuyAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[32]);
}

// ===================================================================

class CDOTAClientMsg_PlayerShowCase::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_PlayerShowCase>()._impl_._has_bits_);
  static void set_has_showcase(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_PlayerShowCase::CDOTAClientMsg_PlayerShowCase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_PlayerShowCase)
}
CDOTAClientMsg_PlayerShowCase::CDOTAClientMsg_PlayerShowCase(const CDOTAClientMsg_PlayerShowCase& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_PlayerShowCase* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.showcase_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.showcase_ = from._impl_.showcase_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_PlayerShowCase)
}

inline void CDOTAClientMsg_PlayerShowCase::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.showcase_){false}
  };
}

CDOTAClientMsg_PlayerShowCase::~CDOTAClientMsg_PlayerShowCase() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_PlayerShowCase)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_PlayerShowCase::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_PlayerShowCase::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_PlayerShowCase::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_PlayerShowCase)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.showcase_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_PlayerShowCase::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool showcase = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_showcase(&has_bits);
          _impl_.showcase_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_PlayerShowCase::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_PlayerShowCase)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool showcase = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_showcase(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_PlayerShowCase)
  return target;
}

size_t CDOTAClientMsg_PlayerShowCase::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_PlayerShowCase)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool showcase = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_PlayerShowCase::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_PlayerShowCase::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_PlayerShowCase::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_PlayerShowCase::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_PlayerShowCase*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_PlayerShowCase&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_PlayerShowCase)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_showcase()) {
    _this->_internal_set_showcase(from._internal_showcase());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_PlayerShowCase::CopyFrom(const CDOTAClientMsg_PlayerShowCase& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_PlayerShowCase)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_PlayerShowCase::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_PlayerShowCase::InternalSwap(CDOTAClientMsg_PlayerShowCase* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.showcase_, other->_impl_.showcase_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_PlayerShowCase::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[33]);
}

// ===================================================================

class CDOTAClientMsg_CameraZoomAmount::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_CameraZoomAmount>()._impl_._has_bits_);
  static void set_has_zoom_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_CameraZoomAmount::CDOTAClientMsg_CameraZoomAmount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_CameraZoomAmount)
}
CDOTAClientMsg_CameraZoomAmount::CDOTAClientMsg_CameraZoomAmount(const CDOTAClientMsg_CameraZoomAmount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_CameraZoomAmount* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.zoom_amount_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.zoom_amount_ = from._impl_.zoom_amount_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_CameraZoomAmount)
}

inline void CDOTAClientMsg_CameraZoomAmount::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.zoom_amount_){0}
  };
}

CDOTAClientMsg_CameraZoomAmount::~CDOTAClientMsg_CameraZoomAmount() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_CameraZoomAmount)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_CameraZoomAmount::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_CameraZoomAmount::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_CameraZoomAmount::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_CameraZoomAmount)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.zoom_amount_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_CameraZoomAmount::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float zoom_amount = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_zoom_amount(&has_bits);
          _impl_.zoom_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_CameraZoomAmount::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_CameraZoomAmount)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float zoom_amount = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_zoom_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_CameraZoomAmount)
  return target;
}

size_t CDOTAClientMsg_CameraZoomAmount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_CameraZoomAmount)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float zoom_amount = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_CameraZoomAmount::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_CameraZoomAmount::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_CameraZoomAmount::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_CameraZoomAmount::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_CameraZoomAmount*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_CameraZoomAmount&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_CameraZoomAmount)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_zoom_amount()) {
    _this->_internal_set_zoom_amount(from._internal_zoom_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_CameraZoomAmount::CopyFrom(const CDOTAClientMsg_CameraZoomAmount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_CameraZoomAmount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_CameraZoomAmount::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_CameraZoomAmount::InternalSwap(CDOTAClientMsg_CameraZoomAmount* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.zoom_amount_, other->_impl_.zoom_amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_CameraZoomAmount::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[34]);
}

// ===================================================================

class CDOTAClientMsg_BroadcasterUsingCameraman::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_BroadcasterUsingCameraman>()._impl_._has_bits_);
  static void set_has_cameraman(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_BroadcasterUsingCameraman::CDOTAClientMsg_BroadcasterUsingCameraman(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_BroadcasterUsingCameraman)
}
CDOTAClientMsg_BroadcasterUsingCameraman::CDOTAClientMsg_BroadcasterUsingCameraman(const CDOTAClientMsg_BroadcasterUsingCameraman& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_BroadcasterUsingCameraman* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cameraman_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.cameraman_ = from._impl_.cameraman_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_BroadcasterUsingCameraman)
}

inline void CDOTAClientMsg_BroadcasterUsingCameraman::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cameraman_){false}
  };
}

CDOTAClientMsg_BroadcasterUsingCameraman::~CDOTAClientMsg_BroadcasterUsingCameraman() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_BroadcasterUsingCameraman)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_BroadcasterUsingCameraman::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_BroadcasterUsingCameraman::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_BroadcasterUsingCameraman::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_BroadcasterUsingCameraman)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cameraman_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_BroadcasterUsingCameraman::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool cameraman = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cameraman(&has_bits);
          _impl_.cameraman_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_BroadcasterUsingCameraman::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_BroadcasterUsingCameraman)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool cameraman = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_cameraman(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_BroadcasterUsingCameraman)
  return target;
}

size_t CDOTAClientMsg_BroadcasterUsingCameraman::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_BroadcasterUsingCameraman)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool cameraman = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_BroadcasterUsingCameraman::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_BroadcasterUsingCameraman::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_BroadcasterUsingCameraman::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_BroadcasterUsingCameraman::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_BroadcasterUsingCameraman*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_BroadcasterUsingCameraman&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_BroadcasterUsingCameraman)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_cameraman()) {
    _this->_internal_set_cameraman(from._internal_cameraman());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_BroadcasterUsingCameraman::CopyFrom(const CDOTAClientMsg_BroadcasterUsingCameraman& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_BroadcasterUsingCameraman)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_BroadcasterUsingCameraman::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_BroadcasterUsingCameraman::InternalSwap(CDOTAClientMsg_BroadcasterUsingCameraman* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.cameraman_, other->_impl_.cameraman_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_BroadcasterUsingCameraman::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[35]);
}

// ===================================================================

class CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)
}
CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator(const CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)
}

inline void CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::~CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)
  return target;
}

size_t CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::CopyFrom(const CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::InternalSwap(CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[36]);
}

// ===================================================================

class CDOTAClientMsg_FillEmptySlotsWithBots::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_FillEmptySlotsWithBots>()._impl_._has_bits_);
  static void set_has_fillwithbots(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_FillEmptySlotsWithBots::CDOTAClientMsg_FillEmptySlotsWithBots(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_FillEmptySlotsWithBots)
}
CDOTAClientMsg_FillEmptySlotsWithBots::CDOTAClientMsg_FillEmptySlotsWithBots(const CDOTAClientMsg_FillEmptySlotsWithBots& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_FillEmptySlotsWithBots* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fillwithbots_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.fillwithbots_ = from._impl_.fillwithbots_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_FillEmptySlotsWithBots)
}

inline void CDOTAClientMsg_FillEmptySlotsWithBots::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fillwithbots_){false}
  };
}

CDOTAClientMsg_FillEmptySlotsWithBots::~CDOTAClientMsg_FillEmptySlotsWithBots() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_FillEmptySlotsWithBots)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_FillEmptySlotsWithBots::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_FillEmptySlotsWithBots::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_FillEmptySlotsWithBots::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_FillEmptySlotsWithBots)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fillwithbots_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_FillEmptySlotsWithBots::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool fillwithbots = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_fillwithbots(&has_bits);
          _impl_.fillwithbots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_FillEmptySlotsWithBots::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_FillEmptySlotsWithBots)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool fillwithbots = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_fillwithbots(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_FillEmptySlotsWithBots)
  return target;
}

size_t CDOTAClientMsg_FillEmptySlotsWithBots::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_FillEmptySlotsWithBots)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool fillwithbots = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_FillEmptySlotsWithBots::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_FillEmptySlotsWithBots::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_FillEmptySlotsWithBots::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_FillEmptySlotsWithBots::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_FillEmptySlotsWithBots*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_FillEmptySlotsWithBots&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_FillEmptySlotsWithBots)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_fillwithbots()) {
    _this->_internal_set_fillwithbots(from._internal_fillwithbots());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_FillEmptySlotsWithBots::CopyFrom(const CDOTAClientMsg_FillEmptySlotsWithBots& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_FillEmptySlotsWithBots)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_FillEmptySlotsWithBots::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_FillEmptySlotsWithBots::InternalSwap(CDOTAClientMsg_FillEmptySlotsWithBots* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.fillwithbots_, other->_impl_.fillwithbots_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_FillEmptySlotsWithBots::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[37]);
}

// ===================================================================

class CDOTAClientMsg_HeroStatueLike::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_HeroStatueLike>()._impl_._has_bits_);
  static void set_has_owner_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_HeroStatueLike::CDOTAClientMsg_HeroStatueLike(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_HeroStatueLike)
}
CDOTAClientMsg_HeroStatueLike::CDOTAClientMsg_HeroStatueLike(const CDOTAClientMsg_HeroStatueLike& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_HeroStatueLike* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.owner_player_id_ = from._impl_.owner_player_id_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_HeroStatueLike)
}

inline void CDOTAClientMsg_HeroStatueLike::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_player_id_){-1}
  };
}

CDOTAClientMsg_HeroStatueLike::~CDOTAClientMsg_HeroStatueLike() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_HeroStatueLike)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_HeroStatueLike::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_HeroStatueLike::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_HeroStatueLike::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_HeroStatueLike)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.owner_player_id_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_HeroStatueLike::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 owner_player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_owner_player_id(&has_bits);
          _impl_.owner_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_HeroStatueLike::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_HeroStatueLike)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 owner_player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_owner_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_HeroStatueLike)
  return target;
}

size_t CDOTAClientMsg_HeroStatueLike::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_HeroStatueLike)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 owner_player_id = 1 [default = -1];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_owner_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_HeroStatueLike::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_HeroStatueLike::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_HeroStatueLike::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_HeroStatueLike::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_HeroStatueLike*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_HeroStatueLike&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_HeroStatueLike)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_owner_player_id()) {
    _this->_internal_set_owner_player_id(from._internal_owner_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_HeroStatueLike::CopyFrom(const CDOTAClientMsg_HeroStatueLike& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_HeroStatueLike)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_HeroStatueLike::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_HeroStatueLike::InternalSwap(CDOTAClientMsg_HeroStatueLike* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.owner_player_id_, other->_impl_.owner_player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_HeroStatueLike::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[38]);
}

// ===================================================================

class CDOTAClientMsg_EventCNY2015Cmd::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_EventCNY2015Cmd>()._impl_._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_EventCNY2015Cmd::CDOTAClientMsg_EventCNY2015Cmd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_EventCNY2015Cmd)
}
CDOTAClientMsg_EventCNY2015Cmd::CDOTAClientMsg_EventCNY2015Cmd(const CDOTAClientMsg_EventCNY2015Cmd& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_EventCNY2015Cmd* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_EventCNY2015Cmd)
}

inline void CDOTAClientMsg_EventCNY2015Cmd::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CDOTAClientMsg_EventCNY2015Cmd::~CDOTAClientMsg_EventCNY2015Cmd() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_EventCNY2015Cmd)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_EventCNY2015Cmd::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CDOTAClientMsg_EventCNY2015Cmd::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_EventCNY2015Cmd::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_EventCNY2015Cmd)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_EventCNY2015Cmd::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_EventCNY2015Cmd::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_EventCNY2015Cmd)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_EventCNY2015Cmd)
  return target;
}

size_t CDOTAClientMsg_EventCNY2015Cmd::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_EventCNY2015Cmd)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes data = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_EventCNY2015Cmd::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_EventCNY2015Cmd::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_EventCNY2015Cmd::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_EventCNY2015Cmd::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_EventCNY2015Cmd*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_EventCNY2015Cmd&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_EventCNY2015Cmd)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_data()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_EventCNY2015Cmd::CopyFrom(const CDOTAClientMsg_EventCNY2015Cmd& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_EventCNY2015Cmd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_EventCNY2015Cmd::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_EventCNY2015Cmd::InternalSwap(CDOTAClientMsg_EventCNY2015Cmd* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_EventCNY2015Cmd::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[39]);
}

// ===================================================================

class CDOTAClientMsg_DemoHero::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_DemoHero>()._impl_._has_bits_);
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hero_id_to_spawn(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_style_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_keep_existing_demohero(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CDOTAClientMsg_DemoHero::CDOTAClientMsg_DemoHero(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_DemoHero)
}
CDOTAClientMsg_DemoHero::CDOTAClientMsg_DemoHero(const CDOTAClientMsg_DemoHero& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_DemoHero* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_defs_){from._impl_.item_defs_}
    , decltype(_impl_.item_ids_){from._impl_.item_ids_}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.hero_id_to_spawn_){}
    , decltype(_impl_.keep_existing_demohero_){}
    , decltype(_impl_.style_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hero_id_, &from._impl_.hero_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.style_index_) -
    reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.style_index_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_DemoHero)
}

inline void CDOTAClientMsg_DemoHero::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_defs_){arena}
    , decltype(_impl_.item_ids_){arena}
    , decltype(_impl_.hero_id_){0}
    , decltype(_impl_.hero_id_to_spawn_){0}
    , decltype(_impl_.keep_existing_demohero_){false}
    , decltype(_impl_.style_index_){255u}
  };
}

CDOTAClientMsg_DemoHero::~CDOTAClientMsg_DemoHero() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_DemoHero)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_DemoHero::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.item_defs_.~RepeatedField();
  _impl_.item_ids_.~RepeatedField();
}

void CDOTAClientMsg_DemoHero::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_DemoHero::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_DemoHero)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.item_defs_.Clear();
  _impl_.item_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.hero_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.keep_existing_demohero_) -
        reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.keep_existing_demohero_));
    _impl_.style_index_ = 255u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_DemoHero::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 hero_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 hero_id_to_spawn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hero_id_to_spawn(&has_bits);
          _impl_.hero_id_to_spawn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 item_defs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_item_defs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_item_defs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 item_ids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_item_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_item_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 style_index = 5 [default = 255];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_style_index(&has_bits);
          _impl_.style_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool keep_existing_demohero = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_keep_existing_demohero(&has_bits);
          _impl_.keep_existing_demohero_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_DemoHero::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_DemoHero)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 hero_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hero_id(), target);
  }

  // optional int32 hero_id_to_spawn = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_hero_id_to_spawn(), target);
  }

  // repeated uint32 item_defs = 3;
  for (int i = 0, n = this->_internal_item_defs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_item_defs(i), target);
  }

  // repeated uint64 item_ids = 4;
  for (int i = 0, n = this->_internal_item_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_item_ids(i), target);
  }

  // optional uint32 style_index = 5 [default = 255];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_style_index(), target);
  }

  // optional bool keep_existing_demohero = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_keep_existing_demohero(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_DemoHero)
  return target;
}

size_t CDOTAClientMsg_DemoHero::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_DemoHero)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 item_defs = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.item_defs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_item_defs_size());
    total_size += data_size;
  }

  // repeated uint64 item_ids = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.item_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_item_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 hero_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hero_id());
    }

    // optional int32 hero_id_to_spawn = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hero_id_to_spawn());
    }

    // optional bool keep_existing_demohero = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 style_index = 5 [default = 255];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_style_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_DemoHero::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_DemoHero::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_DemoHero::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_DemoHero::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_DemoHero*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_DemoHero&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_DemoHero)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.item_defs_.MergeFrom(from._impl_.item_defs_);
  _this->_impl_.item_ids_.MergeFrom(from._impl_.item_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hero_id_to_spawn_ = from._impl_.hero_id_to_spawn_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.keep_existing_demohero_ = from._impl_.keep_existing_demohero_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.style_index_ = from._impl_.style_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_DemoHero::CopyFrom(const CDOTAClientMsg_DemoHero& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_DemoHero)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_DemoHero::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_DemoHero::InternalSwap(CDOTAClientMsg_DemoHero* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.item_defs_.InternalSwap(&other->_impl_.item_defs_);
  _impl_.item_ids_.InternalSwap(&other->_impl_.item_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_DemoHero, _impl_.keep_existing_demohero_)
      + sizeof(CDOTAClientMsg_DemoHero::_impl_.keep_existing_demohero_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_DemoHero, _impl_.hero_id_)>(
          reinterpret_cast<char*>(&_impl_.hero_id_),
          reinterpret_cast<char*>(&other->_impl_.hero_id_));
  swap(_impl_.style_index_, other->_impl_.style_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_DemoHero::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[40]);
}

// ===================================================================

class CDOTAClientMsg_ChallengeSelect::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_ChallengeSelect>()._impl_._has_bits_);
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_slot_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CDOTAClientMsg_ChallengeSelect::CDOTAClientMsg_ChallengeSelect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ChallengeSelect)
}
CDOTAClientMsg_ChallengeSelect::CDOTAClientMsg_ChallengeSelect(const CDOTAClientMsg_ChallengeSelect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ChallengeSelect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_id_){}
    , decltype(_impl_.slot_id_){}
    , decltype(_impl_.sequence_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.event_id_, &from._impl_.event_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sequence_id_) -
    reinterpret_cast<char*>(&_impl_.event_id_)) + sizeof(_impl_.sequence_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ChallengeSelect)
}

inline void CDOTAClientMsg_ChallengeSelect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_id_){0u}
    , decltype(_impl_.slot_id_){0u}
    , decltype(_impl_.sequence_id_){0u}
  };
}

CDOTAClientMsg_ChallengeSelect::~CDOTAClientMsg_ChallengeSelect() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ChallengeSelect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ChallengeSelect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_ChallengeSelect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ChallengeSelect::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ChallengeSelect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.event_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sequence_id_) -
        reinterpret_cast<char*>(&_impl_.event_id_)) + sizeof(_impl_.sequence_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ChallengeSelect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 event_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_event_id(&has_bits);
          _impl_.event_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 slot_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_slot_id(&has_bits);
          _impl_.slot_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sequence_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sequence_id(&has_bits);
          _impl_.sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ChallengeSelect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ChallengeSelect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 event_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_event_id(), target);
  }

  // optional uint32 slot_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_slot_id(), target);
  }

  // optional uint32 sequence_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sequence_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ChallengeSelect)
  return target;
}

size_t CDOTAClientMsg_ChallengeSelect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ChallengeSelect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 event_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_event_id());
    }

    // optional uint32 slot_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_slot_id());
    }

    // optional uint32 sequence_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sequence_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ChallengeSelect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ChallengeSelect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ChallengeSelect::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ChallengeSelect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ChallengeSelect*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ChallengeSelect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ChallengeSelect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.slot_id_ = from._impl_.slot_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sequence_id_ = from._impl_.sequence_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ChallengeSelect::CopyFrom(const CDOTAClientMsg_ChallengeSelect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ChallengeSelect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ChallengeSelect::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ChallengeSelect::InternalSwap(CDOTAClientMsg_ChallengeSelect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_ChallengeSelect, _impl_.sequence_id_)
      + sizeof(CDOTAClientMsg_ChallengeSelect::_impl_.sequence_id_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_ChallengeSelect, _impl_.event_id_)>(
          reinterpret_cast<char*>(&_impl_.event_id_),
          reinterpret_cast<char*>(&other->_impl_.event_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ChallengeSelect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[41]);
}

// ===================================================================

class CDOTAClientMsg_ChallengeReroll::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_ChallengeReroll>()._impl_._has_bits_);
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_slot_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CDOTAClientMsg_ChallengeReroll::CDOTAClientMsg_ChallengeReroll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ChallengeReroll)
}
CDOTAClientMsg_ChallengeReroll::CDOTAClientMsg_ChallengeReroll(const CDOTAClientMsg_ChallengeReroll& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ChallengeReroll* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_id_){}
    , decltype(_impl_.slot_id_){}
    , decltype(_impl_.sequence_id_){}
    , decltype(_impl_.hero_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.event_id_, &from._impl_.event_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hero_id_) -
    reinterpret_cast<char*>(&_impl_.event_id_)) + sizeof(_impl_.hero_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ChallengeReroll)
}

inline void CDOTAClientMsg_ChallengeReroll::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_id_){0}
    , decltype(_impl_.slot_id_){0u}
    , decltype(_impl_.sequence_id_){0u}
    , decltype(_impl_.hero_id_){0u}
  };
}

CDOTAClientMsg_ChallengeReroll::~CDOTAClientMsg_ChallengeReroll() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ChallengeReroll)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ChallengeReroll::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_ChallengeReroll::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ChallengeReroll::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ChallengeReroll)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.event_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hero_id_) -
        reinterpret_cast<char*>(&_impl_.event_id_)) + sizeof(_impl_.hero_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ChallengeReroll::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EEvent_IsValid(val))) {
            _internal_set_event_id(static_cast<::EEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 slot_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_slot_id(&has_bits);
          _impl_.slot_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sequence_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sequence_id(&has_bits);
          _impl_.sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hero_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ChallengeReroll::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ChallengeReroll)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event_id(), target);
  }

  // optional uint32 slot_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_slot_id(), target);
  }

  // optional uint32 sequence_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sequence_id(), target);
  }

  // optional uint32 hero_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_hero_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ChallengeReroll)
  return target;
}

size_t CDOTAClientMsg_ChallengeReroll::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ChallengeReroll)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event_id());
    }

    // optional uint32 slot_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_slot_id());
    }

    // optional uint32 sequence_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sequence_id());
    }

    // optional uint32 hero_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hero_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ChallengeReroll::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ChallengeReroll::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ChallengeReroll::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ChallengeReroll::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ChallengeReroll*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ChallengeReroll&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ChallengeReroll)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.slot_id_ = from._impl_.slot_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sequence_id_ = from._impl_.sequence_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ChallengeReroll::CopyFrom(const CDOTAClientMsg_ChallengeReroll& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ChallengeReroll)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ChallengeReroll::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ChallengeReroll::InternalSwap(CDOTAClientMsg_ChallengeReroll* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_ChallengeReroll, _impl_.hero_id_)
      + sizeof(CDOTAClientMsg_ChallengeReroll::_impl_.hero_id_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_ChallengeReroll, _impl_.event_id_)>(
          reinterpret_cast<char*>(&_impl_.event_id_),
          reinterpret_cast<char*>(&other->_impl_.event_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ChallengeReroll::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[42]);
}

// ===================================================================

class CDOTAClientMsg_CoinWager::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_CoinWager>()._impl_._has_bits_);
  static void set_has_wager_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_CoinWager::CDOTAClientMsg_CoinWager(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_CoinWager)
}
CDOTAClientMsg_CoinWager::CDOTAClientMsg_CoinWager(const CDOTAClientMsg_CoinWager& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_CoinWager* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.wager_amount_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.wager_amount_ = from._impl_.wager_amount_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_CoinWager)
}

inline void CDOTAClientMsg_CoinWager::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.wager_amount_){0u}
  };
}

CDOTAClientMsg_CoinWager::~CDOTAClientMsg_CoinWager() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_CoinWager)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_CoinWager::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_CoinWager::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_CoinWager::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_CoinWager)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wager_amount_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_CoinWager::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 wager_amount = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_wager_amount(&has_bits);
          _impl_.wager_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_CoinWager::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_CoinWager)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 wager_amount = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_wager_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_CoinWager)
  return target;
}

size_t CDOTAClientMsg_CoinWager::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_CoinWager)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 wager_amount = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_wager_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_CoinWager::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_CoinWager::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_CoinWager::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_CoinWager::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_CoinWager*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_CoinWager&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_CoinWager)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_wager_amount()) {
    _this->_internal_set_wager_amount(from._internal_wager_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_CoinWager::CopyFrom(const CDOTAClientMsg_CoinWager& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_CoinWager)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_CoinWager::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_CoinWager::InternalSwap(CDOTAClientMsg_CoinWager* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.wager_amount_, other->_impl_.wager_amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_CoinWager::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[43]);
}

// ===================================================================

class CDOTAClientMsg_CoinWagerToken::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_CoinWagerToken>()._impl_._has_bits_);
  static void set_has_wager_token_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_CoinWagerToken::CDOTAClientMsg_CoinWagerToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_CoinWagerToken)
}
CDOTAClientMsg_CoinWagerToken::CDOTAClientMsg_CoinWagerToken(const CDOTAClientMsg_CoinWagerToken& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_CoinWagerToken* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.wager_token_item_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.wager_token_item_id_ = from._impl_.wager_token_item_id_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_CoinWagerToken)
}

inline void CDOTAClientMsg_CoinWagerToken::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.wager_token_item_id_){uint64_t{0u}}
  };
}

CDOTAClientMsg_CoinWagerToken::~CDOTAClientMsg_CoinWagerToken() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_CoinWagerToken)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_CoinWagerToken::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_CoinWagerToken::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_CoinWagerToken::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_CoinWagerToken)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wager_token_item_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_CoinWagerToken::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 wager_token_item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_wager_token_item_id(&has_bits);
          _impl_.wager_token_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_CoinWagerToken::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_CoinWagerToken)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 wager_token_item_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_wager_token_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_CoinWagerToken)
  return target;
}

size_t CDOTAClientMsg_CoinWagerToken::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_CoinWagerToken)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 wager_token_item_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_wager_token_item_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_CoinWagerToken::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_CoinWagerToken::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_CoinWagerToken::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_CoinWagerToken::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_CoinWagerToken*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_CoinWagerToken&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_CoinWagerToken)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_wager_token_item_id()) {
    _this->_internal_set_wager_token_item_id(from._internal_wager_token_item_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_CoinWagerToken::CopyFrom(const CDOTAClientMsg_CoinWagerToken& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_CoinWagerToken)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_CoinWagerToken::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_CoinWagerToken::InternalSwap(CDOTAClientMsg_CoinWagerToken* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.wager_token_item_id_, other->_impl_.wager_token_item_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_CoinWagerToken::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[44]);
}

// ===================================================================

class CDOTAClientMsg_RankWager::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_RankWager>()._impl_._has_bits_);
  static void set_has_announce_wager(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_RankWager::CDOTAClientMsg_RankWager(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_RankWager)
}
CDOTAClientMsg_RankWager::CDOTAClientMsg_RankWager(const CDOTAClientMsg_RankWager& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_RankWager* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.announce_wager_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.announce_wager_ = from._impl_.announce_wager_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_RankWager)
}

inline void CDOTAClientMsg_RankWager::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.announce_wager_){false}
  };
}

CDOTAClientMsg_RankWager::~CDOTAClientMsg_RankWager() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_RankWager)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_RankWager::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_RankWager::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_RankWager::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_RankWager)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.announce_wager_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_RankWager::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool announce_wager = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_announce_wager(&has_bits);
          _impl_.announce_wager_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_RankWager::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_RankWager)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool announce_wager = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_announce_wager(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_RankWager)
  return target;
}

size_t CDOTAClientMsg_RankWager::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_RankWager)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool announce_wager = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_RankWager::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_RankWager::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_RankWager::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_RankWager::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_RankWager*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_RankWager&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_RankWager)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_announce_wager()) {
    _this->_internal_set_announce_wager(from._internal_announce_wager());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_RankWager::CopyFrom(const CDOTAClientMsg_RankWager& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_RankWager)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_RankWager::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_RankWager::InternalSwap(CDOTAClientMsg_RankWager* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.announce_wager_, other->_impl_.announce_wager_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_RankWager::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[45]);
}

// ===================================================================

class CDOTAClientMsg_PlayerBounty::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_PlayerBounty>()._impl_._has_bits_);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_PlayerBounty::CDOTAClientMsg_PlayerBounty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_PlayerBounty)
}
CDOTAClientMsg_PlayerBounty::CDOTAClientMsg_PlayerBounty(const CDOTAClientMsg_PlayerBounty& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_PlayerBounty* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.player_id_ = from._impl_.player_id_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_PlayerBounty)
}

inline void CDOTAClientMsg_PlayerBounty::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){-1}
  };
}

CDOTAClientMsg_PlayerBounty::~CDOTAClientMsg_PlayerBounty() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_PlayerBounty)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_PlayerBounty::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_PlayerBounty::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_PlayerBounty::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_PlayerBounty)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_id_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_PlayerBounty::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_PlayerBounty::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_PlayerBounty)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_PlayerBounty)
  return target;
}

size_t CDOTAClientMsg_PlayerBounty::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_PlayerBounty)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 player_id = 1 [default = -1];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_PlayerBounty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_PlayerBounty::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_PlayerBounty::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_PlayerBounty::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_PlayerBounty*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_PlayerBounty&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_PlayerBounty)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_player_id()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_PlayerBounty::CopyFrom(const CDOTAClientMsg_PlayerBounty& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_PlayerBounty)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_PlayerBounty::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_PlayerBounty::InternalSwap(CDOTAClientMsg_PlayerBounty* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.player_id_, other->_impl_.player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_PlayerBounty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[46]);
}

// ===================================================================

class CDOTAClientMsg_EventPointsTip::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_EventPointsTip>()._impl_._has_bits_);
  static void set_has_recipient_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_EventPointsTip::CDOTAClientMsg_EventPointsTip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_EventPointsTip)
}
CDOTAClientMsg_EventPointsTip::CDOTAClientMsg_EventPointsTip(const CDOTAClientMsg_EventPointsTip& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_EventPointsTip* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.recipient_player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.recipient_player_id_ = from._impl_.recipient_player_id_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_EventPointsTip)
}

inline void CDOTAClientMsg_EventPointsTip::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.recipient_player_id_){-1}
  };
}

CDOTAClientMsg_EventPointsTip::~CDOTAClientMsg_EventPointsTip() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_EventPointsTip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_EventPointsTip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_EventPointsTip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_EventPointsTip::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_EventPointsTip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.recipient_player_id_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_EventPointsTip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 recipient_player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_recipient_player_id(&has_bits);
          _impl_.recipient_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_EventPointsTip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_EventPointsTip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 recipient_player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_recipient_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_EventPointsTip)
  return target;
}

size_t CDOTAClientMsg_EventPointsTip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_EventPointsTip)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 recipient_player_id = 1 [default = -1];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_recipient_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_EventPointsTip::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_EventPointsTip::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_EventPointsTip::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_EventPointsTip::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_EventPointsTip*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_EventPointsTip&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_EventPointsTip)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_recipient_player_id()) {
    _this->_internal_set_recipient_player_id(from._internal_recipient_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_EventPointsTip::CopyFrom(const CDOTAClientMsg_EventPointsTip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_EventPointsTip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_EventPointsTip::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_EventPointsTip::InternalSwap(CDOTAClientMsg_EventPointsTip* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.recipient_player_id_, other->_impl_.recipient_player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_EventPointsTip::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[47]);
}

// ===================================================================

class CDOTAClientMsg_ExecuteOrders::_Internal {
 public:
};

void CDOTAClientMsg_ExecuteOrders::clear_orders() {
  _impl_.orders_.Clear();
}
CDOTAClientMsg_ExecuteOrders::CDOTAClientMsg_ExecuteOrders(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ExecuteOrders)
}
CDOTAClientMsg_ExecuteOrders::CDOTAClientMsg_ExecuteOrders(const CDOTAClientMsg_ExecuteOrders& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ExecuteOrders* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.orders_){from._impl_.orders_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ExecuteOrders)
}

inline void CDOTAClientMsg_ExecuteOrders::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.orders_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CDOTAClientMsg_ExecuteOrders::~CDOTAClientMsg_ExecuteOrders() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ExecuteOrders)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ExecuteOrders::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.orders_.~RepeatedPtrField();
}

void CDOTAClientMsg_ExecuteOrders::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ExecuteOrders::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ExecuteOrders)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.orders_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ExecuteOrders::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CDOTAMsg_UnitOrder orders = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ExecuteOrders::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ExecuteOrders)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CDOTAMsg_UnitOrder orders = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_orders_size()); i < n; i++) {
    const auto& repfield = this->_internal_orders(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ExecuteOrders)
  return target;
}

size_t CDOTAClientMsg_ExecuteOrders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ExecuteOrders)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CDOTAMsg_UnitOrder orders = 1;
  total_size += 1UL * this->_internal_orders_size();
  for (const auto& msg : this->_impl_.orders_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ExecuteOrders::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ExecuteOrders::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ExecuteOrders::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ExecuteOrders::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ExecuteOrders*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ExecuteOrders&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ExecuteOrders)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.orders_.MergeFrom(from._impl_.orders_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ExecuteOrders::CopyFrom(const CDOTAClientMsg_ExecuteOrders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ExecuteOrders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ExecuteOrders::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ExecuteOrders::InternalSwap(CDOTAClientMsg_ExecuteOrders* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.orders_.InternalSwap(&other->_impl_.orders_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ExecuteOrders::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[48]);
}

// ===================================================================

class CDOTAClientMsg_XPAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_XPAlert>()._impl_._has_bits_);
  static void set_has_target_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_damage_taken(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_XPAlert::CDOTAClientMsg_XPAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_XPAlert)
}
CDOTAClientMsg_XPAlert::CDOTAClientMsg_XPAlert(const CDOTAClientMsg_XPAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_XPAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.damage_taken_){}
    , decltype(_impl_.target_entindex_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.damage_taken_, &from._impl_.damage_taken_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_entindex_) -
    reinterpret_cast<char*>(&_impl_.damage_taken_)) + sizeof(_impl_.target_entindex_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_XPAlert)
}

inline void CDOTAClientMsg_XPAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.damage_taken_){0u}
    , decltype(_impl_.target_entindex_){-1}
  };
}

CDOTAClientMsg_XPAlert::~CDOTAClientMsg_XPAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_XPAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_XPAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_XPAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_XPAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_XPAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.damage_taken_ = 0u;
    _impl_.target_entindex_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_XPAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 target_entindex = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_target_entindex(&has_bits);
          _impl_.target_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 damage_taken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_damage_taken(&has_bits);
          _impl_.damage_taken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_XPAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_XPAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 target_entindex = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_target_entindex(), target);
  }

  // optional uint32 damage_taken = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_damage_taken(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_XPAlert)
  return target;
}

size_t CDOTAClientMsg_XPAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_XPAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 damage_taken = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_damage_taken());
    }

    // optional int32 target_entindex = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_entindex());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_XPAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_XPAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_XPAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_XPAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_XPAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_XPAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_XPAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.damage_taken_ = from._impl_.damage_taken_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_entindex_ = from._impl_.target_entindex_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_XPAlert::CopyFrom(const CDOTAClientMsg_XPAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_XPAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_XPAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_XPAlert::InternalSwap(CDOTAClientMsg_XPAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.damage_taken_, other->_impl_.damage_taken_);
  swap(_impl_.target_entindex_, other->_impl_.target_entindex_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_XPAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[49]);
}

// ===================================================================

class CDOTAClientMsg_TalentTreeAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_TalentTreeAlert>()._impl_._has_bits_);
  static void set_has_target_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_learned(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_TalentTreeAlert::CDOTAClientMsg_TalentTreeAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_TalentTreeAlert)
}
CDOTAClientMsg_TalentTreeAlert::CDOTAClientMsg_TalentTreeAlert(const CDOTAClientMsg_TalentTreeAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_TalentTreeAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_){}
    , decltype(_impl_.learned_){}
    , decltype(_impl_.target_entindex_){}
    , decltype(_impl_.ability_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.slot_, &from._impl_.slot_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ability_id_) -
    reinterpret_cast<char*>(&_impl_.slot_)) + sizeof(_impl_.ability_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_TalentTreeAlert)
}

inline void CDOTAClientMsg_TalentTreeAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_){0}
    , decltype(_impl_.learned_){false}
    , decltype(_impl_.target_entindex_){-1}
    , decltype(_impl_.ability_id_){-1}
  };
}

CDOTAClientMsg_TalentTreeAlert::~CDOTAClientMsg_TalentTreeAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_TalentTreeAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_TalentTreeAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_TalentTreeAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_TalentTreeAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_TalentTreeAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.slot_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.learned_) -
        reinterpret_cast<char*>(&_impl_.slot_)) + sizeof(_impl_.learned_));
    _impl_.target_entindex_ = -1;
    _impl_.ability_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_TalentTreeAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 target_entindex = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_target_entindex(&has_bits);
          _impl_.target_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ability_id = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ability_id(&has_bits);
          _impl_.ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 slot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_slot(&has_bits);
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool learned = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_learned(&has_bits);
          _impl_.learned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_TalentTreeAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_TalentTreeAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 target_entindex = 1 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_target_entindex(), target);
  }

  // optional int32 ability_id = 2 [default = -1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_ability_id(), target);
  }

  // optional int32 slot = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_slot(), target);
  }

  // optional bool learned = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_learned(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_TalentTreeAlert)
  return target;
}

size_t CDOTAClientMsg_TalentTreeAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_TalentTreeAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 slot = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
    }

    // optional bool learned = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional int32 target_entindex = 1 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_entindex());
    }

    // optional int32 ability_id = 2 [default = -1];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ability_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_TalentTreeAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_TalentTreeAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_TalentTreeAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_TalentTreeAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_TalentTreeAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_TalentTreeAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_TalentTreeAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.slot_ = from._impl_.slot_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.learned_ = from._impl_.learned_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.target_entindex_ = from._impl_.target_entindex_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ability_id_ = from._impl_.ability_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_TalentTreeAlert::CopyFrom(const CDOTAClientMsg_TalentTreeAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_TalentTreeAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_TalentTreeAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_TalentTreeAlert::InternalSwap(CDOTAClientMsg_TalentTreeAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_TalentTreeAlert, _impl_.learned_)
      + sizeof(CDOTAClientMsg_TalentTreeAlert::_impl_.learned_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_TalentTreeAlert, _impl_.slot_)>(
          reinterpret_cast<char*>(&_impl_.slot_),
          reinterpret_cast<char*>(&other->_impl_.slot_));
  swap(_impl_.target_entindex_, other->_impl_.target_entindex_);
  swap(_impl_.ability_id_, other->_impl_.ability_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_TalentTreeAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[50]);
}

// ===================================================================

class CDOTAClientMsg_KillcamDamageTaken::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_KillcamDamageTaken>()._impl_._has_bits_);
  static void set_has_target_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_damage_taken(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_item_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_item_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_hero_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_damage_color(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_KillcamDamageTaken::CDOTAClientMsg_KillcamDamageTaken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_KillcamDamageTaken)
}
CDOTAClientMsg_KillcamDamageTaken::CDOTAClientMsg_KillcamDamageTaken(const CDOTAClientMsg_KillcamDamageTaken& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_KillcamDamageTaken* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_name_){}
    , decltype(_impl_.damage_color_){}
    , decltype(_impl_.damage_taken_){}
    , decltype(_impl_.item_type_){}
    , decltype(_impl_.target_entindex_){}
    , decltype(_impl_.item_ability_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hero_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hero_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hero_name()) {
    _this->_impl_.hero_name_.Set(from._internal_hero_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.damage_color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.damage_color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_damage_color()) {
    _this->_impl_.damage_color_.Set(from._internal_damage_color(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.damage_taken_, &from._impl_.damage_taken_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_ability_id_) -
    reinterpret_cast<char*>(&_impl_.damage_taken_)) + sizeof(_impl_.item_ability_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_KillcamDamageTaken)
}

inline void CDOTAClientMsg_KillcamDamageTaken::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_name_){}
    , decltype(_impl_.damage_color_){}
    , decltype(_impl_.damage_taken_){0u}
    , decltype(_impl_.item_type_){0u}
    , decltype(_impl_.target_entindex_){-1}
    , decltype(_impl_.item_ability_id_){-1}
  };
  _impl_.hero_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hero_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.damage_color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.damage_color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CDOTAClientMsg_KillcamDamageTaken::~CDOTAClientMsg_KillcamDamageTaken() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_KillcamDamageTaken)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_KillcamDamageTaken::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hero_name_.Destroy();
  _impl_.damage_color_.Destroy();
}

void CDOTAClientMsg_KillcamDamageTaken::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_KillcamDamageTaken::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_KillcamDamageTaken)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hero_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.damage_color_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.damage_taken_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.item_type_) -
        reinterpret_cast<char*>(&_impl_.damage_taken_)) + sizeof(_impl_.item_type_));
    _impl_.target_entindex_ = -1;
    _impl_.item_ability_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_KillcamDamageTaken::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 target_entindex = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_target_entindex(&has_bits);
          _impl_.target_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 damage_taken = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_damage_taken(&has_bits);
          _impl_.damage_taken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 item_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_type(&has_bits);
          _impl_.item_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_ability_id = 4 [default = -1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_item_ability_id(&has_bits);
          _impl_.item_ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string hero_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_hero_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CDOTAClientMsg_KillcamDamageTaken.hero_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string damage_color = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_damage_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CDOTAClientMsg_KillcamDamageTaken.damage_color");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_KillcamDamageTaken::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_KillcamDamageTaken)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 target_entindex = 1 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_target_entindex(), target);
  }

  // optional uint32 damage_taken = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_damage_taken(), target);
  }

  // optional uint32 item_type = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_item_type(), target);
  }

  // optional int32 item_ability_id = 4 [default = -1];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_item_ability_id(), target);
  }

  // optional string hero_name = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hero_name().data(), static_cast<int>(this->_internal_hero_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDOTAClientMsg_KillcamDamageTaken.hero_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_hero_name(), target);
  }

  // optional string damage_color = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_damage_color().data(), static_cast<int>(this->_internal_damage_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDOTAClientMsg_KillcamDamageTaken.damage_color");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_damage_color(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_KillcamDamageTaken)
  return target;
}

size_t CDOTAClientMsg_KillcamDamageTaken::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_KillcamDamageTaken)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string hero_name = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hero_name());
    }

    // optional string damage_color = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_damage_color());
    }

    // optional uint32 damage_taken = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_damage_taken());
    }

    // optional uint32 item_type = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_item_type());
    }

    // optional int32 target_entindex = 1 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_entindex());
    }

    // optional int32 item_ability_id = 4 [default = -1];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_ability_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_KillcamDamageTaken::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_KillcamDamageTaken::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_KillcamDamageTaken::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_KillcamDamageTaken::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_KillcamDamageTaken*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_KillcamDamageTaken&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_KillcamDamageTaken)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hero_name(from._internal_hero_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_damage_color(from._internal_damage_color());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.damage_taken_ = from._impl_.damage_taken_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.item_type_ = from._impl_.item_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.target_entindex_ = from._impl_.target_entindex_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.item_ability_id_ = from._impl_.item_ability_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_KillcamDamageTaken::CopyFrom(const CDOTAClientMsg_KillcamDamageTaken& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_KillcamDamageTaken)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_KillcamDamageTaken::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_KillcamDamageTaken::InternalSwap(CDOTAClientMsg_KillcamDamageTaken* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hero_name_, lhs_arena,
      &other->_impl_.hero_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.damage_color_, lhs_arena,
      &other->_impl_.damage_color_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_KillcamDamageTaken, _impl_.item_type_)
      + sizeof(CDOTAClientMsg_KillcamDamageTaken::_impl_.item_type_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_KillcamDamageTaken, _impl_.damage_taken_)>(
          reinterpret_cast<char*>(&_impl_.damage_taken_),
          reinterpret_cast<char*>(&other->_impl_.damage_taken_));
  swap(_impl_.target_entindex_, other->_impl_.target_entindex_);
  swap(_impl_.item_ability_id_, other->_impl_.item_ability_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_KillcamDamageTaken::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[51]);
}

// ===================================================================

class CDOTAClientMsg_KillMyHero::_Internal {
 public:
};

CDOTAClientMsg_KillMyHero::CDOTAClientMsg_KillMyHero(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_KillMyHero)
}
CDOTAClientMsg_KillMyHero::CDOTAClientMsg_KillMyHero(const CDOTAClientMsg_KillMyHero& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CDOTAClientMsg_KillMyHero* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_KillMyHero)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_KillMyHero::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_KillMyHero::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_KillMyHero::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[52]);
}

// ===================================================================

class CDOTAClientMsg_QuestStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_QuestStatus>()._impl_._has_bits_);
  static void set_has_quest_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_challenge_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_goal(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_query(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_fail_gametime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_item_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CDOTAClientMsg_QuestStatus::CDOTAClientMsg_QuestStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_QuestStatus)
}
CDOTAClientMsg_QuestStatus::CDOTAClientMsg_QuestStatus(const CDOTAClientMsg_QuestStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_QuestStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.quest_id_){}
    , decltype(_impl_.challenge_id_){}
    , decltype(_impl_.progress_){}
    , decltype(_impl_.goal_){}
    , decltype(_impl_.query_){}
    , decltype(_impl_.fail_gametime_){}
    , decltype(_impl_.item_ability_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.quest_id_, &from._impl_.quest_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.item_ability_id_) -
    reinterpret_cast<char*>(&_impl_.quest_id_)) + sizeof(_impl_.item_ability_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_QuestStatus)
}

inline void CDOTAClientMsg_QuestStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.quest_id_){0u}
    , decltype(_impl_.challenge_id_){0u}
    , decltype(_impl_.progress_){0u}
    , decltype(_impl_.goal_){0u}
    , decltype(_impl_.query_){0u}
    , decltype(_impl_.fail_gametime_){0}
    , decltype(_impl_.item_ability_id_){-1}
  };
}

CDOTAClientMsg_QuestStatus::~CDOTAClientMsg_QuestStatus() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_QuestStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_QuestStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_QuestStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_QuestStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_QuestStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.quest_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.fail_gametime_) -
        reinterpret_cast<char*>(&_impl_.quest_id_)) + sizeof(_impl_.fail_gametime_));
    _impl_.item_ability_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_QuestStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 quest_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_quest_id(&has_bits);
          _impl_.quest_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 challenge_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_challenge_id(&has_bits);
          _impl_.challenge_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 progress = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_progress(&has_bits);
          _impl_.progress_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 goal = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_goal(&has_bits);
          _impl_.goal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 query = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_query(&has_bits);
          _impl_.query_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float fail_gametime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_fail_gametime(&has_bits);
          _impl_.fail_gametime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_ability_id = 7 [default = -1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_item_ability_id(&has_bits);
          _impl_.item_ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_QuestStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_QuestStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 quest_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_quest_id(), target);
  }

  // optional uint32 challenge_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_challenge_id(), target);
  }

  // optional uint32 progress = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_progress(), target);
  }

  // optional uint32 goal = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_goal(), target);
  }

  // optional uint32 query = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_query(), target);
  }

  // optional float fail_gametime = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_fail_gametime(), target);
  }

  // optional int32 item_ability_id = 7 [default = -1];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_item_ability_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_QuestStatus)
  return target;
}

size_t CDOTAClientMsg_QuestStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_QuestStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint32 quest_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_quest_id());
    }

    // optional uint32 challenge_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_challenge_id());
    }

    // optional uint32 progress = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_progress());
    }

    // optional uint32 goal = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_goal());
    }

    // optional uint32 query = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_query());
    }

    // optional float fail_gametime = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional int32 item_ability_id = 7 [default = -1];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_ability_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_QuestStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_QuestStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_QuestStatus::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_QuestStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_QuestStatus*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_QuestStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_QuestStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.quest_id_ = from._impl_.quest_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.challenge_id_ = from._impl_.challenge_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.progress_ = from._impl_.progress_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.goal_ = from._impl_.goal_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.query_ = from._impl_.query_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.fail_gametime_ = from._impl_.fail_gametime_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.item_ability_id_ = from._impl_.item_ability_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_QuestStatus::CopyFrom(const CDOTAClientMsg_QuestStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_QuestStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_QuestStatus::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_QuestStatus::InternalSwap(CDOTAClientMsg_QuestStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_QuestStatus, _impl_.fail_gametime_)
      + sizeof(CDOTAClientMsg_QuestStatus::_impl_.fail_gametime_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_QuestStatus, _impl_.quest_id_)>(
          reinterpret_cast<char*>(&_impl_.quest_id_),
          reinterpret_cast<char*>(&other->_impl_.quest_id_));
  swap(_impl_.item_ability_id_, other->_impl_.item_ability_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_QuestStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[53]);
}

// ===================================================================

class CDOTAClientMsg_ToggleAutoattack::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_ToggleAutoattack>()._impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_show_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_ToggleAutoattack::CDOTAClientMsg_ToggleAutoattack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ToggleAutoattack)
}
CDOTAClientMsg_ToggleAutoattack::CDOTAClientMsg_ToggleAutoattack(const CDOTAClientMsg_ToggleAutoattack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ToggleAutoattack* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.show_message_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.mode_, &from._impl_.mode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.show_message_) -
    reinterpret_cast<char*>(&_impl_.mode_)) + sizeof(_impl_.show_message_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ToggleAutoattack)
}

inline void CDOTAClientMsg_ToggleAutoattack::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){0}
    , decltype(_impl_.show_message_){false}
  };
}

CDOTAClientMsg_ToggleAutoattack::~CDOTAClientMsg_ToggleAutoattack() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ToggleAutoattack)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ToggleAutoattack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_ToggleAutoattack::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ToggleAutoattack::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ToggleAutoattack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.mode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.show_message_) -
        reinterpret_cast<char*>(&_impl_.mode_)) + sizeof(_impl_.show_message_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ToggleAutoattack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_show_message(&has_bits);
          _impl_.show_message_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ToggleAutoattack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ToggleAutoattack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_mode(), target);
  }

  // optional bool show_message = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_show_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ToggleAutoattack)
  return target;
}

size_t CDOTAClientMsg_ToggleAutoattack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ToggleAutoattack)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 mode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mode());
    }

    // optional bool show_message = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ToggleAutoattack::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ToggleAutoattack::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ToggleAutoattack::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ToggleAutoattack::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ToggleAutoattack*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ToggleAutoattack&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ToggleAutoattack)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.show_message_ = from._impl_.show_message_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ToggleAutoattack::CopyFrom(const CDOTAClientMsg_ToggleAutoattack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ToggleAutoattack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ToggleAutoattack::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ToggleAutoattack::InternalSwap(CDOTAClientMsg_ToggleAutoattack* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_ToggleAutoattack, _impl_.show_message_)
      + sizeof(CDOTAClientMsg_ToggleAutoattack::_impl_.show_message_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_ToggleAutoattack, _impl_.mode_)>(
          reinterpret_cast<char*>(&_impl_.mode_),
          reinterpret_cast<char*>(&other->_impl_.mode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ToggleAutoattack::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[54]);
}

// ===================================================================

class CDOTAClientMsg_SpecialAbility::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_SpecialAbility>()._impl_._has_bits_);
  static void set_has_ability_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_target_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_SpecialAbility::CDOTAClientMsg_SpecialAbility(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_SpecialAbility)
}
CDOTAClientMsg_SpecialAbility::CDOTAClientMsg_SpecialAbility(const CDOTAClientMsg_SpecialAbility& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_SpecialAbility* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ability_index_){}
    , decltype(_impl_.target_entindex_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ability_index_, &from._impl_.ability_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_entindex_) -
    reinterpret_cast<char*>(&_impl_.ability_index_)) + sizeof(_impl_.target_entindex_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_SpecialAbility)
}

inline void CDOTAClientMsg_SpecialAbility::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ability_index_){0u}
    , decltype(_impl_.target_entindex_){-1}
  };
}

CDOTAClientMsg_SpecialAbility::~CDOTAClientMsg_SpecialAbility() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_SpecialAbility)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_SpecialAbility::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_SpecialAbility::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_SpecialAbility::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_SpecialAbility)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.ability_index_ = 0u;
    _impl_.target_entindex_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_SpecialAbility::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ability_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ability_index(&has_bits);
          _impl_.ability_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_entindex = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_target_entindex(&has_bits);
          _impl_.target_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_SpecialAbility::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_SpecialAbility)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ability_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ability_index(), target);
  }

  // optional int32 target_entindex = 2 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_target_entindex(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_SpecialAbility)
  return target;
}

size_t CDOTAClientMsg_SpecialAbility::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_SpecialAbility)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 ability_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ability_index());
    }

    // optional int32 target_entindex = 2 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_entindex());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_SpecialAbility::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_SpecialAbility::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_SpecialAbility::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_SpecialAbility::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_SpecialAbility*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_SpecialAbility&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_SpecialAbility)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ability_index_ = from._impl_.ability_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_entindex_ = from._impl_.target_entindex_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_SpecialAbility::CopyFrom(const CDOTAClientMsg_SpecialAbility& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_SpecialAbility)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_SpecialAbility::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_SpecialAbility::InternalSwap(CDOTAClientMsg_SpecialAbility* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.ability_index_, other->_impl_.ability_index_);
  swap(_impl_.target_entindex_, other->_impl_.target_entindex_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_SpecialAbility::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[55]);
}

// ===================================================================

class CDOTAClientMsg_SetEnemyStartingPosition::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_SetEnemyStartingPosition>()._impl_._has_bits_);
  static void set_has_enemy_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enemy_starting_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_SetEnemyStartingPosition::CDOTAClientMsg_SetEnemyStartingPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_SetEnemyStartingPosition)
}
CDOTAClientMsg_SetEnemyStartingPosition::CDOTAClientMsg_SetEnemyStartingPosition(const CDOTAClientMsg_SetEnemyStartingPosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_SetEnemyStartingPosition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enemy_starting_position_){}
    , decltype(_impl_.enemy_player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.enemy_starting_position_, &from._impl_.enemy_starting_position_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enemy_player_id_) -
    reinterpret_cast<char*>(&_impl_.enemy_starting_position_)) + sizeof(_impl_.enemy_player_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_SetEnemyStartingPosition)
}

inline void CDOTAClientMsg_SetEnemyStartingPosition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enemy_starting_position_){0u}
    , decltype(_impl_.enemy_player_id_){-1}
  };
}

CDOTAClientMsg_SetEnemyStartingPosition::~CDOTAClientMsg_SetEnemyStartingPosition() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_SetEnemyStartingPosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_SetEnemyStartingPosition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_SetEnemyStartingPosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_SetEnemyStartingPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_SetEnemyStartingPosition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.enemy_starting_position_ = 0u;
    _impl_.enemy_player_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_SetEnemyStartingPosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 enemy_player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enemy_player_id(&has_bits);
          _impl_.enemy_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 enemy_starting_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_enemy_starting_position(&has_bits);
          _impl_.enemy_starting_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_SetEnemyStartingPosition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_SetEnemyStartingPosition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 enemy_player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_enemy_player_id(), target);
  }

  // optional uint32 enemy_starting_position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_enemy_starting_position(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_SetEnemyStartingPosition)
  return target;
}

size_t CDOTAClientMsg_SetEnemyStartingPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_SetEnemyStartingPosition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 enemy_starting_position = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_enemy_starting_position());
    }

    // optional int32 enemy_player_id = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_enemy_player_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_SetEnemyStartingPosition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_SetEnemyStartingPosition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_SetEnemyStartingPosition::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_SetEnemyStartingPosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_SetEnemyStartingPosition*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_SetEnemyStartingPosition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_SetEnemyStartingPosition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.enemy_starting_position_ = from._impl_.enemy_starting_position_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.enemy_player_id_ = from._impl_.enemy_player_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_SetEnemyStartingPosition::CopyFrom(const CDOTAClientMsg_SetEnemyStartingPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_SetEnemyStartingPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_SetEnemyStartingPosition::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_SetEnemyStartingPosition::InternalSwap(CDOTAClientMsg_SetEnemyStartingPosition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enemy_starting_position_, other->_impl_.enemy_starting_position_);
  swap(_impl_.enemy_player_id_, other->_impl_.enemy_player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_SetEnemyStartingPosition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[56]);
}

// ===================================================================

class CDOTAClientMsg_SetDesiredWardPlacement::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_SetDesiredWardPlacement>()._impl_._has_bits_);
  static void set_has_ward_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ward_x(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ward_y(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CDOTAClientMsg_SetDesiredWardPlacement::CDOTAClientMsg_SetDesiredWardPlacement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_SetDesiredWardPlacement)
}
CDOTAClientMsg_SetDesiredWardPlacement::CDOTAClientMsg_SetDesiredWardPlacement(const CDOTAClientMsg_SetDesiredWardPlacement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_SetDesiredWardPlacement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ward_index_){}
    , decltype(_impl_.ward_x_){}
    , decltype(_impl_.ward_y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ward_index_, &from._impl_.ward_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ward_y_) -
    reinterpret_cast<char*>(&_impl_.ward_index_)) + sizeof(_impl_.ward_y_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_SetDesiredWardPlacement)
}

inline void CDOTAClientMsg_SetDesiredWardPlacement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ward_index_){0u}
    , decltype(_impl_.ward_x_){0}
    , decltype(_impl_.ward_y_){0}
  };
}

CDOTAClientMsg_SetDesiredWardPlacement::~CDOTAClientMsg_SetDesiredWardPlacement() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_SetDesiredWardPlacement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_SetDesiredWardPlacement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_SetDesiredWardPlacement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_SetDesiredWardPlacement::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_SetDesiredWardPlacement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.ward_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ward_y_) -
        reinterpret_cast<char*>(&_impl_.ward_index_)) + sizeof(_impl_.ward_y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_SetDesiredWardPlacement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ward_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ward_index(&has_bits);
          _impl_.ward_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float ward_x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_ward_x(&has_bits);
          _impl_.ward_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float ward_y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_ward_y(&has_bits);
          _impl_.ward_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_SetDesiredWardPlacement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_SetDesiredWardPlacement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ward_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ward_index(), target);
  }

  // optional float ward_x = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_ward_x(), target);
  }

  // optional float ward_y = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_ward_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_SetDesiredWardPlacement)
  return target;
}

size_t CDOTAClientMsg_SetDesiredWardPlacement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_SetDesiredWardPlacement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 ward_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ward_index());
    }

    // optional float ward_x = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float ward_y = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_SetDesiredWardPlacement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_SetDesiredWardPlacement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_SetDesiredWardPlacement::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_SetDesiredWardPlacement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_SetDesiredWardPlacement*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_SetDesiredWardPlacement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_SetDesiredWardPlacement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ward_index_ = from._impl_.ward_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ward_x_ = from._impl_.ward_x_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ward_y_ = from._impl_.ward_y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_SetDesiredWardPlacement::CopyFrom(const CDOTAClientMsg_SetDesiredWardPlacement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_SetDesiredWardPlacement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_SetDesiredWardPlacement::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_SetDesiredWardPlacement::InternalSwap(CDOTAClientMsg_SetDesiredWardPlacement* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_SetDesiredWardPlacement, _impl_.ward_y_)
      + sizeof(CDOTAClientMsg_SetDesiredWardPlacement::_impl_.ward_y_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_SetDesiredWardPlacement, _impl_.ward_index_)>(
          reinterpret_cast<char*>(&_impl_.ward_index_),
          reinterpret_cast<char*>(&other->_impl_.ward_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_SetDesiredWardPlacement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[57]);
}

// ===================================================================

class CDOTAClientMsg_RollDice::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_RollDice>()._impl_._has_bits_);
  static void set_has_channel_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_roll_min(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_roll_max(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CDOTAClientMsg_RollDice::CDOTAClientMsg_RollDice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_RollDice)
}
CDOTAClientMsg_RollDice::CDOTAClientMsg_RollDice(const CDOTAClientMsg_RollDice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_RollDice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.channel_type_){}
    , decltype(_impl_.roll_min_){}
    , decltype(_impl_.roll_max_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.channel_type_, &from._impl_.channel_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.roll_max_) -
    reinterpret_cast<char*>(&_impl_.channel_type_)) + sizeof(_impl_.roll_max_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_RollDice)
}

inline void CDOTAClientMsg_RollDice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.channel_type_){0u}
    , decltype(_impl_.roll_min_){0u}
    , decltype(_impl_.roll_max_){0u}
  };
}

CDOTAClientMsg_RollDice::~CDOTAClientMsg_RollDice() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_RollDice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_RollDice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_RollDice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_RollDice::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_RollDice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.channel_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.roll_max_) -
        reinterpret_cast<char*>(&_impl_.channel_type_)) + sizeof(_impl_.roll_max_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_RollDice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 channel_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_channel_type(&has_bits);
          _impl_.channel_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 roll_min = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_roll_min(&has_bits);
          _impl_.roll_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 roll_max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_roll_max(&has_bits);
          _impl_.roll_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_RollDice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_RollDice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 channel_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_channel_type(), target);
  }

  // optional uint32 roll_min = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_roll_min(), target);
  }

  // optional uint32 roll_max = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_roll_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_RollDice)
  return target;
}

size_t CDOTAClientMsg_RollDice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_RollDice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 channel_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channel_type());
    }

    // optional uint32 roll_min = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_roll_min());
    }

    // optional uint32 roll_max = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_roll_max());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_RollDice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_RollDice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_RollDice::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_RollDice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_RollDice*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_RollDice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_RollDice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.channel_type_ = from._impl_.channel_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.roll_min_ = from._impl_.roll_min_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.roll_max_ = from._impl_.roll_max_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_RollDice::CopyFrom(const CDOTAClientMsg_RollDice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_RollDice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_RollDice::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_RollDice::InternalSwap(CDOTAClientMsg_RollDice* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_RollDice, _impl_.roll_max_)
      + sizeof(CDOTAClientMsg_RollDice::_impl_.roll_max_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_RollDice, _impl_.channel_type_)>(
          reinterpret_cast<char*>(&_impl_.channel_type_),
          reinterpret_cast<char*>(&other->_impl_.channel_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_RollDice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[58]);
}

// ===================================================================

class CDOTAClientMsg_FlipCoin::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_FlipCoin>()._impl_._has_bits_);
  static void set_has_channel_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_FlipCoin::CDOTAClientMsg_FlipCoin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_FlipCoin)
}
CDOTAClientMsg_FlipCoin::CDOTAClientMsg_FlipCoin(const CDOTAClientMsg_FlipCoin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_FlipCoin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.channel_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.channel_type_ = from._impl_.channel_type_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_FlipCoin)
}

inline void CDOTAClientMsg_FlipCoin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.channel_type_){0u}
  };
}

CDOTAClientMsg_FlipCoin::~CDOTAClientMsg_FlipCoin() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_FlipCoin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_FlipCoin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_FlipCoin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_FlipCoin::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_FlipCoin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.channel_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_FlipCoin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 channel_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_channel_type(&has_bits);
          _impl_.channel_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_FlipCoin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_FlipCoin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 channel_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_channel_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_FlipCoin)
  return target;
}

size_t CDOTAClientMsg_FlipCoin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_FlipCoin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 channel_type = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channel_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_FlipCoin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_FlipCoin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_FlipCoin::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_FlipCoin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_FlipCoin*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_FlipCoin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_FlipCoin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_channel_type()) {
    _this->_internal_set_channel_type(from._internal_channel_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_FlipCoin::CopyFrom(const CDOTAClientMsg_FlipCoin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_FlipCoin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_FlipCoin::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_FlipCoin::InternalSwap(CDOTAClientMsg_FlipCoin* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.channel_type_, other->_impl_.channel_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_FlipCoin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[59]);
}

// ===================================================================

class CDOTAClientMsg_RequestItemSuggestions::_Internal {
 public:
};

CDOTAClientMsg_RequestItemSuggestions::CDOTAClientMsg_RequestItemSuggestions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_RequestItemSuggestions)
}
CDOTAClientMsg_RequestItemSuggestions::CDOTAClientMsg_RequestItemSuggestions(const CDOTAClientMsg_RequestItemSuggestions& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CDOTAClientMsg_RequestItemSuggestions* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_RequestItemSuggestions)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_RequestItemSuggestions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_RequestItemSuggestions::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_RequestItemSuggestions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[60]);
}

// ===================================================================

class CDOTAClientMsg_MakeTeamCaptain::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_MakeTeamCaptain>()._impl_._has_bits_);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_MakeTeamCaptain::CDOTAClientMsg_MakeTeamCaptain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_MakeTeamCaptain)
}
CDOTAClientMsg_MakeTeamCaptain::CDOTAClientMsg_MakeTeamCaptain(const CDOTAClientMsg_MakeTeamCaptain& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_MakeTeamCaptain* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.player_id_ = from._impl_.player_id_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_MakeTeamCaptain)
}

inline void CDOTAClientMsg_MakeTeamCaptain::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){-1}
  };
}

CDOTAClientMsg_MakeTeamCaptain::~CDOTAClientMsg_MakeTeamCaptain() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_MakeTeamCaptain)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_MakeTeamCaptain::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_MakeTeamCaptain::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_MakeTeamCaptain::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_MakeTeamCaptain)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_id_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_MakeTeamCaptain::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_MakeTeamCaptain::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_MakeTeamCaptain)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_MakeTeamCaptain)
  return target;
}

size_t CDOTAClientMsg_MakeTeamCaptain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_MakeTeamCaptain)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 player_id = 1 [default = -1];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_MakeTeamCaptain::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_MakeTeamCaptain::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_MakeTeamCaptain::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_MakeTeamCaptain::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_MakeTeamCaptain*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_MakeTeamCaptain&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_MakeTeamCaptain)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_player_id()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_MakeTeamCaptain::CopyFrom(const CDOTAClientMsg_MakeTeamCaptain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_MakeTeamCaptain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_MakeTeamCaptain::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_MakeTeamCaptain::InternalSwap(CDOTAClientMsg_MakeTeamCaptain* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.player_id_, other->_impl_.player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_MakeTeamCaptain::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[61]);
}

// ===================================================================

class CDOTAClientMsg_HelpTipSystemStateChanged::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_HelpTipSystemStateChanged>()._impl_._has_bits_);
  static void set_has_tip_displayed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_HelpTipSystemStateChanged::CDOTAClientMsg_HelpTipSystemStateChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_HelpTipSystemStateChanged)
}
CDOTAClientMsg_HelpTipSystemStateChanged::CDOTAClientMsg_HelpTipSystemStateChanged(const CDOTAClientMsg_HelpTipSystemStateChanged& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_HelpTipSystemStateChanged* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tip_displayed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.tip_displayed_ = from._impl_.tip_displayed_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_HelpTipSystemStateChanged)
}

inline void CDOTAClientMsg_HelpTipSystemStateChanged::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tip_displayed_){false}
  };
}

CDOTAClientMsg_HelpTipSystemStateChanged::~CDOTAClientMsg_HelpTipSystemStateChanged() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_HelpTipSystemStateChanged)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_HelpTipSystemStateChanged::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_HelpTipSystemStateChanged::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_HelpTipSystemStateChanged::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_HelpTipSystemStateChanged)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tip_displayed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_HelpTipSystemStateChanged::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool tip_displayed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tip_displayed(&has_bits);
          _impl_.tip_displayed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_HelpTipSystemStateChanged::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_HelpTipSystemStateChanged)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool tip_displayed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_tip_displayed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_HelpTipSystemStateChanged)
  return target;
}

size_t CDOTAClientMsg_HelpTipSystemStateChanged::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_HelpTipSystemStateChanged)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool tip_displayed = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_HelpTipSystemStateChanged::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_HelpTipSystemStateChanged::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_HelpTipSystemStateChanged::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_HelpTipSystemStateChanged::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_HelpTipSystemStateChanged*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_HelpTipSystemStateChanged&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_HelpTipSystemStateChanged)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tip_displayed()) {
    _this->_internal_set_tip_displayed(from._internal_tip_displayed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_HelpTipSystemStateChanged::CopyFrom(const CDOTAClientMsg_HelpTipSystemStateChanged& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_HelpTipSystemStateChanged)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_HelpTipSystemStateChanged::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_HelpTipSystemStateChanged::InternalSwap(CDOTAClientMsg_HelpTipSystemStateChanged* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.tip_displayed_, other->_impl_.tip_displayed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_HelpTipSystemStateChanged::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[62]);
}

// ===================================================================

class CDOTAClientMsg_RequestBulkCombatLog::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_RequestBulkCombatLog>()._impl_._has_bits_);
  static void set_has_game_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_recent_player_death(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CDOTAClientMsg_RequestBulkCombatLog::CDOTAClientMsg_RequestBulkCombatLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_RequestBulkCombatLog)
}
CDOTAClientMsg_RequestBulkCombatLog::CDOTAClientMsg_RequestBulkCombatLog(const CDOTAClientMsg_RequestBulkCombatLog& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_RequestBulkCombatLog* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.game_time_){}
    , decltype(_impl_.duration_){}
    , decltype(_impl_.recent_player_death_){}
    , decltype(_impl_.player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.game_time_, &from._impl_.game_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_id_) -
    reinterpret_cast<char*>(&_impl_.game_time_)) + sizeof(_impl_.player_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_RequestBulkCombatLog)
}

inline void CDOTAClientMsg_RequestBulkCombatLog::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.game_time_){0}
    , decltype(_impl_.duration_){0}
    , decltype(_impl_.recent_player_death_){false}
    , decltype(_impl_.player_id_){-1}
  };
}

CDOTAClientMsg_RequestBulkCombatLog::~CDOTAClientMsg_RequestBulkCombatLog() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_RequestBulkCombatLog)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_RequestBulkCombatLog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_RequestBulkCombatLog::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_RequestBulkCombatLog::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_RequestBulkCombatLog)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.game_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.recent_player_death_) -
        reinterpret_cast<char*>(&_impl_.game_time_)) + sizeof(_impl_.recent_player_death_));
    _impl_.player_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_RequestBulkCombatLog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float game_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_game_time(&has_bits);
          _impl_.game_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_duration(&has_bits);
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool recent_player_death = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_recent_player_death(&has_bits);
          _impl_.recent_player_death_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 player_id = 4 [default = -1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_RequestBulkCombatLog::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_RequestBulkCombatLog)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float game_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_game_time(), target);
  }

  // optional float duration = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_duration(), target);
  }

  // optional bool recent_player_death = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_recent_player_death(), target);
  }

  // optional int32 player_id = 4 [default = -1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_RequestBulkCombatLog)
  return target;
}

size_t CDOTAClientMsg_RequestBulkCombatLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_RequestBulkCombatLog)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional float game_time = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float duration = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional bool recent_player_death = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional int32 player_id = 4 [default = -1];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_RequestBulkCombatLog::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_RequestBulkCombatLog::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_RequestBulkCombatLog::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_RequestBulkCombatLog::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_RequestBulkCombatLog*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_RequestBulkCombatLog&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_RequestBulkCombatLog)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.game_time_ = from._impl_.game_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.duration_ = from._impl_.duration_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.recent_player_death_ = from._impl_.recent_player_death_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.player_id_ = from._impl_.player_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_RequestBulkCombatLog::CopyFrom(const CDOTAClientMsg_RequestBulkCombatLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_RequestBulkCombatLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_RequestBulkCombatLog::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_RequestBulkCombatLog::InternalSwap(CDOTAClientMsg_RequestBulkCombatLog* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_RequestBulkCombatLog, _impl_.recent_player_death_)
      + sizeof(CDOTAClientMsg_RequestBulkCombatLog::_impl_.recent_player_death_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_RequestBulkCombatLog, _impl_.game_time_)>(
          reinterpret_cast<char*>(&_impl_.game_time_),
          reinterpret_cast<char*>(&other->_impl_.game_time_));
  swap(_impl_.player_id_, other->_impl_.player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_RequestBulkCombatLog::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[63]);
}

// ===================================================================

class CDOTAClientMsg_AbilityDraftRequestAbility::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_AbilityDraftRequestAbility>()._impl_._has_bits_);
  static void set_has_requested_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ctrl_is_down(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_AbilityDraftRequestAbility::CDOTAClientMsg_AbilityDraftRequestAbility(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_AbilityDraftRequestAbility)
}
CDOTAClientMsg_AbilityDraftRequestAbility::CDOTAClientMsg_AbilityDraftRequestAbility(const CDOTAClientMsg_AbilityDraftRequestAbility& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_AbilityDraftRequestAbility* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctrl_is_down_){}
    , decltype(_impl_.requested_ability_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ctrl_is_down_, &from._impl_.ctrl_is_down_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.requested_ability_id_) -
    reinterpret_cast<char*>(&_impl_.ctrl_is_down_)) + sizeof(_impl_.requested_ability_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_AbilityDraftRequestAbility)
}

inline void CDOTAClientMsg_AbilityDraftRequestAbility::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctrl_is_down_){false}
    , decltype(_impl_.requested_ability_id_){-1}
  };
}

CDOTAClientMsg_AbilityDraftRequestAbility::~CDOTAClientMsg_AbilityDraftRequestAbility() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_AbilityDraftRequestAbility)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_AbilityDraftRequestAbility::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_AbilityDraftRequestAbility::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_AbilityDraftRequestAbility::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_AbilityDraftRequestAbility)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.ctrl_is_down_ = false;
    _impl_.requested_ability_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_AbilityDraftRequestAbility::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 requested_ability_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_requested_ability_id(&has_bits);
          _impl_.requested_ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ctrl_is_down = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ctrl_is_down(&has_bits);
          _impl_.ctrl_is_down_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_AbilityDraftRequestAbility::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_AbilityDraftRequestAbility)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 requested_ability_id = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_requested_ability_id(), target);
  }

  // optional bool ctrl_is_down = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_ctrl_is_down(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_AbilityDraftRequestAbility)
  return target;
}

size_t CDOTAClientMsg_AbilityDraftRequestAbility::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_AbilityDraftRequestAbility)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool ctrl_is_down = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 requested_ability_id = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_requested_ability_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_AbilityDraftRequestAbility::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_AbilityDraftRequestAbility::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_AbilityDraftRequestAbility::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_AbilityDraftRequestAbility::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_AbilityDraftRequestAbility*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_AbilityDraftRequestAbility&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_AbilityDraftRequestAbility)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ctrl_is_down_ = from._impl_.ctrl_is_down_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.requested_ability_id_ = from._impl_.requested_ability_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_AbilityDraftRequestAbility::CopyFrom(const CDOTAClientMsg_AbilityDraftRequestAbility& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_AbilityDraftRequestAbility)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_AbilityDraftRequestAbility::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_AbilityDraftRequestAbility::InternalSwap(CDOTAClientMsg_AbilityDraftRequestAbility* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.ctrl_is_down_, other->_impl_.ctrl_is_down_);
  swap(_impl_.requested_ability_id_, other->_impl_.requested_ability_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_AbilityDraftRequestAbility::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[64]);
}

// ===================================================================

class CDOTAClientMsg_GuideSelectOption::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_GuideSelectOption>()._impl_._has_bits_);
  static void set_has_option(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_force_recalculate(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_GuideSelectOption::CDOTAClientMsg_GuideSelectOption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_GuideSelectOption)
}
CDOTAClientMsg_GuideSelectOption::CDOTAClientMsg_GuideSelectOption(const CDOTAClientMsg_GuideSelectOption& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_GuideSelectOption* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.option_){}
    , decltype(_impl_.force_recalculate_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.option_, &from._impl_.option_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.force_recalculate_) -
    reinterpret_cast<char*>(&_impl_.option_)) + sizeof(_impl_.force_recalculate_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_GuideSelectOption)
}

inline void CDOTAClientMsg_GuideSelectOption::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.option_){0u}
    , decltype(_impl_.force_recalculate_){false}
  };
}

CDOTAClientMsg_GuideSelectOption::~CDOTAClientMsg_GuideSelectOption() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_GuideSelectOption)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_GuideSelectOption::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_GuideSelectOption::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_GuideSelectOption::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_GuideSelectOption)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.option_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.force_recalculate_) -
        reinterpret_cast<char*>(&_impl_.option_)) + sizeof(_impl_.force_recalculate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_GuideSelectOption::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 option = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_option(&has_bits);
          _impl_.option_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool force_recalculate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_force_recalculate(&has_bits);
          _impl_.force_recalculate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_GuideSelectOption::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_GuideSelectOption)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 option = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_option(), target);
  }

  // optional bool force_recalculate = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_force_recalculate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_GuideSelectOption)
  return target;
}

size_t CDOTAClientMsg_GuideSelectOption::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_GuideSelectOption)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 option = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_option());
    }

    // optional bool force_recalculate = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_GuideSelectOption::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_GuideSelectOption::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_GuideSelectOption::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_GuideSelectOption::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_GuideSelectOption*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_GuideSelectOption&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_GuideSelectOption)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.option_ = from._impl_.option_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.force_recalculate_ = from._impl_.force_recalculate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_GuideSelectOption::CopyFrom(const CDOTAClientMsg_GuideSelectOption& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_GuideSelectOption)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_GuideSelectOption::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_GuideSelectOption::InternalSwap(CDOTAClientMsg_GuideSelectOption* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_GuideSelectOption, _impl_.force_recalculate_)
      + sizeof(CDOTAClientMsg_GuideSelectOption::_impl_.force_recalculate_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_GuideSelectOption, _impl_.option_)>(
          reinterpret_cast<char*>(&_impl_.option_),
          reinterpret_cast<char*>(&other->_impl_.option_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_GuideSelectOption::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[65]);
}

// ===================================================================

class CDOTAClientMsg_GuideSelected::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_GuideSelected>()._impl_._has_bits_);
  static void set_has_guide_workshop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_plus_guide(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_GuideSelected::CDOTAClientMsg_GuideSelected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_GuideSelected)
}
CDOTAClientMsg_GuideSelected::CDOTAClientMsg_GuideSelected(const CDOTAClientMsg_GuideSelected& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_GuideSelected* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.guide_workshop_id_){}
    , decltype(_impl_.is_plus_guide_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.guide_workshop_id_, &from._impl_.guide_workshop_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_plus_guide_) -
    reinterpret_cast<char*>(&_impl_.guide_workshop_id_)) + sizeof(_impl_.is_plus_guide_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_GuideSelected)
}

inline void CDOTAClientMsg_GuideSelected::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.guide_workshop_id_){uint64_t{0u}}
    , decltype(_impl_.is_plus_guide_){false}
  };
}

CDOTAClientMsg_GuideSelected::~CDOTAClientMsg_GuideSelected() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_GuideSelected)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_GuideSelected::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_GuideSelected::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_GuideSelected::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_GuideSelected)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.guide_workshop_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_plus_guide_) -
        reinterpret_cast<char*>(&_impl_.guide_workshop_id_)) + sizeof(_impl_.is_plus_guide_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_GuideSelected::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 guide_workshop_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_guide_workshop_id(&has_bits);
          _impl_.guide_workshop_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_plus_guide = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_plus_guide(&has_bits);
          _impl_.is_plus_guide_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_GuideSelected::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_GuideSelected)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 guide_workshop_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_guide_workshop_id(), target);
  }

  // optional bool is_plus_guide = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_plus_guide(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_GuideSelected)
  return target;
}

size_t CDOTAClientMsg_GuideSelected::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_GuideSelected)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 guide_workshop_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_guide_workshop_id());
    }

    // optional bool is_plus_guide = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_GuideSelected::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_GuideSelected::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_GuideSelected::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_GuideSelected::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_GuideSelected*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_GuideSelected&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_GuideSelected)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.guide_workshop_id_ = from._impl_.guide_workshop_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_plus_guide_ = from._impl_.is_plus_guide_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_GuideSelected::CopyFrom(const CDOTAClientMsg_GuideSelected& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_GuideSelected)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_GuideSelected::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_GuideSelected::InternalSwap(CDOTAClientMsg_GuideSelected* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_GuideSelected, _impl_.is_plus_guide_)
      + sizeof(CDOTAClientMsg_GuideSelected::_impl_.is_plus_guide_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_GuideSelected, _impl_.guide_workshop_id_)>(
          reinterpret_cast<char*>(&_impl_.guide_workshop_id_),
          reinterpret_cast<char*>(&other->_impl_.guide_workshop_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_GuideSelected::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[66]);
}

// ===================================================================

class CDOTAClientMsg_DamageReport::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_DamageReport>()._impl_._has_bits_);
  static void set_has_target_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_source_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_damage_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_broadcast(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CDOTAClientMsg_DamageReport::CDOTAClientMsg_DamageReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_DamageReport)
}
CDOTAClientMsg_DamageReport::CDOTAClientMsg_DamageReport(const CDOTAClientMsg_DamageReport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_DamageReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_hero_id_){}
    , decltype(_impl_.source_hero_id_){}
    , decltype(_impl_.damage_amount_){}
    , decltype(_impl_.broadcast_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.target_hero_id_, &from._impl_.target_hero_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.broadcast_) -
    reinterpret_cast<char*>(&_impl_.target_hero_id_)) + sizeof(_impl_.broadcast_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_DamageReport)
}

inline void CDOTAClientMsg_DamageReport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_hero_id_){0u}
    , decltype(_impl_.source_hero_id_){0u}
    , decltype(_impl_.damage_amount_){0}
    , decltype(_impl_.broadcast_){false}
  };
}

CDOTAClientMsg_DamageReport::~CDOTAClientMsg_DamageReport() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_DamageReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_DamageReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_DamageReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_DamageReport::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_DamageReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.target_hero_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.broadcast_) -
        reinterpret_cast<char*>(&_impl_.target_hero_id_)) + sizeof(_impl_.broadcast_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_DamageReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 target_hero_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_target_hero_id(&has_bits);
          _impl_.target_hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 source_hero_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_source_hero_id(&has_bits);
          _impl_.source_hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 damage_amount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_damage_amount(&has_bits);
          _impl_.damage_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool broadcast = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_broadcast(&has_bits);
          _impl_.broadcast_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_DamageReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_DamageReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 target_hero_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_target_hero_id(), target);
  }

  // optional uint32 source_hero_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_source_hero_id(), target);
  }

  // optional int32 damage_amount = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_damage_amount(), target);
  }

  // optional bool broadcast = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_broadcast(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_DamageReport)
  return target;
}

size_t CDOTAClientMsg_DamageReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_DamageReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 target_hero_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_target_hero_id());
    }

    // optional uint32 source_hero_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_source_hero_id());
    }

    // optional int32 damage_amount = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_damage_amount());
    }

    // optional bool broadcast = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_DamageReport::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_DamageReport::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_DamageReport::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_DamageReport::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_DamageReport*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_DamageReport&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_DamageReport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.target_hero_id_ = from._impl_.target_hero_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.source_hero_id_ = from._impl_.source_hero_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.damage_amount_ = from._impl_.damage_amount_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.broadcast_ = from._impl_.broadcast_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_DamageReport::CopyFrom(const CDOTAClientMsg_DamageReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_DamageReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_DamageReport::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_DamageReport::InternalSwap(CDOTAClientMsg_DamageReport* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_DamageReport, _impl_.broadcast_)
      + sizeof(CDOTAClientMsg_DamageReport::_impl_.broadcast_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_DamageReport, _impl_.target_hero_id_)>(
          reinterpret_cast<char*>(&_impl_.target_hero_id_),
          reinterpret_cast<char*>(&other->_impl_.target_hero_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_DamageReport::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[67]);
}

// ===================================================================

class CDOTAClientMsg_SalutePlayer::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_SalutePlayer>()._impl_._has_bits_);
  static void set_has_target_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_SalutePlayer::CDOTAClientMsg_SalutePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_SalutePlayer)
}
CDOTAClientMsg_SalutePlayer::CDOTAClientMsg_SalutePlayer(const CDOTAClientMsg_SalutePlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_SalutePlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_id_){}
    , decltype(_impl_.target_player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.event_id_, &from._impl_.event_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_player_id_) -
    reinterpret_cast<char*>(&_impl_.event_id_)) + sizeof(_impl_.target_player_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_SalutePlayer)
}

inline void CDOTAClientMsg_SalutePlayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_id_){0}
    , decltype(_impl_.target_player_id_){-1}
  };
}

CDOTAClientMsg_SalutePlayer::~CDOTAClientMsg_SalutePlayer() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_SalutePlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_SalutePlayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_SalutePlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_SalutePlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_SalutePlayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.event_id_ = 0;
    _impl_.target_player_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_SalutePlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 target_player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_target_player_id(&has_bits);
          _impl_.target_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 event_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_event_id(&has_bits);
          _impl_.event_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_SalutePlayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_SalutePlayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 target_player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_target_player_id(), target);
  }

  // optional int32 event_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_event_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_SalutePlayer)
  return target;
}

size_t CDOTAClientMsg_SalutePlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_SalutePlayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 event_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_event_id());
    }

    // optional int32 target_player_id = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_player_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_SalutePlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_SalutePlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_SalutePlayer::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_SalutePlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_SalutePlayer*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_SalutePlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_SalutePlayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_player_id_ = from._impl_.target_player_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_SalutePlayer::CopyFrom(const CDOTAClientMsg_SalutePlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_SalutePlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_SalutePlayer::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_SalutePlayer::InternalSwap(CDOTAClientMsg_SalutePlayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.event_id_, other->_impl_.event_id_);
  swap(_impl_.target_player_id_, other->_impl_.target_player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_SalutePlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[68]);
}

// ===================================================================

class CDOTAClientMsg_TipAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_TipAlert>()._impl_._has_bits_);
  static void set_has_tip_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_TipAlert::CDOTAClientMsg_TipAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_TipAlert)
}
CDOTAClientMsg_TipAlert::CDOTAClientMsg_TipAlert(const CDOTAClientMsg_TipAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_TipAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tip_text_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tip_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tip_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tip_text()) {
    _this->_impl_.tip_text_.Set(from._internal_tip_text(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_TipAlert)
}

inline void CDOTAClientMsg_TipAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tip_text_){}
  };
  _impl_.tip_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tip_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CDOTAClientMsg_TipAlert::~CDOTAClientMsg_TipAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_TipAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_TipAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tip_text_.Destroy();
}

void CDOTAClientMsg_TipAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_TipAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_TipAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tip_text_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_TipAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tip_text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tip_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CDOTAClientMsg_TipAlert.tip_text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_TipAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_TipAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string tip_text = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tip_text().data(), static_cast<int>(this->_internal_tip_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDOTAClientMsg_TipAlert.tip_text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tip_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_TipAlert)
  return target;
}

size_t CDOTAClientMsg_TipAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_TipAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string tip_text = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tip_text());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_TipAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_TipAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_TipAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_TipAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_TipAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_TipAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_TipAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tip_text()) {
    _this->_internal_set_tip_text(from._internal_tip_text());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_TipAlert::CopyFrom(const CDOTAClientMsg_TipAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_TipAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_TipAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_TipAlert::InternalSwap(CDOTAClientMsg_TipAlert* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tip_text_, lhs_arena,
      &other->_impl_.tip_text_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_TipAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[69]);
}

// ===================================================================

class CDOTAClientMsg_EmptyTeleportAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_EmptyTeleportAlert>()._impl_._has_bits_);
  static void set_has_target_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_EmptyTeleportAlert::CDOTAClientMsg_EmptyTeleportAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_EmptyTeleportAlert)
}
CDOTAClientMsg_EmptyTeleportAlert::CDOTAClientMsg_EmptyTeleportAlert(const CDOTAClientMsg_EmptyTeleportAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_EmptyTeleportAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_entindex_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.target_entindex_ = from._impl_.target_entindex_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_EmptyTeleportAlert)
}

inline void CDOTAClientMsg_EmptyTeleportAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_entindex_){-1}
  };
}

CDOTAClientMsg_EmptyTeleportAlert::~CDOTAClientMsg_EmptyTeleportAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_EmptyTeleportAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_EmptyTeleportAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_EmptyTeleportAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_EmptyTeleportAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_EmptyTeleportAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.target_entindex_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_EmptyTeleportAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 target_entindex = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_target_entindex(&has_bits);
          _impl_.target_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_EmptyTeleportAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_EmptyTeleportAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 target_entindex = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_target_entindex(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_EmptyTeleportAlert)
  return target;
}

size_t CDOTAClientMsg_EmptyTeleportAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_EmptyTeleportAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 target_entindex = 1 [default = -1];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_entindex());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_EmptyTeleportAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_EmptyTeleportAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_EmptyTeleportAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_EmptyTeleportAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_EmptyTeleportAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_EmptyTeleportAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_EmptyTeleportAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_target_entindex()) {
    _this->_internal_set_target_entindex(from._internal_target_entindex());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_EmptyTeleportAlert::CopyFrom(const CDOTAClientMsg_EmptyTeleportAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_EmptyTeleportAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_EmptyTeleportAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_EmptyTeleportAlert::InternalSwap(CDOTAClientMsg_EmptyTeleportAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.target_entindex_, other->_impl_.target_entindex_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_EmptyTeleportAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[70]);
}

// ===================================================================

class CDOTAClientMsg_SetCavernMapVariant::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_SetCavernMapVariant>()._impl_._has_bits_);
  static void set_has_map_variant(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_SetCavernMapVariant::CDOTAClientMsg_SetCavernMapVariant(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_SetCavernMapVariant)
}
CDOTAClientMsg_SetCavernMapVariant::CDOTAClientMsg_SetCavernMapVariant(const CDOTAClientMsg_SetCavernMapVariant& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_SetCavernMapVariant* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.map_variant_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.map_variant_ = from._impl_.map_variant_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_SetCavernMapVariant)
}

inline void CDOTAClientMsg_SetCavernMapVariant::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.map_variant_){255u}
  };
}

CDOTAClientMsg_SetCavernMapVariant::~CDOTAClientMsg_SetCavernMapVariant() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_SetCavernMapVariant)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_SetCavernMapVariant::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_SetCavernMapVariant::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_SetCavernMapVariant::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_SetCavernMapVariant)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.map_variant_ = 255u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_SetCavernMapVariant::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 map_variant = 1 [default = 255];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_map_variant(&has_bits);
          _impl_.map_variant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_SetCavernMapVariant::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_SetCavernMapVariant)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 map_variant = 1 [default = 255];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_map_variant(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_SetCavernMapVariant)
  return target;
}

size_t CDOTAClientMsg_SetCavernMapVariant::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_SetCavernMapVariant)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 map_variant = 1 [default = 255];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_map_variant());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_SetCavernMapVariant::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_SetCavernMapVariant::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_SetCavernMapVariant::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_SetCavernMapVariant::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_SetCavernMapVariant*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_SetCavernMapVariant&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_SetCavernMapVariant)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_map_variant()) {
    _this->_internal_set_map_variant(from._internal_map_variant());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_SetCavernMapVariant::CopyFrom(const CDOTAClientMsg_SetCavernMapVariant& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_SetCavernMapVariant)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_SetCavernMapVariant::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_SetCavernMapVariant::InternalSwap(CDOTAClientMsg_SetCavernMapVariant* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.map_variant_, other->_impl_.map_variant_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_SetCavernMapVariant::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[71]);
}

// ===================================================================

class CDOTAClientMsg_PauseGameOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_PauseGameOrder>()._impl_._has_bits_);
  static void set_has_order_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_PauseGameOrder::CDOTAClientMsg_PauseGameOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_PauseGameOrder)
}
CDOTAClientMsg_PauseGameOrder::CDOTAClientMsg_PauseGameOrder(const CDOTAClientMsg_PauseGameOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_PauseGameOrder* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.order_id_){}
    , decltype(_impl_.data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.order_id_, &from._impl_.order_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.data_) -
    reinterpret_cast<char*>(&_impl_.order_id_)) + sizeof(_impl_.data_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_PauseGameOrder)
}

inline void CDOTAClientMsg_PauseGameOrder::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.order_id_){0}
    , decltype(_impl_.data_){0}
  };
}

CDOTAClientMsg_PauseGameOrder::~CDOTAClientMsg_PauseGameOrder() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_PauseGameOrder)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_PauseGameOrder::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_PauseGameOrder::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_PauseGameOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_PauseGameOrder)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.order_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.data_) -
        reinterpret_cast<char*>(&_impl_.order_id_)) + sizeof(_impl_.data_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_PauseGameOrder::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 order_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_order_id(&has_bits);
          _impl_.order_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_data(&has_bits);
          _impl_.data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_PauseGameOrder::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_PauseGameOrder)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 order_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_order_id(), target);
  }

  // optional int32 data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_PauseGameOrder)
  return target;
}

size_t CDOTAClientMsg_PauseGameOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_PauseGameOrder)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 order_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_order_id());
    }

    // optional int32 data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_data());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_PauseGameOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_PauseGameOrder::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_PauseGameOrder::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_PauseGameOrder::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_PauseGameOrder*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_PauseGameOrder&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_PauseGameOrder)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.order_id_ = from._impl_.order_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.data_ = from._impl_.data_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_PauseGameOrder::CopyFrom(const CDOTAClientMsg_PauseGameOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_PauseGameOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_PauseGameOrder::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_PauseGameOrder::InternalSwap(CDOTAClientMsg_PauseGameOrder* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_PauseGameOrder, _impl_.data_)
      + sizeof(CDOTAClientMsg_PauseGameOrder::_impl_.data_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_PauseGameOrder, _impl_.order_id_)>(
          reinterpret_cast<char*>(&_impl_.order_id_),
          reinterpret_cast<char*>(&other->_impl_.order_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_PauseGameOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[72]);
}

// ===================================================================

class CDOTAClientMsg_VersusScene_PlayerBehavior::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_VersusScene_PlayerBehavior>()._impl_._has_bits_);
  static void set_has_behavior(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::VersusScene_PlayActivity& play_activity(const CDOTAClientMsg_VersusScene_PlayerBehavior* msg);
  static void set_has_play_activity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::VersusScene_ChatWheel& chat_wheel(const CDOTAClientMsg_VersusScene_PlayerBehavior* msg);
  static void set_has_chat_wheel(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::VersusScene_PlaybackRate& playback_rate(const CDOTAClientMsg_VersusScene_PlayerBehavior* msg);
  static void set_has_playback_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::VersusScene_PlayActivity&
CDOTAClientMsg_VersusScene_PlayerBehavior::_Internal::play_activity(const CDOTAClientMsg_VersusScene_PlayerBehavior* msg) {
  return *msg->_impl_.play_activity_;
}
const ::VersusScene_ChatWheel&
CDOTAClientMsg_VersusScene_PlayerBehavior::_Internal::chat_wheel(const CDOTAClientMsg_VersusScene_PlayerBehavior* msg) {
  return *msg->_impl_.chat_wheel_;
}
const ::VersusScene_PlaybackRate&
CDOTAClientMsg_VersusScene_PlayerBehavior::_Internal::playback_rate(const CDOTAClientMsg_VersusScene_PlayerBehavior* msg) {
  return *msg->_impl_.playback_rate_;
}
void CDOTAClientMsg_VersusScene_PlayerBehavior::clear_play_activity() {
  if (_impl_.play_activity_ != nullptr) _impl_.play_activity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CDOTAClientMsg_VersusScene_PlayerBehavior::clear_chat_wheel() {
  if (_impl_.chat_wheel_ != nullptr) _impl_.chat_wheel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CDOTAClientMsg_VersusScene_PlayerBehavior::clear_playback_rate() {
  if (_impl_.playback_rate_ != nullptr) _impl_.playback_rate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CDOTAClientMsg_VersusScene_PlayerBehavior::CDOTAClientMsg_VersusScene_PlayerBehavior(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_VersusScene_PlayerBehavior)
}
CDOTAClientMsg_VersusScene_PlayerBehavior::CDOTAClientMsg_VersusScene_PlayerBehavior(const CDOTAClientMsg_VersusScene_PlayerBehavior& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_VersusScene_PlayerBehavior* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.play_activity_){nullptr}
    , decltype(_impl_.chat_wheel_){nullptr}
    , decltype(_impl_.playback_rate_){nullptr}
    , decltype(_impl_.behavior_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_play_activity()) {
    _this->_impl_.play_activity_ = new ::VersusScene_PlayActivity(*from._impl_.play_activity_);
  }
  if (from._internal_has_chat_wheel()) {
    _this->_impl_.chat_wheel_ = new ::VersusScene_ChatWheel(*from._impl_.chat_wheel_);
  }
  if (from._internal_has_playback_rate()) {
    _this->_impl_.playback_rate_ = new ::VersusScene_PlaybackRate(*from._impl_.playback_rate_);
  }
  _this->_impl_.behavior_ = from._impl_.behavior_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_VersusScene_PlayerBehavior)
}

inline void CDOTAClientMsg_VersusScene_PlayerBehavior::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.play_activity_){nullptr}
    , decltype(_impl_.chat_wheel_){nullptr}
    , decltype(_impl_.playback_rate_){nullptr}
    , decltype(_impl_.behavior_){1}
  };
}

CDOTAClientMsg_VersusScene_PlayerBehavior::~CDOTAClientMsg_VersusScene_PlayerBehavior() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_VersusScene_PlayerBehavior)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_VersusScene_PlayerBehavior::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.play_activity_;
  if (this != internal_default_instance()) delete _impl_.chat_wheel_;
  if (this != internal_default_instance()) delete _impl_.playback_rate_;
}

void CDOTAClientMsg_VersusScene_PlayerBehavior::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_VersusScene_PlayerBehavior::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_VersusScene_PlayerBehavior)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.play_activity_ != nullptr);
      _impl_.play_activity_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.chat_wheel_ != nullptr);
      _impl_.chat_wheel_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.playback_rate_ != nullptr);
      _impl_.playback_rate_->Clear();
    }
    _impl_.behavior_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_VersusScene_PlayerBehavior::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EDOTAVersusScenePlayerBehavior behavior = 1 [default = VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EDOTAVersusScenePlayerBehavior_IsValid(val))) {
            _internal_set_behavior(static_cast<::EDOTAVersusScenePlayerBehavior>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .VersusScene_PlayActivity play_activity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_play_activity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .VersusScene_ChatWheel chat_wheel = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_chat_wheel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .VersusScene_PlaybackRate playback_rate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_playback_rate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_VersusScene_PlayerBehavior::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_VersusScene_PlayerBehavior)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .EDOTAVersusScenePlayerBehavior behavior = 1 [default = VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_behavior(), target);
  }

  // optional .VersusScene_PlayActivity play_activity = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::play_activity(this),
        _Internal::play_activity(this).GetCachedSize(), target, stream);
  }

  // optional .VersusScene_ChatWheel chat_wheel = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::chat_wheel(this),
        _Internal::chat_wheel(this).GetCachedSize(), target, stream);
  }

  // optional .VersusScene_PlaybackRate playback_rate = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::playback_rate(this),
        _Internal::playback_rate(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_VersusScene_PlayerBehavior)
  return target;
}

size_t CDOTAClientMsg_VersusScene_PlayerBehavior::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_VersusScene_PlayerBehavior)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .VersusScene_PlayActivity play_activity = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.play_activity_);
    }

    // optional .VersusScene_ChatWheel chat_wheel = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chat_wheel_);
    }

    // optional .VersusScene_PlaybackRate playback_rate = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.playback_rate_);
    }

    // optional .EDOTAVersusScenePlayerBehavior behavior = 1 [default = VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_behavior());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_VersusScene_PlayerBehavior::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_VersusScene_PlayerBehavior::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_VersusScene_PlayerBehavior::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_VersusScene_PlayerBehavior::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_VersusScene_PlayerBehavior*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_VersusScene_PlayerBehavior&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_VersusScene_PlayerBehavior)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_play_activity()->::VersusScene_PlayActivity::MergeFrom(
          from._internal_play_activity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_chat_wheel()->::VersusScene_ChatWheel::MergeFrom(
          from._internal_chat_wheel());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_playback_rate()->::VersusScene_PlaybackRate::MergeFrom(
          from._internal_playback_rate());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.behavior_ = from._impl_.behavior_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_VersusScene_PlayerBehavior::CopyFrom(const CDOTAClientMsg_VersusScene_PlayerBehavior& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_VersusScene_PlayerBehavior)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_VersusScene_PlayerBehavior::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_VersusScene_PlayerBehavior::InternalSwap(CDOTAClientMsg_VersusScene_PlayerBehavior* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_VersusScene_PlayerBehavior, _impl_.playback_rate_)
      + sizeof(CDOTAClientMsg_VersusScene_PlayerBehavior::_impl_.playback_rate_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_VersusScene_PlayerBehavior, _impl_.play_activity_)>(
          reinterpret_cast<char*>(&_impl_.play_activity_),
          reinterpret_cast<char*>(&other->_impl_.play_activity_));
  swap(_impl_.behavior_, other->_impl_.behavior_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_VersusScene_PlayerBehavior::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[73]);
}

// ===================================================================

class CDOTAClientMsg_EmptyItemSlotAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_EmptyItemSlotAlert>()._impl_._has_bits_);
  static void set_has_target_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_slot_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_EmptyItemSlotAlert::CDOTAClientMsg_EmptyItemSlotAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_EmptyItemSlotAlert)
}
CDOTAClientMsg_EmptyItemSlotAlert::CDOTAClientMsg_EmptyItemSlotAlert(const CDOTAClientMsg_EmptyItemSlotAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_EmptyItemSlotAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_index_){}
    , decltype(_impl_.target_entindex_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.slot_index_, &from._impl_.slot_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_entindex_) -
    reinterpret_cast<char*>(&_impl_.slot_index_)) + sizeof(_impl_.target_entindex_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_EmptyItemSlotAlert)
}

inline void CDOTAClientMsg_EmptyItemSlotAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_index_){0}
    , decltype(_impl_.target_entindex_){-1}
  };
}

CDOTAClientMsg_EmptyItemSlotAlert::~CDOTAClientMsg_EmptyItemSlotAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_EmptyItemSlotAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_EmptyItemSlotAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_EmptyItemSlotAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_EmptyItemSlotAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_EmptyItemSlotAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.slot_index_ = 0;
    _impl_.target_entindex_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_EmptyItemSlotAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 target_entindex = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_target_entindex(&has_bits);
          _impl_.target_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 slot_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_slot_index(&has_bits);
          _impl_.slot_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_EmptyItemSlotAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_EmptyItemSlotAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 target_entindex = 1 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_target_entindex(), target);
  }

  // optional int32 slot_index = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_slot_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_EmptyItemSlotAlert)
  return target;
}

size_t CDOTAClientMsg_EmptyItemSlotAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_EmptyItemSlotAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 slot_index = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot_index());
    }

    // optional int32 target_entindex = 1 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_entindex());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_EmptyItemSlotAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_EmptyItemSlotAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_EmptyItemSlotAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_EmptyItemSlotAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_EmptyItemSlotAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_EmptyItemSlotAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_EmptyItemSlotAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.slot_index_ = from._impl_.slot_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_entindex_ = from._impl_.target_entindex_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_EmptyItemSlotAlert::CopyFrom(const CDOTAClientMsg_EmptyItemSlotAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_EmptyItemSlotAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_EmptyItemSlotAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_EmptyItemSlotAlert::InternalSwap(CDOTAClientMsg_EmptyItemSlotAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.slot_index_, other->_impl_.slot_index_);
  swap(_impl_.target_entindex_, other->_impl_.target_entindex_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_EmptyItemSlotAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[74]);
}

// ===================================================================

class CDOTAClientMsg_AddOverwatchReportMarker::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_AddOverwatchReportMarker>()._impl_._has_bits_);
  static void set_has_target_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seconds_ago(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_AddOverwatchReportMarker::CDOTAClientMsg_AddOverwatchReportMarker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_AddOverwatchReportMarker)
}
CDOTAClientMsg_AddOverwatchReportMarker::CDOTAClientMsg_AddOverwatchReportMarker(const CDOTAClientMsg_AddOverwatchReportMarker& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_AddOverwatchReportMarker* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.seconds_ago_){}
    , decltype(_impl_.target_player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.reason_, &from._impl_.reason_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_player_id_) -
    reinterpret_cast<char*>(&_impl_.reason_)) + sizeof(_impl_.target_player_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_AddOverwatchReportMarker)
}

inline void CDOTAClientMsg_AddOverwatchReportMarker::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){0}
    , decltype(_impl_.seconds_ago_){0u}
    , decltype(_impl_.target_player_id_){-1}
  };
}

CDOTAClientMsg_AddOverwatchReportMarker::~CDOTAClientMsg_AddOverwatchReportMarker() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_AddOverwatchReportMarker)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_AddOverwatchReportMarker::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_AddOverwatchReportMarker::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_AddOverwatchReportMarker::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_AddOverwatchReportMarker)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.reason_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.seconds_ago_) -
        reinterpret_cast<char*>(&_impl_.reason_)) + sizeof(_impl_.seconds_ago_));
    _impl_.target_player_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_AddOverwatchReportMarker::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 target_player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_target_player_id(&has_bits);
          _impl_.target_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EOverwatchReportReason reason = 2 [default = k_EOverwatchReportReason_Unknown];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EOverwatchReportReason_IsValid(val))) {
            _internal_set_reason(static_cast<::EOverwatchReportReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 seconds_ago = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_seconds_ago(&has_bits);
          _impl_.seconds_ago_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_AddOverwatchReportMarker::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_AddOverwatchReportMarker)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 target_player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_target_player_id(), target);
  }

  // optional .EOverwatchReportReason reason = 2 [default = k_EOverwatchReportReason_Unknown];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_reason(), target);
  }

  // optional uint32 seconds_ago = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_seconds_ago(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_AddOverwatchReportMarker)
  return target;
}

size_t CDOTAClientMsg_AddOverwatchReportMarker::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_AddOverwatchReportMarker)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .EOverwatchReportReason reason = 2 [default = k_EOverwatchReportReason_Unknown];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_reason());
    }

    // optional uint32 seconds_ago = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seconds_ago());
    }

    // optional int32 target_player_id = 1 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_player_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_AddOverwatchReportMarker::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_AddOverwatchReportMarker::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_AddOverwatchReportMarker::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_AddOverwatchReportMarker::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_AddOverwatchReportMarker*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_AddOverwatchReportMarker&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_AddOverwatchReportMarker)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.reason_ = from._impl_.reason_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.seconds_ago_ = from._impl_.seconds_ago_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.target_player_id_ = from._impl_.target_player_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_AddOverwatchReportMarker::CopyFrom(const CDOTAClientMsg_AddOverwatchReportMarker& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_AddOverwatchReportMarker)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_AddOverwatchReportMarker::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_AddOverwatchReportMarker::InternalSwap(CDOTAClientMsg_AddOverwatchReportMarker* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_AddOverwatchReportMarker, _impl_.seconds_ago_)
      + sizeof(CDOTAClientMsg_AddOverwatchReportMarker::_impl_.seconds_ago_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_AddOverwatchReportMarker, _impl_.reason_)>(
          reinterpret_cast<char*>(&_impl_.reason_),
          reinterpret_cast<char*>(&other->_impl_.reason_));
  swap(_impl_.target_player_id_, other->_impl_.target_player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_AddOverwatchReportMarker::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[75]);
}

// ===================================================================

class CDOTAClientMsg_AddCommunicationsReportMarker::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_AddCommunicationsReportMarker>()._impl_._has_bits_);
  static void set_has_target_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_AddCommunicationsReportMarker::CDOTAClientMsg_AddCommunicationsReportMarker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_AddCommunicationsReportMarker)
}
CDOTAClientMsg_AddCommunicationsReportMarker::CDOTAClientMsg_AddCommunicationsReportMarker(const CDOTAClientMsg_AddCommunicationsReportMarker& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_AddCommunicationsReportMarker* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.target_player_id_ = from._impl_.target_player_id_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_AddCommunicationsReportMarker)
}

inline void CDOTAClientMsg_AddCommunicationsReportMarker::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_player_id_){-1}
  };
}

CDOTAClientMsg_AddCommunicationsReportMarker::~CDOTAClientMsg_AddCommunicationsReportMarker() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_AddCommunicationsReportMarker)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_AddCommunicationsReportMarker::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_AddCommunicationsReportMarker::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_AddCommunicationsReportMarker::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_AddCommunicationsReportMarker)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.target_player_id_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_AddCommunicationsReportMarker::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 target_player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_target_player_id(&has_bits);
          _impl_.target_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_AddCommunicationsReportMarker::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_AddCommunicationsReportMarker)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 target_player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_target_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_AddCommunicationsReportMarker)
  return target;
}

size_t CDOTAClientMsg_AddCommunicationsReportMarker::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_AddCommunicationsReportMarker)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 target_player_id = 1 [default = -1];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_AddCommunicationsReportMarker::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_AddCommunicationsReportMarker::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_AddCommunicationsReportMarker::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_AddCommunicationsReportMarker::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_AddCommunicationsReportMarker*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_AddCommunicationsReportMarker&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_AddCommunicationsReportMarker)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_target_player_id()) {
    _this->_internal_set_target_player_id(from._internal_target_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_AddCommunicationsReportMarker::CopyFrom(const CDOTAClientMsg_AddCommunicationsReportMarker& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_AddCommunicationsReportMarker)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_AddCommunicationsReportMarker::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_AddCommunicationsReportMarker::InternalSwap(CDOTAClientMsg_AddCommunicationsReportMarker* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.target_player_id_, other->_impl_.target_player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_AddCommunicationsReportMarker::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[76]);
}

// ===================================================================

class CDOTAClientMsg_AddCommunicationsBlockMarker::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_AddCommunicationsBlockMarker>()._impl_._has_bits_);
  static void set_has_target_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_AddCommunicationsBlockMarker::CDOTAClientMsg_AddCommunicationsBlockMarker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_AddCommunicationsBlockMarker)
}
CDOTAClientMsg_AddCommunicationsBlockMarker::CDOTAClientMsg_AddCommunicationsBlockMarker(const CDOTAClientMsg_AddCommunicationsBlockMarker& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_AddCommunicationsBlockMarker* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.target_player_id_ = from._impl_.target_player_id_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_AddCommunicationsBlockMarker)
}

inline void CDOTAClientMsg_AddCommunicationsBlockMarker::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.target_player_id_){-1}
  };
}

CDOTAClientMsg_AddCommunicationsBlockMarker::~CDOTAClientMsg_AddCommunicationsBlockMarker() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_AddCommunicationsBlockMarker)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_AddCommunicationsBlockMarker::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_AddCommunicationsBlockMarker::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_AddCommunicationsBlockMarker::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_AddCommunicationsBlockMarker)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.target_player_id_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_AddCommunicationsBlockMarker::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 target_player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_target_player_id(&has_bits);
          _impl_.target_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_AddCommunicationsBlockMarker::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_AddCommunicationsBlockMarker)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 target_player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_target_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_AddCommunicationsBlockMarker)
  return target;
}

size_t CDOTAClientMsg_AddCommunicationsBlockMarker::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_AddCommunicationsBlockMarker)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 target_player_id = 1 [default = -1];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_AddCommunicationsBlockMarker::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_AddCommunicationsBlockMarker::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_AddCommunicationsBlockMarker::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_AddCommunicationsBlockMarker::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_AddCommunicationsBlockMarker*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_AddCommunicationsBlockMarker&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_AddCommunicationsBlockMarker)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_target_player_id()) {
    _this->_internal_set_target_player_id(from._internal_target_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_AddCommunicationsBlockMarker::CopyFrom(const CDOTAClientMsg_AddCommunicationsBlockMarker& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_AddCommunicationsBlockMarker)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_AddCommunicationsBlockMarker::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_AddCommunicationsBlockMarker::InternalSwap(CDOTAClientMsg_AddCommunicationsBlockMarker* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.target_player_id_, other->_impl_.target_player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_AddCommunicationsBlockMarker::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[77]);
}

// ===================================================================

class CDOTAClientMsg_AghsStatusAlert::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_AghsStatusAlert>()._impl_._has_bits_);
  static void set_has_source_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_target_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_entindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_alert_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_AghsStatusAlert::CDOTAClientMsg_AghsStatusAlert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_AghsStatusAlert)
}
CDOTAClientMsg_AghsStatusAlert::CDOTAClientMsg_AghsStatusAlert(const CDOTAClientMsg_AghsStatusAlert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_AghsStatusAlert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alert_type_){}
    , decltype(_impl_.target_entindex_){}
    , decltype(_impl_.source_player_id_){}
    , decltype(_impl_.target_player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.alert_type_, &from._impl_.alert_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_player_id_) -
    reinterpret_cast<char*>(&_impl_.alert_type_)) + sizeof(_impl_.target_player_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_AghsStatusAlert)
}

inline void CDOTAClientMsg_AghsStatusAlert::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alert_type_){0u}
    , decltype(_impl_.target_entindex_){-1}
    , decltype(_impl_.source_player_id_){-1}
    , decltype(_impl_.target_player_id_){-1}
  };
}

CDOTAClientMsg_AghsStatusAlert::~CDOTAClientMsg_AghsStatusAlert() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_AghsStatusAlert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_AghsStatusAlert::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_AghsStatusAlert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_AghsStatusAlert::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_AghsStatusAlert)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    _impl_.alert_type_ = 0u;
    _impl_.target_entindex_ = -1;
    _impl_.source_player_id_ = -1;
    _impl_.target_player_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_AghsStatusAlert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 source_player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_source_player_id(&has_bits);
          _impl_.source_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_player_id = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_target_player_id(&has_bits);
          _impl_.target_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_entindex = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_target_entindex(&has_bits);
          _impl_.target_entindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 alert_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_alert_type(&has_bits);
          _impl_.alert_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_AghsStatusAlert::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_AghsStatusAlert)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 source_player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_source_player_id(), target);
  }

  // optional int32 target_player_id = 2 [default = -1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_target_player_id(), target);
  }

  // optional int32 target_entindex = 3 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_target_entindex(), target);
  }

  // optional uint32 alert_type = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_alert_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_AghsStatusAlert)
  return target;
}

size_t CDOTAClientMsg_AghsStatusAlert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_AghsStatusAlert)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 alert_type = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_alert_type());
    }

    // optional int32 target_entindex = 3 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_entindex());
    }

    // optional int32 source_player_id = 1 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_source_player_id());
    }

    // optional int32 target_player_id = 2 [default = -1];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_player_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_AghsStatusAlert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_AghsStatusAlert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_AghsStatusAlert::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_AghsStatusAlert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_AghsStatusAlert*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_AghsStatusAlert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_AghsStatusAlert)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.alert_type_ = from._impl_.alert_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_entindex_ = from._impl_.target_entindex_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.source_player_id_ = from._impl_.source_player_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.target_player_id_ = from._impl_.target_player_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_AghsStatusAlert::CopyFrom(const CDOTAClientMsg_AghsStatusAlert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_AghsStatusAlert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_AghsStatusAlert::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_AghsStatusAlert::InternalSwap(CDOTAClientMsg_AghsStatusAlert* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.alert_type_, other->_impl_.alert_type_);
  swap(_impl_.target_entindex_, other->_impl_.target_entindex_);
  swap(_impl_.source_player_id_, other->_impl_.source_player_id_);
  swap(_impl_.target_player_id_, other->_impl_.target_player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_AghsStatusAlert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[78]);
}

// ===================================================================

class CDOTAClientMsg_PerfReport::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_PerfReport>()._impl_._has_bits_);
  static void set_has_average_frame_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_frame_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_average_compute_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_compute_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_average_client_tick_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_client_tick_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_average_client_simulate_time(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_max_client_simulate_time(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_average_output_time(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_max_output_time(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_average_wait_for_rendering_to_complete_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_max_wait_for_rendering_to_complete_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_average_swap_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_max_swap_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_average_frame_update_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_max_frame_update_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_average_idle_time(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_max_idle_time(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_average_input_processing_time(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_max_input_processing_time(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
};

CDOTAClientMsg_PerfReport::CDOTAClientMsg_PerfReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_PerfReport)
}
CDOTAClientMsg_PerfReport::CDOTAClientMsg_PerfReport(const CDOTAClientMsg_PerfReport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_PerfReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.average_frame_time_){}
    , decltype(_impl_.max_frame_time_){}
    , decltype(_impl_.average_compute_time_){}
    , decltype(_impl_.max_compute_time_){}
    , decltype(_impl_.average_client_tick_time_){}
    , decltype(_impl_.max_client_tick_time_){}
    , decltype(_impl_.average_client_simulate_time_){}
    , decltype(_impl_.max_client_simulate_time_){}
    , decltype(_impl_.average_output_time_){}
    , decltype(_impl_.max_output_time_){}
    , decltype(_impl_.average_wait_for_rendering_to_complete_time_){}
    , decltype(_impl_.max_wait_for_rendering_to_complete_time_){}
    , decltype(_impl_.average_swap_time_){}
    , decltype(_impl_.max_swap_time_){}
    , decltype(_impl_.average_frame_update_time_){}
    , decltype(_impl_.max_frame_update_time_){}
    , decltype(_impl_.average_idle_time_){}
    , decltype(_impl_.max_idle_time_){}
    , decltype(_impl_.average_input_processing_time_){}
    , decltype(_impl_.max_input_processing_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.average_frame_time_, &from._impl_.average_frame_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_input_processing_time_) -
    reinterpret_cast<char*>(&_impl_.average_frame_time_)) + sizeof(_impl_.max_input_processing_time_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_PerfReport)
}

inline void CDOTAClientMsg_PerfReport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.average_frame_time_){0}
    , decltype(_impl_.max_frame_time_){0}
    , decltype(_impl_.average_compute_time_){0}
    , decltype(_impl_.max_compute_time_){0}
    , decltype(_impl_.average_client_tick_time_){0}
    , decltype(_impl_.max_client_tick_time_){0}
    , decltype(_impl_.average_client_simulate_time_){0}
    , decltype(_impl_.max_client_simulate_time_){0}
    , decltype(_impl_.average_output_time_){0}
    , decltype(_impl_.max_output_time_){0}
    , decltype(_impl_.average_wait_for_rendering_to_complete_time_){0}
    , decltype(_impl_.max_wait_for_rendering_to_complete_time_){0}
    , decltype(_impl_.average_swap_time_){0}
    , decltype(_impl_.max_swap_time_){0}
    , decltype(_impl_.average_frame_update_time_){0}
    , decltype(_impl_.max_frame_update_time_){0}
    , decltype(_impl_.average_idle_time_){0}
    , decltype(_impl_.max_idle_time_){0}
    , decltype(_impl_.average_input_processing_time_){0}
    , decltype(_impl_.max_input_processing_time_){0}
  };
}

CDOTAClientMsg_PerfReport::~CDOTAClientMsg_PerfReport() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_PerfReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_PerfReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_PerfReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_PerfReport::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_PerfReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.average_frame_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.max_client_simulate_time_) -
        reinterpret_cast<char*>(&_impl_.average_frame_time_)) + sizeof(_impl_.max_client_simulate_time_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.average_output_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.max_frame_update_time_) -
        reinterpret_cast<char*>(&_impl_.average_output_time_)) + sizeof(_impl_.max_frame_update_time_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&_impl_.average_idle_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.max_input_processing_time_) -
        reinterpret_cast<char*>(&_impl_.average_idle_time_)) + sizeof(_impl_.max_input_processing_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_PerfReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float average_frame_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_average_frame_time(&has_bits);
          _impl_.average_frame_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_frame_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_max_frame_time(&has_bits);
          _impl_.max_frame_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float average_compute_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_average_compute_time(&has_bits);
          _impl_.average_compute_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_compute_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_max_compute_time(&has_bits);
          _impl_.max_compute_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float average_client_tick_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_average_client_tick_time(&has_bits);
          _impl_.average_client_tick_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_client_tick_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_max_client_tick_time(&has_bits);
          _impl_.max_client_tick_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float average_client_simulate_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_average_client_simulate_time(&has_bits);
          _impl_.average_client_simulate_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_client_simulate_time = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_max_client_simulate_time(&has_bits);
          _impl_.max_client_simulate_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float average_output_time = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_average_output_time(&has_bits);
          _impl_.average_output_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_output_time = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_max_output_time(&has_bits);
          _impl_.max_output_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float average_wait_for_rendering_to_complete_time = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_average_wait_for_rendering_to_complete_time(&has_bits);
          _impl_.average_wait_for_rendering_to_complete_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_wait_for_rendering_to_complete_time = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_max_wait_for_rendering_to_complete_time(&has_bits);
          _impl_.max_wait_for_rendering_to_complete_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float average_swap_time = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_average_swap_time(&has_bits);
          _impl_.average_swap_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_swap_time = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_max_swap_time(&has_bits);
          _impl_.max_swap_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float average_frame_update_time = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_average_frame_update_time(&has_bits);
          _impl_.average_frame_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_frame_update_time = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_max_frame_update_time(&has_bits);
          _impl_.max_frame_update_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float average_idle_time = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _Internal::set_has_average_idle_time(&has_bits);
          _impl_.average_idle_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_idle_time = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _Internal::set_has_max_idle_time(&has_bits);
          _impl_.max_idle_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float average_input_processing_time = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _Internal::set_has_average_input_processing_time(&has_bits);
          _impl_.average_input_processing_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_input_processing_time = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 165)) {
          _Internal::set_has_max_input_processing_time(&has_bits);
          _impl_.max_input_processing_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_PerfReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_PerfReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float average_frame_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_average_frame_time(), target);
  }

  // optional float max_frame_time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_max_frame_time(), target);
  }

  // optional float average_compute_time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_average_compute_time(), target);
  }

  // optional float max_compute_time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_max_compute_time(), target);
  }

  // optional float average_client_tick_time = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_average_client_tick_time(), target);
  }

  // optional float max_client_tick_time = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_max_client_tick_time(), target);
  }

  // optional float average_client_simulate_time = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_average_client_simulate_time(), target);
  }

  // optional float max_client_simulate_time = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_max_client_simulate_time(), target);
  }

  // optional float average_output_time = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_average_output_time(), target);
  }

  // optional float max_output_time = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_max_output_time(), target);
  }

  // optional float average_wait_for_rendering_to_complete_time = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_average_wait_for_rendering_to_complete_time(), target);
  }

  // optional float max_wait_for_rendering_to_complete_time = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_max_wait_for_rendering_to_complete_time(), target);
  }

  // optional float average_swap_time = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_average_swap_time(), target);
  }

  // optional float max_swap_time = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_max_swap_time(), target);
  }

  // optional float average_frame_update_time = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_average_frame_update_time(), target);
  }

  // optional float max_frame_update_time = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_max_frame_update_time(), target);
  }

  // optional float average_idle_time = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(17, this->_internal_average_idle_time(), target);
  }

  // optional float max_idle_time = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_max_idle_time(), target);
  }

  // optional float average_input_processing_time = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(19, this->_internal_average_input_processing_time(), target);
  }

  // optional float max_input_processing_time = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(20, this->_internal_max_input_processing_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_PerfReport)
  return target;
}

size_t CDOTAClientMsg_PerfReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_PerfReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float average_frame_time = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float max_frame_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float average_compute_time = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float max_compute_time = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float average_client_tick_time = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float max_client_tick_time = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float average_client_simulate_time = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float max_client_simulate_time = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float average_output_time = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float max_output_time = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float average_wait_for_rendering_to_complete_time = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float max_wait_for_rendering_to_complete_time = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional float average_swap_time = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float max_swap_time = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional float average_frame_update_time = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional float max_frame_update_time = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional float average_idle_time = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 4;
    }

    // optional float max_idle_time = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 4;
    }

    // optional float average_input_processing_time = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 4;
    }

    // optional float max_input_processing_time = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_PerfReport::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_PerfReport::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_PerfReport::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_PerfReport::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_PerfReport*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_PerfReport&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_PerfReport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.average_frame_time_ = from._impl_.average_frame_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.max_frame_time_ = from._impl_.max_frame_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.average_compute_time_ = from._impl_.average_compute_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.max_compute_time_ = from._impl_.max_compute_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.average_client_tick_time_ = from._impl_.average_client_tick_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.max_client_tick_time_ = from._impl_.max_client_tick_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.average_client_simulate_time_ = from._impl_.average_client_simulate_time_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.max_client_simulate_time_ = from._impl_.max_client_simulate_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.average_output_time_ = from._impl_.average_output_time_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.max_output_time_ = from._impl_.max_output_time_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.average_wait_for_rendering_to_complete_time_ = from._impl_.average_wait_for_rendering_to_complete_time_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.max_wait_for_rendering_to_complete_time_ = from._impl_.max_wait_for_rendering_to_complete_time_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.average_swap_time_ = from._impl_.average_swap_time_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.max_swap_time_ = from._impl_.max_swap_time_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.average_frame_update_time_ = from._impl_.average_frame_update_time_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.max_frame_update_time_ = from._impl_.max_frame_update_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.average_idle_time_ = from._impl_.average_idle_time_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.max_idle_time_ = from._impl_.max_idle_time_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.average_input_processing_time_ = from._impl_.average_input_processing_time_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.max_input_processing_time_ = from._impl_.max_input_processing_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_PerfReport::CopyFrom(const CDOTAClientMsg_PerfReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_PerfReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_PerfReport::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_PerfReport::InternalSwap(CDOTAClientMsg_PerfReport* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_PerfReport, _impl_.max_input_processing_time_)
      + sizeof(CDOTAClientMsg_PerfReport::_impl_.max_input_processing_time_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_PerfReport, _impl_.average_frame_time_)>(
          reinterpret_cast<char*>(&_impl_.average_frame_time_),
          reinterpret_cast<char*>(&other->_impl_.average_frame_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_PerfReport::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[79]);
}

// ===================================================================

class CDOTAClientMsg_ContextualTips_Subscribe_Entry::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_ContextualTips_Subscribe_Entry>()._impl_._has_bits_);
  static void set_has_unsubscribe(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tip_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prior_display_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CDOTAClientMsg_ContextualTips_Subscribe_Entry::CDOTAClientMsg_ContextualTips_Subscribe_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ContextualTips_Subscribe_Entry)
}
CDOTAClientMsg_ContextualTips_Subscribe_Entry::CDOTAClientMsg_ContextualTips_Subscribe_Entry(const CDOTAClientMsg_ContextualTips_Subscribe_Entry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ContextualTips_Subscribe_Entry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.variants_seen_){from._impl_.variants_seen_}
    , decltype(_impl_.unsubscribe_){}
    , decltype(_impl_.tip_id_){}
    , decltype(_impl_.prior_display_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.unsubscribe_, &from._impl_.unsubscribe_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prior_display_count_) -
    reinterpret_cast<char*>(&_impl_.unsubscribe_)) + sizeof(_impl_.prior_display_count_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ContextualTips_Subscribe_Entry)
}

inline void CDOTAClientMsg_ContextualTips_Subscribe_Entry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.variants_seen_){arena}
    , decltype(_impl_.unsubscribe_){false}
    , decltype(_impl_.tip_id_){0}
    , decltype(_impl_.prior_display_count_){0}
  };
}

CDOTAClientMsg_ContextualTips_Subscribe_Entry::~CDOTAClientMsg_ContextualTips_Subscribe_Entry() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ContextualTips_Subscribe_Entry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ContextualTips_Subscribe_Entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.variants_seen_.~RepeatedField();
}

void CDOTAClientMsg_ContextualTips_Subscribe_Entry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ContextualTips_Subscribe_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ContextualTips_Subscribe_Entry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.variants_seen_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.unsubscribe_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.prior_display_count_) -
        reinterpret_cast<char*>(&_impl_.unsubscribe_)) + sizeof(_impl_.prior_display_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ContextualTips_Subscribe_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool unsubscribe = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_unsubscribe(&has_bits);
          _impl_.unsubscribe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tip_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tip_id(&has_bits);
          _impl_.tip_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prior_display_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prior_display_count(&has_bits);
          _impl_.prior_display_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 variants_seen = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_variants_seen(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_variants_seen(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ContextualTips_Subscribe_Entry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ContextualTips_Subscribe_Entry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool unsubscribe = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_unsubscribe(), target);
  }

  // optional int32 tip_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_tip_id(), target);
  }

  // optional int32 prior_display_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prior_display_count(), target);
  }

  // repeated int32 variants_seen = 4;
  for (int i = 0, n = this->_internal_variants_seen_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_variants_seen(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ContextualTips_Subscribe_Entry)
  return target;
}

size_t CDOTAClientMsg_ContextualTips_Subscribe_Entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ContextualTips_Subscribe_Entry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 variants_seen = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.variants_seen_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_variants_seen_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool unsubscribe = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 tip_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tip_id());
    }

    // optional int32 prior_display_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prior_display_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ContextualTips_Subscribe_Entry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ContextualTips_Subscribe_Entry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ContextualTips_Subscribe_Entry::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ContextualTips_Subscribe_Entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ContextualTips_Subscribe_Entry*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ContextualTips_Subscribe_Entry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ContextualTips_Subscribe_Entry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.variants_seen_.MergeFrom(from._impl_.variants_seen_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.unsubscribe_ = from._impl_.unsubscribe_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tip_id_ = from._impl_.tip_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prior_display_count_ = from._impl_.prior_display_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ContextualTips_Subscribe_Entry::CopyFrom(const CDOTAClientMsg_ContextualTips_Subscribe_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ContextualTips_Subscribe_Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ContextualTips_Subscribe_Entry::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ContextualTips_Subscribe_Entry::InternalSwap(CDOTAClientMsg_ContextualTips_Subscribe_Entry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.variants_seen_.InternalSwap(&other->_impl_.variants_seen_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_ContextualTips_Subscribe_Entry, _impl_.prior_display_count_)
      + sizeof(CDOTAClientMsg_ContextualTips_Subscribe_Entry::_impl_.prior_display_count_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientMsg_ContextualTips_Subscribe_Entry, _impl_.unsubscribe_)>(
          reinterpret_cast<char*>(&_impl_.unsubscribe_),
          reinterpret_cast<char*>(&other->_impl_.unsubscribe_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ContextualTips_Subscribe_Entry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[80]);
}

// ===================================================================

class CDOTAClientMsg_ContextualTips_Subscribe::_Internal {
 public:
};

CDOTAClientMsg_ContextualTips_Subscribe::CDOTAClientMsg_ContextualTips_Subscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ContextualTips_Subscribe)
}
CDOTAClientMsg_ContextualTips_Subscribe::CDOTAClientMsg_ContextualTips_Subscribe(const CDOTAClientMsg_ContextualTips_Subscribe& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ContextualTips_Subscribe* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tips_){from._impl_.tips_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ContextualTips_Subscribe)
}

inline void CDOTAClientMsg_ContextualTips_Subscribe::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tips_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CDOTAClientMsg_ContextualTips_Subscribe::~CDOTAClientMsg_ContextualTips_Subscribe() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ContextualTips_Subscribe)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ContextualTips_Subscribe::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tips_.~RepeatedPtrField();
}

void CDOTAClientMsg_ContextualTips_Subscribe::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ContextualTips_Subscribe::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ContextualTips_Subscribe)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tips_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ContextualTips_Subscribe::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CDOTAClientMsg_ContextualTips_Subscribe_Entry tips = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tips(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ContextualTips_Subscribe::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ContextualTips_Subscribe)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CDOTAClientMsg_ContextualTips_Subscribe_Entry tips = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tips_size()); i < n; i++) {
    const auto& repfield = this->_internal_tips(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ContextualTips_Subscribe)
  return target;
}

size_t CDOTAClientMsg_ContextualTips_Subscribe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ContextualTips_Subscribe)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CDOTAClientMsg_ContextualTips_Subscribe_Entry tips = 1;
  total_size += 1UL * this->_internal_tips_size();
  for (const auto& msg : this->_impl_.tips_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ContextualTips_Subscribe::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ContextualTips_Subscribe::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ContextualTips_Subscribe::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ContextualTips_Subscribe::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ContextualTips_Subscribe*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ContextualTips_Subscribe&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ContextualTips_Subscribe)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tips_.MergeFrom(from._impl_.tips_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ContextualTips_Subscribe::CopyFrom(const CDOTAClientMsg_ContextualTips_Subscribe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ContextualTips_Subscribe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ContextualTips_Subscribe::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ContextualTips_Subscribe::InternalSwap(CDOTAClientMsg_ContextualTips_Subscribe* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tips_.InternalSwap(&other->_impl_.tips_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ContextualTips_Subscribe::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[81]);
}

// ===================================================================

class CDOTAClientMsg_ChatMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_ChatMessage>()._impl_._has_bits_);
  static void set_has_channel_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDOTAClientMsg_ChatMessage::CDOTAClientMsg_ChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_ChatMessage)
}
CDOTAClientMsg_ChatMessage::CDOTAClientMsg_ChatMessage(const CDOTAClientMsg_ChatMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_ChatMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_text_){}
    , decltype(_impl_.channel_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message_text()) {
    _this->_impl_.message_text_.Set(from._internal_message_text(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.channel_type_ = from._impl_.channel_type_;
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_ChatMessage)
}

inline void CDOTAClientMsg_ChatMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_text_){}
    , decltype(_impl_.channel_type_){0u}
  };
  _impl_.message_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CDOTAClientMsg_ChatMessage::~CDOTAClientMsg_ChatMessage() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_ChatMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_ChatMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_text_.Destroy();
}

void CDOTAClientMsg_ChatMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_ChatMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_ChatMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_text_.ClearNonDefaultToEmpty();
  }
  _impl_.channel_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_ChatMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 channel_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_channel_type(&has_bits);
          _impl_.channel_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message_text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CDOTAClientMsg_ChatMessage.message_text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_ChatMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_ChatMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 channel_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_channel_type(), target);
  }

  // optional string message_text = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message_text().data(), static_cast<int>(this->_internal_message_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDOTAClientMsg_ChatMessage.message_text");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_ChatMessage)
  return target;
}

size_t CDOTAClientMsg_ChatMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_ChatMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string message_text = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message_text());
    }

    // optional uint32 channel_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channel_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_ChatMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_ChatMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_ChatMessage::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_ChatMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_ChatMessage*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_ChatMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_ChatMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message_text(from._internal_message_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.channel_type_ = from._impl_.channel_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_ChatMessage::CopyFrom(const CDOTAClientMsg_ChatMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_ChatMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_ChatMessage::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_ChatMessage::InternalSwap(CDOTAClientMsg_ChatMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_text_, lhs_arena,
      &other->_impl_.message_text_, rhs_arena
  );
  swap(_impl_.channel_type_, other->_impl_.channel_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_ChatMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[82]);
}

// ===================================================================

class CDOTAClientMsg_DuelAccepted::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientMsg_DuelAccepted>()._impl_._has_bits_);
  static void set_has_challenger_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_accepter_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTAClientMsg_DuelAccepted::CDOTAClientMsg_DuelAccepted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientMsg_DuelAccepted)
}
CDOTAClientMsg_DuelAccepted::CDOTAClientMsg_DuelAccepted(const CDOTAClientMsg_DuelAccepted& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientMsg_DuelAccepted* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.challenger_player_id_){}
    , decltype(_impl_.accepter_player_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.challenger_player_id_, &from._impl_.challenger_player_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.accepter_player_id_) -
    reinterpret_cast<char*>(&_impl_.challenger_player_id_)) + sizeof(_impl_.accepter_player_id_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientMsg_DuelAccepted)
}

inline void CDOTAClientMsg_DuelAccepted::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.challenger_player_id_){-1}
    , decltype(_impl_.accepter_player_id_){-1}
  };
}

CDOTAClientMsg_DuelAccepted::~CDOTAClientMsg_DuelAccepted() {
  // @@protoc_insertion_point(destructor:CDOTAClientMsg_DuelAccepted)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientMsg_DuelAccepted::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTAClientMsg_DuelAccepted::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientMsg_DuelAccepted::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientMsg_DuelAccepted)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.challenger_player_id_ = -1;
    _impl_.accepter_player_id_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientMsg_DuelAccepted::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 challenger_player_id = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_challenger_player_id(&has_bits);
          _impl_.challenger_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 accepter_player_id = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_accepter_player_id(&has_bits);
          _impl_.accepter_player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientMsg_DuelAccepted::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientMsg_DuelAccepted)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 challenger_player_id = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_challenger_player_id(), target);
  }

  // optional int32 accepter_player_id = 2 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_accepter_player_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientMsg_DuelAccepted)
  return target;
}

size_t CDOTAClientMsg_DuelAccepted::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientMsg_DuelAccepted)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 challenger_player_id = 1 [default = -1];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_challenger_player_id());
    }

    // optional int32 accepter_player_id = 2 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_accepter_player_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientMsg_DuelAccepted::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientMsg_DuelAccepted::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientMsg_DuelAccepted::GetClassData() const { return &_class_data_; }


void CDOTAClientMsg_DuelAccepted::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientMsg_DuelAccepted*>(&to_msg);
  auto& from = static_cast<const CDOTAClientMsg_DuelAccepted&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientMsg_DuelAccepted)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.challenger_player_id_ = from._impl_.challenger_player_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.accepter_player_id_ = from._impl_.accepter_player_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientMsg_DuelAccepted::CopyFrom(const CDOTAClientMsg_DuelAccepted& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientMsg_DuelAccepted)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientMsg_DuelAccepted::IsInitialized() const {
  return true;
}

void CDOTAClientMsg_DuelAccepted::InternalSwap(CDOTAClientMsg_DuelAccepted* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.challenger_player_id_, other->_impl_.challenger_player_id_);
  swap(_impl_.accepter_player_id_, other->_impl_.accepter_player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientMsg_DuelAccepted::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fclientmessages_2eproto_getter, &descriptor_table_dota_5fclientmessages_2eproto_once,
      file_level_metadata_dota_5fclientmessages_2eproto[83]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_MapPing*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_MapPing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_MapPing >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ItemAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ItemAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ItemAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_EnemyItemAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_EnemyItemAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_EnemyItemAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ModifierAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ModifierAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ModifierAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ClickedBuff*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ClickedBuff >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ClickedBuff >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_HPManaAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_HPManaAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_HPManaAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_NeutralCampAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_NeutralCampAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_NeutralCampAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_GlyphAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_GlyphAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_GlyphAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_RadarAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_RadarAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_RadarAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_MapLine*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_MapLine >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_MapLine >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_AspectRatio*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_AspectRatio >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_AspectRatio >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_UnitsAutoAttackMode*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_UnitsAutoAttackMode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_UnitsAutoAttackMode >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_UnitsAutoAttackAfterSpell*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_UnitsAutoAttackAfterSpell >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_UnitsAutoAttackAfterSpell >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_TeleportRequiresHalt*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_TeleportRequiresHalt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_TeleportRequiresHalt >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ChannelRequiresHalt*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ChannelRequiresHalt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ChannelRequiresHalt >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_SearchString*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_SearchString >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_SearchString >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_Pause*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_Pause >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_Pause >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ShopViewMode*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ShopViewMode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ShopViewMode >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_SetUnitShareFlag*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_SetUnitShareFlag >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_SetUnitShareFlag >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_SwapRequest*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_SwapRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_SwapRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_SwapAccept*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_SwapAccept >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_SwapAccept >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_WorldLine*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_WorldLine >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_WorldLine >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_RequestGraphUpdate*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_RequestGraphUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_RequestGraphUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ChatWheel*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ChatWheel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ChatWheel >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_SendStatPopup*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_SendStatPopup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_SendStatPopup >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_DismissAllStatPopups*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_DismissAllStatPopups >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_DismissAllStatPopups >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_BeginLastHitChallenge*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_BeginLastHitChallenge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_BeginLastHitChallenge >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_UpdateQuickBuyItem*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_UpdateQuickBuyItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_UpdateQuickBuyItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_UpdateQuickBuy*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_UpdateQuickBuy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_UpdateQuickBuy >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_RecordVote*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_RecordVote >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_RecordVote >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_WillPurchaseAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_WillPurchaseAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_WillPurchaseAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_BuyBackStateAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_BuyBackStateAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_BuyBackStateAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_QuickBuyAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_QuickBuyAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_QuickBuyAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_PlayerShowCase*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_PlayerShowCase >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_PlayerShowCase >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_CameraZoomAmount*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_CameraZoomAmount >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_CameraZoomAmount >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_BroadcasterUsingCameraman*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_BroadcasterUsingCameraman >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_BroadcasterUsingCameraman >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_FillEmptySlotsWithBots*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_FillEmptySlotsWithBots >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_FillEmptySlotsWithBots >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_HeroStatueLike*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_HeroStatueLike >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_HeroStatueLike >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_EventCNY2015Cmd*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_EventCNY2015Cmd >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_EventCNY2015Cmd >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_DemoHero*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_DemoHero >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_DemoHero >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ChallengeSelect*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ChallengeSelect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ChallengeSelect >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ChallengeReroll*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ChallengeReroll >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ChallengeReroll >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_CoinWager*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_CoinWager >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_CoinWager >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_CoinWagerToken*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_CoinWagerToken >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_CoinWagerToken >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_RankWager*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_RankWager >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_RankWager >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_PlayerBounty*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_PlayerBounty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_PlayerBounty >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_EventPointsTip*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_EventPointsTip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_EventPointsTip >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ExecuteOrders*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ExecuteOrders >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ExecuteOrders >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_XPAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_XPAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_XPAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_TalentTreeAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_TalentTreeAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_TalentTreeAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_KillcamDamageTaken*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_KillcamDamageTaken >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_KillcamDamageTaken >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_KillMyHero*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_KillMyHero >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_KillMyHero >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_QuestStatus*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_QuestStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_QuestStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ToggleAutoattack*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ToggleAutoattack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ToggleAutoattack >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_SpecialAbility*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_SpecialAbility >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_SpecialAbility >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_SetEnemyStartingPosition*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_SetEnemyStartingPosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_SetEnemyStartingPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_SetDesiredWardPlacement*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_SetDesiredWardPlacement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_SetDesiredWardPlacement >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_RollDice*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_RollDice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_RollDice >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_FlipCoin*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_FlipCoin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_FlipCoin >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_RequestItemSuggestions*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_RequestItemSuggestions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_RequestItemSuggestions >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_MakeTeamCaptain*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_MakeTeamCaptain >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_MakeTeamCaptain >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_HelpTipSystemStateChanged*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_HelpTipSystemStateChanged >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_HelpTipSystemStateChanged >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_RequestBulkCombatLog*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_RequestBulkCombatLog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_RequestBulkCombatLog >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_AbilityDraftRequestAbility*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_AbilityDraftRequestAbility >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_AbilityDraftRequestAbility >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_GuideSelectOption*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_GuideSelectOption >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_GuideSelectOption >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_GuideSelected*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_GuideSelected >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_GuideSelected >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_DamageReport*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_DamageReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_DamageReport >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_SalutePlayer*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_SalutePlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_SalutePlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_TipAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_TipAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_TipAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_EmptyTeleportAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_EmptyTeleportAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_EmptyTeleportAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_SetCavernMapVariant*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_SetCavernMapVariant >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_SetCavernMapVariant >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_PauseGameOrder*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_PauseGameOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_PauseGameOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_VersusScene_PlayerBehavior*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_VersusScene_PlayerBehavior >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_VersusScene_PlayerBehavior >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_EmptyItemSlotAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_EmptyItemSlotAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_EmptyItemSlotAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_AddOverwatchReportMarker*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_AddOverwatchReportMarker >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_AddOverwatchReportMarker >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_AddCommunicationsReportMarker*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_AddCommunicationsReportMarker >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_AddCommunicationsReportMarker >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_AddCommunicationsBlockMarker*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_AddCommunicationsBlockMarker >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_AddCommunicationsBlockMarker >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_AghsStatusAlert*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_AghsStatusAlert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_AghsStatusAlert >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_PerfReport*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_PerfReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_PerfReport >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ContextualTips_Subscribe_Entry*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ContextualTips_Subscribe_Entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ContextualTips_Subscribe_Entry >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ContextualTips_Subscribe*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ContextualTips_Subscribe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ContextualTips_Subscribe >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_ChatMessage*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_ChatMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_ChatMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTAClientMsg_DuelAccepted*
Arena::CreateMaybeMessage< ::CDOTAClientMsg_DuelAccepted >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientMsg_DuelAccepted >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
